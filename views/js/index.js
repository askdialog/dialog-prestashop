var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var _a2, _b, _c, _d;
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link2 of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link2);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node2 of mutation.addedNodes) {
        if (node2.tagName === "LINK" && node2.rel === "modulepreload")
          processPreload(node2);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link2) {
    const fetchOpts = {};
    if (link2.integrity) fetchOpts.integrity = link2.integrity;
    if (link2.referrerPolicy) fetchOpts.referrerPolicy = link2.referrerPolicy;
    if (link2.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link2.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link2) {
    if (link2.ep)
      return;
    link2.ep = true;
    const fetchOpts = getFetchOpts(link2);
    fetch(link2.href, fetchOpts);
  }
})();
var n$2, l$3, u$3, i$3, o$2, r$3, f$3, e$3, c$3 = {}, s$2 = [], a$2 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i, h$3 = Array.isArray;
function v$3(n2, l2) {
  for (var u2 in l2) n2[u2] = l2[u2];
  return n2;
}
function p$3(n2) {
  var l2 = n2.parentNode;
  l2 && l2.removeChild(n2);
}
function y$3(l2, u2, t2) {
  var i, o2, r2, f2 = {};
  for (r2 in u2) "key" == r2 ? i = u2[r2] : "ref" == r2 ? o2 = u2[r2] : f2[r2] = u2[r2];
  if (arguments.length > 2 && (f2.children = arguments.length > 3 ? n$2.call(arguments, 2) : t2), "function" == typeof l2 && null != l2.defaultProps) for (r2 in l2.defaultProps) void 0 === f2[r2] && (f2[r2] = l2.defaultProps[r2]);
  return d$3(l2, f2, i, o2, null);
}
function d$3(n2, t2, i, o2, r2) {
  var f2 = { type: n2, props: t2, key: i, ref: o2, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: null == r2 ? ++u$3 : r2, __i: -1, __u: 0 };
  return null == r2 && null != l$3.vnode && l$3.vnode(f2), f2;
}
function _$2() {
  return { current: null };
}
function g$3(n2) {
  return n2.children;
}
function b$3(n2, l2) {
  this.props = n2, this.context = l2;
}
function m$3(n2, l2) {
  if (null == l2) return n2.__ ? m$3(n2.__, n2.__i + 1) : null;
  for (var u2; l2 < n2.__k.length; l2++) if (null != (u2 = n2.__k[l2]) && null != u2.__e) return u2.__e;
  return "function" == typeof n2.type ? m$3(n2) : null;
}
function w$4(n2) {
  var l2, u2;
  if (null != (n2 = n2.__) && null != n2.__c) {
    for (n2.__e = n2.__c.base = null, l2 = 0; l2 < n2.__k.length; l2++) if (null != (u2 = n2.__k[l2]) && null != u2.__e) {
      n2.__e = n2.__c.base = u2.__e;
      break;
    }
    return w$4(n2);
  }
}
function k$4(n2) {
  (!n2.__d && (n2.__d = true) && i$3.push(n2) && !x$4.__r++ || o$2 !== l$3.debounceRendering) && ((o$2 = l$3.debounceRendering) || r$3)(x$4);
}
function x$4() {
  var n2, u2, t2, o2, r2, e2, c6, s2, a2;
  for (i$3.sort(f$3); n2 = i$3.shift(); ) n2.__d && (u2 = i$3.length, o2 = void 0, e2 = (r2 = (t2 = n2).__v).__e, s2 = [], a2 = [], (c6 = t2.__P) && ((o2 = v$3({}, r2)).__v = r2.__v + 1, l$3.vnode && l$3.vnode(o2), F$3(c6, o2, r2, t2.__n, void 0 !== c6.ownerSVGElement, 32 & r2.__u ? [e2] : null, s2, null == e2 ? m$3(r2) : e2, !!(32 & r2.__u), a2), o2.__v = r2.__v, o2.__.__k[o2.__i] = o2, L$2(s2, o2, a2), o2.__e != e2 && w$4(o2)), i$3.length > u2 && i$3.sort(f$3));
  x$4.__r = 0;
}
function C$3(n2, l2, u2, t2, i, o2, r2, f2, e2, a2, h2) {
  var v2, p2, y2, d2, _2, g2 = t2 && t2.__k || s$2, b2 = l2.length;
  for (u2.__d = e2, P$3(u2, l2, g2), e2 = u2.__d, v2 = 0; v2 < b2; v2++) null != (y2 = u2.__k[v2]) && "boolean" != typeof y2 && "function" != typeof y2 && (p2 = -1 === y2.__i ? c$3 : g2[y2.__i] || c$3, y2.__i = v2, F$3(n2, y2, p2, i, o2, r2, f2, e2, a2, h2), d2 = y2.__e, y2.ref && p2.ref != y2.ref && (p2.ref && O$2(p2.ref, null, y2), h2.push(y2.ref, y2.__c || d2, y2)), null == _2 && null != d2 && (_2 = d2), 65536 & y2.__u || p2.__k === y2.__k ? (d2 || p2.__e != e2 || (e2 = m$3(p2)), e2 = S$2(y2, e2, n2)) : "function" == typeof y2.type && void 0 !== y2.__d ? e2 = y2.__d : d2 && (e2 = d2.nextSibling), y2.__d = void 0, y2.__u &= -196609);
  u2.__d = e2, u2.__e = _2;
}
function P$3(n2, l2, u2) {
  var t2, i, o2, r2, f2, e2 = l2.length, c6 = u2.length, s2 = c6, a2 = 0;
  for (n2.__k = [], t2 = 0; t2 < e2; t2++) r2 = t2 + a2, null != (i = n2.__k[t2] = null == (i = l2[t2]) || "boolean" == typeof i || "function" == typeof i ? null : "string" == typeof i || "number" == typeof i || "bigint" == typeof i || i.constructor == String ? d$3(null, i, null, null, null) : h$3(i) ? d$3(g$3, { children: i }, null, null, null) : void 0 === i.constructor && i.__b > 0 ? d$3(i.type, i.props, i.key, i.ref ? i.ref : null, i.__v) : i) ? (i.__ = n2, i.__b = n2.__b + 1, f2 = I$2(i, u2, r2, s2), i.__i = f2, o2 = null, -1 !== f2 && (s2--, (o2 = u2[f2]) && (o2.__u |= 131072)), null == o2 || null === o2.__v ? (-1 == f2 && a2--, "function" != typeof i.type && (i.__u |= 65536)) : f2 !== r2 && (f2 === r2 + 1 ? a2++ : f2 > r2 ? s2 > e2 - r2 ? a2 += f2 - r2 : a2-- : f2 < r2 ? f2 == r2 - 1 && (a2 = f2 - r2) : a2 = 0, f2 !== t2 + a2 && (i.__u |= 65536))) : (o2 = u2[r2]) && null == o2.key && o2.__e && 0 == (131072 & o2.__u) && (o2.__e == n2.__d && (n2.__d = m$3(o2)), j$3(o2, o2, false), u2[r2] = null, s2--);
  if (s2) for (t2 = 0; t2 < c6; t2++) null != (o2 = u2[t2]) && 0 == (131072 & o2.__u) && (o2.__e == n2.__d && (n2.__d = m$3(o2)), j$3(o2, o2));
}
function S$2(n2, l2, u2) {
  var t2, i;
  if ("function" == typeof n2.type) {
    for (t2 = n2.__k, i = 0; t2 && i < t2.length; i++) t2[i] && (t2[i].__ = n2, l2 = S$2(t2[i], l2, u2));
    return l2;
  }
  n2.__e != l2 && (u2.insertBefore(n2.__e, l2 || null), l2 = n2.__e);
  do {
    l2 = l2 && l2.nextSibling;
  } while (null != l2 && 8 === l2.nodeType);
  return l2;
}
function $$2(n2, l2) {
  return l2 = l2 || [], null == n2 || "boolean" == typeof n2 || (h$3(n2) ? n2.some(function(n3) {
    $$2(n3, l2);
  }) : l2.push(n2)), l2;
}
function I$2(n2, l2, u2, t2) {
  var i = n2.key, o2 = n2.type, r2 = u2 - 1, f2 = u2 + 1, e2 = l2[u2];
  if (null === e2 || e2 && i == e2.key && o2 === e2.type && 0 == (131072 & e2.__u)) return u2;
  if (t2 > (null != e2 && 0 == (131072 & e2.__u) ? 1 : 0)) for (; r2 >= 0 || f2 < l2.length; ) {
    if (r2 >= 0) {
      if ((e2 = l2[r2]) && 0 == (131072 & e2.__u) && i == e2.key && o2 === e2.type) return r2;
      r2--;
    }
    if (f2 < l2.length) {
      if ((e2 = l2[f2]) && 0 == (131072 & e2.__u) && i == e2.key && o2 === e2.type) return f2;
      f2++;
    }
  }
  return -1;
}
function H$2(n2, l2, u2) {
  "-" === l2[0] ? n2.setProperty(l2, null == u2 ? "" : u2) : n2[l2] = null == u2 ? "" : "number" != typeof u2 || a$2.test(l2) ? u2 : u2 + "px";
}
function T$3(n2, l2, u2, t2, i) {
  var o2;
  n: if ("style" === l2) if ("string" == typeof u2) n2.style.cssText = u2;
  else {
    if ("string" == typeof t2 && (n2.style.cssText = t2 = ""), t2) for (l2 in t2) u2 && l2 in u2 || H$2(n2.style, l2, "");
    if (u2) for (l2 in u2) t2 && u2[l2] === t2[l2] || H$2(n2.style, l2, u2[l2]);
  }
  else if ("o" === l2[0] && "n" === l2[1]) o2 = l2 !== (l2 = l2.replace(/(PointerCapture)$|Capture$/i, "$1")), l2 = l2.toLowerCase() in n2 || "onFocusOut" === l2 || "onFocusIn" === l2 ? l2.toLowerCase().slice(2) : l2.slice(2), n2.l || (n2.l = {}), n2.l[l2 + o2] = u2, u2 ? t2 ? u2.u = t2.u : (u2.u = Date.now(), n2.addEventListener(l2, o2 ? D$3 : A$4, o2)) : n2.removeEventListener(l2, o2 ? D$3 : A$4, o2);
  else {
    if (i) l2 = l2.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
    else if ("width" !== l2 && "height" !== l2 && "href" !== l2 && "list" !== l2 && "form" !== l2 && "tabIndex" !== l2 && "download" !== l2 && "rowSpan" !== l2 && "colSpan" !== l2 && "role" !== l2 && l2 in n2) try {
      n2[l2] = null == u2 ? "" : u2;
      break n;
    } catch (n3) {
    }
    "function" == typeof u2 || (null == u2 || false === u2 && "-" !== l2[4] ? n2.removeAttribute(l2) : n2.setAttribute(l2, u2));
  }
}
function A$4(n2) {
  if (this.l) {
    var u2 = this.l[n2.type + false];
    if (n2.t) {
      if (n2.t <= u2.u) return;
    } else n2.t = Date.now();
    return u2(l$3.event ? l$3.event(n2) : n2);
  }
}
function D$3(n2) {
  if (this.l) return this.l[n2.type + true](l$3.event ? l$3.event(n2) : n2);
}
function F$3(n2, u2, t2, i, o2, r2, f2, e2, c6, s2) {
  var a2, p2, y2, d2, _2, m2, w2, k2, x2, P2, S2, $2, I2, H2, T2, A2 = u2.type;
  if (void 0 !== u2.constructor) return null;
  128 & t2.__u && (c6 = !!(32 & t2.__u), r2 = [e2 = u2.__e = t2.__e]), (a2 = l$3.__b) && a2(u2);
  n: if ("function" == typeof A2) try {
    if (k2 = u2.props, x2 = (a2 = A2.contextType) && i[a2.__c], P2 = a2 ? x2 ? x2.props.value : a2.__ : i, t2.__c ? w2 = (p2 = u2.__c = t2.__c).__ = p2.__E : ("prototype" in A2 && A2.prototype.render ? u2.__c = p2 = new A2(k2, P2) : (u2.__c = p2 = new b$3(k2, P2), p2.constructor = A2, p2.render = z$4), x2 && x2.sub(p2), p2.props = k2, p2.state || (p2.state = {}), p2.context = P2, p2.__n = i, y2 = p2.__d = true, p2.__h = [], p2._sb = []), null == p2.__s && (p2.__s = p2.state), null != A2.getDerivedStateFromProps && (p2.__s == p2.state && (p2.__s = v$3({}, p2.__s)), v$3(p2.__s, A2.getDerivedStateFromProps(k2, p2.__s))), d2 = p2.props, _2 = p2.state, p2.__v = u2, y2) null == A2.getDerivedStateFromProps && null != p2.componentWillMount && p2.componentWillMount(), null != p2.componentDidMount && p2.__h.push(p2.componentDidMount);
    else {
      if (null == A2.getDerivedStateFromProps && k2 !== d2 && null != p2.componentWillReceiveProps && p2.componentWillReceiveProps(k2, P2), !p2.__e && (null != p2.shouldComponentUpdate && false === p2.shouldComponentUpdate(k2, p2.__s, P2) || u2.__v === t2.__v)) {
        for (u2.__v !== t2.__v && (p2.props = k2, p2.state = p2.__s, p2.__d = false), u2.__e = t2.__e, u2.__k = t2.__k, u2.__k.forEach(function(n3) {
          n3 && (n3.__ = u2);
        }), S2 = 0; S2 < p2._sb.length; S2++) p2.__h.push(p2._sb[S2]);
        p2._sb = [], p2.__h.length && f2.push(p2);
        break n;
      }
      null != p2.componentWillUpdate && p2.componentWillUpdate(k2, p2.__s, P2), null != p2.componentDidUpdate && p2.__h.push(function() {
        p2.componentDidUpdate(d2, _2, m2);
      });
    }
    if (p2.context = P2, p2.props = k2, p2.__P = n2, p2.__e = false, $2 = l$3.__r, I2 = 0, "prototype" in A2 && A2.prototype.render) {
      for (p2.state = p2.__s, p2.__d = false, $2 && $2(u2), a2 = p2.render(p2.props, p2.state, p2.context), H2 = 0; H2 < p2._sb.length; H2++) p2.__h.push(p2._sb[H2]);
      p2._sb = [];
    } else do {
      p2.__d = false, $2 && $2(u2), a2 = p2.render(p2.props, p2.state, p2.context), p2.state = p2.__s;
    } while (p2.__d && ++I2 < 25);
    p2.state = p2.__s, null != p2.getChildContext && (i = v$3(v$3({}, i), p2.getChildContext())), y2 || null == p2.getSnapshotBeforeUpdate || (m2 = p2.getSnapshotBeforeUpdate(d2, _2)), C$3(n2, h$3(T2 = null != a2 && a2.type === g$3 && null == a2.key ? a2.props.children : a2) ? T2 : [T2], u2, t2, i, o2, r2, f2, e2, c6, s2), p2.base = u2.__e, u2.__u &= -161, p2.__h.length && f2.push(p2), w2 && (p2.__E = p2.__ = null);
  } catch (n3) {
    u2.__v = null, c6 || null != r2 ? (u2.__e = e2, u2.__u |= c6 ? 160 : 32, r2[r2.indexOf(e2)] = null) : (u2.__e = t2.__e, u2.__k = t2.__k), l$3.__e(n3, u2, t2);
  }
  else null == r2 && u2.__v === t2.__v ? (u2.__k = t2.__k, u2.__e = t2.__e) : u2.__e = M$2(t2.__e, u2, t2, i, o2, r2, f2, c6, s2);
  (a2 = l$3.diffed) && a2(u2);
}
function L$2(n2, u2, t2) {
  u2.__d = void 0;
  for (var i = 0; i < t2.length; i++) O$2(t2[i], t2[++i], t2[++i]);
  l$3.__c && l$3.__c(u2, n2), n2.some(function(u3) {
    try {
      n2 = u3.__h, u3.__h = [], n2.some(function(n3) {
        n3.call(u3);
      });
    } catch (n3) {
      l$3.__e(n3, u3.__v);
    }
  });
}
function M$2(l2, u2, t2, i, o2, r2, f2, e2, s2) {
  var a2, v2, y2, d2, _2, g2, b2, w2 = t2.props, k2 = u2.props, x2 = u2.type;
  if ("svg" === x2 && (o2 = true), null != r2) {
    for (a2 = 0; a2 < r2.length; a2++) if ((_2 = r2[a2]) && "setAttribute" in _2 == !!x2 && (x2 ? _2.localName === x2 : 3 === _2.nodeType)) {
      l2 = _2, r2[a2] = null;
      break;
    }
  }
  if (null == l2) {
    if (null === x2) return document.createTextNode(k2);
    l2 = o2 ? document.createElementNS("http://www.w3.org/2000/svg", x2) : document.createElement(x2, k2.is && k2), r2 = null, e2 = false;
  }
  if (null === x2) w2 === k2 || e2 && l2.data === k2 || (l2.data = k2);
  else {
    if (r2 = r2 && n$2.call(l2.childNodes), w2 = t2.props || c$3, !e2 && null != r2) for (w2 = {}, a2 = 0; a2 < l2.attributes.length; a2++) w2[(_2 = l2.attributes[a2]).name] = _2.value;
    for (a2 in w2) _2 = w2[a2], "children" == a2 || ("dangerouslySetInnerHTML" == a2 ? y2 = _2 : "key" === a2 || a2 in k2 || T$3(l2, a2, null, _2, o2));
    for (a2 in k2) _2 = k2[a2], "children" == a2 ? d2 = _2 : "dangerouslySetInnerHTML" == a2 ? v2 = _2 : "value" == a2 ? g2 = _2 : "checked" == a2 ? b2 = _2 : "key" === a2 || e2 && "function" != typeof _2 || w2[a2] === _2 || T$3(l2, a2, _2, w2[a2], o2);
    if (v2) e2 || y2 && (v2.__html === y2.__html || v2.__html === l2.innerHTML) || (l2.innerHTML = v2.__html), u2.__k = [];
    else if (y2 && (l2.innerHTML = ""), C$3(l2, h$3(d2) ? d2 : [d2], u2, t2, i, o2 && "foreignObject" !== x2, r2, f2, r2 ? r2[0] : t2.__k && m$3(t2, 0), e2, s2), null != r2) for (a2 = r2.length; a2--; ) null != r2[a2] && p$3(r2[a2]);
    e2 || (a2 = "value", void 0 !== g2 && (g2 !== l2[a2] || "progress" === x2 && !g2 || "option" === x2 && g2 !== w2[a2]) && T$3(l2, a2, g2, w2[a2], false), a2 = "checked", void 0 !== b2 && b2 !== l2[a2] && T$3(l2, a2, b2, w2[a2], false));
  }
  return l2;
}
function O$2(n2, u2, t2) {
  try {
    "function" == typeof n2 ? n2(u2) : n2.current = u2;
  } catch (n3) {
    l$3.__e(n3, t2);
  }
}
function j$3(n2, u2, t2) {
  var i, o2;
  if (l$3.unmount && l$3.unmount(n2), (i = n2.ref) && (i.current && i.current !== n2.__e || O$2(i, null, u2)), null != (i = n2.__c)) {
    if (i.componentWillUnmount) try {
      i.componentWillUnmount();
    } catch (n3) {
      l$3.__e(n3, u2);
    }
    i.base = i.__P = null, n2.__c = void 0;
  }
  if (i = n2.__k) for (o2 = 0; o2 < i.length; o2++) i[o2] && j$3(i[o2], u2, t2 || "function" != typeof n2.type);
  t2 || null == n2.__e || p$3(n2.__e), n2.__ = n2.__e = n2.__d = void 0;
}
function z$4(n2, l2, u2) {
  return this.constructor(n2, u2);
}
function N$2(u2, t2, i) {
  var o2, r2, f2, e2;
  l$3.__ && l$3.__(u2, t2), r2 = (o2 = "function" == typeof i) ? null : i && i.__k || t2.__k, f2 = [], e2 = [], F$3(t2, u2 = (!o2 && i || t2).__k = y$3(g$3, null, [u2]), r2 || c$3, c$3, void 0 !== t2.ownerSVGElement, !o2 && i ? [i] : r2 ? null : t2.firstChild ? n$2.call(t2.childNodes) : null, f2, !o2 && i ? i : r2 ? r2.__e : t2.firstChild, o2, e2), L$2(f2, u2, e2);
}
function q$4(n2, l2) {
  N$2(n2, l2, q$4);
}
function B$3(l2, u2, t2) {
  var i, o2, r2, f2, e2 = v$3({}, l2.props);
  for (r2 in l2.type && l2.type.defaultProps && (f2 = l2.type.defaultProps), u2) "key" == r2 ? i = u2[r2] : "ref" == r2 ? o2 = u2[r2] : e2[r2] = void 0 === u2[r2] && void 0 !== f2 ? f2[r2] : u2[r2];
  return arguments.length > 2 && (e2.children = arguments.length > 3 ? n$2.call(arguments, 2) : t2), d$3(l2.type, e2, i || l2.key, o2 || l2.ref, null);
}
function E$2(n2, l2) {
  var u2 = { __c: l2 = "__cC" + e$3++, __: n2, Consumer: function(n3, l3) {
    return n3.children(l3);
  }, Provider: function(n3) {
    var u3, t2;
    return this.getChildContext || (u3 = [], (t2 = {})[l2] = this, this.getChildContext = function() {
      return t2;
    }, this.shouldComponentUpdate = function(n4) {
      this.props.value !== n4.value && u3.some(function(n5) {
        n5.__e = true, k$4(n5);
      });
    }, this.sub = function(n4) {
      u3.push(n4);
      var l3 = n4.componentWillUnmount;
      n4.componentWillUnmount = function() {
        u3.splice(u3.indexOf(n4), 1), l3 && l3.call(n4);
      };
    }), n3.children;
  } };
  return u2.Provider.__ = u2.Consumer.contextType = u2;
}
n$2 = s$2.slice, l$3 = { __e: function(n2, l2, u2, t2) {
  for (var i, o2, r2; l2 = l2.__; ) if ((i = l2.__c) && !i.__) try {
    if ((o2 = i.constructor) && null != o2.getDerivedStateFromError && (i.setState(o2.getDerivedStateFromError(n2)), r2 = i.__d), null != i.componentDidCatch && (i.componentDidCatch(n2, t2 || {}), r2 = i.__d), r2) return i.__E = i;
  } catch (l3) {
    n2 = l3;
  }
  throw n2;
} }, u$3 = 0, b$3.prototype.setState = function(n2, l2) {
  var u2;
  u2 = null != this.__s && this.__s !== this.state ? this.__s : this.__s = v$3({}, this.state), "function" == typeof n2 && (n2 = n2(v$3({}, u2), this.props)), n2 && v$3(u2, n2), null != n2 && this.__v && (l2 && this._sb.push(l2), k$4(this));
}, b$3.prototype.forceUpdate = function(n2) {
  this.__v && (this.__e = true, n2 && this.__h.push(n2), k$4(this));
}, b$3.prototype.render = g$3, i$3 = [], r$3 = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, f$3 = function(n2, l2) {
  return n2.__v.__b - l2.__v.__b;
}, x$4.__r = 0, e$3 = 0;
var f$2 = 0;
function u$2(e2, t2, n2, o2, i, u2) {
  var a2, c6, p2 = {};
  for (c6 in t2) "ref" == c6 ? a2 = t2[c6] : p2[c6] = t2[c6];
  var l2 = { type: e2, props: p2, key: n2, ref: a2, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: --f$2, __i: -1, __u: 0, __source: i, __self: u2 };
  if ("function" == typeof e2 && (a2 = e2.defaultProps)) for (c6 in a2) void 0 === p2[c6] && (p2[c6] = a2[c6]);
  return l$3.vnode && l$3.vnode(l2), l2;
}
var e$2, t$2 = "undefined" != typeof window ? window : void 0, i$2 = "undefined" != typeof globalThis ? globalThis : t$2, n$1 = Array.prototype, r$2 = n$1.forEach, s$1 = n$1.indexOf, o$1 = null == i$2 ? void 0 : i$2.navigator, a$1 = null == i$2 ? void 0 : i$2.document, l$2 = null == i$2 ? void 0 : i$2.location, u$1 = null == i$2 ? void 0 : i$2.fetch, c$2 = null != i$2 && i$2.XMLHttpRequest && "withCredentials" in new i$2.XMLHttpRequest() ? i$2.XMLHttpRequest : void 0, d$2 = null == i$2 ? void 0 : i$2.AbortController, h$2 = null == o$1 ? void 0 : o$1.userAgent, _$1 = null != t$2 ? t$2 : {}, p$2 = { DEBUG: false, LIB_VERSION: "1.203.1" }, v$2 = "$copy_autocapture", g$2 = ["$snapshot", "$pageview", "$pageleave", "$set", "survey dismissed", "survey sent", "survey shown", "$identify", "$groupidentify", "$create_alias", "$$client_ingestion_warning", "$web_experiment_applied", "$feature_enrollment_update", "$feature_flag_called"];
!function(e2) {
  e2.GZipJS = "gzip-js", e2.Base64 = "base64";
}(e$2 || (e$2 = {}));
function m$2(e2, t2) {
  return -1 !== e2.indexOf(t2);
}
var b$2 = function(e2) {
  return e2.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
}, y$2 = function(e2) {
  return e2.replace(/^\$/, "");
};
var w$3 = Array.isArray, S$1 = Object.prototype, E$1 = S$1.hasOwnProperty, k$3 = S$1.toString, x$3 = w$3 || function(e2) {
  return "[object Array]" === k$3.call(e2);
}, I$1 = (e2) => "function" == typeof e2, C$2 = (e2) => e2 === Object(e2) && !x$3(e2), P$2 = (e2) => {
  if (C$2(e2)) {
    for (var t2 in e2) if (E$1.call(e2, t2)) return false;
    return true;
  }
  return false;
}, R$1 = (e2) => void 0 === e2, F$2 = (e2) => "[object String]" == k$3.call(e2), T$2 = (e2) => F$2(e2) && 0 === e2.trim().length, $$1 = (e2) => null === e2, O$1 = (e2) => R$1(e2) || $$1(e2), L$1 = (e2) => "[object Number]" == k$3.call(e2), M$1 = (e2) => "[object Boolean]" === k$3.call(e2), A$3 = (e2) => e2 instanceof FormData, D$2 = (e2) => m$2(g$2, e2), N$1 = (e2) => {
  var i = { _log: function(i2) {
    if (t$2 && (p$2.DEBUG || _$1.POSTHOG_DEBUG) && !R$1(t$2.console) && t$2.console) {
      for (var n2 = ("__rrweb_original__" in t$2.console[i2]) ? t$2.console[i2].__rrweb_original__ : t$2.console[i2], r2 = arguments.length, s2 = new Array(r2 > 1 ? r2 - 1 : 0), o2 = 1; o2 < r2; o2++) s2[o2 - 1] = arguments[o2];
      n2(e2, ...s2);
    }
  }, info: function() {
    for (var e3 = arguments.length, t2 = new Array(e3), n2 = 0; n2 < e3; n2++) t2[n2] = arguments[n2];
    i._log("log", ...t2);
  }, warn: function() {
    for (var e3 = arguments.length, t2 = new Array(e3), n2 = 0; n2 < e3; n2++) t2[n2] = arguments[n2];
    i._log("warn", ...t2);
  }, error: function() {
    for (var e3 = arguments.length, t2 = new Array(e3), n2 = 0; n2 < e3; n2++) t2[n2] = arguments[n2];
    i._log("error", ...t2);
  }, critical: function() {
    for (var t2 = arguments.length, i2 = new Array(t2), n2 = 0; n2 < t2; n2++) i2[n2] = arguments[n2];
    console.error(e2, ...i2);
  }, uninitializedWarning: (e3) => {
    i.error("You must initialize PostHog before calling ".concat(e3));
  }, createLogger: (t2) => N$1("".concat(e2, " ").concat(t2)) };
  return i;
}, q$3 = N$1("[PostHog.js]"), B$2 = q$3.createLogger, H$1 = B$2("[ExternalScriptsLoader]"), U$1 = (e2, t2, i) => {
  if (e2.config.disable_external_dependency_loading) return H$1.warn("".concat(t2, " was requested but loading of external scripts is disabled.")), i("Loading of external scripts is disabled");
  var n2 = () => {
    if (!a$1) return i("document not found");
    var e3 = a$1.createElement("script");
    e3.type = "text/javascript", e3.crossOrigin = "anonymous", e3.src = t2, e3.onload = (e4) => i(void 0, e4), e3.onerror = (e4) => i(e4);
    var n3, r2 = a$1.querySelectorAll("body > script");
    r2.length > 0 ? null === (n3 = r2[0].parentNode) || void 0 === n3 || n3.insertBefore(e3, r2[0]) : a$1.body.appendChild(e3);
  };
  null != a$1 && a$1.body ? n2() : null == a$1 || a$1.addEventListener("DOMContentLoaded", n2);
};
function z$3(e2, t2) {
  var i = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e2);
    t2 && (n2 = n2.filter(function(t3) {
      return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
    })), i.push.apply(i, n2);
  }
  return i;
}
function j$2(e2) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var i = null != arguments[t2] ? arguments[t2] : {};
    t2 % 2 ? z$3(Object(i), true).forEach(function(t3) {
      W$1(e2, t3, i[t3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i)) : z$3(Object(i)).forEach(function(t3) {
      Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i, t3));
    });
  }
  return e2;
}
function W$1(e2, t2, i) {
  return t2 in e2 ? Object.defineProperty(e2, t2, { value: i, enumerable: true, configurable: true, writable: true }) : e2[t2] = i, e2;
}
function G$1(e2, t2) {
  if (null == e2) return {};
  var i, n2, r2 = function(e3, t3) {
    if (null == e3) return {};
    var i2, n3, r3 = {}, s3 = Object.keys(e3);
    for (n3 = 0; n3 < s3.length; n3++) i2 = s3[n3], t3.indexOf(i2) >= 0 || (r3[i2] = e3[i2]);
    return r3;
  }(e2, t2);
  if (Object.getOwnPropertySymbols) {
    var s2 = Object.getOwnPropertySymbols(e2);
    for (n2 = 0; n2 < s2.length; n2++) i = s2[n2], t2.indexOf(i) >= 0 || Object.prototype.propertyIsEnumerable.call(e2, i) && (r2[i] = e2[i]);
  }
  return r2;
}
_$1.__PosthogExtensions__ = _$1.__PosthogExtensions__ || {}, _$1.__PosthogExtensions__.loadExternalDependency = (e2, t2, i) => {
  var n2 = "/static/".concat(t2, ".js") + "?v=".concat(e2.version);
  if ("remote-config" === t2 && (n2 = "/array/".concat(e2.config.token, "/config.js")), "toolbar" === t2) {
    var r2 = 3e5, s2 = Math.floor(Date.now() / r2) * r2;
    n2 = "".concat(n2, "&t=").concat(s2);
  }
  var o2 = e2.requestRouter.endpointFor("assets", n2);
  U$1(e2, o2, i);
}, _$1.__PosthogExtensions__.loadSiteApp = (e2, t2, i) => {
  var n2 = e2.requestRouter.endpointFor("api", t2);
  U$1(e2, n2, i);
};
var V$2 = {};
function J$1(e2, t2, i) {
  if (x$3(e2)) {
    if (r$2 && e2.forEach === r$2) e2.forEach(t2, i);
    else if ("length" in e2 && e2.length === +e2.length) {
      for (var n2 = 0, s2 = e2.length; n2 < s2; n2++) if (n2 in e2 && t2.call(i, e2[n2], n2) === V$2) return;
    }
  }
}
function Y$1(e2, t2, i) {
  if (!O$1(e2)) {
    if (x$3(e2)) return J$1(e2, t2, i);
    if (A$3(e2)) {
      for (var n2 of e2.entries()) if (t2.call(i, n2[1], n2[0]) === V$2) return;
    } else for (var r2 in e2) if (E$1.call(e2, r2) && t2.call(i, e2[r2], r2) === V$2) return;
  }
}
var K$1 = function(e2) {
  for (var t2 = arguments.length, i = new Array(t2 > 1 ? t2 - 1 : 0), n2 = 1; n2 < t2; n2++) i[n2 - 1] = arguments[n2];
  return J$1(i, function(t3) {
    for (var i2 in t3) void 0 !== t3[i2] && (e2[i2] = t3[i2]);
  }), e2;
};
function X$1(e2) {
  for (var t2 = Object.keys(e2), i = t2.length, n2 = new Array(i); i--; ) n2[i] = [t2[i], e2[t2[i]]];
  return n2;
}
var Q$1 = function(e2) {
  try {
    return e2();
  } catch (e3) {
    return;
  }
}, Z$1 = function(e2) {
  return function() {
    try {
      for (var t2 = arguments.length, i = new Array(t2), n2 = 0; n2 < t2; n2++) i[n2] = arguments[n2];
      return e2.apply(this, i);
    } catch (e3) {
      q$3.critical("Implementation error. Please turn on debug mode and open a ticket on https://app.posthog.com/home#panel=support%3Asupport%3A."), q$3.critical(e3);
    }
  };
}, ee = function(e2) {
  var t2 = {};
  return Y$1(e2, function(e3, i) {
    F$2(e3) && e3.length > 0 && (t2[i] = e3);
  }), t2;
};
function te(e2, t2) {
  return i = e2, n2 = (e3) => F$2(e3) && !$$1(t2) ? e3.slice(0, t2) : e3, r2 = /* @__PURE__ */ new Set(), function e3(t3, i2) {
    return t3 !== Object(t3) ? n2 ? n2(t3, i2) : t3 : r2.has(t3) ? void 0 : (r2.add(t3), x$3(t3) ? (s2 = [], J$1(t3, (t4) => {
      s2.push(e3(t4));
    })) : (s2 = {}, Y$1(t3, (t4, i3) => {
      r2.has(t4) || (s2[i3] = e3(t4, i3));
    })), s2);
    var s2;
  }(i);
  var i, n2, r2;
}
var ie = function() {
  function e2(t2) {
    return t2 && (t2.preventDefault = e2.preventDefault, t2.stopPropagation = e2.stopPropagation), t2;
  }
  return e2.preventDefault = function() {
    this.returnValue = false;
  }, e2.stopPropagation = function() {
    this.cancelBubble = true;
  }, function(i, n2, r2, s2, o2) {
    if (i) if (i.addEventListener && !s2) i.addEventListener(n2, r2, !!o2);
    else {
      var a2 = "on" + n2, l2 = i[a2];
      i[a2] = /* @__PURE__ */ function(i2, n3, r3) {
        return function(s3) {
          if (s3 = s3 || e2(null == t$2 ? void 0 : t$2.event)) {
            var o3, a3 = true;
            I$1(r3) && (o3 = r3(s3));
            var l3 = n3.call(i2, s3);
            return false !== o3 && false !== l3 || (a3 = false), a3;
          }
        };
      }(i, r2, l2);
    }
    else q$3.error("No valid element provided to register_event");
  };
}();
function ne(e2, t2) {
  for (var i = 0; i < e2.length; i++) if (t2(e2[i])) return e2[i];
}
var re$2 = "$people_distinct_id", se = "__alias", oe = "__timers", ae = "$autocapture_disabled_server_side", le = "$heatmaps_enabled_server_side", ue = "$exception_capture_enabled_server_side", ce = "$web_vitals_enabled_server_side", de = "$dead_clicks_enabled_server_side", he = "$web_vitals_allowed_metrics", _e = "$session_recording_enabled_server_side", pe = "$console_log_recording_enabled_server_side", ve = "$session_recording_network_payload_capture", ge = "$session_recording_canvas_recording", fe = "$replay_sample_rate", me = "$replay_minimum_duration", be = "$replay_script_config", ye = "$sesid", we = "$session_is_sampled", Se = "$session_recording_url_trigger_activated_session", Ee = "$session_recording_event_trigger_activated_session", ke = "$enabled_feature_flags", xe = "$early_access_features", Ie = "$stored_person_properties", Ce = "$stored_group_properties", Pe = "$surveys", Re = "$surveys_activated", Fe = "$flag_call_reported", Te = "$user_state", $e = "$client_session_props", Oe = "$capture_rate_limit", Le = "$initial_campaign_params", Me = "$initial_referrer_info", Ae = "$initial_person_info", De = "$epp", Ne = "__POSTHOG_TOOLBAR__", qe = "$posthog_cklsh", Be = [re$2, se, "__cmpns", oe, _e, le, ye, ke, Te, xe, Ce, Ie, Pe, Fe, $e, Oe, Le, Me, De], He = B$2("[FeatureFlags]"), Ue = "$active_feature_flags", ze = "$override_feature_flags", je = "$feature_flag_payloads", We = (e2) => {
  var t2 = {};
  for (var [i, n2] of X$1(e2 || {})) n2 && (t2[i] = n2);
  return t2;
};
class Ge {
  constructor(e2) {
    W$1(this, "_override_warning", false), W$1(this, "_hasLoadedFlags", false), W$1(this, "_requestInFlight", false), W$1(this, "_reloadingDisabled", false), W$1(this, "_additionalReloadRequested", false), W$1(this, "_decideCalled", false), W$1(this, "_flagsLoadedFromRemote", false), this.instance = e2, this.featureFlagEventHandlers = [];
  }
  decide() {
    if (this.instance.config.__preview_remote_config) this._decideCalled = true;
    else {
      var e2 = !this._reloadDebouncer && (this.instance.config.advanced_disable_feature_flags || this.instance.config.advanced_disable_feature_flags_on_first_load);
      this._callDecideEndpoint({ disableFlags: e2 });
    }
  }
  get hasLoadedFlags() {
    return this._hasLoadedFlags;
  }
  getFlags() {
    return Object.keys(this.getFlagVariants());
  }
  getFlagVariants() {
    var e2 = this.instance.get_property(ke), t2 = this.instance.get_property(ze);
    if (!t2) return e2 || {};
    for (var i = K$1({}, e2), n2 = Object.keys(t2), r2 = 0; r2 < n2.length; r2++) i[n2[r2]] = t2[n2[r2]];
    return this._override_warning || (He.warn(" Overriding feature flags!", { enabledFlags: e2, overriddenFlags: t2, finalFlags: i }), this._override_warning = true), i;
  }
  getFlagPayloads() {
    return this.instance.get_property(je) || {};
  }
  reloadFeatureFlags() {
    this._reloadingDisabled || this.instance.config.advanced_disable_feature_flags || this._reloadDebouncer || (this._reloadDebouncer = setTimeout(() => {
      this._callDecideEndpoint();
    }, 5));
  }
  clearDebouncer() {
    clearTimeout(this._reloadDebouncer), this._reloadDebouncer = void 0;
  }
  ensureFlagsLoaded() {
    this._hasLoadedFlags || this._requestInFlight || this._reloadDebouncer || this.reloadFeatureFlags();
  }
  setAnonymousDistinctId(e2) {
    this.$anon_distinct_id = e2;
  }
  setReloadingPaused(e2) {
    this._reloadingDisabled = e2;
  }
  _callDecideEndpoint(t2) {
    if (this.clearDebouncer(), !this.instance.config.advanced_disable_decide) if (this._requestInFlight) this._additionalReloadRequested = true;
    else {
      var i = { token: this.instance.config.token, distinct_id: this.instance.get_distinct_id(), groups: this.instance.getGroups(), $anon_distinct_id: this.$anon_distinct_id, person_properties: this.instance.get_property(Ie), group_properties: this.instance.get_property(Ce) };
      (null != t2 && t2.disableFlags || this.instance.config.advanced_disable_feature_flags) && (i.disable_flags = true), this._requestInFlight = true, this.instance._send_request({ method: "POST", url: this.instance.requestRouter.endpointFor("api", "/decide/?v=3"), data: i, compression: this.instance.config.disable_compression ? void 0 : e$2.Base64, timeout: this.instance.config.feature_flag_request_timeout_ms, callback: (e2) => {
        var t3, n2, r2 = true;
        (200 === e2.statusCode && (this.$anon_distinct_id = void 0, r2 = false), this._requestInFlight = false, this._decideCalled) || (this._decideCalled = true, this.instance._onRemoteConfig(null !== (n2 = e2.json) && void 0 !== n2 ? n2 : {}));
        i.disable_flags || (this._flagsLoadedFromRemote = !r2, this.receivedFeatureFlags(null !== (t3 = e2.json) && void 0 !== t3 ? t3 : {}, r2), this._additionalReloadRequested && (this._additionalReloadRequested = false, this._callDecideEndpoint()));
      } });
    }
  }
  getFeatureFlag(e2) {
    var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    if (this._hasLoadedFlags || this.getFlags() && this.getFlags().length > 0) {
      var i, n2, r2, s2, o2, a2 = this.getFlagVariants()[e2], l2 = "".concat(a2), u2 = this.instance.get_property(Fe) || {};
      if (t2.send_event || !("send_event" in t2)) {
        if (!(e2 in u2) || !u2[e2].includes(l2)) x$3(u2[e2]) ? u2[e2].push(l2) : u2[e2] = [l2], null === (i = this.instance.persistence) || void 0 === i || i.register({ [Fe]: u2 }), this.instance.capture("$feature_flag_called", { $feature_flag: e2, $feature_flag_response: a2, $feature_flag_payload: this.getFeatureFlagPayload(e2) || null, $feature_flag_bootstrapped_response: (null === (n2 = this.instance.config.bootstrap) || void 0 === n2 || null === (r2 = n2.featureFlags) || void 0 === r2 ? void 0 : r2[e2]) || null, $feature_flag_bootstrapped_payload: (null === (s2 = this.instance.config.bootstrap) || void 0 === s2 || null === (o2 = s2.featureFlagPayloads) || void 0 === o2 ? void 0 : o2[e2]) || null, $used_bootstrap_value: !this._flagsLoadedFromRemote });
      }
      return a2;
    }
    He.warn('getFeatureFlag for key "' + e2 + `" failed. Feature flags didn't load in time.`);
  }
  getFeatureFlagPayload(e2) {
    return this.getFlagPayloads()[e2];
  }
  isFeatureEnabled(e2) {
    var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    if (this._hasLoadedFlags || this.getFlags() && this.getFlags().length > 0) return !!this.getFeatureFlag(e2, t2);
    He.warn('isFeatureEnabled for key "' + e2 + `" failed. Feature flags didn't load in time.`);
  }
  addFeatureFlagsHandler(e2) {
    this.featureFlagEventHandlers.push(e2);
  }
  removeFeatureFlagsHandler(e2) {
    this.featureFlagEventHandlers = this.featureFlagEventHandlers.filter((t2) => t2 !== e2);
  }
  receivedFeatureFlags(e2, t2) {
    if (this.instance.persistence) {
      this._hasLoadedFlags = true;
      var i = this.getFlagVariants(), n2 = this.getFlagPayloads();
      !function(e3, t3) {
        var i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, n3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}, r2 = e3.featureFlags, s2 = e3.featureFlagPayloads;
        if (r2) if (x$3(r2)) {
          var o2 = {};
          if (r2) for (var a2 = 0; a2 < r2.length; a2++) o2[r2[a2]] = true;
          t3 && t3.register({ [Ue]: r2, [ke]: o2 });
        } else {
          var l2 = r2, u2 = s2;
          e3.errorsWhileComputingFlags && (l2 = j$2(j$2({}, i2), l2), u2 = j$2(j$2({}, n3), u2)), t3 && t3.register({ [Ue]: Object.keys(We(l2)), [ke]: l2 || {}, [je]: u2 || {} });
        }
      }(e2, this.instance.persistence, i, n2), this._fireFeatureFlagsCallbacks(t2);
    }
  }
  override(e2) {
    var t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    if (!this.instance.__loaded || !this.instance.persistence) return He.uninitializedWarning("posthog.feature_flags.override");
    if (this._override_warning = t2, false === e2) this.instance.persistence.unregister(ze);
    else if (x$3(e2)) {
      for (var i = {}, n2 = 0; n2 < e2.length; n2++) i[e2[n2]] = true;
      this.instance.persistence.register({ [ze]: i });
    } else this.instance.persistence.register({ [ze]: e2 });
  }
  onFeatureFlags(e2) {
    if (this.addFeatureFlagsHandler(e2), this._hasLoadedFlags) {
      var { flags: t2, flagVariants: i } = this._prepareFeatureFlagsForCallbacks();
      e2(t2, i);
    }
    return () => this.removeFeatureFlagsHandler(e2);
  }
  updateEarlyAccessFeatureEnrollment(e2, t2) {
    var i, n2 = (this.instance.get_property(xe) || []).find((t3) => t3.flagKey === e2), r2 = { ["$feature_enrollment/".concat(e2)]: t2 }, s2 = { $feature_flag: e2, $feature_enrollment: t2, $set: r2 };
    n2 && (s2.$early_access_feature_name = n2.name), this.instance.capture("$feature_enrollment_update", s2), this.setPersonPropertiesForFlags(r2, false);
    var o2 = j$2(j$2({}, this.getFlagVariants()), {}, { [e2]: t2 });
    null === (i = this.instance.persistence) || void 0 === i || i.register({ [Ue]: Object.keys(We(o2)), [ke]: o2 }), this._fireFeatureFlagsCallbacks();
  }
  getEarlyAccessFeatures(e2) {
    var t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], i = this.instance.get_property(xe);
    if (i && !t2) return e2(i);
    this.instance._send_request({ url: this.instance.requestRouter.endpointFor("api", "/api/early_access_features/?token=".concat(this.instance.config.token)), method: "GET", callback: (t3) => {
      var i2;
      if (t3.json) {
        var n2 = t3.json.earlyAccessFeatures;
        return null === (i2 = this.instance.persistence) || void 0 === i2 || i2.register({ [xe]: n2 }), e2(n2);
      }
    } });
  }
  _prepareFeatureFlagsForCallbacks() {
    var e2 = this.getFlags(), t2 = this.getFlagVariants();
    return { flags: e2.filter((e3) => t2[e3]), flagVariants: Object.keys(t2).filter((e3) => t2[e3]).reduce((e3, i) => (e3[i] = t2[i], e3), {}) };
  }
  _fireFeatureFlagsCallbacks(e2) {
    var { flags: t2, flagVariants: i } = this._prepareFeatureFlagsForCallbacks();
    this.featureFlagEventHandlers.forEach((n2) => n2(t2, i, { errorsLoading: e2 }));
  }
  setPersonPropertiesForFlags(e2) {
    var t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i = this.instance.get_property(Ie) || {};
    this.instance.register({ [Ie]: j$2(j$2({}, i), e2) }), t2 && this.instance.reloadFeatureFlags();
  }
  resetPersonPropertiesForFlags() {
    this.instance.unregister(Ie);
  }
  setGroupPropertiesForFlags(e2) {
    var t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i = this.instance.get_property(Ce) || {};
    0 !== Object.keys(i).length && Object.keys(i).forEach((t3) => {
      i[t3] = j$2(j$2({}, i[t3]), e2[t3]), delete e2[t3];
    }), this.instance.register({ [Ce]: j$2(j$2({}, i), e2) }), t2 && this.instance.reloadFeatureFlags();
  }
  resetGroupPropertiesForFlags(e2) {
    if (e2) {
      var t2 = this.instance.get_property(Ce) || {};
      this.instance.register({ [Ce]: j$2(j$2({}, t2), {}, { [e2]: {} }) });
    } else this.instance.unregister(Ce);
  }
}
Math.trunc || (Math.trunc = function(e2) {
  return e2 < 0 ? Math.ceil(e2) : Math.floor(e2);
}), Number.isInteger || (Number.isInteger = function(e2) {
  return L$1(e2) && isFinite(e2) && Math.floor(e2) === e2;
});
var Ve = "0123456789abcdef";
class Je {
  constructor(e2) {
    if (this.bytes = e2, 16 !== e2.length) throw new TypeError("not 128-bit length");
  }
  static fromFieldsV7(e2, t2, i, n2) {
    if (!Number.isInteger(e2) || !Number.isInteger(t2) || !Number.isInteger(i) || !Number.isInteger(n2) || e2 < 0 || t2 < 0 || i < 0 || n2 < 0 || e2 > 281474976710655 || t2 > 4095 || i > 1073741823 || n2 > 4294967295) throw new RangeError("invalid field value");
    var r2 = new Uint8Array(16);
    return r2[0] = e2 / Math.pow(2, 40), r2[1] = e2 / Math.pow(2, 32), r2[2] = e2 / Math.pow(2, 24), r2[3] = e2 / Math.pow(2, 16), r2[4] = e2 / Math.pow(2, 8), r2[5] = e2, r2[6] = 112 | t2 >>> 8, r2[7] = t2, r2[8] = 128 | i >>> 24, r2[9] = i >>> 16, r2[10] = i >>> 8, r2[11] = i, r2[12] = n2 >>> 24, r2[13] = n2 >>> 16, r2[14] = n2 >>> 8, r2[15] = n2, new Je(r2);
  }
  toString() {
    for (var e2 = "", t2 = 0; t2 < this.bytes.length; t2++) e2 = e2 + Ve.charAt(this.bytes[t2] >>> 4) + Ve.charAt(15 & this.bytes[t2]), 3 !== t2 && 5 !== t2 && 7 !== t2 && 9 !== t2 || (e2 += "-");
    if (36 !== e2.length) throw new Error("Invalid UUIDv7 was generated");
    return e2;
  }
  clone() {
    return new Je(this.bytes.slice(0));
  }
  equals(e2) {
    return 0 === this.compareTo(e2);
  }
  compareTo(e2) {
    for (var t2 = 0; t2 < 16; t2++) {
      var i = this.bytes[t2] - e2.bytes[t2];
      if (0 !== i) return Math.sign(i);
    }
    return 0;
  }
}
class Ye {
  constructor() {
    W$1(this, "timestamp", 0), W$1(this, "counter", 0), W$1(this, "random", new Qe());
  }
  generate() {
    var e2 = this.generateOrAbort();
    if (R$1(e2)) {
      this.timestamp = 0;
      var t2 = this.generateOrAbort();
      if (R$1(t2)) throw new Error("Could not generate UUID after timestamp reset");
      return t2;
    }
    return e2;
  }
  generateOrAbort() {
    var e2 = Date.now();
    if (e2 > this.timestamp) this.timestamp = e2, this.resetCounter();
    else {
      if (!(e2 + 1e4 > this.timestamp)) return;
      this.counter++, this.counter > 4398046511103 && (this.timestamp++, this.resetCounter());
    }
    return Je.fromFieldsV7(this.timestamp, Math.trunc(this.counter / Math.pow(2, 30)), this.counter & Math.pow(2, 30) - 1, this.random.nextUint32());
  }
  resetCounter() {
    this.counter = 1024 * this.random.nextUint32() + (1023 & this.random.nextUint32());
  }
}
var Ke, Xe = (e2) => {
  if ("undefined" != typeof UUIDV7_DENY_WEAK_RNG && UUIDV7_DENY_WEAK_RNG) throw new Error("no cryptographically strong RNG available");
  for (var t2 = 0; t2 < e2.length; t2++) e2[t2] = 65536 * Math.trunc(65536 * Math.random()) + Math.trunc(65536 * Math.random());
  return e2;
};
t$2 && !R$1(t$2.crypto) && crypto.getRandomValues && (Xe = (e2) => crypto.getRandomValues(e2));
class Qe {
  constructor() {
    W$1(this, "buffer", new Uint32Array(8)), W$1(this, "cursor", 1 / 0);
  }
  nextUint32() {
    return this.cursor >= this.buffer.length && (Xe(this.buffer), this.cursor = 0), this.buffer[this.cursor++];
  }
}
var Ze = () => et().toString(), et = () => (Ke || (Ke = new Ye())).generate(), tt = "Thu, 01 Jan 1970 00:00:00 GMT", it = "";
var nt = /[a-z0-9][a-z0-9-]+\.[a-z]{2,}$/i;
function rt(e2, t2) {
  if (t2) {
    var i = function(e3) {
      var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : a$1;
      if (it) return it;
      if (!t3) return "";
      if (["localhost", "127.0.0.1"].includes(e3)) return "";
      for (var i2 = e3.split("."), n3 = Math.min(i2.length, 8), r2 = "dmn_chk_" + Ze(), s2 = new RegExp("(^|;)\\s*" + r2 + "=1"); !it && n3--; ) {
        var o2 = i2.slice(n3).join("."), l2 = r2 + "=1;domain=." + o2;
        t3.cookie = l2, s2.test(t3.cookie) && (t3.cookie = l2 + ";expires=" + tt, it = o2);
      }
      return it;
    }(e2);
    if (!i) {
      var n2 = ((e3) => {
        var t3 = e3.match(nt);
        return t3 ? t3[0] : "";
      })(e2);
      n2 !== i && q$3.info("Warning: cookie subdomain discovery mismatch", n2, i), i = n2;
    }
    return i ? "; domain=." + i : "";
  }
  return "";
}
var st = { is_supported: () => !!a$1, error: function(e2) {
  q$3.error("cookieStore error: " + e2);
}, get: function(e2) {
  if (a$1) {
    try {
      for (var t2 = e2 + "=", i = a$1.cookie.split(";").filter((e3) => e3.length), n2 = 0; n2 < i.length; n2++) {
        for (var r2 = i[n2]; " " == r2.charAt(0); ) r2 = r2.substring(1, r2.length);
        if (0 === r2.indexOf(t2)) return decodeURIComponent(r2.substring(t2.length, r2.length));
      }
    } catch (e3) {
    }
    return null;
  }
}, parse: function(e2) {
  var t2;
  try {
    t2 = JSON.parse(st.get(e2)) || {};
  } catch (e3) {
  }
  return t2;
}, set: function(e2, t2, i, n2, r2) {
  if (a$1) try {
    var s2 = "", o2 = "", l2 = rt(a$1.location.hostname, n2);
    if (i) {
      var u2 = /* @__PURE__ */ new Date();
      u2.setTime(u2.getTime() + 24 * i * 60 * 60 * 1e3), s2 = "; expires=" + u2.toUTCString();
    }
    r2 && (o2 = "; secure");
    var c6 = e2 + "=" + encodeURIComponent(JSON.stringify(t2)) + s2 + "; SameSite=Lax; path=/" + l2 + o2;
    return c6.length > 3686.4 && q$3.warn("cookieStore warning: large cookie, len=" + c6.length), a$1.cookie = c6, c6;
  } catch (e3) {
    return;
  }
}, remove: function(e2, t2) {
  try {
    st.set(e2, "", -1, t2);
  } catch (e3) {
    return;
  }
} }, ot = null, at = { is_supported: function() {
  if (!$$1(ot)) return ot;
  var e2 = true;
  if (R$1(t$2)) e2 = false;
  else try {
    var i = "__mplssupport__";
    at.set(i, "xyz"), '"xyz"' !== at.get(i) && (e2 = false), at.remove(i);
  } catch (t2) {
    e2 = false;
  }
  return e2 || q$3.error("localStorage unsupported; falling back to cookie store"), ot = e2, e2;
}, error: function(e2) {
  q$3.error("localStorage error: " + e2);
}, get: function(e2) {
  try {
    return null == t$2 ? void 0 : t$2.localStorage.getItem(e2);
  } catch (e3) {
    at.error(e3);
  }
  return null;
}, parse: function(e2) {
  try {
    return JSON.parse(at.get(e2)) || {};
  } catch (e3) {
  }
  return null;
}, set: function(e2, i) {
  try {
    null == t$2 || t$2.localStorage.setItem(e2, JSON.stringify(i));
  } catch (e3) {
    at.error(e3);
  }
}, remove: function(e2) {
  try {
    null == t$2 || t$2.localStorage.removeItem(e2);
  } catch (e3) {
    at.error(e3);
  }
} }, lt = ["distinct_id", ye, we, De, Ae], ut = j$2(j$2({}, at), {}, { parse: function(e2) {
  try {
    var t2 = {};
    try {
      t2 = st.parse(e2) || {};
    } catch (e3) {
    }
    var i = K$1(t2, JSON.parse(at.get(e2) || "{}"));
    return at.set(e2, i), i;
  } catch (e3) {
  }
  return null;
}, set: function(e2, t2, i, n2, r2, s2) {
  try {
    at.set(e2, t2, void 0, void 0, s2);
    var o2 = {};
    lt.forEach((e3) => {
      t2[e3] && (o2[e3] = t2[e3]);
    }), Object.keys(o2).length && st.set(e2, o2, i, n2, r2, s2);
  } catch (e3) {
    at.error(e3);
  }
}, remove: function(e2, i) {
  try {
    null == t$2 || t$2.localStorage.removeItem(e2), st.remove(e2, i);
  } catch (e3) {
    at.error(e3);
  }
} }), ct = {}, dt = { is_supported: function() {
  return true;
}, error: function(e2) {
  q$3.error("memoryStorage error: " + e2);
}, get: function(e2) {
  return ct[e2] || null;
}, parse: function(e2) {
  return ct[e2] || null;
}, set: function(e2, t2) {
  ct[e2] = t2;
}, remove: function(e2) {
  delete ct[e2];
} }, ht = null, _t = { is_supported: function() {
  if (!$$1(ht)) return ht;
  if (ht = true, R$1(t$2)) ht = false;
  else try {
    var e2 = "__support__";
    _t.set(e2, "xyz"), '"xyz"' !== _t.get(e2) && (ht = false), _t.remove(e2);
  } catch (e3) {
    ht = false;
  }
  return ht;
}, error: function(e2) {
  q$3.error("sessionStorage error: ", e2);
}, get: function(e2) {
  try {
    return null == t$2 ? void 0 : t$2.sessionStorage.getItem(e2);
  } catch (e3) {
    _t.error(e3);
  }
  return null;
}, parse: function(e2) {
  try {
    return JSON.parse(_t.get(e2)) || null;
  } catch (e3) {
  }
  return null;
}, set: function(e2, i) {
  try {
    null == t$2 || t$2.sessionStorage.setItem(e2, JSON.stringify(i));
  } catch (e3) {
    _t.error(e3);
  }
}, remove: function(e2) {
  try {
    null == t$2 || t$2.sessionStorage.removeItem(e2);
  } catch (e3) {
    _t.error(e3);
  }
} }, pt = ["localhost", "127.0.0.1"], vt = (e2) => {
  var t2 = null == a$1 ? void 0 : a$1.createElement("a");
  return R$1(t2) ? null : (t2.href = e2, t2);
}, gt = function(e2, t2) {
  return !!function(e3) {
    try {
      new RegExp(e3);
    } catch (e4) {
      return false;
    }
    return true;
  }(t2) && new RegExp(t2).test(e2);
}, ft = function(e2) {
  var t2, i, n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "&", r2 = [];
  return Y$1(e2, function(e3, n3) {
    R$1(e3) || R$1(n3) || "undefined" === n3 || (t2 = encodeURIComponent(((e4) => e4 instanceof File)(e3) ? e3.name : e3.toString()), i = encodeURIComponent(n3), r2[r2.length] = i + "=" + t2);
  }), r2.join(n2);
}, mt = function(e2, t2) {
  for (var i, n2 = ((e2.split("#")[0] || "").split("?")[1] || "").split("&"), r2 = 0; r2 < n2.length; r2++) {
    var s2 = n2[r2].split("=");
    if (s2[0] === t2) {
      i = s2;
      break;
    }
  }
  if (!x$3(i) || i.length < 2) return "";
  var o2 = i[1];
  try {
    o2 = decodeURIComponent(o2);
  } catch (e3) {
    q$3.error("Skipping decoding for malformed query param: " + o2);
  }
  return o2.replace(/\+/g, " ");
}, bt = function(e2, t2) {
  var i = e2.match(new RegExp(t2 + "=([^&]*)"));
  return i ? i[1] : null;
}, yt = "Mobile", wt = "iOS", St = "Android", Et = "Tablet", kt = St + " " + Et, xt = "iPad", It = "Apple", Ct = It + " Watch", Pt = "Safari", Rt = "BlackBerry", Ft = "Samsung", Tt = Ft + "Browser", $t = Ft + " Internet", Ot = "Chrome", Lt = Ot + " OS", Mt = Ot + " " + wt, At = "Internet Explorer", Dt = At + " " + yt, Nt = "Opera", qt = Nt + " Mini", Bt = "Edge", Ht = "Microsoft " + Bt, Ut = "Firefox", zt = Ut + " " + wt, jt = "Nintendo", Wt = "PlayStation", Gt = "Xbox", Vt = St + " " + yt, Jt = yt + " " + Pt, Yt = "Windows", Kt = Yt + " Phone", Xt = "Nokia", Qt = "Ouya", Zt = "Generic", ei = Zt + " " + yt.toLowerCase(), ti = Zt + " " + Et.toLowerCase(), ii = "Konqueror", ni = "(\\d+(\\.\\d+)?)", ri = new RegExp("Version/" + ni), si = new RegExp(Gt, "i"), oi = new RegExp(Wt + " \\w+", "i"), ai = new RegExp(jt + " \\w+", "i"), li = new RegExp(Rt + "|PlayBook|BB10", "i"), ui = { "NT3.51": "NT 3.11", "NT4.0": "NT 4.0", "5.0": "2000", 5.1: "XP", 5.2: "XP", "6.0": "Vista", 6.1: "7", 6.2: "8", 6.3: "8.1", 6.4: "10", "10.0": "10" };
var ci = (e2, t2) => t2 && m$2(t2, It) || function(e3) {
  return m$2(e3, Pt) && !m$2(e3, Ot) && !m$2(e3, St);
}(e2), di = function(e2, t2) {
  return t2 = t2 || "", m$2(e2, " OPR/") && m$2(e2, "Mini") ? qt : m$2(e2, " OPR/") ? Nt : li.test(e2) ? Rt : m$2(e2, "IE" + yt) || m$2(e2, "WPDesktop") ? Dt : m$2(e2, Tt) ? $t : m$2(e2, Bt) || m$2(e2, "Edg/") ? Ht : m$2(e2, "FBIOS") ? "Facebook " + yt : m$2(e2, "UCWEB") || m$2(e2, "UCBrowser") ? "UC Browser" : m$2(e2, "CriOS") ? Mt : m$2(e2, "CrMo") || m$2(e2, Ot) ? Ot : m$2(e2, St) && m$2(e2, Pt) ? Vt : m$2(e2, "FxiOS") ? zt : m$2(e2.toLowerCase(), ii.toLowerCase()) ? ii : ci(e2, t2) ? m$2(e2, yt) ? Jt : Pt : m$2(e2, Ut) ? Ut : m$2(e2, "MSIE") || m$2(e2, "Trident/") ? At : m$2(e2, "Gecko") ? Ut : "";
}, hi = { [Dt]: [new RegExp("rv:" + ni)], [Ht]: [new RegExp(Bt + "?\\/" + ni)], [Ot]: [new RegExp("(" + Ot + "|CrMo)\\/" + ni)], [Mt]: [new RegExp("CriOS\\/" + ni)], "UC Browser": [new RegExp("(UCBrowser|UCWEB)\\/" + ni)], [Pt]: [ri], [Jt]: [ri], [Nt]: [new RegExp("(Opera|OPR)\\/" + ni)], [Ut]: [new RegExp(Ut + "\\/" + ni)], [zt]: [new RegExp("FxiOS\\/" + ni)], [ii]: [new RegExp("Konqueror[:/]?" + ni, "i")], [Rt]: [new RegExp(Rt + " " + ni), ri], [Vt]: [new RegExp("android\\s" + ni, "i")], [$t]: [new RegExp(Tt + "\\/" + ni)], [At]: [new RegExp("(rv:|MSIE )" + ni)], Mozilla: [new RegExp("rv:" + ni)] }, _i = [[new RegExp(Gt + "; " + Gt + " (.*?)[);]", "i"), (e2) => [Gt, e2 && e2[1] || ""]], [new RegExp(jt, "i"), [jt, ""]], [new RegExp(Wt, "i"), [Wt, ""]], [li, [Rt, ""]], [new RegExp(Yt, "i"), (e2, t2) => {
  if (/Phone/.test(t2) || /WPDesktop/.test(t2)) return [Kt, ""];
  if (new RegExp(yt).test(t2) && !/IEMobile\b/.test(t2)) return [Yt + " " + yt, ""];
  var i = /Windows NT ([0-9.]+)/i.exec(t2);
  if (i && i[1]) {
    var n2 = i[1], r2 = ui[n2] || "";
    return /arm/i.test(t2) && (r2 = "RT"), [Yt, r2];
  }
  return [Yt, ""];
}], [/((iPhone|iPad|iPod).*?OS (\d+)_(\d+)_?(\d+)?|iPhone)/, (e2) => {
  if (e2 && e2[3]) {
    var t2 = [e2[3], e2[4], e2[5] || "0"];
    return [wt, t2.join(".")];
  }
  return [wt, ""];
}], [/(watch.*\/(\d+\.\d+\.\d+)|watch os,(\d+\.\d+),)/i, (e2) => {
  var t2 = "";
  return e2 && e2.length >= 3 && (t2 = R$1(e2[2]) ? e2[3] : e2[2]), ["watchOS", t2];
}], [new RegExp("(" + St + " (\\d+)\\.(\\d+)\\.?(\\d+)?|" + St + ")", "i"), (e2) => {
  if (e2 && e2[2]) {
    var t2 = [e2[2], e2[3], e2[4] || "0"];
    return [St, t2.join(".")];
  }
  return [St, ""];
}], [/Mac OS X (\d+)[_.](\d+)[_.]?(\d+)?/i, (e2) => {
  var t2 = ["Mac OS X", ""];
  if (e2 && e2[1]) {
    var i = [e2[1], e2[2], e2[3] || "0"];
    t2[1] = i.join(".");
  }
  return t2;
}], [/Mac/i, ["Mac OS X", ""]], [/CrOS/, [Lt, ""]], [/Linux|debian/i, ["Linux", ""]]], pi = function(e2) {
  return ai.test(e2) ? jt : oi.test(e2) ? Wt : si.test(e2) ? Gt : new RegExp(Qt, "i").test(e2) ? Qt : new RegExp("(" + Kt + "|WPDesktop)", "i").test(e2) ? Kt : /iPad/.test(e2) ? xt : /iPod/.test(e2) ? "iPod Touch" : /iPhone/.test(e2) ? "iPhone" : /(watch)(?: ?os[,/]|\d,\d\/)[\d.]+/i.test(e2) ? Ct : li.test(e2) ? Rt : /(kobo)\s(ereader|touch)/i.test(e2) ? "Kobo" : new RegExp(Xt, "i").test(e2) ? Xt : /(kf[a-z]{2}wi|aeo[c-r]{2})( bui|\))/i.test(e2) || /(kf[a-z]+)( bui|\)).+silk\//i.test(e2) ? "Kindle Fire" : /(Android|ZTE)/i.test(e2) ? !new RegExp(yt).test(e2) || /(9138B|TB782B|Nexus [97]|pixel c|HUAWEISHT|BTV|noble nook|smart ultra 6)/i.test(e2) ? /pixel[\daxl ]{1,6}/i.test(e2) && !/pixel c/i.test(e2) || /(huaweimed-al00|tah-|APA|SM-G92|i980|zte|U304AA)/i.test(e2) || /lmy47v/i.test(e2) && !/QTAQZ3/i.test(e2) ? St : kt : St : new RegExp("(pda|" + yt + ")", "i").test(e2) ? ei : new RegExp(Et, "i").test(e2) && !new RegExp(Et + " pc", "i").test(e2) ? ti : "";
}, vi = "https?://(.*)", gi = ["utm_source", "utm_medium", "utm_campaign", "utm_content", "utm_term", "gclid", "gad_source", "gclsrc", "dclid", "gbraid", "wbraid", "fbclid", "msclkid", "twclid", "li_fat_id", "mc_cid", "igshid", "ttclid", "rdt_cid"], fi = { campaignParams: function(e2) {
  return a$1 ? this._campaignParamsFromUrl(a$1.URL, e2) : {};
}, _campaignParamsFromUrl: function(e2, t2) {
  var i = gi.concat(t2 || []), n2 = {};
  return Y$1(i, function(t3) {
    var i2 = mt(e2, t3);
    n2[t3] = i2 || null;
  }), n2;
}, _searchEngine: function(e2) {
  return e2 ? 0 === e2.search(vi + "google.([^/?]*)") ? "google" : 0 === e2.search(vi + "bing.com") ? "bing" : 0 === e2.search(vi + "yahoo.com") ? "yahoo" : 0 === e2.search(vi + "duckduckgo.com") ? "duckduckgo" : null : null;
}, _searchInfoFromReferrer: function(e2) {
  var t2 = fi._searchEngine(e2), i = "yahoo" != t2 ? "q" : "p", n2 = {};
  if (!$$1(t2)) {
    n2.$search_engine = t2;
    var r2 = a$1 ? mt(a$1.referrer, i) : "";
    r2.length && (n2.ph_keyword = r2);
  }
  return n2;
}, searchInfo: function() {
  var e2 = null == a$1 ? void 0 : a$1.referrer;
  return e2 ? this._searchInfoFromReferrer(e2) : {};
}, browser: di, browserVersion: function(e2, t2) {
  var i = di(e2, t2), n2 = hi[i];
  if (R$1(n2)) return null;
  for (var r2 = 0; r2 < n2.length; r2++) {
    var s2 = n2[r2], o2 = e2.match(s2);
    if (o2) return parseFloat(o2[o2.length - 2]);
  }
  return null;
}, browserLanguage: function() {
  return navigator.language || navigator.userLanguage;
}, browserLanguagePrefix: function() {
  var e2 = this.browserLanguage();
  return "string" == typeof e2 ? e2.split("-")[0] : void 0;
}, os: function(e2) {
  for (var t2 = 0; t2 < _i.length; t2++) {
    var [i, n2] = _i[t2], r2 = i.exec(e2), s2 = r2 && (I$1(n2) ? n2(r2, e2) : n2);
    if (s2) return s2;
  }
  return ["", ""];
}, device: pi, deviceType: function(e2) {
  var t2 = pi(e2);
  return t2 === xt || t2 === kt || "Kobo" === t2 || "Kindle Fire" === t2 || t2 === ti ? Et : t2 === jt || t2 === Gt || t2 === Wt || t2 === Qt ? "Console" : t2 === Ct ? "Wearable" : t2 ? yt : "Desktop";
}, referrer: function() {
  return (null == a$1 ? void 0 : a$1.referrer) || "$direct";
}, referringDomain: function() {
  var e2;
  return null != a$1 && a$1.referrer && (null === (e2 = vt(a$1.referrer)) || void 0 === e2 ? void 0 : e2.host) || "$direct";
}, referrerInfo: function() {
  return { $referrer: this.referrer(), $referring_domain: this.referringDomain() };
}, initialPersonInfo: function() {
  return { r: this.referrer().substring(0, 1e3), u: null == l$2 ? void 0 : l$2.href.substring(0, 1e3) };
}, initialPersonPropsFromInfo: function(e2) {
  var t2, { r: i, u: n2 } = e2, r2 = { $initial_referrer: i, $initial_referring_domain: null == i ? void 0 : "$direct" == i ? "$direct" : null === (t2 = vt(i)) || void 0 === t2 ? void 0 : t2.host };
  if (n2) {
    r2.$initial_current_url = n2;
    var s2 = vt(n2);
    r2.$initial_host = null == s2 ? void 0 : s2.host, r2.$initial_pathname = null == s2 ? void 0 : s2.pathname, Y$1(this._campaignParamsFromUrl(n2), function(e3, t3) {
      r2["$initial_" + y$2(t3)] = e3;
    });
  }
  i && Y$1(this._searchInfoFromReferrer(i), function(e3, t3) {
    r2["$initial_" + y$2(t3)] = e3;
  });
  return r2;
}, timezone: function() {
  try {
    return Intl.DateTimeFormat().resolvedOptions().timeZone;
  } catch (e2) {
    return;
  }
}, timezoneOffset: function() {
  try {
    return (/* @__PURE__ */ new Date()).getTimezoneOffset();
  } catch (e2) {
    return;
  }
}, properties: function() {
  if (!h$2) return {};
  var [e2, i] = fi.os(h$2);
  return K$1(ee({ $os: e2, $os_version: i, $browser: fi.browser(h$2, navigator.vendor), $device: fi.device(h$2), $device_type: fi.deviceType(h$2), $timezone: fi.timezone(), $timezone_offset: fi.timezoneOffset() }), { $current_url: null == l$2 ? void 0 : l$2.href, $host: null == l$2 ? void 0 : l$2.host, $pathname: null == l$2 ? void 0 : l$2.pathname, $raw_user_agent: h$2.length > 1e3 ? h$2.substring(0, 997) + "..." : h$2, $browser_version: fi.browserVersion(h$2, navigator.vendor), $browser_language: fi.browserLanguage(), $browser_language_prefix: fi.browserLanguagePrefix(), $screen_height: null == t$2 ? void 0 : t$2.screen.height, $screen_width: null == t$2 ? void 0 : t$2.screen.width, $viewport_height: null == t$2 ? void 0 : t$2.innerHeight, $viewport_width: null == t$2 ? void 0 : t$2.innerWidth, $lib: "web", $lib_version: p$2.LIB_VERSION, $insert_id: Math.random().toString(36).substring(2, 10) + Math.random().toString(36).substring(2, 10), $time: Date.now() / 1e3 });
}, people_properties: function() {
  if (!h$2) return {};
  var [e2, t2] = fi.os(h$2);
  return K$1(ee({ $os: e2, $os_version: t2, $browser: fi.browser(h$2, navigator.vendor) }), { $browser_version: fi.browserVersion(h$2, navigator.vendor) });
} }, mi = ["cookie", "localstorage", "localstorage+cookie", "sessionstorage", "memory"];
class bi {
  constructor(e2) {
    this.config = e2, this.props = {}, this.campaign_params_saved = false, this.name = ((e3) => {
      var t2 = "";
      return e3.token && (t2 = e3.token.replace(/\+/g, "PL").replace(/\//g, "SL").replace(/=/g, "EQ")), e3.persistence_name ? "ph_" + e3.persistence_name : "ph_" + t2 + "_posthog";
    })(e2), this.storage = this.buildStorage(e2), this.load(), e2.debug && q$3.info("Persistence loaded", e2.persistence, j$2({}, this.props)), this.update_config(e2, e2), this.save();
  }
  buildStorage(e2) {
    -1 === mi.indexOf(e2.persistence.toLowerCase()) && (q$3.critical("Unknown persistence type " + e2.persistence + "; falling back to localStorage+cookie"), e2.persistence = "localStorage+cookie");
    var t2 = e2.persistence.toLowerCase();
    return "localstorage" === t2 && at.is_supported() ? at : "localstorage+cookie" === t2 && ut.is_supported() ? ut : "sessionstorage" === t2 && _t.is_supported() ? _t : "memory" === t2 ? dt : "cookie" === t2 ? st : ut.is_supported() ? ut : st;
  }
  properties() {
    var e2 = {};
    return Y$1(this.props, function(t2, i) {
      if (i === ke && C$2(t2)) for (var n2 = Object.keys(t2), r2 = 0; r2 < n2.length; r2++) e2["$feature/".concat(n2[r2])] = t2[n2[r2]];
      else a2 = i, l2 = false, ($$1(o2 = Be) ? l2 : s$1 && o2.indexOf === s$1 ? -1 != o2.indexOf(a2) : (Y$1(o2, function(e3) {
        if (l2 || (l2 = e3 === a2)) return V$2;
      }), l2)) || (e2[i] = t2);
      var o2, a2, l2;
    }), e2;
  }
  load() {
    if (!this.disabled) {
      var e2 = this.storage.parse(this.name);
      e2 && (this.props = K$1({}, e2));
    }
  }
  save() {
    this.disabled || this.storage.set(this.name, this.props, this.expire_days, this.cross_subdomain, this.secure, this.config.debug);
  }
  remove() {
    this.storage.remove(this.name, false), this.storage.remove(this.name, true);
  }
  clear() {
    this.remove(), this.props = {};
  }
  register_once(e2, t2, i) {
    if (C$2(e2)) {
      R$1(t2) && (t2 = "None"), this.expire_days = R$1(i) ? this.default_expiry : i;
      var n2 = false;
      if (Y$1(e2, (e3, i2) => {
        this.props.hasOwnProperty(i2) && this.props[i2] !== t2 || (this.props[i2] = e3, n2 = true);
      }), n2) return this.save(), true;
    }
    return false;
  }
  register(e2, t2) {
    if (C$2(e2)) {
      this.expire_days = R$1(t2) ? this.default_expiry : t2;
      var i = false;
      if (Y$1(e2, (t3, n2) => {
        e2.hasOwnProperty(n2) && this.props[n2] !== t3 && (this.props[n2] = t3, i = true);
      }), i) return this.save(), true;
    }
    return false;
  }
  unregister(e2) {
    e2 in this.props && (delete this.props[e2], this.save());
  }
  update_campaign_params() {
    if (!this.campaign_params_saved) {
      var e2 = fi.campaignParams(this.config.custom_campaign_params);
      P$2(ee(e2)) || this.register(e2), this.campaign_params_saved = true;
    }
  }
  update_search_keyword() {
    this.register(fi.searchInfo());
  }
  update_referrer_info() {
    this.register_once(fi.referrerInfo(), void 0);
  }
  set_initial_person_info() {
    this.props[Le] || this.props[Me] || this.register_once({ [Ae]: fi.initialPersonInfo() }, void 0);
  }
  get_referrer_info() {
    return ee({ $referrer: this.props.$referrer, $referring_domain: this.props.$referring_domain });
  }
  get_initial_props() {
    var e2 = {};
    Y$1([Me, Le], (t3) => {
      var i2 = this.props[t3];
      i2 && Y$1(i2, function(t4, i3) {
        e2["$initial_" + y$2(i3)] = t4;
      });
    });
    var t2 = this.props[Ae];
    if (t2) {
      var i = fi.initialPersonPropsFromInfo(t2);
      K$1(e2, i);
    }
    return e2;
  }
  safe_merge(e2) {
    return Y$1(this.props, function(t2, i) {
      i in e2 || (e2[i] = t2);
    }), e2;
  }
  update_config(e2, t2) {
    if (this.default_expiry = this.expire_days = e2.cookie_expiration, this.set_disabled(e2.disable_persistence), this.set_cross_subdomain(e2.cross_subdomain_cookie), this.set_secure(e2.secure_cookie), e2.persistence !== t2.persistence) {
      var i = this.buildStorage(e2), n2 = this.props;
      this.clear(), this.storage = i, this.props = n2, this.save();
    }
  }
  set_disabled(e2) {
    this.disabled = e2, this.disabled ? this.remove() : this.save();
  }
  set_cross_subdomain(e2) {
    e2 !== this.cross_subdomain && (this.cross_subdomain = e2, this.remove(), this.save());
  }
  get_cross_subdomain() {
    return !!this.cross_subdomain;
  }
  set_secure(e2) {
    e2 !== this.secure && (this.secure = e2, this.remove(), this.save());
  }
  set_event_timer(e2, t2) {
    var i = this.props[oe] || {};
    i[e2] = t2, this.props[oe] = i, this.save();
  }
  remove_event_timer(e2) {
    var t2 = (this.props[oe] || {})[e2];
    return R$1(t2) || (delete this.props[oe][e2], this.save()), t2;
  }
  get_property(e2) {
    return this.props[e2];
  }
  set_property(e2, t2) {
    this.props[e2] = t2, this.save();
  }
}
function yi(e2) {
  var t2, i;
  return (null === (t2 = JSON.stringify(e2, (i = [], function(e3, t3) {
    if (C$2(t3)) {
      for (; i.length > 0 && i[i.length - 1] !== this; ) i.pop();
      return i.includes(t3) ? "[Circular]" : (i.push(t3), t3);
    }
    return t3;
  }))) || void 0 === t2 ? void 0 : t2.length) || 0;
}
function wi(e2) {
  var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 66060288e-1;
  if (e2.size >= t2 && e2.data.length > 1) {
    var i = Math.floor(e2.data.length / 2), n2 = e2.data.slice(0, i), r2 = e2.data.slice(i);
    return [wi({ size: yi(n2), data: n2, sessionId: e2.sessionId, windowId: e2.windowId }), wi({ size: yi(r2), data: r2, sessionId: e2.sessionId, windowId: e2.windowId })].flatMap((e3) => e3);
  }
  return [e2];
}
var Si = ((e2) => (e2[e2.DomContentLoaded = 0] = "DomContentLoaded", e2[e2.Load = 1] = "Load", e2[e2.FullSnapshot = 2] = "FullSnapshot", e2[e2.IncrementalSnapshot = 3] = "IncrementalSnapshot", e2[e2.Meta = 4] = "Meta", e2[e2.Custom = 5] = "Custom", e2[e2.Plugin = 6] = "Plugin", e2))(Si || {}), Ei = ((e2) => (e2[e2.Mutation = 0] = "Mutation", e2[e2.MouseMove = 1] = "MouseMove", e2[e2.MouseInteraction = 2] = "MouseInteraction", e2[e2.Scroll = 3] = "Scroll", e2[e2.ViewportResize = 4] = "ViewportResize", e2[e2.Input = 5] = "Input", e2[e2.TouchMove = 6] = "TouchMove", e2[e2.MediaInteraction = 7] = "MediaInteraction", e2[e2.StyleSheetRule = 8] = "StyleSheetRule", e2[e2.CanvasMutation = 9] = "CanvasMutation", e2[e2.Font = 10] = "Font", e2[e2.Log = 11] = "Log", e2[e2.Drag = 12] = "Drag", e2[e2.StyleDeclaration = 13] = "StyleDeclaration", e2[e2.Selection = 14] = "Selection", e2[e2.AdoptedStyleSheet = 15] = "AdoptedStyleSheet", e2[e2.CustomElement = 16] = "CustomElement", e2))(Ei || {});
function ki(e2) {
  var t2;
  return e2 instanceof Element && (e2.id === Ne || !(null === (t2 = e2.closest) || void 0 === t2 || !t2.call(e2, ".toolbar-global-fade-container")));
}
function xi(e2) {
  return !!e2 && 1 === e2.nodeType;
}
function Ii(e2, t2) {
  return !!e2 && !!e2.tagName && e2.tagName.toLowerCase() === t2.toLowerCase();
}
function Ci(e2) {
  return !!e2 && 3 === e2.nodeType;
}
function Pi(e2) {
  return !!e2 && 11 === e2.nodeType;
}
function Ri(e2) {
  return e2 ? b$2(e2).split(/\s+/) : [];
}
function Fi(e2) {
  var i = null == t$2 ? void 0 : t$2.location.href;
  return !!(i && e2 && e2.some((e3) => i.match(e3)));
}
function Ti(e2) {
  var t2 = "";
  switch (typeof e2.className) {
    case "string":
      t2 = e2.className;
      break;
    case "object":
      t2 = (e2.className && "baseVal" in e2.className ? e2.className.baseVal : null) || e2.getAttribute("class") || "";
      break;
    default:
      t2 = "";
  }
  return Ri(t2);
}
function $i(e2) {
  return O$1(e2) ? null : b$2(e2).split(/(\s+)/).filter((e3) => Gi(e3)).join("").replace(/[\r\n]/g, " ").replace(/[ ]+/g, " ").substring(0, 255);
}
function Oi(e2) {
  var t2 = "";
  return Ni(e2) && !qi(e2) && e2.childNodes && e2.childNodes.length && Y$1(e2.childNodes, function(e3) {
    var i;
    Ci(e3) && e3.textContent && (t2 += null !== (i = $i(e3.textContent)) && void 0 !== i ? i : "");
  }), b$2(t2);
}
function Li(e2) {
  return R$1(e2.target) ? e2.srcElement || null : null !== (t2 = e2.target) && void 0 !== t2 && t2.shadowRoot ? e2.composedPath()[0] || null : e2.target || null;
  var t2;
}
var Mi = ["a", "button", "form", "input", "select", "textarea", "label"];
function Ai(e2) {
  var t2 = e2.parentNode;
  return !(!t2 || !xi(t2)) && t2;
}
function Di(e2, i) {
  var n2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0, r2 = arguments.length > 3 ? arguments[3] : void 0, s2 = arguments.length > 4 ? arguments[4] : void 0;
  if (!t$2 || !e2 || Ii(e2, "html") || !xi(e2)) return false;
  if (null != n2 && n2.url_allowlist && !Fi(n2.url_allowlist)) return false;
  if (null != n2 && n2.url_ignorelist && Fi(n2.url_ignorelist)) return false;
  if (null != n2 && n2.dom_event_allowlist) {
    var o2 = n2.dom_event_allowlist;
    if (o2 && !o2.some((e3) => i.type === e3)) return false;
  }
  for (var a2 = false, l2 = [e2], u2 = true, c6 = e2; c6.parentNode && !Ii(c6, "body"); ) if (Pi(c6.parentNode)) l2.push(c6.parentNode.host), c6 = c6.parentNode.host;
  else {
    if (!(u2 = Ai(c6))) break;
    if (r2 || Mi.indexOf(u2.tagName.toLowerCase()) > -1) a2 = true;
    else {
      var d2 = t$2.getComputedStyle(u2);
      d2 && "pointer" === d2.getPropertyValue("cursor") && (a2 = true);
    }
    l2.push(u2), c6 = u2;
  }
  if (!function(e3, t2) {
    var i2 = null == t2 ? void 0 : t2.element_allowlist;
    if (R$1(i2)) return true;
    var n3 = function(e4) {
      if (i2.some((t3) => e4.tagName.toLowerCase() === t3)) return { v: true };
    };
    for (var r3 of e3) {
      var s3 = n3(r3);
      if ("object" == typeof s3) return s3.v;
    }
    return false;
  }(l2, n2)) return false;
  if (!function(e3, t2) {
    var i2 = null == t2 ? void 0 : t2.css_selector_allowlist;
    if (R$1(i2)) return true;
    var n3 = function(e4) {
      if (i2.some((t3) => e4.matches(t3))) return { v: true };
    };
    for (var r3 of e3) {
      var s3 = n3(r3);
      if ("object" == typeof s3) return s3.v;
    }
    return false;
  }(l2, n2)) return false;
  var h2 = t$2.getComputedStyle(e2);
  if (h2 && "pointer" === h2.getPropertyValue("cursor") && "click" === i.type) return true;
  var _2 = e2.tagName.toLowerCase();
  switch (_2) {
    case "html":
      return false;
    case "form":
      return (s2 || ["submit"]).indexOf(i.type) >= 0;
    case "input":
    case "select":
    case "textarea":
      return (s2 || ["change", "click"]).indexOf(i.type) >= 0;
    default:
      return a2 ? (s2 || ["click"]).indexOf(i.type) >= 0 : (s2 || ["click"]).indexOf(i.type) >= 0 && (Mi.indexOf(_2) > -1 || "true" === e2.getAttribute("contenteditable"));
  }
}
function Ni(e2) {
  for (var t2 = e2; t2.parentNode && !Ii(t2, "body"); t2 = t2.parentNode) {
    var i = Ti(t2);
    if (m$2(i, "ph-sensitive") || m$2(i, "ph-no-capture")) return false;
  }
  if (m$2(Ti(e2), "ph-include")) return true;
  var n2 = e2.type || "";
  if (F$2(n2)) switch (n2.toLowerCase()) {
    case "hidden":
    case "password":
      return false;
  }
  var r2 = e2.name || e2.id || "";
  if (F$2(r2)) {
    if (/^cc|cardnum|ccnum|creditcard|csc|cvc|cvv|exp|pass|pwd|routing|seccode|securitycode|securitynum|socialsec|socsec|ssn/i.test(r2.replace(/[^a-zA-Z0-9]/g, ""))) return false;
  }
  return true;
}
function qi(e2) {
  return !!(Ii(e2, "input") && !["button", "checkbox", "submit", "reset"].includes(e2.type) || Ii(e2, "select") || Ii(e2, "textarea") || "true" === e2.getAttribute("contenteditable"));
}
var Bi = "(4[0-9]{12}(?:[0-9]{3})?)|(5[1-5][0-9]{14})|(6(?:011|5[0-9]{2})[0-9]{12})|(3[47][0-9]{13})|(3(?:0[0-5]|[68][0-9])[0-9]{11})|((?:2131|1800|35[0-9]{3})[0-9]{11})", Hi = new RegExp("^(?:".concat(Bi, ")$")), Ui = new RegExp(Bi), zi = "\\d{3}-?\\d{2}-?\\d{4}", ji = new RegExp("^(".concat(zi, ")$")), Wi = new RegExp("(".concat(zi, ")"));
function Gi(e2) {
  var t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
  if (O$1(e2)) return false;
  if (F$2(e2)) {
    if (e2 = b$2(e2), (t2 ? Hi : Ui).test((e2 || "").replace(/[- ]/g, ""))) return false;
    if ((t2 ? ji : Wi).test(e2)) return false;
  }
  return true;
}
function Vi(e2) {
  var t2 = Oi(e2);
  return Gi(t2 = "".concat(t2, " ").concat(Ji(e2)).trim()) ? t2 : "";
}
function Ji(e2) {
  var t2 = "";
  return e2 && e2.childNodes && e2.childNodes.length && Y$1(e2.childNodes, function(e3) {
    var i;
    if (e3 && "span" === (null === (i = e3.tagName) || void 0 === i ? void 0 : i.toLowerCase())) try {
      var n2 = Oi(e3);
      t2 = "".concat(t2, " ").concat(n2).trim(), e3.childNodes && e3.childNodes.length && (t2 = "".concat(t2, " ").concat(Ji(e3)).trim());
    } catch (e4) {
      q$3.error("[AutoCapture]", e4);
    }
  }), t2;
}
function Yi(e2) {
  return function(e3) {
    var t2 = e3.map((e4) => {
      var t3, i, n2 = "";
      if (e4.tag_name && (n2 += e4.tag_name), e4.attr_class) for (var r2 of (e4.attr_class.sort(), e4.attr_class)) n2 += ".".concat(r2.replace(/"/g, ""));
      var s2 = j$2(j$2(j$2(j$2({}, e4.text ? { text: e4.text } : {}), {}, { "nth-child": null !== (t3 = e4.nth_child) && void 0 !== t3 ? t3 : 0, "nth-of-type": null !== (i = e4.nth_of_type) && void 0 !== i ? i : 0 }, e4.href ? { href: e4.href } : {}), e4.attr_id ? { attr_id: e4.attr_id } : {}), e4.attributes), o2 = {};
      return X$1(s2).sort((e5, t4) => {
        var [i2] = e5, [n3] = t4;
        return i2.localeCompare(n3);
      }).forEach((e5) => {
        var [t4, i2] = e5;
        return o2[Ki(t4.toString())] = Ki(i2.toString());
      }), n2 += ":", n2 += X$1(s2).map((e5) => {
        var [t4, i2] = e5;
        return "".concat(t4, '="').concat(i2, '"');
      }).join("");
    });
    return t2.join(";");
  }(function(e3) {
    return e3.map((e4) => {
      var t2, i, n2 = { text: null === (t2 = e4.$el_text) || void 0 === t2 ? void 0 : t2.slice(0, 400), tag_name: e4.tag_name, href: null === (i = e4.attr__href) || void 0 === i ? void 0 : i.slice(0, 2048), attr_class: Xi(e4), attr_id: e4.attr__id, nth_child: e4.nth_child, nth_of_type: e4.nth_of_type, attributes: {} };
      return X$1(e4).filter((e5) => {
        var [t3] = e5;
        return 0 === t3.indexOf("attr__");
      }).forEach((e5) => {
        var [t3, i2] = e5;
        return n2.attributes[t3] = i2;
      }), n2;
    });
  }(e2));
}
function Ki(e2) {
  return e2.replace(/"|\\"/g, '\\"');
}
function Xi(e2) {
  var t2 = e2.attr__class;
  return t2 ? x$3(t2) ? t2 : Ri(t2) : void 0;
}
var Qi = "[SessionRecording]", Zi = "redacted", en$1 = { initiatorTypes: ["audio", "beacon", "body", "css", "early-hint", "embed", "fetch", "frame", "iframe", "icon", "image", "img", "input", "link", "navigation", "object", "ping", "script", "track", "video", "xmlhttprequest"], maskRequestFn: (e2) => e2, recordHeaders: false, recordBody: false, recordInitialRequests: false, recordPerformance: false, performanceEntryTypeToObserve: ["first-input", "navigation", "paint", "resource"], payloadSizeLimitBytes: 1e6, payloadHostDenyList: [".lr-ingest.io", ".ingest.sentry.io", ".clarity.ms", "analytics.google.com"] }, tn$1 = ["authorization", "x-forwarded-for", "authorization", "cookie", "set-cookie", "x-api-key", "x-real-ip", "remote-addr", "forwarded", "proxy-authorization", "x-csrf-token", "x-csrftoken", "x-xsrf-token"], nn$1 = ["password", "secret", "passwd", "api_key", "apikey", "auth", "credentials", "mysql_pwd", "privatekey", "private_key", "token"], rn$1 = ["/s/", "/e/", "/i/"];
function sn$1(e2, t2, i, n2) {
  if (O$1(e2)) return e2;
  var r2 = (null == t2 ? void 0 : t2["content-length"]) || function(e3) {
    return new Blob([e3]).size;
  }(e2);
  return F$2(r2) && (r2 = parseInt(r2)), r2 > i ? Qi + " ".concat(n2, " body too large to record (").concat(r2, " bytes)") : e2;
}
function on$1(e2, t2) {
  if (O$1(e2)) return e2;
  var i = e2;
  return Gi(i, false) || (i = Qi + " " + t2 + " body " + Zi), Y$1(nn$1, (e3) => {
    var n2, r2;
    null !== (n2 = i) && void 0 !== n2 && n2.length && -1 !== (null === (r2 = i) || void 0 === r2 ? void 0 : r2.indexOf(e3)) && (i = Qi + " " + t2 + " body " + Zi + " as might contain: " + e3);
  }), i;
}
var an$1 = (e2, t2) => {
  var i, n2, r2, s2 = { payloadSizeLimitBytes: en$1.payloadSizeLimitBytes, performanceEntryTypeToObserve: [...en$1.performanceEntryTypeToObserve], payloadHostDenyList: [...t2.payloadHostDenyList || [], ...en$1.payloadHostDenyList] }, o2 = false !== e2.session_recording.recordHeaders && t2.recordHeaders, a2 = false !== e2.session_recording.recordBody && t2.recordBody, l2 = false !== e2.capture_performance && t2.recordPerformance, u2 = (i = s2, r2 = Math.min(1e6, null !== (n2 = i.payloadSizeLimitBytes) && void 0 !== n2 ? n2 : 1e6), (e3) => (null != e3 && e3.requestBody && (e3.requestBody = sn$1(e3.requestBody, e3.requestHeaders, r2, "Request")), null != e3 && e3.responseBody && (e3.responseBody = sn$1(e3.responseBody, e3.responseHeaders, r2, "Response")), e3)), c6 = (t3) => {
    return u2(((e3, t4) => {
      var i3, n4 = vt(e3.name), r3 = 0 === t4.indexOf("http") ? null === (i3 = vt(t4)) || void 0 === i3 ? void 0 : i3.pathname : t4;
      "/" === r3 && (r3 = "");
      var s3 = null == n4 ? void 0 : n4.pathname.replace(r3 || "", "");
      if (!(n4 && s3 && rn$1.some((e4) => 0 === s3.indexOf(e4)))) return e3;
    })((n3 = (i2 = t3).requestHeaders, O$1(n3) || Y$1(Object.keys(null != n3 ? n3 : {}), (e3) => {
      tn$1.includes(e3.toLowerCase()) && (n3[e3] = Zi);
    }), i2), e2.api_host));
    var i2, n3;
  }, d2 = I$1(e2.session_recording.maskNetworkRequestFn);
  return d2 && I$1(e2.session_recording.maskCapturedNetworkRequestFn) && q$3.warn("Both `maskNetworkRequestFn` and `maskCapturedNetworkRequestFn` are defined. `maskNetworkRequestFn` will be ignored."), d2 && (e2.session_recording.maskCapturedNetworkRequestFn = (t3) => {
    var i2 = e2.session_recording.maskNetworkRequestFn({ url: t3.name });
    return j$2(j$2({}, t3), {}, { name: null == i2 ? void 0 : i2.url });
  }), s2.maskRequestFn = I$1(e2.session_recording.maskCapturedNetworkRequestFn) ? (t3) => {
    var i2, n3, r3, s3 = c6(t3);
    return s3 && null !== (i2 = null === (n3 = (r3 = e2.session_recording).maskCapturedNetworkRequestFn) || void 0 === n3 ? void 0 : n3.call(r3, s3)) && void 0 !== i2 ? i2 : void 0;
  } : (e3) => function(e4) {
    if (!R$1(e4)) return e4.requestBody = on$1(e4.requestBody, "Request"), e4.responseBody = on$1(e4.responseBody, "Response"), e4;
  }(c6(e3)), j$2(j$2(j$2({}, en$1), s2), {}, { recordHeaders: o2, recordBody: a2, recordPerformance: l2, recordInitialRequests: l2 });
};
function ln$1(e2, t2, i, n2, r2) {
  return t2 > i && (q$3.warn("min cannot be greater than max."), t2 = i), L$1(e2) ? e2 > i ? (n2 && q$3.warn(n2 + " cannot be  greater than max: " + i + ". Using max value instead."), i) : e2 < t2 ? (n2 && q$3.warn(n2 + " cannot be less than min: " + t2 + ". Using min value instead."), t2) : e2 : (n2 && q$3.warn(n2 + " must be a number. using max or fallback. max: " + i + ", fallback: " + r2), ln$1(r2 || i, t2, i, n2));
}
let un$1 = class un {
  constructor(e2) {
    var t2, i, n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    W$1(this, "bucketSize", 100), W$1(this, "refillRate", 10), W$1(this, "mutationBuckets", {}), W$1(this, "loggedTracker", {}), W$1(this, "refillBuckets", () => {
      Object.keys(this.mutationBuckets).forEach((e3) => {
        this.mutationBuckets[e3] = this.mutationBuckets[e3] + this.refillRate, this.mutationBuckets[e3] >= this.bucketSize && delete this.mutationBuckets[e3];
      });
    }), W$1(this, "getNodeOrRelevantParent", (e3) => {
      var t3 = this.rrweb.mirror.getNode(e3);
      if ("svg" !== (null == t3 ? void 0 : t3.nodeName) && t3 instanceof Element) {
        var i2 = t3.closest("svg");
        if (i2) return [this.rrweb.mirror.getId(i2), i2];
      }
      return [e3, t3];
    }), W$1(this, "numberOfChanges", (e3) => {
      var t3, i2, n3, r2, s2, o2, a2, l2;
      return (null !== (t3 = null === (i2 = e3.removes) || void 0 === i2 ? void 0 : i2.length) && void 0 !== t3 ? t3 : 0) + (null !== (n3 = null === (r2 = e3.attributes) || void 0 === r2 ? void 0 : r2.length) && void 0 !== n3 ? n3 : 0) + (null !== (s2 = null === (o2 = e3.texts) || void 0 === o2 ? void 0 : o2.length) && void 0 !== s2 ? s2 : 0) + (null !== (a2 = null === (l2 = e3.adds) || void 0 === l2 ? void 0 : l2.length) && void 0 !== a2 ? a2 : 0);
    }), W$1(this, "throttleMutations", (e3) => {
      if (3 !== e3.type || 0 !== e3.data.source) return e3;
      var t3 = e3.data, i2 = this.numberOfChanges(t3);
      t3.attributes && (t3.attributes = t3.attributes.filter((e4) => {
        var t4, i3, n4, [r2, s2] = this.getNodeOrRelevantParent(e4.id);
        if (0 === this.mutationBuckets[r2]) return false;
        (this.mutationBuckets[r2] = null !== (t4 = this.mutationBuckets[r2]) && void 0 !== t4 ? t4 : this.bucketSize, this.mutationBuckets[r2] = Math.max(this.mutationBuckets[r2] - 1, 0), 0 === this.mutationBuckets[r2]) && (this.loggedTracker[r2] || (this.loggedTracker[r2] = true, null === (i3 = (n4 = this.options).onBlockedNode) || void 0 === i3 || i3.call(n4, r2, s2)));
        return e4;
      }));
      var n3 = this.numberOfChanges(t3);
      return 0 !== n3 || i2 === n3 ? e3 : void 0;
    }), this.rrweb = e2, this.options = n2, this.refillRate = ln$1(null !== (t2 = this.options.refillRate) && void 0 !== t2 ? t2 : this.refillRate, 0, 100, "mutation throttling refill rate"), this.bucketSize = ln$1(null !== (i = this.options.bucketSize) && void 0 !== i ? i : this.bucketSize, 0, 100, "mutation throttling bucket size"), setInterval(() => {
      this.refillBuckets();
    }, 1e3);
  }
};
var cn$1 = Uint8Array, dn$1 = Uint16Array, hn$1 = Uint32Array, _n$1 = new cn$1([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), pn$1 = new cn$1([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), vn$1 = new cn$1([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), gn$1 = function(e2, t2) {
  for (var i = new dn$1(31), n2 = 0; n2 < 31; ++n2) i[n2] = t2 += 1 << e2[n2 - 1];
  var r2 = new hn$1(i[30]);
  for (n2 = 1; n2 < 30; ++n2) for (var s2 = i[n2]; s2 < i[n2 + 1]; ++s2) r2[s2] = s2 - i[n2] << 5 | n2;
  return [i, r2];
}, fn$1 = gn$1(_n$1, 2), mn$1 = fn$1[0], bn$1 = fn$1[1];
mn$1[28] = 258, bn$1[258] = 28;
for (var yn$1 = gn$1(pn$1, 0)[1], wn$1 = new dn$1(32768), Sn$1 = 0; Sn$1 < 32768; ++Sn$1) {
  var En$1 = (43690 & Sn$1) >>> 1 | (21845 & Sn$1) << 1;
  En$1 = (61680 & (En$1 = (52428 & En$1) >>> 2 | (13107 & En$1) << 2)) >>> 4 | (3855 & En$1) << 4, wn$1[Sn$1] = ((65280 & En$1) >>> 8 | (255 & En$1) << 8) >>> 1;
}
var kn = function(e2, t2, i) {
  for (var n2 = e2.length, r2 = 0, s2 = new dn$1(t2); r2 < n2; ++r2) ++s2[e2[r2] - 1];
  var o2, a2 = new dn$1(t2);
  for (r2 = 0; r2 < t2; ++r2) a2[r2] = a2[r2 - 1] + s2[r2 - 1] << 1;
  for (o2 = new dn$1(n2), r2 = 0; r2 < n2; ++r2) o2[r2] = wn$1[a2[e2[r2] - 1]++] >>> 15 - e2[r2];
  return o2;
}, xn$1 = new cn$1(288);
for (Sn$1 = 0; Sn$1 < 144; ++Sn$1) xn$1[Sn$1] = 8;
for (Sn$1 = 144; Sn$1 < 256; ++Sn$1) xn$1[Sn$1] = 9;
for (Sn$1 = 256; Sn$1 < 280; ++Sn$1) xn$1[Sn$1] = 7;
for (Sn$1 = 280; Sn$1 < 288; ++Sn$1) xn$1[Sn$1] = 8;
var In = new cn$1(32);
for (Sn$1 = 0; Sn$1 < 32; ++Sn$1) In[Sn$1] = 5;
var Cn$1 = kn(xn$1, 9), Pn = kn(In, 5), Rn = function(e2) {
  return (e2 / 8 >> 0) + (7 & e2 && 1);
}, Fn = function(e2, t2, i) {
  (null == i || i > e2.length) && (i = e2.length);
  var n2 = new (e2 instanceof dn$1 ? dn$1 : e2 instanceof hn$1 ? hn$1 : cn$1)(i - t2);
  return n2.set(e2.subarray(t2, i)), n2;
}, Tn = function(e2, t2, i) {
  i <<= 7 & t2;
  var n2 = t2 / 8 >> 0;
  e2[n2] |= i, e2[n2 + 1] |= i >>> 8;
}, $n = function(e2, t2, i) {
  i <<= 7 & t2;
  var n2 = t2 / 8 >> 0;
  e2[n2] |= i, e2[n2 + 1] |= i >>> 8, e2[n2 + 2] |= i >>> 16;
}, On = function(e2, t2) {
  for (var i = [], n2 = 0; n2 < e2.length; ++n2) e2[n2] && i.push({ s: n2, f: e2[n2] });
  var r2 = i.length, s2 = i.slice();
  if (!r2) return [new cn$1(0), 0];
  if (1 == r2) {
    var o2 = new cn$1(i[0].s + 1);
    return o2[i[0].s] = 1, [o2, 1];
  }
  i.sort(function(e3, t3) {
    return e3.f - t3.f;
  }), i.push({ s: -1, f: 25001 });
  var a2 = i[0], l2 = i[1], u2 = 0, c6 = 1, d2 = 2;
  for (i[0] = { s: -1, f: a2.f + l2.f, l: a2, r: l2 }; c6 != r2 - 1; ) a2 = i[i[u2].f < i[d2].f ? u2++ : d2++], l2 = i[u2 != c6 && i[u2].f < i[d2].f ? u2++ : d2++], i[c6++] = { s: -1, f: a2.f + l2.f, l: a2, r: l2 };
  var h2 = s2[0].s;
  for (n2 = 1; n2 < r2; ++n2) s2[n2].s > h2 && (h2 = s2[n2].s);
  var _2 = new dn$1(h2 + 1), p2 = Ln(i[c6 - 1], _2, 0);
  if (p2 > t2) {
    n2 = 0;
    var v2 = 0, g2 = p2 - t2, f2 = 1 << g2;
    for (s2.sort(function(e3, t3) {
      return _2[t3.s] - _2[e3.s] || e3.f - t3.f;
    }); n2 < r2; ++n2) {
      var m2 = s2[n2].s;
      if (!(_2[m2] > t2)) break;
      v2 += f2 - (1 << p2 - _2[m2]), _2[m2] = t2;
    }
    for (v2 >>>= g2; v2 > 0; ) {
      var b2 = s2[n2].s;
      _2[b2] < t2 ? v2 -= 1 << t2 - _2[b2]++ - 1 : ++n2;
    }
    for (; n2 >= 0 && v2; --n2) {
      var y2 = s2[n2].s;
      _2[y2] == t2 && (--_2[y2], ++v2);
    }
    p2 = t2;
  }
  return [new cn$1(_2), p2];
}, Ln = function(e2, t2, i) {
  return -1 == e2.s ? Math.max(Ln(e2.l, t2, i + 1), Ln(e2.r, t2, i + 1)) : t2[e2.s] = i;
}, Mn = function(e2) {
  for (var t2 = e2.length; t2 && !e2[--t2]; ) ;
  for (var i = new dn$1(++t2), n2 = 0, r2 = e2[0], s2 = 1, o2 = function(e3) {
    i[n2++] = e3;
  }, a2 = 1; a2 <= t2; ++a2) if (e2[a2] == r2 && a2 != t2) ++s2;
  else {
    if (!r2 && s2 > 2) {
      for (; s2 > 138; s2 -= 138) o2(32754);
      s2 > 2 && (o2(s2 > 10 ? s2 - 11 << 5 | 28690 : s2 - 3 << 5 | 12305), s2 = 0);
    } else if (s2 > 3) {
      for (o2(r2), --s2; s2 > 6; s2 -= 6) o2(8304);
      s2 > 2 && (o2(s2 - 3 << 5 | 8208), s2 = 0);
    }
    for (; s2--; ) o2(r2);
    s2 = 1, r2 = e2[a2];
  }
  return [i.subarray(0, n2), t2];
}, An = function(e2, t2) {
  for (var i = 0, n2 = 0; n2 < t2.length; ++n2) i += e2[n2] * t2[n2];
  return i;
}, Dn = function(e2, t2, i) {
  var n2 = i.length, r2 = Rn(t2 + 2);
  e2[r2] = 255 & n2, e2[r2 + 1] = n2 >>> 8, e2[r2 + 2] = 255 ^ e2[r2], e2[r2 + 3] = 255 ^ e2[r2 + 1];
  for (var s2 = 0; s2 < n2; ++s2) e2[r2 + s2 + 4] = i[s2];
  return 8 * (r2 + 4 + n2);
}, Nn = function(e2, t2, i, n2, r2, s2, o2, a2, l2, u2, c6) {
  Tn(t2, c6++, i), ++r2[256];
  for (var d2 = On(r2, 15), h2 = d2[0], _2 = d2[1], p2 = On(s2, 15), v2 = p2[0], g2 = p2[1], f2 = Mn(h2), m2 = f2[0], b2 = f2[1], y2 = Mn(v2), w2 = y2[0], S2 = y2[1], E2 = new dn$1(19), k2 = 0; k2 < m2.length; ++k2) E2[31 & m2[k2]]++;
  for (k2 = 0; k2 < w2.length; ++k2) E2[31 & w2[k2]]++;
  for (var x2 = On(E2, 7), I2 = x2[0], C2 = x2[1], P2 = 19; P2 > 4 && !I2[vn$1[P2 - 1]]; --P2) ;
  var R2, F2, T2, $2, O2 = u2 + 5 << 3, L2 = An(r2, xn$1) + An(s2, In) + o2, M2 = An(r2, h2) + An(s2, v2) + o2 + 14 + 3 * P2 + An(E2, I2) + (2 * E2[16] + 3 * E2[17] + 7 * E2[18]);
  if (O2 <= L2 && O2 <= M2) return Dn(t2, c6, e2.subarray(l2, l2 + u2));
  if (Tn(t2, c6, 1 + (M2 < L2)), c6 += 2, M2 < L2) {
    R2 = kn(h2, _2), F2 = h2, T2 = kn(v2, g2), $2 = v2;
    var A2 = kn(I2, C2);
    Tn(t2, c6, b2 - 257), Tn(t2, c6 + 5, S2 - 1), Tn(t2, c6 + 10, P2 - 4), c6 += 14;
    for (k2 = 0; k2 < P2; ++k2) Tn(t2, c6 + 3 * k2, I2[vn$1[k2]]);
    c6 += 3 * P2;
    for (var D2 = [m2, w2], N2 = 0; N2 < 2; ++N2) {
      var q2 = D2[N2];
      for (k2 = 0; k2 < q2.length; ++k2) {
        var B2 = 31 & q2[k2];
        Tn(t2, c6, A2[B2]), c6 += I2[B2], B2 > 15 && (Tn(t2, c6, q2[k2] >>> 5 & 127), c6 += q2[k2] >>> 12);
      }
    }
  } else R2 = Cn$1, F2 = xn$1, T2 = Pn, $2 = In;
  for (k2 = 0; k2 < a2; ++k2) if (n2[k2] > 255) {
    B2 = n2[k2] >>> 18 & 31;
    $n(t2, c6, R2[B2 + 257]), c6 += F2[B2 + 257], B2 > 7 && (Tn(t2, c6, n2[k2] >>> 23 & 31), c6 += _n$1[B2]);
    var H2 = 31 & n2[k2];
    $n(t2, c6, T2[H2]), c6 += $2[H2], H2 > 3 && ($n(t2, c6, n2[k2] >>> 5 & 8191), c6 += pn$1[H2]);
  } else $n(t2, c6, R2[n2[k2]]), c6 += F2[n2[k2]];
  return $n(t2, c6, R2[256]), c6 + F2[256];
}, qn = new hn$1([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]), Bn = function() {
  for (var e2 = new hn$1(256), t2 = 0; t2 < 256; ++t2) {
    for (var i = t2, n2 = 9; --n2; ) i = (1 & i && 3988292384) ^ i >>> 1;
    e2[t2] = i;
  }
  return e2;
}(), Hn = function() {
  var e2 = 4294967295;
  return { p: function(t2) {
    for (var i = e2, n2 = 0; n2 < t2.length; ++n2) i = Bn[255 & i ^ t2[n2]] ^ i >>> 8;
    e2 = i;
  }, d: function() {
    return 4294967295 ^ e2;
  } };
}, Un = function(e2, t2, i, n2, r2) {
  return function(e3, t3, i2, n3, r3, s2) {
    var o2 = e3.length, a2 = new cn$1(n3 + o2 + 5 * (1 + Math.floor(o2 / 7e3)) + r3), l2 = a2.subarray(n3, a2.length - r3), u2 = 0;
    if (!t3 || o2 < 8) for (var c6 = 0; c6 <= o2; c6 += 65535) {
      var d2 = c6 + 65535;
      d2 < o2 ? u2 = Dn(l2, u2, e3.subarray(c6, d2)) : (l2[c6] = s2, u2 = Dn(l2, u2, e3.subarray(c6, o2)));
    }
    else {
      for (var h2 = qn[t3 - 1], _2 = h2 >>> 13, p2 = 8191 & h2, v2 = (1 << i2) - 1, g2 = new dn$1(32768), f2 = new dn$1(v2 + 1), m2 = Math.ceil(i2 / 3), b2 = 2 * m2, y2 = function(t4) {
        return (e3[t4] ^ e3[t4 + 1] << m2 ^ e3[t4 + 2] << b2) & v2;
      }, w2 = new hn$1(25e3), S2 = new dn$1(288), E2 = new dn$1(32), k2 = 0, x2 = 0, I2 = (c6 = 0, 0), C2 = 0, P2 = 0; c6 < o2; ++c6) {
        var R2 = y2(c6), F2 = 32767 & c6, T2 = f2[R2];
        if (g2[F2] = T2, f2[R2] = F2, C2 <= c6) {
          var $2 = o2 - c6;
          if ((k2 > 7e3 || I2 > 24576) && $2 > 423) {
            u2 = Nn(e3, l2, 0, w2, S2, E2, x2, I2, P2, c6 - P2, u2), I2 = k2 = x2 = 0, P2 = c6;
            for (var O2 = 0; O2 < 286; ++O2) S2[O2] = 0;
            for (O2 = 0; O2 < 30; ++O2) E2[O2] = 0;
          }
          var L2 = 2, M2 = 0, A2 = p2, D2 = F2 - T2 & 32767;
          if ($2 > 2 && R2 == y2(c6 - D2)) for (var N2 = Math.min(_2, $2) - 1, q2 = Math.min(32767, c6), B2 = Math.min(258, $2); D2 <= q2 && --A2 && F2 != T2; ) {
            if (e3[c6 + L2] == e3[c6 + L2 - D2]) {
              for (var H2 = 0; H2 < B2 && e3[c6 + H2] == e3[c6 + H2 - D2]; ++H2) ;
              if (H2 > L2) {
                if (L2 = H2, M2 = D2, H2 > N2) break;
                var U2 = Math.min(D2, H2 - 2), z2 = 0;
                for (O2 = 0; O2 < U2; ++O2) {
                  var j2 = c6 - D2 + O2 + 32768 & 32767, W2 = j2 - g2[j2] + 32768 & 32767;
                  W2 > z2 && (z2 = W2, T2 = j2);
                }
              }
            }
            D2 += (F2 = T2) - (T2 = g2[F2]) + 32768 & 32767;
          }
          if (M2) {
            w2[I2++] = 268435456 | bn$1[L2] << 18 | yn$1[M2];
            var G2 = 31 & bn$1[L2], V2 = 31 & yn$1[M2];
            x2 += _n$1[G2] + pn$1[V2], ++S2[257 + G2], ++E2[V2], C2 = c6 + L2, ++k2;
          } else w2[I2++] = e3[c6], ++S2[e3[c6]];
        }
      }
      u2 = Nn(e3, l2, s2, w2, S2, E2, x2, I2, P2, c6 - P2, u2);
    }
    return Fn(a2, 0, n3 + Rn(u2) + r3);
  }(e2, null == t2.level ? 6 : t2.level, null == t2.mem ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(e2.length)))) : 12 + t2.mem, i, n2, !r2);
}, zn = function(e2, t2, i) {
  for (; i; ++t2) e2[t2] = i, i >>>= 8;
}, jn = function(e2, t2) {
  var i = t2.filename;
  if (e2[0] = 31, e2[1] = 139, e2[2] = 8, e2[8] = t2.level < 2 ? 4 : 9 == t2.level ? 2 : 0, e2[9] = 3, 0 != t2.mtime && zn(e2, 4, Math.floor(new Date(t2.mtime || Date.now()) / 1e3)), i) {
    e2[3] = 8;
    for (var n2 = 0; n2 <= i.length; ++n2) e2[n2 + 10] = i.charCodeAt(n2);
  }
}, Wn = function(e2) {
  return 10 + (e2.filename && e2.filename.length + 1 || 0);
};
function Gn(e2, t2) {
  void 0 === t2 && (t2 = {});
  var i = Hn(), n2 = e2.length;
  i.p(e2);
  var r2 = Un(e2, t2, Wn(t2), 8), s2 = r2.length;
  return jn(r2, t2), zn(r2, s2 - 8, i.d()), zn(r2, s2 - 4, n2), r2;
}
function Vn(e2, t2) {
  var i = e2.length;
  if ("undefined" != typeof TextEncoder) return new TextEncoder().encode(e2);
  for (var n2 = new cn$1(e2.length + (e2.length >>> 1)), r2 = 0, s2 = function(e3) {
    n2[r2++] = e3;
  }, o2 = 0; o2 < i; ++o2) {
    if (r2 + 5 > n2.length) {
      var a2 = new cn$1(r2 + 8 + (i - o2 << 1));
      a2.set(n2), n2 = a2;
    }
    var l2 = e2.charCodeAt(o2);
    l2 < 128 || t2 ? s2(l2) : l2 < 2048 ? (s2(192 | l2 >>> 6), s2(128 | 63 & l2)) : l2 > 55295 && l2 < 57344 ? (s2(240 | (l2 = 65536 + (1047552 & l2) | 1023 & e2.charCodeAt(++o2)) >>> 18), s2(128 | l2 >>> 12 & 63), s2(128 | l2 >>> 6 & 63), s2(128 | 63 & l2)) : (s2(224 | l2 >>> 12), s2(128 | l2 >>> 6 & 63), s2(128 | 63 & l2));
  }
  return Fn(n2, 0, r2);
}
var Jn = "[SessionRecording]", Yn = B$2(Jn), Kn = 3e5, Xn = [Ei.MouseMove, Ei.MouseInteraction, Ei.Scroll, Ei.ViewportResize, Ei.Input, Ei.TouchMove, Ei.MediaInteraction, Ei.Drag], Qn = (e2) => ({ rrwebMethod: e2, enqueuedAt: Date.now(), attempt: 1 });
function Zn(e2) {
  return function(e3, t2) {
    for (var i = "", n2 = 0; n2 < e3.length; ) {
      var r2 = e3[n2++];
      i += String.fromCharCode(r2);
    }
    return i;
  }(Gn(Vn(JSON.stringify(e2))));
}
function er(e2) {
  return e2.type === Si.Custom && "sessionIdle" === e2.data.tag;
}
function tr(e2, t2) {
  return t2.some((t3) => "regex" === t3.matching && new RegExp(t3.url).test(e2));
}
class ir {
  get sessionIdleThresholdMilliseconds() {
    return this.instance.config.session_recording.session_idle_threshold_ms || 3e5;
  }
  get rrwebRecord() {
    var e2, t2;
    return null == _$1 || null === (e2 = _$1.__PosthogExtensions__) || void 0 === e2 || null === (t2 = e2.rrweb) || void 0 === t2 ? void 0 : t2.record;
  }
  get started() {
    return this._captureStarted;
  }
  get sessionManager() {
    if (!this.instance.sessionManager) throw new Error(Jn + " must be started with a valid sessionManager.");
    return this.instance.sessionManager;
  }
  get fullSnapshotIntervalMillis() {
    var e2, t2;
    return "trigger_pending" === this.triggerStatus ? 6e4 : null !== (e2 = null === (t2 = this.instance.config.session_recording) || void 0 === t2 ? void 0 : t2.full_snapshot_interval_millis) && void 0 !== e2 ? e2 : Kn;
  }
  get isSampled() {
    var e2 = this.instance.get_property(we);
    return M$1(e2) ? e2 : null;
  }
  get sessionDuration() {
    var e2, t2, i = null === (e2 = this.buffer) || void 0 === e2 ? void 0 : e2.data[(null === (t2 = this.buffer) || void 0 === t2 ? void 0 : t2.data.length) - 1], { sessionStartTimestamp: n2 } = this.sessionManager.checkAndGetSessionAndWindowId(true);
    return i ? i.timestamp - n2 : null;
  }
  get isRecordingEnabled() {
    var e2 = !!this.instance.get_property(_e), i = !this.instance.config.disable_session_recording;
    return t$2 && e2 && i;
  }
  get isConsoleLogCaptureEnabled() {
    var e2 = !!this.instance.get_property(pe), t2 = this.instance.config.enable_recording_console_log;
    return null != t2 ? t2 : e2;
  }
  get canvasRecording() {
    var e2, t2, i, n2, r2, s2, o2 = this.instance.config.session_recording.captureCanvas, a2 = this.instance.get_property(ge), l2 = null !== (e2 = null !== (t2 = null == o2 ? void 0 : o2.recordCanvas) && void 0 !== t2 ? t2 : null == a2 ? void 0 : a2.enabled) && void 0 !== e2 && e2, u2 = null !== (i = null !== (n2 = null == o2 ? void 0 : o2.canvasFps) && void 0 !== n2 ? n2 : null == a2 ? void 0 : a2.fps) && void 0 !== i ? i : 0, c6 = null !== (r2 = null !== (s2 = null == o2 ? void 0 : o2.canvasQuality) && void 0 !== s2 ? s2 : null == a2 ? void 0 : a2.quality) && void 0 !== r2 ? r2 : 0;
    return { enabled: l2, fps: ln$1(u2, 0, 12, "canvas recording fps"), quality: ln$1(c6, 0, 1, "canvas recording quality") };
  }
  get networkPayloadCapture() {
    var e2, t2, i = this.instance.get_property(ve), n2 = { recordHeaders: null === (e2 = this.instance.config.session_recording) || void 0 === e2 ? void 0 : e2.recordHeaders, recordBody: null === (t2 = this.instance.config.session_recording) || void 0 === t2 ? void 0 : t2.recordBody }, r2 = (null == n2 ? void 0 : n2.recordHeaders) || (null == i ? void 0 : i.recordHeaders), s2 = (null == n2 ? void 0 : n2.recordBody) || (null == i ? void 0 : i.recordBody), o2 = C$2(this.instance.config.capture_performance) ? this.instance.config.capture_performance.network_timing : this.instance.config.capture_performance, a2 = !!(M$1(o2) ? o2 : null == i ? void 0 : i.capturePerformance);
    return r2 || s2 || a2 ? { recordHeaders: r2, recordBody: s2, recordPerformance: a2 } : void 0;
  }
  get sampleRate() {
    var e2 = this.instance.get_property(fe);
    return L$1(e2) ? e2 : null;
  }
  get minimumDuration() {
    var e2 = this.instance.get_property(me);
    return L$1(e2) ? e2 : null;
  }
  get status() {
    return this.receivedDecide ? this.isRecordingEnabled ? this._urlBlocked ? "paused" : O$1(this._linkedFlag) || this._linkedFlagSeen ? "trigger_pending" === this.triggerStatus ? "buffering" : M$1(this.isSampled) ? this.isSampled ? "sampled" : "disabled" : "active" : "buffering" : "disabled" : "buffering";
  }
  get urlTriggerStatus() {
    var e2;
    return 0 === this._urlTriggers.length ? "trigger_disabled" : (null === (e2 = this.instance) || void 0 === e2 ? void 0 : e2.get_property(Se)) === this.sessionId ? "trigger_activated" : "trigger_pending";
  }
  get eventTriggerStatus() {
    var e2;
    return 0 === this._eventTriggers.length ? "trigger_disabled" : (null === (e2 = this.instance) || void 0 === e2 ? void 0 : e2.get_property(Ee)) === this.sessionId ? "trigger_activated" : "trigger_pending";
  }
  get triggerStatus() {
    var e2 = "trigger_activated" === this.eventTriggerStatus || "trigger_activated" === this.urlTriggerStatus, t2 = "trigger_pending" === this.eventTriggerStatus || "trigger_pending" === this.urlTriggerStatus;
    return e2 ? "trigger_activated" : t2 ? "trigger_pending" : "trigger_disabled";
  }
  constructor(e2) {
    if (W$1(this, "queuedRRWebEvents", []), W$1(this, "isIdle", false), W$1(this, "_linkedFlagSeen", false), W$1(this, "_lastActivityTimestamp", Date.now()), W$1(this, "_linkedFlag", null), W$1(this, "_removePageViewCaptureHook", void 0), W$1(this, "_onSessionIdListener", void 0), W$1(this, "_persistDecideOnSessionListener", void 0), W$1(this, "_samplingSessionListener", void 0), W$1(this, "_urlTriggers", []), W$1(this, "_urlBlocklist", []), W$1(this, "_urlBlocked", false), W$1(this, "_eventTriggers", []), W$1(this, "_removeEventTriggerCaptureHook", void 0), W$1(this, "_forceAllowLocalhostNetworkCapture", false), W$1(this, "_onBeforeUnload", () => {
      this._flushBuffer();
    }), W$1(this, "_onOffline", () => {
      this._tryAddCustomEvent("browser offline", {});
    }), W$1(this, "_onOnline", () => {
      this._tryAddCustomEvent("browser online", {});
    }), W$1(this, "_onVisibilityChange", () => {
      if (null != a$1 && a$1.visibilityState) {
        var e3 = "window " + a$1.visibilityState;
        this._tryAddCustomEvent(e3, {});
      }
    }), this.instance = e2, this._captureStarted = false, this._endpoint = "/s/", this.stopRrweb = void 0, this.receivedDecide = false, !this.instance.sessionManager) throw Yn.error("started without valid sessionManager"), new Error(Jn + " started without valid sessionManager. This is a bug.");
    if (this.instance.config.__preview_experimental_cookieless_mode) throw new Error(Jn + " cannot be used with __preview_experimental_cookieless_mode.");
    var { sessionId: t2, windowId: i } = this.sessionManager.checkAndGetSessionAndWindowId();
    this.sessionId = t2, this.windowId = i, this.buffer = this.clearBuffer(), this.sessionIdleThresholdMilliseconds >= this.sessionManager.sessionTimeoutMs && Yn.warn("session_idle_threshold_ms (".concat(this.sessionIdleThresholdMilliseconds, ") is greater than the session timeout (").concat(this.sessionManager.sessionTimeoutMs, "). Session will never be detected as idle"));
  }
  startIfEnabledOrStop(e2) {
    this.isRecordingEnabled ? (this._startCapture(e2), null == t$2 || t$2.addEventListener("beforeunload", this._onBeforeUnload), null == t$2 || t$2.addEventListener("offline", this._onOffline), null == t$2 || t$2.addEventListener("online", this._onOnline), null == t$2 || t$2.addEventListener("visibilitychange", this._onVisibilityChange), this._setupSampling(), this._addEventTriggerListener(), O$1(this._removePageViewCaptureHook) && (this._removePageViewCaptureHook = this.instance.on("eventCaptured", (e3) => {
      try {
        if ("$pageview" === e3.event) {
          var t2 = null != e3 && e3.properties.$current_url ? this._maskUrl(null == e3 ? void 0 : e3.properties.$current_url) : "";
          if (!t2) return;
          this._tryAddCustomEvent("$pageview", { href: t2 });
        }
      } catch (e4) {
        Yn.error("Could not add $pageview to rrweb session", e4);
      }
    })), this._onSessionIdListener || (this._onSessionIdListener = this.sessionManager.onSessionId((e3, t2, i) => {
      var n2, r2, s2, o2;
      i && (this._tryAddCustomEvent("$session_id_change", { sessionId: e3, windowId: t2, changeReason: i }), null === (n2 = this.instance) || void 0 === n2 || null === (r2 = n2.persistence) || void 0 === r2 || r2.unregister(Ee), null === (s2 = this.instance) || void 0 === s2 || null === (o2 = s2.persistence) || void 0 === o2 || o2.unregister(Se));
    }))) : this.stopRecording();
  }
  stopRecording() {
    var e2, i, n2, r2;
    this._captureStarted && this.stopRrweb && (this.stopRrweb(), this.stopRrweb = void 0, this._captureStarted = false, null == t$2 || t$2.removeEventListener("beforeunload", this._onBeforeUnload), null == t$2 || t$2.removeEventListener("offline", this._onOffline), null == t$2 || t$2.removeEventListener("online", this._onOnline), null == t$2 || t$2.removeEventListener("visibilitychange", this._onVisibilityChange), this.clearBuffer(), clearInterval(this._fullSnapshotTimer), null === (e2 = this._removePageViewCaptureHook) || void 0 === e2 || e2.call(this), this._removePageViewCaptureHook = void 0, null === (i = this._removeEventTriggerCaptureHook) || void 0 === i || i.call(this), this._removeEventTriggerCaptureHook = void 0, null === (n2 = this._onSessionIdListener) || void 0 === n2 || n2.call(this), this._onSessionIdListener = void 0, null === (r2 = this._samplingSessionListener) || void 0 === r2 || r2.call(this), this._samplingSessionListener = void 0, Yn.info("stopped"));
  }
  makeSamplingDecision(e2) {
    var t2, i = this.sessionId !== e2, n2 = this.sampleRate;
    if (L$1(n2)) {
      var r2, s2 = this.isSampled, o2 = i || !M$1(s2);
      if (o2) r2 = Math.random() < n2;
      else r2 = s2;
      o2 && (r2 ? this._reportStarted("sampled") : Yn.warn("Sample rate (".concat(n2, ") has determined that this sessionId (").concat(e2, ") will not be sent to the server.")), this._tryAddCustomEvent("samplingDecisionMade", { sampleRate: n2, isSampled: r2 })), null === (t2 = this.instance.persistence) || void 0 === t2 || t2.register({ [we]: r2 });
    } else {
      var a2;
      null === (a2 = this.instance.persistence) || void 0 === a2 || a2.register({ [we]: null });
    }
  }
  onRemoteConfig(e2) {
    var t2, i, n2, r2, s2, o2;
    (this._tryAddCustomEvent("$remote_config_received", e2), this._persistRemoteConfig(e2), this._linkedFlag = (null === (t2 = e2.sessionRecording) || void 0 === t2 ? void 0 : t2.linkedFlag) || null, null !== (i = e2.sessionRecording) && void 0 !== i && i.endpoint) && (this._endpoint = null === (o2 = e2.sessionRecording) || void 0 === o2 ? void 0 : o2.endpoint);
    if (this._setupSampling(), !O$1(this._linkedFlag) && !this._linkedFlagSeen) {
      var a2 = F$2(this._linkedFlag) ? this._linkedFlag : this._linkedFlag.flag, l2 = F$2(this._linkedFlag) ? null : this._linkedFlag.variant;
      this.instance.onFeatureFlags((e3, t3) => {
        var i2 = C$2(t3) && a2 in t3, n3 = l2 ? t3[a2] === l2 : i2;
        n3 && this._reportStarted("linked_flag_matched", { linkedFlag: a2, linkedVariant: l2 }), this._linkedFlagSeen = n3;
      });
    }
    null !== (n2 = e2.sessionRecording) && void 0 !== n2 && n2.urlTriggers && (this._urlTriggers = e2.sessionRecording.urlTriggers), null !== (r2 = e2.sessionRecording) && void 0 !== r2 && r2.urlBlocklist && (this._urlBlocklist = e2.sessionRecording.urlBlocklist), null !== (s2 = e2.sessionRecording) && void 0 !== s2 && s2.eventTriggers && (this._eventTriggers = e2.sessionRecording.eventTriggers), this.receivedDecide = true, this.startIfEnabledOrStop();
  }
  _setupSampling() {
    L$1(this.sampleRate) && O$1(this._samplingSessionListener) && (this._samplingSessionListener = this.sessionManager.onSessionId((e2) => {
      this.makeSamplingDecision(e2);
    }));
  }
  _persistRemoteConfig(e2) {
    if (this.instance.persistence) {
      var t2, i = this.instance.persistence, n2 = () => {
        var t3, n3, r2, s2, o2, a2, l2, u2, c6 = null === (t3 = e2.sessionRecording) || void 0 === t3 ? void 0 : t3.sampleRate, d2 = O$1(c6) ? null : parseFloat(c6), h2 = null === (n3 = e2.sessionRecording) || void 0 === n3 ? void 0 : n3.minimumDurationMilliseconds;
        i.register({ [_e]: !!e2.sessionRecording, [pe]: null === (r2 = e2.sessionRecording) || void 0 === r2 ? void 0 : r2.consoleLogRecordingEnabled, [ve]: j$2({ capturePerformance: e2.capturePerformance }, null === (s2 = e2.sessionRecording) || void 0 === s2 ? void 0 : s2.networkPayloadCapture), [ge]: { enabled: null === (o2 = e2.sessionRecording) || void 0 === o2 ? void 0 : o2.recordCanvas, fps: null === (a2 = e2.sessionRecording) || void 0 === a2 ? void 0 : a2.canvasFps, quality: null === (l2 = e2.sessionRecording) || void 0 === l2 ? void 0 : l2.canvasQuality }, [fe]: d2, [me]: R$1(h2) ? null : h2, [be]: null === (u2 = e2.sessionRecording) || void 0 === u2 ? void 0 : u2.scriptConfig });
      };
      n2(), null === (t2 = this._persistDecideOnSessionListener) || void 0 === t2 || t2.call(this), this._persistDecideOnSessionListener = this.sessionManager.onSessionId(n2);
    }
  }
  log(e2) {
    var t2, i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "log";
    null === (t2 = this.instance.sessionRecording) || void 0 === t2 || t2.onRRwebEmit({ type: 6, data: { plugin: "rrweb/console@1", payload: { level: i, trace: [], payload: [JSON.stringify(e2)] } }, timestamp: Date.now() });
  }
  _startCapture(e2) {
    if (!R$1(Object.assign) && !R$1(Array.from) && !(this._captureStarted || this.instance.config.disable_session_recording || this.instance.consent.isOptedOut())) {
      var t2, i;
      if (this._captureStarted = true, this.sessionManager.checkAndGetSessionAndWindowId(), this.rrwebRecord) this._onScriptLoaded();
      else null === (t2 = _$1.__PosthogExtensions__) || void 0 === t2 || null === (i = t2.loadExternalDependency) || void 0 === i || i.call(t2, this.instance, this.scriptName, (e3) => {
        if (e3) return Yn.error("could not load recorder", e3);
        this._onScriptLoaded();
      });
      Yn.info("starting"), "active" === this.status && this._reportStarted(e2 || "recording_initialized");
    }
  }
  get scriptName() {
    var e2, t2, i;
    return (null === (e2 = this.instance) || void 0 === e2 || null === (t2 = e2.persistence) || void 0 === t2 || null === (i = t2.get_property(be)) || void 0 === i ? void 0 : i.script) || "recorder";
  }
  isInteractiveEvent(e2) {
    var t2;
    return 3 === e2.type && -1 !== Xn.indexOf(null === (t2 = e2.data) || void 0 === t2 ? void 0 : t2.source);
  }
  _updateWindowAndSessionIds(e2) {
    var t2 = this.isInteractiveEvent(e2);
    t2 || this.isIdle || e2.timestamp - this._lastActivityTimestamp > this.sessionIdleThresholdMilliseconds && (this.isIdle = true, clearInterval(this._fullSnapshotTimer), this._tryAddCustomEvent("sessionIdle", { eventTimestamp: e2.timestamp, lastActivityTimestamp: this._lastActivityTimestamp, threshold: this.sessionIdleThresholdMilliseconds, bufferLength: this.buffer.data.length, bufferSize: this.buffer.size }), this._flushBuffer());
    var i = false;
    if (t2 && (this._lastActivityTimestamp = e2.timestamp, this.isIdle && (this.isIdle = false, this._tryAddCustomEvent("sessionNoLongerIdle", { reason: "user activity", type: e2.type }), i = true)), !this.isIdle) {
      var { windowId: n2, sessionId: r2 } = this.sessionManager.checkAndGetSessionAndWindowId(!t2, e2.timestamp), s2 = this.sessionId !== r2, o2 = this.windowId !== n2;
      this.windowId = n2, this.sessionId = r2, s2 || o2 ? (this.stopRecording(), this.startIfEnabledOrStop("session_id_changed")) : i && this._scheduleFullSnapshot();
    }
  }
  _tryRRWebMethod(e2) {
    try {
      return e2.rrwebMethod(), true;
    } catch (t2) {
      return this.queuedRRWebEvents.length < 10 ? this.queuedRRWebEvents.push({ enqueuedAt: e2.enqueuedAt || Date.now(), attempt: e2.attempt++, rrwebMethod: e2.rrwebMethod }) : Yn.warn("could not emit queued rrweb event.", t2, e2), false;
    }
  }
  _tryAddCustomEvent(e2, t2) {
    return this._tryRRWebMethod(Qn(() => this.rrwebRecord.addCustomEvent(e2, t2)));
  }
  _tryTakeFullSnapshot() {
    return this._tryRRWebMethod(Qn(() => this.rrwebRecord.takeFullSnapshot()));
  }
  _onScriptLoaded() {
    var e2, t2 = { blockClass: "ph-no-capture", blockSelector: void 0, ignoreClass: "ph-ignore-input", maskTextClass: "ph-mask", maskTextSelector: void 0, maskTextFn: void 0, maskAllInputs: true, maskInputOptions: { password: true }, maskInputFn: void 0, slimDOMOptions: {}, collectFonts: false, inlineStylesheet: true, recordCrossOriginIframes: false }, i = this.instance.config.session_recording;
    for (var [n2, r2] of Object.entries(i || {})) n2 in t2 && ("maskInputOptions" === n2 ? t2.maskInputOptions = j$2({ password: true }, r2) : t2[n2] = r2);
    if (this.canvasRecording && this.canvasRecording.enabled && (t2.recordCanvas = true, t2.sampling = { canvas: this.canvasRecording.fps }, t2.dataURLOptions = { type: "image/webp", quality: this.canvasRecording.quality }), this.rrwebRecord) {
      this.mutationRateLimiter = null !== (e2 = this.mutationRateLimiter) && void 0 !== e2 ? e2 : new un$1(this.rrwebRecord, { refillRate: this.instance.config.session_recording.__mutationRateLimiterRefillRate, bucketSize: this.instance.config.session_recording.__mutationRateLimiterBucketSize, onBlockedNode: (e3, t3) => {
        var i2 = "Too many mutations on node '".concat(e3, "'. Rate limiting. This could be due to SVG animations or something similar");
        Yn.info(i2, { node: t3 }), this.log(Jn + " " + i2, "warn");
      } });
      var s2 = this._gatherRRWebPlugins();
      this.stopRrweb = this.rrwebRecord(j$2({ emit: (e3) => {
        this.onRRwebEmit(e3);
      }, plugins: s2 }, t2)), this._lastActivityTimestamp = Date.now(), this.isIdle = false, this._tryAddCustomEvent("$session_options", { sessionRecordingOptions: t2, activePlugins: s2.map((e3) => null == e3 ? void 0 : e3.name) }), this._tryAddCustomEvent("$posthog_config", { config: this.instance.config });
    } else Yn.error("onScriptLoaded was called but rrwebRecord is not available. This indicates something has gone wrong.");
  }
  _scheduleFullSnapshot() {
    if (this._fullSnapshotTimer && clearInterval(this._fullSnapshotTimer), !this.isIdle) {
      var e2 = this.fullSnapshotIntervalMillis;
      e2 && (this._fullSnapshotTimer = setInterval(() => {
        this._tryTakeFullSnapshot();
      }, e2));
    }
  }
  _gatherRRWebPlugins() {
    var e2, t2, i, n2, r2 = [], s2 = null === (e2 = _$1.__PosthogExtensions__) || void 0 === e2 || null === (t2 = e2.rrwebPlugins) || void 0 === t2 ? void 0 : t2.getRecordConsolePlugin;
    s2 && this.isConsoleLogCaptureEnabled && r2.push(s2());
    var o2 = null === (i = _$1.__PosthogExtensions__) || void 0 === i || null === (n2 = i.rrwebPlugins) || void 0 === n2 ? void 0 : n2.getRecordNetworkPlugin;
    this.networkPayloadCapture && I$1(o2) && (!pt.includes(location.hostname) || this._forceAllowLocalhostNetworkCapture ? r2.push(o2(an$1(this.instance.config, this.networkPayloadCapture))) : Yn.info("NetworkCapture not started because we are on localhost."));
    return r2;
  }
  onRRwebEmit(e2) {
    var t2;
    if (this._processQueuedEvents(), e2 && C$2(e2)) {
      if (e2.type === Si.Meta) {
        var i = this._maskUrl(e2.data.href);
        if (this._lastHref = i, !i) return;
        e2.data.href = i;
      } else this._pageViewFallBack();
      if (this._checkUrlTriggerConditions(), "paused" !== this.status || function(e3) {
        return e3.type === Si.Custom && "recording paused" === e3.data.tag;
      }(e2)) {
        e2.type === Si.FullSnapshot && this._scheduleFullSnapshot(), e2.type === Si.FullSnapshot && "trigger_pending" === this.triggerStatus && this.clearBuffer();
        var n2 = this.mutationRateLimiter ? this.mutationRateLimiter.throttleMutations(e2) : e2;
        if (n2) {
          var r2 = function(e3) {
            var t3 = e3;
            if (t3 && C$2(t3) && 6 === t3.type && C$2(t3.data) && "rrweb/console@1" === t3.data.plugin) {
              t3.data.payload.payload.length > 10 && (t3.data.payload.payload = t3.data.payload.payload.slice(0, 10), t3.data.payload.payload.push("...[truncated]"));
              for (var i2 = [], n3 = 0; n3 < t3.data.payload.payload.length; n3++) t3.data.payload.payload[n3] && t3.data.payload.payload[n3].length > 2e3 ? i2.push(t3.data.payload.payload[n3].slice(0, 2e3) + "...[truncated]") : i2.push(t3.data.payload.payload[n3]);
              return t3.data.payload.payload = i2, e3;
            }
            return e3;
          }(n2);
          if (this._updateWindowAndSessionIds(r2), !this.isIdle || er(r2)) {
            if (er(r2)) {
              var s2 = r2.data.payload;
              if (s2) {
                var o2 = s2.lastActivityTimestamp, a2 = s2.threshold;
                r2.timestamp = o2 + a2;
              }
            }
            var l2 = null === (t2 = this.instance.config.session_recording.compress_events) || void 0 === t2 || t2 ? function(e3) {
              if (yi(e3) < 1024) return e3;
              try {
                if (e3.type === Si.FullSnapshot) return j$2(j$2({}, e3), {}, { data: Zn(e3.data), cv: "2024-10" });
                if (e3.type === Si.IncrementalSnapshot && e3.data.source === Ei.Mutation) return j$2(j$2({}, e3), {}, { cv: "2024-10", data: j$2(j$2({}, e3.data), {}, { texts: Zn(e3.data.texts), attributes: Zn(e3.data.attributes), removes: Zn(e3.data.removes), adds: Zn(e3.data.adds) }) });
                if (e3.type === Si.IncrementalSnapshot && e3.data.source === Ei.StyleSheetRule) return j$2(j$2({}, e3), {}, { cv: "2024-10", data: j$2(j$2({}, e3.data), {}, { adds: Zn(e3.data.adds), removes: Zn(e3.data.removes) }) });
              } catch (e4) {
                Yn.error("could not compress event - will use uncompressed event", e4);
              }
              return e3;
            }(r2) : r2, u2 = { $snapshot_bytes: yi(l2), $snapshot_data: l2, $session_id: this.sessionId, $window_id: this.windowId };
            "disabled" !== this.status ? this._captureSnapshotBuffered(u2) : this.clearBuffer();
          }
        }
      }
    }
  }
  _pageViewFallBack() {
    if (!this.instance.config.capture_pageview && t$2) {
      var e2 = this._maskUrl(t$2.location.href);
      this._lastHref !== e2 && (this._tryAddCustomEvent("$url_changed", { href: e2 }), this._lastHref = e2);
    }
  }
  _processQueuedEvents() {
    if (this.queuedRRWebEvents.length) {
      var e2 = [...this.queuedRRWebEvents];
      this.queuedRRWebEvents = [], e2.forEach((e3) => {
        Date.now() - e3.enqueuedAt <= 2e3 && this._tryRRWebMethod(e3);
      });
    }
  }
  _maskUrl(e2) {
    var t2 = this.instance.config.session_recording;
    if (t2.maskNetworkRequestFn) {
      var i, n2 = { url: e2 };
      return null === (i = n2 = t2.maskNetworkRequestFn(n2)) || void 0 === i ? void 0 : i.url;
    }
    return e2;
  }
  clearBuffer() {
    return this.buffer = { size: 0, data: [], sessionId: this.sessionId, windowId: this.windowId }, this.buffer;
  }
  _flushBuffer() {
    this.flushBufferTimer && (clearTimeout(this.flushBufferTimer), this.flushBufferTimer = void 0);
    var e2 = this.minimumDuration, t2 = this.sessionDuration, i = L$1(t2) && t2 >= 0, n2 = L$1(e2) && i && t2 < e2;
    if ("buffering" === this.status || "paused" === this.status || n2) return this.flushBufferTimer = setTimeout(() => {
      this._flushBuffer();
    }, 2e3), this.buffer;
    this.buffer.data.length > 0 && wi(this.buffer).forEach((e3) => {
      this._captureSnapshot({ $snapshot_bytes: e3.size, $snapshot_data: e3.data, $session_id: e3.sessionId, $window_id: e3.windowId, $lib: "web", $lib_version: p$2.LIB_VERSION });
    });
    return this.clearBuffer();
  }
  _captureSnapshotBuffered(e2) {
    var t2, i = 2 + ((null === (t2 = this.buffer) || void 0 === t2 ? void 0 : t2.data.length) || 0);
    !this.isIdle && (this.buffer.size + e2.$snapshot_bytes + i > 943718.4 || this.buffer.sessionId !== this.sessionId) && (this.buffer = this._flushBuffer()), this.buffer.size += e2.$snapshot_bytes, this.buffer.data.push(e2.$snapshot_data), this.flushBufferTimer || this.isIdle || (this.flushBufferTimer = setTimeout(() => {
      this._flushBuffer();
    }, 2e3));
  }
  _captureSnapshot(e2) {
    this.instance.capture("$snapshot", e2, { _url: this.instance.requestRouter.endpointFor("api", this._endpoint), _noTruncate: true, _batchKey: "recordings", skip_client_rate_limiting: true });
  }
  _checkUrlTriggerConditions() {
    if (void 0 !== t$2 && t$2.location.href) {
      var e2 = t$2.location.href, i = "paused" === this.status, n2 = tr(e2, this._urlBlocklist);
      n2 && !i ? this._pauseRecording() : !n2 && i && this._resumeRecording(), tr(e2, this._urlTriggers) && this._activateTrigger("url");
    }
  }
  _activateTrigger(e2) {
    var t2, i;
    "trigger_pending" === this.triggerStatus && (null === (t2 = this.instance) || void 0 === t2 || null === (i = t2.persistence) || void 0 === i || i.register({ ["url" === e2 ? Se : Ee]: this.sessionId }), this._flushBuffer(), this._reportStarted(e2 + "_trigger_matched"));
  }
  _pauseRecording() {
    "paused" !== this.status && (this._urlBlocked = true, clearInterval(this._fullSnapshotTimer), Yn.info("recording paused due to URL blocker"), this._tryAddCustomEvent("recording paused", { reason: "url blocker" }));
  }
  _resumeRecording() {
    "paused" === this.status && (this._urlBlocked = false, this._tryTakeFullSnapshot(), this._scheduleFullSnapshot(), this._tryAddCustomEvent("recording resumed", { reason: "left blocked url" }), Yn.info("recording resumed"));
  }
  _addEventTriggerListener() {
    0 !== this._eventTriggers.length && O$1(this._removeEventTriggerCaptureHook) && (this._removeEventTriggerCaptureHook = this.instance.on("eventCaptured", (e2) => {
      try {
        this._eventTriggers.includes(e2.event) && this._activateTrigger("event");
      } catch (e3) {
        Yn.error("Could not activate event trigger", e3);
      }
    }));
  }
  overrideLinkedFlag() {
    this._linkedFlagSeen = true, this._reportStarted("linked_flag_overridden");
  }
  overrideSampling() {
    var e2;
    null === (e2 = this.instance.persistence) || void 0 === e2 || e2.register({ [we]: true }), this._reportStarted("sampling_overridden");
  }
  overrideTrigger(e2) {
    this._activateTrigger(e2);
  }
  _reportStarted(e2, t2) {
    this.instance.register_for_session({ $session_recording_start_reason: e2 }), Yn.info(e2.replace("_", " "), t2), m$2(["recording_initialized", "session_id_changed"], e2) || this._tryAddCustomEvent(e2, t2);
  }
}
var nr = B$2("[RemoteConfig]");
class rr {
  constructor(e2) {
    this.instance = e2;
  }
  get remoteConfig() {
    var e2, t2;
    return null === (e2 = _$1._POSTHOG_REMOTE_CONFIG) || void 0 === e2 || null === (t2 = e2[this.instance.config.token]) || void 0 === t2 ? void 0 : t2.config;
  }
  _loadRemoteConfigJs(e2) {
    var t2, i, n2;
    null !== (t2 = _$1.__PosthogExtensions__) && void 0 !== t2 && t2.loadExternalDependency ? null === (i = _$1.__PosthogExtensions__) || void 0 === i || null === (n2 = i.loadExternalDependency) || void 0 === n2 || n2.call(i, this.instance, "remote-config", () => e2(this.remoteConfig)) : (nr.error("PostHog Extensions not found. Cannot load remote config."), e2());
  }
  _loadRemoteConfigJSON(e2) {
    this.instance._send_request({ method: "GET", url: this.instance.requestRouter.endpointFor("assets", "/array/".concat(this.instance.config.token, "/config")), callback: (t2) => {
      e2(t2.json);
    } });
  }
  load() {
    try {
      if (this.remoteConfig) return nr.info("Using preloaded remote config", this.remoteConfig), void this.onRemoteConfig(this.remoteConfig);
      if (this.instance.config.advanced_disable_decide) return void nr.warn("Remote config is disabled. Falling back to local config.");
      this._loadRemoteConfigJs((e2) => {
        if (!e2) return nr.info("No config found after loading remote JS config. Falling back to JSON."), void this._loadRemoteConfigJSON((e3) => {
          this.onRemoteConfig(e3);
        });
        this.onRemoteConfig(e2);
      });
    } catch (e2) {
      nr.error("Error loading remote config", e2);
    }
  }
  onRemoteConfig(e2) {
    e2 ? this.instance.config.__preview_remote_config ? (this.instance._onRemoteConfig(e2), false !== e2.hasFeatureFlags && this.instance.featureFlags.ensureFlagsLoaded()) : nr.info("__preview_remote_config is disabled. Logging config instead", e2) : nr.error("Failed to fetch remote config from PostHog.");
  }
}
var sr, or = null != t$2 && t$2.location ? bt(t$2.location.hash, "__posthog") || bt(location.hash, "state") : null, ar = "_postHogToolbarParams";
!function(e2) {
  e2[e2.UNINITIALIZED = 0] = "UNINITIALIZED", e2[e2.LOADING = 1] = "LOADING", e2[e2.LOADED = 2] = "LOADED";
}(sr || (sr = {}));
class lr {
  constructor(e2) {
    this.instance = e2;
  }
  setToolbarState(e2) {
    _$1.ph_toolbar_state = e2;
  }
  getToolbarState() {
    var e2;
    return null !== (e2 = _$1.ph_toolbar_state) && void 0 !== e2 ? e2 : sr.UNINITIALIZED;
  }
  maybeLoadToolbar() {
    var e2, i, n2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0, r2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0, s2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0;
    if (!t$2 || !a$1) return false;
    n2 = null !== (e2 = n2) && void 0 !== e2 ? e2 : t$2.location, s2 = null !== (i = s2) && void 0 !== i ? i : t$2.history;
    try {
      if (!r2) {
        try {
          t$2.localStorage.setItem("test", "test"), t$2.localStorage.removeItem("test");
        } catch (e3) {
          return false;
        }
        r2 = null == t$2 ? void 0 : t$2.localStorage;
      }
      var o2, l2 = or || bt(n2.hash, "__posthog") || bt(n2.hash, "state"), u2 = l2 ? Q$1(() => JSON.parse(atob(decodeURIComponent(l2)))) || Q$1(() => JSON.parse(decodeURIComponent(l2))) : null;
      return u2 && "ph_authorize" === u2.action ? ((o2 = u2).source = "url", o2 && Object.keys(o2).length > 0 && (u2.desiredHash ? n2.hash = u2.desiredHash : s2 ? s2.replaceState(s2.state, "", n2.pathname + n2.search) : n2.hash = "")) : ((o2 = JSON.parse(r2.getItem(ar) || "{}")).source = "localstorage", delete o2.userIntent), !(!o2.token || this.instance.config.token !== o2.token) && (this.loadToolbar(o2), true);
    } catch (e3) {
      return false;
    }
  }
  _callLoadToolbar(e2) {
    (_$1.ph_load_toolbar || _$1.ph_load_editor)(e2, this.instance);
  }
  loadToolbar(e2) {
    var i = !(null == a$1 || !a$1.getElementById(Ne));
    if (!t$2 || i) return false;
    var n2 = "custom" === this.instance.requestRouter.region && this.instance.config.advanced_disable_toolbar_metrics, r2 = j$2(j$2({ token: this.instance.config.token }, e2), {}, { apiURL: this.instance.requestRouter.endpointFor("ui") }, n2 ? { instrument: false } : {});
    if (t$2.localStorage.setItem(ar, JSON.stringify(j$2(j$2({}, r2), {}, { source: void 0 }))), this.getToolbarState() === sr.LOADED) this._callLoadToolbar(r2);
    else if (this.getToolbarState() === sr.UNINITIALIZED) {
      var s2, o2;
      this.setToolbarState(sr.LOADING), null === (s2 = _$1.__PosthogExtensions__) || void 0 === s2 || null === (o2 = s2.loadExternalDependency) || void 0 === o2 || o2.call(s2, this.instance, "toolbar", (e3) => {
        if (e3) return q$3.error("[Toolbar] Failed to load", e3), void this.setToolbarState(sr.UNINITIALIZED);
        this.setToolbarState(sr.LOADED), this._callLoadToolbar(r2);
      }), ie(t$2, "turbolinks:load", () => {
        this.setToolbarState(sr.UNINITIALIZED), this.loadToolbar(r2);
      });
    }
    return true;
  }
  _loadEditor(e2) {
    return this.loadToolbar(e2);
  }
  maybeLoadEditor() {
    var e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0, t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0, i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0;
    return this.maybeLoadToolbar(e2, t2, i);
  }
}
class ur {
  constructor(e2) {
    W$1(this, "isPaused", true), W$1(this, "queue", []), W$1(this, "flushTimeoutMs", 3e3), this.sendRequest = e2;
  }
  enqueue(e2) {
    this.queue.push(e2), this.flushTimeout || this.setFlushTimeout();
  }
  unload() {
    this.clearFlushTimeout();
    var e2 = this.queue.length > 0 ? this.formatQueue() : {}, t2 = Object.values(e2), i = [...t2.filter((e3) => 0 === e3.url.indexOf("/e")), ...t2.filter((e3) => 0 !== e3.url.indexOf("/e"))];
    i.map((e3) => {
      this.sendRequest(j$2(j$2({}, e3), {}, { transport: "sendBeacon" }));
    });
  }
  enable() {
    this.isPaused = false, this.setFlushTimeout();
  }
  setFlushTimeout() {
    var e2 = this;
    this.isPaused || (this.flushTimeout = setTimeout(() => {
      if (this.clearFlushTimeout(), this.queue.length > 0) {
        var t2 = this.formatQueue(), i = function(i2) {
          var n3 = t2[i2], r2 = (/* @__PURE__ */ new Date()).getTime();
          n3.data && x$3(n3.data) && Y$1(n3.data, (e3) => {
            e3.offset = Math.abs(e3.timestamp - r2), delete e3.timestamp;
          }), e2.sendRequest(n3);
        };
        for (var n2 in t2) i(n2);
      }
    }, this.flushTimeoutMs));
  }
  clearFlushTimeout() {
    clearTimeout(this.flushTimeout), this.flushTimeout = void 0;
  }
  formatQueue() {
    var e2 = {};
    return Y$1(this.queue, (t2) => {
      var i, n2 = t2, r2 = (n2 ? n2.batchKey : null) || n2.url;
      R$1(e2[r2]) && (e2[r2] = j$2(j$2({}, n2), {}, { data: [] })), null === (i = e2[r2].data) || void 0 === i || i.push(n2.data);
    }), this.queue = [], e2;
  }
}
var cr = function(e2) {
  var t2, i, n2, r2, s2 = "";
  for (t2 = i = 0, n2 = (e2 = (e2 + "").replace(/\r\n/g, "\n").replace(/\r/g, "\n")).length, r2 = 0; r2 < n2; r2++) {
    var o2 = e2.charCodeAt(r2), a2 = null;
    o2 < 128 ? i++ : a2 = o2 > 127 && o2 < 2048 ? String.fromCharCode(o2 >> 6 | 192, 63 & o2 | 128) : String.fromCharCode(o2 >> 12 | 224, o2 >> 6 & 63 | 128, 63 & o2 | 128), $$1(a2) || (i > t2 && (s2 += e2.substring(t2, i)), s2 += a2, t2 = i = r2 + 1);
  }
  return i > t2 && (s2 += e2.substring(t2, e2.length)), s2;
}, dr = !!c$2 || !!u$1, hr = "text/plain", _r = (e2, t2) => {
  var [i, n2] = e2.split("?"), r2 = j$2({}, t2);
  null == n2 || n2.split("&").forEach((e3) => {
    var [t3] = e3.split("=");
    delete r2[t3];
  });
  var s2 = ft(r2);
  return s2 = s2 ? (n2 ? n2 + "&" : "") + s2 : n2, "".concat(i, "?").concat(s2);
}, pr = (e2, t2) => JSON.stringify(e2, (e3, t3) => "bigint" == typeof t3 ? t3.toString() : t3, t2), vr = (t2) => {
  var { data: i, compression: n2 } = t2;
  if (i) {
    if (n2 === e$2.GZipJS) {
      var r2 = Gn(Vn(pr(i)), { mtime: 0 }), s2 = new Blob([r2], { type: hr });
      return { contentType: hr, body: s2, estimatedSize: s2.size };
    }
    if (n2 === e$2.Base64) {
      var o2 = function(e2) {
        var t3, i2, n3, r3, s3, o3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", a3 = 0, l3 = 0, u2 = "", c6 = [];
        if (!e2) return e2;
        e2 = cr(e2);
        do {
          t3 = (s3 = e2.charCodeAt(a3++) << 16 | e2.charCodeAt(a3++) << 8 | e2.charCodeAt(a3++)) >> 18 & 63, i2 = s3 >> 12 & 63, n3 = s3 >> 6 & 63, r3 = 63 & s3, c6[l3++] = o3.charAt(t3) + o3.charAt(i2) + o3.charAt(n3) + o3.charAt(r3);
        } while (a3 < e2.length);
        switch (u2 = c6.join(""), e2.length % 3) {
          case 1:
            u2 = u2.slice(0, -2) + "==";
            break;
          case 2:
            u2 = u2.slice(0, -1) + "=";
        }
        return u2;
      }(pr(i)), a2 = ((e2) => "data=" + encodeURIComponent("string" == typeof e2 ? e2 : pr(e2)))(o2);
      return { contentType: "application/x-www-form-urlencoded", body: a2, estimatedSize: new Blob([a2]).size };
    }
    var l2 = pr(i);
    return { contentType: "application/json", body: l2, estimatedSize: new Blob([l2]).size };
  }
}, gr = [];
u$1 && gr.push({ transport: "fetch", method: (e2) => {
  var t2, i, { contentType: n2, body: r2, estimatedSize: s2 } = null !== (t2 = vr(e2)) && void 0 !== t2 ? t2 : {}, o2 = new Headers();
  Y$1(e2.headers, function(e3, t3) {
    o2.append(t3, e3);
  }), n2 && o2.append("Content-Type", n2);
  var a2 = e2.url, l2 = null;
  if (d$2) {
    var c6 = new d$2();
    l2 = { signal: c6.signal, timeout: setTimeout(() => c6.abort(), e2.timeout) };
  }
  u$1(a2, j$2({ method: (null == e2 ? void 0 : e2.method) || "GET", headers: o2, keepalive: "POST" === e2.method && (s2 || 0) < 52428.8, body: r2, signal: null === (i = l2) || void 0 === i ? void 0 : i.signal }, e2.fetchOptions)).then((t3) => t3.text().then((i2) => {
    var n3, r3 = { statusCode: t3.status, text: i2 };
    if (200 === t3.status) try {
      r3.json = JSON.parse(i2);
    } catch (e3) {
      q$3.error(e3);
    }
    null === (n3 = e2.callback) || void 0 === n3 || n3.call(e2, r3);
  })).catch((t3) => {
    var i2;
    q$3.error(t3), null === (i2 = e2.callback) || void 0 === i2 || i2.call(e2, { statusCode: 0, text: t3 });
  }).finally(() => l2 ? clearTimeout(l2.timeout) : null);
} }), c$2 && gr.push({ transport: "XHR", method: (e2) => {
  var t2, i = new c$2();
  i.open(e2.method || "GET", e2.url, true);
  var { contentType: n2, body: r2 } = null !== (t2 = vr(e2)) && void 0 !== t2 ? t2 : {};
  Y$1(e2.headers, function(e3, t3) {
    i.setRequestHeader(t3, e3);
  }), n2 && i.setRequestHeader("Content-Type", n2), e2.timeout && (i.timeout = e2.timeout), i.withCredentials = true, i.onreadystatechange = () => {
    if (4 === i.readyState) {
      var t3, n3 = { statusCode: i.status, text: i.responseText };
      if (200 === i.status) try {
        n3.json = JSON.parse(i.responseText);
      } catch (e3) {
      }
      null === (t3 = e2.callback) || void 0 === t3 || t3.call(e2, n3);
    }
  }, i.send(r2);
} }), null != o$1 && o$1.sendBeacon && gr.push({ transport: "sendBeacon", method: (e2) => {
  var t2 = _r(e2.url, { beacon: "1" });
  try {
    var i, { contentType: n2, body: r2 } = null !== (i = vr(e2)) && void 0 !== i ? i : {}, s2 = "string" == typeof r2 ? new Blob([r2], { type: n2 }) : r2;
    o$1.sendBeacon(t2, s2);
  } catch (e3) {
  }
} });
var fr = ["retriesPerformedSoFar"];
class mr {
  constructor(e2) {
    W$1(this, "isPolling", false), W$1(this, "pollIntervalMs", 3e3), W$1(this, "queue", []), this.instance = e2, this.queue = [], this.areWeOnline = true, !R$1(t$2) && "onLine" in t$2.navigator && (this.areWeOnline = t$2.navigator.onLine, t$2.addEventListener("online", () => {
      this.areWeOnline = true, this.flush();
    }), t$2.addEventListener("offline", () => {
      this.areWeOnline = false;
    }));
  }
  retriableRequest(e2) {
    var { retriesPerformedSoFar: t2 } = e2, i = G$1(e2, fr);
    L$1(t2) && t2 > 0 && (i.url = _r(i.url, { retry_count: t2 })), this.instance._send_request(j$2(j$2({}, i), {}, { callback: (e3) => {
      var n2;
      200 !== e3.statusCode && (e3.statusCode < 400 || e3.statusCode >= 500) && (null != t2 ? t2 : 0) < 10 ? this.enqueue(j$2({ retriesPerformedSoFar: t2 }, i)) : null === (n2 = i.callback) || void 0 === n2 || n2.call(i, e3);
    } }));
  }
  enqueue(e2) {
    var t2 = e2.retriesPerformedSoFar || 0;
    e2.retriesPerformedSoFar = t2 + 1;
    var i = function(e3) {
      var t3 = 3e3 * Math.pow(2, e3), i2 = t3 / 2, n3 = Math.min(18e5, t3), r3 = (Math.random() - 0.5) * (n3 - i2);
      return Math.ceil(n3 + r3);
    }(t2), n2 = Date.now() + i;
    this.queue.push({ retryAt: n2, requestOptions: e2 });
    var r2 = "Enqueued failed request for retry in ".concat(i);
    navigator.onLine || (r2 += " (Browser is offline)"), q$3.warn(r2), this.isPolling || (this.isPolling = true, this.poll());
  }
  poll() {
    this.poller && clearTimeout(this.poller), this.poller = setTimeout(() => {
      this.areWeOnline && this.queue.length > 0 && this.flush(), this.poll();
    }, this.pollIntervalMs);
  }
  flush() {
    var e2 = Date.now(), t2 = [], i = this.queue.filter((i2) => i2.retryAt < e2 || (t2.push(i2), false));
    if (this.queue = t2, i.length > 0) for (var { requestOptions: n2 } of i) this.retriableRequest(n2);
  }
  unload() {
    for (var { requestOptions: e2 } of (this.poller && (clearTimeout(this.poller), this.poller = void 0), this.queue)) try {
      this.instance._send_request(j$2(j$2({}, e2), {}, { transport: "sendBeacon" }));
    } catch (e3) {
      q$3.error(e3);
    }
    this.queue = [];
  }
}
var br, yr = B$2("[SessionId]");
class wr {
  constructor(e2, t2, i) {
    var n2;
    if (W$1(this, "_sessionIdChangedHandlers", []), !e2.persistence) throw new Error("SessionIdManager requires a PostHogPersistence instance");
    if (e2.config.__preview_experimental_cookieless_mode) throw new Error("SessionIdManager cannot be used with __preview_experimental_cookieless_mode");
    this.config = e2.config, this.persistence = e2.persistence, this._windowId = void 0, this._sessionId = void 0, this._sessionStartTimestamp = null, this._sessionActivityTimestamp = null, this._sessionIdGenerator = t2 || Ze, this._windowIdGenerator = i || Ze;
    var r2 = this.config.persistence_name || this.config.token, s2 = this.config.session_idle_timeout_seconds || 1800;
    if (this._sessionTimeoutMs = 1e3 * ln$1(s2, 60, 36e3, "session_idle_timeout_seconds", 1800), e2.register({ $configured_session_timeout_ms: this._sessionTimeoutMs }), this.resetIdleTimer(), this._window_id_storage_key = "ph_" + r2 + "_window_id", this._primary_window_exists_storage_key = "ph_" + r2 + "_primary_window_exists", this._canUseSessionStorage()) {
      var o2 = _t.parse(this._window_id_storage_key), a2 = _t.parse(this._primary_window_exists_storage_key);
      o2 && !a2 ? this._windowId = o2 : _t.remove(this._window_id_storage_key), _t.set(this._primary_window_exists_storage_key, true);
    }
    if (null !== (n2 = this.config.bootstrap) && void 0 !== n2 && n2.sessionID) try {
      var l2 = ((e3) => {
        var t3 = e3.replace(/-/g, "");
        if (32 !== t3.length) throw new Error("Not a valid UUID");
        if ("7" !== t3[12]) throw new Error("Not a UUIDv7");
        return parseInt(t3.substring(0, 12), 16);
      })(this.config.bootstrap.sessionID);
      this._setSessionId(this.config.bootstrap.sessionID, (/* @__PURE__ */ new Date()).getTime(), l2);
    } catch (e3) {
      yr.error("Invalid sessionID in bootstrap", e3);
    }
    this._listenToReloadWindow();
  }
  get sessionTimeoutMs() {
    return this._sessionTimeoutMs;
  }
  onSessionId(e2) {
    return R$1(this._sessionIdChangedHandlers) && (this._sessionIdChangedHandlers = []), this._sessionIdChangedHandlers.push(e2), this._sessionId && e2(this._sessionId, this._windowId), () => {
      this._sessionIdChangedHandlers = this._sessionIdChangedHandlers.filter((t2) => t2 !== e2);
    };
  }
  _canUseSessionStorage() {
    return "memory" !== this.config.persistence && !this.persistence.disabled && _t.is_supported();
  }
  _setWindowId(e2) {
    e2 !== this._windowId && (this._windowId = e2, this._canUseSessionStorage() && _t.set(this._window_id_storage_key, e2));
  }
  _getWindowId() {
    return this._windowId ? this._windowId : this._canUseSessionStorage() ? _t.parse(this._window_id_storage_key) : null;
  }
  _setSessionId(e2, t2, i) {
    e2 === this._sessionId && t2 === this._sessionActivityTimestamp && i === this._sessionStartTimestamp || (this._sessionStartTimestamp = i, this._sessionActivityTimestamp = t2, this._sessionId = e2, this.persistence.register({ [ye]: [t2, e2, i] }));
  }
  _getSessionId() {
    if (this._sessionId && this._sessionActivityTimestamp && this._sessionStartTimestamp) return [this._sessionActivityTimestamp, this._sessionId, this._sessionStartTimestamp];
    var e2 = this.persistence.props[ye];
    return x$3(e2) && 2 === e2.length && e2.push(e2[0]), e2 || [0, null, 0];
  }
  resetSessionId() {
    this._setSessionId(null, null, null);
  }
  _listenToReloadWindow() {
    null == t$2 || t$2.addEventListener("beforeunload", () => {
      this._canUseSessionStorage() && _t.remove(this._primary_window_exists_storage_key);
    });
  }
  checkAndGetSessionAndWindowId() {
    var e2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
    if (this.config.__preview_experimental_cookieless_mode) throw new Error("checkAndGetSessionAndWindowId should not be called in __preview_experimental_cookieless_mode");
    var i = t2 || (/* @__PURE__ */ new Date()).getTime(), [n2, r2, s2] = this._getSessionId(), o2 = this._getWindowId(), a2 = L$1(s2) && s2 > 0 && Math.abs(i - s2) > 864e5, l2 = false, u2 = !r2, c6 = !e2 && Math.abs(i - n2) > this.sessionTimeoutMs;
    u2 || c6 || a2 ? (r2 = this._sessionIdGenerator(), o2 = this._windowIdGenerator(), yr.info("new session ID generated", { sessionId: r2, windowId: o2, changeReason: { noSessionId: u2, activityTimeout: c6, sessionPastMaximumLength: a2 } }), s2 = i, l2 = true) : o2 || (o2 = this._windowIdGenerator(), l2 = true);
    var d2 = 0 === n2 || !e2 || a2 ? i : n2, h2 = 0 === s2 ? (/* @__PURE__ */ new Date()).getTime() : s2;
    return this._setWindowId(o2), this._setSessionId(r2, d2, h2), e2 || this.resetIdleTimer(), l2 && this._sessionIdChangedHandlers.forEach((e3) => e3(r2, o2, l2 ? { noSessionId: u2, activityTimeout: c6, sessionPastMaximumLength: a2 } : void 0)), { sessionId: r2, windowId: o2, sessionStartTimestamp: h2, changeReason: l2 ? { noSessionId: u2, activityTimeout: c6, sessionPastMaximumLength: a2 } : void 0, lastActivityTimestamp: n2 };
  }
  resetIdleTimer() {
    clearTimeout(this._enforceIdleTimeout), this._enforceIdleTimeout = setTimeout(() => {
      this.resetSessionId();
    }, 1.1 * this.sessionTimeoutMs);
  }
}
!function(e2) {
  e2.US = "us", e2.EU = "eu", e2.CUSTOM = "custom";
}(br || (br = {}));
var Sr = "i.posthog.com";
class Er {
  constructor(e2) {
    W$1(this, "_regionCache", {}), this.instance = e2;
  }
  get apiHost() {
    var e2 = this.instance.config.api_host.trim().replace(/\/$/, "");
    return "https://app.posthog.com" === e2 ? "https://us.i.posthog.com" : e2;
  }
  get uiHost() {
    var e2, t2 = null === (e2 = this.instance.config.ui_host) || void 0 === e2 ? void 0 : e2.replace(/\/$/, "");
    return t2 || (t2 = this.apiHost.replace(".".concat(Sr), ".posthog.com")), "https://app.posthog.com" === t2 ? "https://us.posthog.com" : t2;
  }
  get region() {
    return this._regionCache[this.apiHost] || (/https:\/\/(app|us|us-assets)(\.i)?\.posthog\.com/i.test(this.apiHost) ? this._regionCache[this.apiHost] = br.US : /https:\/\/(eu|eu-assets)(\.i)?\.posthog\.com/i.test(this.apiHost) ? this._regionCache[this.apiHost] = br.EU : this._regionCache[this.apiHost] = br.CUSTOM), this._regionCache[this.apiHost];
  }
  endpointFor(e2) {
    var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
    if (t2 && (t2 = "/" === t2[0] ? t2 : "/".concat(t2)), "ui" === e2) return this.uiHost + t2;
    if (this.region === br.CUSTOM) return this.apiHost + t2;
    var i = Sr + t2;
    switch (e2) {
      case "assets":
        return "https://".concat(this.region, "-assets.").concat(i);
      case "api":
        return "https://".concat(this.region, ".").concat(i);
    }
  }
}
var kr = "posthog-js";
function xr(e2) {
  var { organization: t2, projectId: i, prefix: n2, severityAllowList: r2 = ["error"] } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
  return (s2) => {
    var o2, a2, l2, u2, c6;
    if (!("*" === r2 || r2.includes(s2.level)) || !e2.__loaded) return s2;
    s2.tags || (s2.tags = {});
    var d2 = e2.requestRouter.endpointFor("ui", "/project/".concat(e2.config.token, "/person/").concat(e2.get_distinct_id()));
    s2.tags["PostHog Person URL"] = d2, e2.sessionRecordingStarted() && (s2.tags["PostHog Recording URL"] = e2.get_session_replay_url({ withTimestamp: true }));
    var h2 = (null === (o2 = s2.exception) || void 0 === o2 ? void 0 : o2.values) || [];
    h2.map((e3) => {
      e3.stacktrace && (e3.stacktrace.type = "raw");
    });
    var _2 = { $exception_message: (null === (a2 = h2[0]) || void 0 === a2 ? void 0 : a2.value) || s2.message, $exception_type: null === (l2 = h2[0]) || void 0 === l2 ? void 0 : l2.type, $exception_personURL: d2, $exception_level: s2.level, $exception_list: h2, $sentry_event_id: s2.event_id, $sentry_exception: s2.exception, $sentry_exception_message: (null === (u2 = h2[0]) || void 0 === u2 ? void 0 : u2.value) || s2.message, $sentry_exception_type: null === (c6 = h2[0]) || void 0 === c6 ? void 0 : c6.type, $sentry_tags: s2.tags };
    return t2 && i && (_2.$sentry_url = (n2 || "https://sentry.io/organizations/") + t2 + "/issues/?project=" + i + "&query=" + s2.event_id), e2.exceptions.sendExceptionEvent(_2), s2;
  };
}
class Ir {
  constructor(e2, t2, i, n2, r2) {
    this.name = kr, this.setupOnce = function(s2) {
      s2(xr(e2, { organization: t2, projectId: i, prefix: n2, severityAllowList: r2 }));
    };
  }
}
var Cr, Pr, Rr, Fr = B$2("[SegmentIntegration]");
function Tr(e2, t2) {
  var i = e2.config.segment;
  if (!i) return t2();
  !function(e3, t3) {
    var i2 = e3.config.segment;
    if (!i2) return t3();
    var n2 = (i3) => {
      var n3 = () => i3.anonymousId() || Ze();
      e3.config.get_device_id = n3, i3.id() && (e3.register({ distinct_id: i3.id(), $device_id: n3() }), e3.persistence.set_property(Te, "identified")), t3();
    }, r2 = i2.user();
    "then" in r2 && I$1(r2.then) ? r2.then((e4) => n2(e4)) : n2(r2);
  }(e2, () => {
    i.register(((e3) => {
      Promise && Promise.resolve || Fr.warn("This browser does not have Promise support, and can not use the segment integration");
      var t3 = (t4, i2) => {
        var n2;
        if (!i2) return t4;
        t4.event.userId || t4.event.anonymousId === e3.get_distinct_id() || (Fr.info("No userId set, resetting PostHog"), e3.reset()), t4.event.userId && t4.event.userId !== e3.get_distinct_id() && (Fr.info("UserId set, identifying with PostHog"), e3.identify(t4.event.userId));
        var r2 = e3._calculate_event_properties(i2, null !== (n2 = t4.event.properties) && void 0 !== n2 ? n2 : {}, /* @__PURE__ */ new Date());
        return t4.event.properties = Object.assign({}, r2, t4.event.properties), t4;
      };
      return { name: "PostHog JS", type: "enrichment", version: "1.0.0", isLoaded: () => true, load: () => Promise.resolve(), track: (e4) => t3(e4, e4.event.event), page: (e4) => t3(e4, "$pageview"), identify: (e4) => t3(e4, "$identify"), screen: (e4) => t3(e4, "$screen") };
    })(e2)).then(() => {
      t2();
    });
  });
}
class $r {
  constructor(e2) {
    this._instance = e2;
  }
  doPageView(e2) {
    var i, n2 = this._previousPageViewProperties(e2);
    return this._currentPath = null !== (i = null == t$2 ? void 0 : t$2.location.pathname) && void 0 !== i ? i : "", this._instance.scrollManager.resetContext(), this._prevPageviewTimestamp = e2, n2;
  }
  doPageLeave(e2) {
    return this._previousPageViewProperties(e2);
  }
  _previousPageViewProperties(e2) {
    var t2 = this._currentPath, i = this._prevPageviewTimestamp, n2 = this._instance.scrollManager.getContext();
    if (!i) return {};
    var r2 = {};
    if (n2) {
      var { maxScrollHeight: s2, lastScrollY: o2, maxScrollY: a2, maxContentHeight: l2, lastContentY: u2, maxContentY: c6 } = n2;
      if (!(R$1(s2) || R$1(o2) || R$1(a2) || R$1(l2) || R$1(u2) || R$1(c6))) s2 = Math.ceil(s2), o2 = Math.ceil(o2), a2 = Math.ceil(a2), l2 = Math.ceil(l2), u2 = Math.ceil(u2), c6 = Math.ceil(c6), r2 = { $prev_pageview_last_scroll: o2, $prev_pageview_last_scroll_percentage: s2 <= 1 ? 1 : ln$1(o2 / s2, 0, 1), $prev_pageview_max_scroll: a2, $prev_pageview_max_scroll_percentage: s2 <= 1 ? 1 : ln$1(a2 / s2, 0, 1), $prev_pageview_last_content: u2, $prev_pageview_last_content_percentage: l2 <= 1 ? 1 : ln$1(u2 / l2, 0, 1), $prev_pageview_max_content: c6, $prev_pageview_max_content_percentage: l2 <= 1 ? 1 : ln$1(c6 / l2, 0, 1) };
    }
    return t2 && (r2.$prev_pageview_pathname = t2), i && (r2.$prev_pageview_duration = (e2.getTime() - i.getTime()) / 1e3), r2;
  }
}
!function(e2) {
  e2.Popover = "popover", e2.API = "api", e2.Widget = "widget";
}(Cr || (Cr = {})), function(e2) {
  e2.Open = "open", e2.MultipleChoice = "multiple_choice", e2.SingleChoice = "single_choice", e2.Rating = "rating", e2.Link = "link";
}(Pr || (Pr = {})), function(e2) {
  e2.NextQuestion = "next_question", e2.End = "end", e2.ResponseBased = "response_based", e2.SpecificQuestion = "specific_question";
}(Rr || (Rr = {}));
class Or {
  constructor() {
    W$1(this, "events", {}), this.events = {};
  }
  on(e2, t2) {
    return this.events[e2] || (this.events[e2] = []), this.events[e2].push(t2), () => {
      this.events[e2] = this.events[e2].filter((e3) => e3 !== t2);
    };
  }
  emit(e2, t2) {
    for (var i of this.events[e2] || []) i(t2);
    for (var n2 of this.events["*"] || []) n2(e2, t2);
  }
}
class Lr {
  constructor(e2) {
    W$1(this, "_debugEventEmitter", new Or()), W$1(this, "checkStep", (e3, t2) => this.checkStepEvent(e3, t2) && this.checkStepUrl(e3, t2) && this.checkStepElement(e3, t2)), W$1(this, "checkStepEvent", (e3, t2) => null == t2 || !t2.event || (null == e3 ? void 0 : e3.event) === (null == t2 ? void 0 : t2.event)), this.instance = e2, this.actionEvents = /* @__PURE__ */ new Set(), this.actionRegistry = /* @__PURE__ */ new Set();
  }
  init() {
    var e2;
    if (!R$1(null === (e2 = this.instance) || void 0 === e2 ? void 0 : e2._addCaptureHook)) {
      var t2;
      null === (t2 = this.instance) || void 0 === t2 || t2._addCaptureHook((e3, t3) => {
        this.on(e3, t3);
      });
    }
  }
  register(e2) {
    var t2, i;
    if (!R$1(null === (t2 = this.instance) || void 0 === t2 ? void 0 : t2._addCaptureHook) && (e2.forEach((e3) => {
      var t3, i2;
      null === (t3 = this.actionRegistry) || void 0 === t3 || t3.add(e3), null === (i2 = e3.steps) || void 0 === i2 || i2.forEach((e4) => {
        var t4;
        null === (t4 = this.actionEvents) || void 0 === t4 || t4.add((null == e4 ? void 0 : e4.event) || "");
      });
    }), null !== (i = this.instance) && void 0 !== i && i.autocapture)) {
      var n2, r2 = /* @__PURE__ */ new Set();
      e2.forEach((e3) => {
        var t3;
        null === (t3 = e3.steps) || void 0 === t3 || t3.forEach((e4) => {
          null != e4 && e4.selector && r2.add(null == e4 ? void 0 : e4.selector);
        });
      }), null === (n2 = this.instance) || void 0 === n2 || n2.autocapture.setElementSelectors(r2);
    }
  }
  on(e2, t2) {
    var i;
    null != t2 && 0 != e2.length && (this.actionEvents.has(e2) || this.actionEvents.has(null == t2 ? void 0 : t2.event)) && this.actionRegistry && (null === (i = this.actionRegistry) || void 0 === i ? void 0 : i.size) > 0 && this.actionRegistry.forEach((e3) => {
      this.checkAction(t2, e3) && this._debugEventEmitter.emit("actionCaptured", e3.name);
    });
  }
  _addActionHook(e2) {
    this.onAction("actionCaptured", (t2) => e2(t2));
  }
  checkAction(e2, t2) {
    if (null == (null == t2 ? void 0 : t2.steps)) return false;
    for (var i of t2.steps) if (this.checkStep(e2, i)) return true;
    return false;
  }
  onAction(e2, t2) {
    return this._debugEventEmitter.on(e2, t2);
  }
  checkStepUrl(e2, t2) {
    if (null != t2 && t2.url) {
      var i, n2 = null == e2 || null === (i = e2.properties) || void 0 === i ? void 0 : i.$current_url;
      if (!n2 || "string" != typeof n2) return false;
      if (!Lr.matchString(n2, null == t2 ? void 0 : t2.url, (null == t2 ? void 0 : t2.url_matching) || "contains")) return false;
    }
    return true;
  }
  static matchString(e2, i, n2) {
    switch (n2) {
      case "regex":
        return !!t$2 && gt(e2, i);
      case "exact":
        return i === e2;
      case "contains":
        var r2 = Lr.escapeStringRegexp(i).replace(/_/g, ".").replace(/%/g, ".*");
        return gt(e2, r2);
      default:
        return false;
    }
  }
  static escapeStringRegexp(e2) {
    return e2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
  }
  checkStepElement(e2, t2) {
    if ((null != t2 && t2.href || null != t2 && t2.tag_name || null != t2 && t2.text) && !this.getElementsList(e2).some((e3) => !(null != t2 && t2.href && !Lr.matchString(e3.href || "", null == t2 ? void 0 : t2.href, (null == t2 ? void 0 : t2.href_matching) || "exact")) && ((null == t2 || !t2.tag_name || e3.tag_name === (null == t2 ? void 0 : t2.tag_name)) && !(null != t2 && t2.text && !Lr.matchString(e3.text || "", null == t2 ? void 0 : t2.text, (null == t2 ? void 0 : t2.text_matching) || "exact") && !Lr.matchString(e3.$el_text || "", null == t2 ? void 0 : t2.text, (null == t2 ? void 0 : t2.text_matching) || "exact"))))) return false;
    if (null != t2 && t2.selector) {
      var i, n2 = null == e2 || null === (i = e2.properties) || void 0 === i ? void 0 : i.$element_selectors;
      if (!n2) return false;
      if (!n2.includes(null == t2 ? void 0 : t2.selector)) return false;
    }
    return true;
  }
  getElementsList(e2) {
    return null == (null == e2 ? void 0 : e2.properties.$elements) ? [] : null == e2 ? void 0 : e2.properties.$elements;
  }
}
class Mr {
  constructor(e2) {
    this.instance = e2, this.eventToSurveys = /* @__PURE__ */ new Map(), this.actionToSurveys = /* @__PURE__ */ new Map();
  }
  register(e2) {
    var t2;
    R$1(null === (t2 = this.instance) || void 0 === t2 ? void 0 : t2._addCaptureHook) || (this.setupEventBasedSurveys(e2), this.setupActionBasedSurveys(e2));
  }
  setupActionBasedSurveys(e2) {
    var t2 = e2.filter((e3) => {
      var t3, i, n2, r2;
      return (null === (t3 = e3.conditions) || void 0 === t3 ? void 0 : t3.actions) && (null === (i = e3.conditions) || void 0 === i || null === (n2 = i.actions) || void 0 === n2 || null === (r2 = n2.values) || void 0 === r2 ? void 0 : r2.length) > 0;
    });
    if (0 !== t2.length) {
      if (null == this.actionMatcher) {
        this.actionMatcher = new Lr(this.instance), this.actionMatcher.init();
        this.actionMatcher._addActionHook((e3) => {
          this.onAction(e3);
        });
      }
      t2.forEach((e3) => {
        var t3, i, n2, r2, s2, o2, a2, l2, u2, c6;
        e3.conditions && null !== (t3 = e3.conditions) && void 0 !== t3 && t3.actions && null !== (i = e3.conditions) && void 0 !== i && null !== (n2 = i.actions) && void 0 !== n2 && n2.values && (null === (r2 = e3.conditions) || void 0 === r2 || null === (s2 = r2.actions) || void 0 === s2 || null === (o2 = s2.values) || void 0 === o2 ? void 0 : o2.length) > 0 && (null === (a2 = this.actionMatcher) || void 0 === a2 || a2.register(e3.conditions.actions.values), null === (l2 = e3.conditions) || void 0 === l2 || null === (u2 = l2.actions) || void 0 === u2 || null === (c6 = u2.values) || void 0 === c6 || c6.forEach((t4) => {
          if (t4 && t4.name) {
            var i2 = this.actionToSurveys.get(t4.name);
            i2 && i2.push(e3.id), this.actionToSurveys.set(t4.name, i2 || [e3.id]);
          }
        }));
      });
    }
  }
  setupEventBasedSurveys(e2) {
    var t2;
    if (0 !== e2.filter((e3) => {
      var t3, i, n2, r2;
      return (null === (t3 = e3.conditions) || void 0 === t3 ? void 0 : t3.events) && (null === (i = e3.conditions) || void 0 === i || null === (n2 = i.events) || void 0 === n2 || null === (r2 = n2.values) || void 0 === r2 ? void 0 : r2.length) > 0;
    }).length) {
      null === (t2 = this.instance) || void 0 === t2 || t2._addCaptureHook((e3, t3) => {
        this.onEvent(e3, t3);
      }), e2.forEach((e3) => {
        var t3, i, n2;
        null === (t3 = e3.conditions) || void 0 === t3 || null === (i = t3.events) || void 0 === i || null === (n2 = i.values) || void 0 === n2 || n2.forEach((t4) => {
          if (t4 && t4.name) {
            var i2 = this.eventToSurveys.get(t4.name);
            i2 && i2.push(e3.id), this.eventToSurveys.set(t4.name, i2 || [e3.id]);
          }
        });
      });
    }
  }
  onEvent(e2, t2) {
    var i, n2, r2 = (null === (i = this.instance) || void 0 === i || null === (n2 = i.persistence) || void 0 === n2 ? void 0 : n2.props[Re]) || [];
    if (Mr.SURVEY_SHOWN_EVENT_NAME == e2 && t2 && r2.length > 0) {
      var s2, o2 = null == t2 || null === (s2 = t2.properties) || void 0 === s2 ? void 0 : s2.$survey_id;
      if (o2) {
        var a2 = r2.indexOf(o2);
        a2 >= 0 && (r2.splice(a2, 1), this._updateActivatedSurveys(r2));
      }
    } else this.eventToSurveys.has(e2) && this._updateActivatedSurveys(r2.concat(this.eventToSurveys.get(e2) || []));
  }
  onAction(e2) {
    var t2, i, n2 = (null === (t2 = this.instance) || void 0 === t2 || null === (i = t2.persistence) || void 0 === i ? void 0 : i.props[Re]) || [];
    this.actionToSurveys.has(e2) && this._updateActivatedSurveys(n2.concat(this.actionToSurveys.get(e2) || []));
  }
  _updateActivatedSurveys(e2) {
    var t2, i;
    null === (t2 = this.instance) || void 0 === t2 || null === (i = t2.persistence) || void 0 === i || i.register({ [Re]: [...new Set(e2)] });
  }
  getSurveys() {
    var e2, t2, i = null === (e2 = this.instance) || void 0 === e2 || null === (t2 = e2.persistence) || void 0 === t2 ? void 0 : t2.props[Re];
    return i || [];
  }
  getEventToSurveys() {
    return this.eventToSurveys;
  }
  _getActionMatcher() {
    return this.actionMatcher;
  }
}
W$1(Mr, "SURVEY_SHOWN_EVENT_NAME", "survey shown");
var Ar, Dr, Nr, qr, Br, Hr, Ur, zr, jr = {}, Wr = [], Gr = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i, Vr = Array.isArray;
function Jr(e2, t2) {
  for (var i in t2) e2[i] = t2[i];
  return e2;
}
function Yr(e2) {
  var t2 = e2.parentNode;
  t2 && t2.removeChild(e2);
}
function Kr(e2, t2, i, n2, r2) {
  var s2 = { type: e2, props: t2, key: i, ref: n2, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: null == r2 ? ++Nr : r2, __i: -1, __u: 0 };
  return null == r2 && null != Dr.vnode && Dr.vnode(s2), s2;
}
function Xr(e2) {
  return e2.children;
}
function Qr(e2, t2) {
  this.props = e2, this.context = t2;
}
function Zr(e2, t2) {
  if (null == t2) return e2.__ ? Zr(e2.__, e2.__i + 1) : null;
  for (var i; t2 < e2.__k.length; t2++) if (null != (i = e2.__k[t2]) && null != i.__e) return i.__e;
  return "function" == typeof e2.type ? Zr(e2) : null;
}
function es(e2) {
  var t2, i;
  if (null != (e2 = e2.__) && null != e2.__c) {
    for (e2.__e = e2.__c.base = null, t2 = 0; t2 < e2.__k.length; t2++) if (null != (i = e2.__k[t2]) && null != i.__e) {
      e2.__e = e2.__c.base = i.__e;
      break;
    }
    return es(e2);
  }
}
function ts$1(e2) {
  (!e2.__d && (e2.__d = true) && qr.push(e2) && !is$1.__r++ || Br !== Dr.debounceRendering) && ((Br = Dr.debounceRendering) || Hr)(is$1);
}
function is$1() {
  var e2, t2, i, n2, r2, s2, o2, a2, l2;
  for (qr.sort(Ur); e2 = qr.shift(); ) e2.__d && (t2 = qr.length, n2 = void 0, s2 = (r2 = (i = e2).__v).__e, a2 = [], l2 = [], (o2 = i.__P) && ((n2 = Jr({}, r2)).__v = r2.__v + 1, Dr.vnode && Dr.vnode(n2), ds(o2, n2, r2, i.__n, void 0 !== o2.ownerSVGElement, 32 & r2.__u ? [s2] : null, a2, null == s2 ? Zr(r2) : s2, !!(32 & r2.__u), l2), n2.__.__k[n2.__i] = n2, hs(a2, n2, l2), n2.__e != s2 && es(n2)), qr.length > t2 && qr.sort(Ur));
  is$1.__r = 0;
}
function ns(e2, t2, i, n2, r2, s2, o2, a2, l2, u2, c6) {
  var d2, h2, _2, p2, v2, g2 = n2 && n2.__k || Wr, f2 = t2.length;
  for (i.__d = l2, rs(i, t2, g2), l2 = i.__d, d2 = 0; d2 < f2; d2++) null != (_2 = i.__k[d2]) && "boolean" != typeof _2 && "function" != typeof _2 && (h2 = -1 === _2.__i ? jr : g2[_2.__i] || jr, _2.__i = d2, ds(e2, _2, h2, r2, s2, o2, a2, l2, u2, c6), p2 = _2.__e, _2.ref && h2.ref != _2.ref && (h2.ref && ps(h2.ref, null, _2), c6.push(_2.ref, _2.__c || p2, _2)), null == v2 && null != p2 && (v2 = p2), 65536 & _2.__u || h2.__k === _2.__k ? l2 = ss(_2, l2, e2) : "function" == typeof _2.type && void 0 !== _2.__d ? l2 = _2.__d : p2 && (l2 = p2.nextSibling), _2.__d = void 0, _2.__u &= -196609);
  i.__d = l2, i.__e = v2;
}
function rs(e2, t2, i) {
  var n2, r2, s2, o2, a2, l2 = t2.length, u2 = i.length, c6 = u2, d2 = 0;
  for (e2.__k = [], n2 = 0; n2 < l2; n2++) null != (r2 = e2.__k[n2] = null == (r2 = t2[n2]) || "boolean" == typeof r2 || "function" == typeof r2 ? null : "string" == typeof r2 || "number" == typeof r2 || "bigint" == typeof r2 || r2.constructor == String ? Kr(null, r2, null, null, r2) : Vr(r2) ? Kr(Xr, { children: r2 }, null, null, null) : void 0 === r2.constructor && r2.__b > 0 ? Kr(r2.type, r2.props, r2.key, r2.ref ? r2.ref : null, r2.__v) : r2) ? (r2.__ = e2, r2.__b = e2.__b + 1, a2 = os(r2, i, o2 = n2 + d2, c6), r2.__i = a2, s2 = null, -1 !== a2 && (c6--, (s2 = i[a2]) && (s2.__u |= 131072)), null == s2 || null === s2.__v ? (-1 == a2 && d2--, "function" != typeof r2.type && (r2.__u |= 65536)) : a2 !== o2 && (a2 === o2 + 1 ? d2++ : a2 > o2 ? c6 > l2 - o2 ? d2 += a2 - o2 : d2-- : d2 = a2 < o2 && a2 == o2 - 1 ? a2 - o2 : 0, a2 !== n2 + d2 && (r2.__u |= 65536))) : (s2 = i[n2]) && null == s2.key && s2.__e && (s2.__e == e2.__d && (e2.__d = Zr(s2)), vs(s2, s2, false), i[n2] = null, c6--);
  if (c6) for (n2 = 0; n2 < u2; n2++) null != (s2 = i[n2]) && 0 == (131072 & s2.__u) && (s2.__e == e2.__d && (e2.__d = Zr(s2)), vs(s2, s2));
}
function ss(e2, t2, i) {
  var n2, r2;
  if ("function" == typeof e2.type) {
    for (n2 = e2.__k, r2 = 0; n2 && r2 < n2.length; r2++) n2[r2] && (n2[r2].__ = e2, t2 = ss(n2[r2], t2, i));
    return t2;
  }
  return e2.__e != t2 && (i.insertBefore(e2.__e, t2 || null), t2 = e2.__e), t2 && t2.nextSibling;
}
function os(e2, t2, i, n2) {
  var r2 = e2.key, s2 = e2.type, o2 = i - 1, a2 = i + 1, l2 = t2[i];
  if (null === l2 || l2 && r2 == l2.key && s2 === l2.type) return i;
  if (n2 > (null != l2 && 0 == (131072 & l2.__u) ? 1 : 0)) for (; o2 >= 0 || a2 < t2.length; ) {
    if (o2 >= 0) {
      if ((l2 = t2[o2]) && 0 == (131072 & l2.__u) && r2 == l2.key && s2 === l2.type) return o2;
      o2--;
    }
    if (a2 < t2.length) {
      if ((l2 = t2[a2]) && 0 == (131072 & l2.__u) && r2 == l2.key && s2 === l2.type) return a2;
      a2++;
    }
  }
  return -1;
}
function as(e2, t2, i) {
  "-" === t2[0] ? e2.setProperty(t2, null == i ? "" : i) : e2[t2] = null == i ? "" : "number" != typeof i || Gr.test(t2) ? i : i + "px";
}
function ls(e2, t2, i, n2, r2) {
  var s2;
  e: if ("style" === t2) if ("string" == typeof i) e2.style.cssText = i;
  else {
    if ("string" == typeof n2 && (e2.style.cssText = n2 = ""), n2) for (t2 in n2) i && t2 in i || as(e2.style, t2, "");
    if (i) for (t2 in i) n2 && i[t2] === n2[t2] || as(e2.style, t2, i[t2]);
  }
  else if ("o" === t2[0] && "n" === t2[1]) s2 = t2 !== (t2 = t2.replace(/(PointerCapture)$|Capture$/, "$1")), t2 = t2.toLowerCase() in e2 ? t2.toLowerCase().slice(2) : t2.slice(2), e2.l || (e2.l = {}), e2.l[t2 + s2] = i, i ? n2 ? i.u = n2.u : (i.u = Date.now(), e2.addEventListener(t2, s2 ? cs : us, s2)) : e2.removeEventListener(t2, s2 ? cs : us, s2);
  else {
    if (r2) t2 = t2.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
    else if ("width" !== t2 && "height" !== t2 && "href" !== t2 && "list" !== t2 && "form" !== t2 && "tabIndex" !== t2 && "download" !== t2 && "rowSpan" !== t2 && "colSpan" !== t2 && "role" !== t2 && t2 in e2) try {
      e2[t2] = null == i ? "" : i;
      break e;
    } catch (e3) {
    }
    "function" == typeof i || (null == i || false === i && "-" !== t2[4] ? e2.removeAttribute(t2) : e2.setAttribute(t2, i));
  }
}
function us(e2) {
  var t2 = this.l[e2.type + false];
  if (e2.t) {
    if (e2.t <= t2.u) return;
  } else e2.t = Date.now();
  return t2(Dr.event ? Dr.event(e2) : e2);
}
function cs(e2) {
  return this.l[e2.type + true](Dr.event ? Dr.event(e2) : e2);
}
function ds(e2, t2, i, n2, r2, s2, o2, a2, l2, u2) {
  var c6, d2, h2, _2, p2, v2, g2, f2, m2, b2, y2, w2, S2, E2, k2, x2 = t2.type;
  if (void 0 !== t2.constructor) return null;
  128 & i.__u && (l2 = !!(32 & i.__u), s2 = [a2 = t2.__e = i.__e]), (c6 = Dr.__b) && c6(t2);
  e: if ("function" == typeof x2) try {
    if (f2 = t2.props, m2 = (c6 = x2.contextType) && n2[c6.__c], b2 = c6 ? m2 ? m2.props.value : c6.__ : n2, i.__c ? g2 = (d2 = t2.__c = i.__c).__ = d2.__E : ("prototype" in x2 && x2.prototype.render ? t2.__c = d2 = new x2(f2, b2) : (t2.__c = d2 = new Qr(f2, b2), d2.constructor = x2, d2.render = gs), m2 && m2.sub(d2), d2.props = f2, d2.state || (d2.state = {}), d2.context = b2, d2.__n = n2, h2 = d2.__d = true, d2.__h = [], d2._sb = []), null == d2.__s && (d2.__s = d2.state), null != x2.getDerivedStateFromProps && (d2.__s == d2.state && (d2.__s = Jr({}, d2.__s)), Jr(d2.__s, x2.getDerivedStateFromProps(f2, d2.__s))), _2 = d2.props, p2 = d2.state, d2.__v = t2, h2) null == x2.getDerivedStateFromProps && null != d2.componentWillMount && d2.componentWillMount(), null != d2.componentDidMount && d2.__h.push(d2.componentDidMount);
    else {
      if (null == x2.getDerivedStateFromProps && f2 !== _2 && null != d2.componentWillReceiveProps && d2.componentWillReceiveProps(f2, b2), !d2.__e && (null != d2.shouldComponentUpdate && false === d2.shouldComponentUpdate(f2, d2.__s, b2) || t2.__v === i.__v)) {
        for (t2.__v !== i.__v && (d2.props = f2, d2.state = d2.__s, d2.__d = false), t2.__e = i.__e, t2.__k = i.__k, t2.__k.forEach(function(e3) {
          e3 && (e3.__ = t2);
        }), y2 = 0; y2 < d2._sb.length; y2++) d2.__h.push(d2._sb[y2]);
        d2._sb = [], d2.__h.length && o2.push(d2);
        break e;
      }
      null != d2.componentWillUpdate && d2.componentWillUpdate(f2, d2.__s, b2), null != d2.componentDidUpdate && d2.__h.push(function() {
        d2.componentDidUpdate(_2, p2, v2);
      });
    }
    if (d2.context = b2, d2.props = f2, d2.__P = e2, d2.__e = false, w2 = Dr.__r, S2 = 0, "prototype" in x2 && x2.prototype.render) {
      for (d2.state = d2.__s, d2.__d = false, w2 && w2(t2), c6 = d2.render(d2.props, d2.state, d2.context), E2 = 0; E2 < d2._sb.length; E2++) d2.__h.push(d2._sb[E2]);
      d2._sb = [];
    } else do {
      d2.__d = false, w2 && w2(t2), c6 = d2.render(d2.props, d2.state, d2.context), d2.state = d2.__s;
    } while (d2.__d && ++S2 < 25);
    d2.state = d2.__s, null != d2.getChildContext && (n2 = Jr(Jr({}, n2), d2.getChildContext())), h2 || null == d2.getSnapshotBeforeUpdate || (v2 = d2.getSnapshotBeforeUpdate(_2, p2)), ns(e2, Vr(k2 = null != c6 && c6.type === Xr && null == c6.key ? c6.props.children : c6) ? k2 : [k2], t2, i, n2, r2, s2, o2, a2, l2, u2), d2.base = t2.__e, t2.__u &= -161, d2.__h.length && o2.push(d2), g2 && (d2.__E = d2.__ = null);
  } catch (e3) {
    t2.__v = null, l2 || null != s2 ? (t2.__e = a2, t2.__u |= l2 ? 160 : 32, s2[s2.indexOf(a2)] = null) : (t2.__e = i.__e, t2.__k = i.__k), Dr.__e(e3, t2, i);
  }
  else null == s2 && t2.__v === i.__v ? (t2.__k = i.__k, t2.__e = i.__e) : t2.__e = _s(i.__e, t2, i, n2, r2, s2, o2, l2, u2);
  (c6 = Dr.diffed) && c6(t2);
}
function hs(e2, t2, i) {
  t2.__d = void 0;
  for (var n2 = 0; n2 < i.length; n2++) ps(i[n2], i[++n2], i[++n2]);
  Dr.__c && Dr.__c(t2, e2), e2.some(function(t3) {
    try {
      e2 = t3.__h, t3.__h = [], e2.some(function(e3) {
        e3.call(t3);
      });
    } catch (e3) {
      Dr.__e(e3, t3.__v);
    }
  });
}
function _s(e2, t2, i, n2, r2, s2, o2, a2, l2) {
  var u2, c6, d2, h2, _2, p2, v2, g2 = i.props, f2 = t2.props, m2 = t2.type;
  if ("svg" === m2 && (r2 = true), null != s2) {
    for (u2 = 0; u2 < s2.length; u2++) if ((_2 = s2[u2]) && "setAttribute" in _2 == !!m2 && (m2 ? _2.localName === m2 : 3 === _2.nodeType)) {
      e2 = _2, s2[u2] = null;
      break;
    }
  }
  if (null == e2) {
    if (null === m2) return document.createTextNode(f2);
    e2 = r2 ? document.createElementNS("http://www.w3.org/2000/svg", m2) : document.createElement(m2, f2.is && f2), s2 = null, a2 = false;
  }
  if (null === m2) g2 === f2 || a2 && e2.data === f2 || (e2.data = f2);
  else {
    if (s2 = s2 && Ar.call(e2.childNodes), g2 = i.props || jr, !a2 && null != s2) for (g2 = {}, u2 = 0; u2 < e2.attributes.length; u2++) g2[(_2 = e2.attributes[u2]).name] = _2.value;
    for (u2 in g2) _2 = g2[u2], "children" == u2 || ("dangerouslySetInnerHTML" == u2 ? d2 = _2 : "key" === u2 || u2 in f2 || ls(e2, u2, null, _2, r2));
    for (u2 in f2) _2 = f2[u2], "children" == u2 ? h2 = _2 : "dangerouslySetInnerHTML" == u2 ? c6 = _2 : "value" == u2 ? p2 = _2 : "checked" == u2 ? v2 = _2 : "key" === u2 || a2 && "function" != typeof _2 || g2[u2] === _2 || ls(e2, u2, _2, g2[u2], r2);
    if (c6) a2 || d2 && (c6.__html === d2.__html || c6.__html === e2.innerHTML) || (e2.innerHTML = c6.__html), t2.__k = [];
    else if (d2 && (e2.innerHTML = ""), ns(e2, Vr(h2) ? h2 : [h2], t2, i, n2, r2 && "foreignObject" !== m2, s2, o2, s2 ? s2[0] : i.__k && Zr(i, 0), a2, l2), null != s2) for (u2 = s2.length; u2--; ) null != s2[u2] && Yr(s2[u2]);
    a2 || (u2 = "value", void 0 !== p2 && (p2 !== e2[u2] || "progress" === m2 && !p2 || "option" === m2 && p2 !== g2[u2]) && ls(e2, u2, p2, g2[u2], false), u2 = "checked", void 0 !== v2 && v2 !== e2[u2] && ls(e2, u2, v2, g2[u2], false));
  }
  return e2;
}
function ps(e2, t2, i) {
  try {
    "function" == typeof e2 ? e2(t2) : e2.current = t2;
  } catch (e3) {
    Dr.__e(e3, i);
  }
}
function vs(e2, t2, i) {
  var n2, r2;
  if (Dr.unmount && Dr.unmount(e2), (n2 = e2.ref) && (n2.current && n2.current !== e2.__e || ps(n2, null, t2)), null != (n2 = e2.__c)) {
    if (n2.componentWillUnmount) try {
      n2.componentWillUnmount();
    } catch (e3) {
      Dr.__e(e3, t2);
    }
    n2.base = n2.__P = null, e2.__c = void 0;
  }
  if (n2 = e2.__k) for (r2 = 0; r2 < n2.length; r2++) n2[r2] && vs(n2[r2], t2, i || "function" != typeof e2.type);
  i || null == e2.__e || Yr(e2.__e), e2.__ = e2.__e = e2.__d = void 0;
}
function gs(e2, t2, i) {
  return this.constructor(e2, i);
}
Ar = Wr.slice, Dr = { __e: function(e2, t2, i, n2) {
  for (var r2, s2, o2; t2 = t2.__; ) if ((r2 = t2.__c) && !r2.__) try {
    if ((s2 = r2.constructor) && null != s2.getDerivedStateFromError && (r2.setState(s2.getDerivedStateFromError(e2)), o2 = r2.__d), null != r2.componentDidCatch && (r2.componentDidCatch(e2, n2 || {}), o2 = r2.__d), o2) return r2.__E = r2;
  } catch (t3) {
    e2 = t3;
  }
  throw e2;
} }, Nr = 0, Qr.prototype.setState = function(e2, t2) {
  var i;
  i = null != this.__s && this.__s !== this.state ? this.__s : this.__s = Jr({}, this.state), "function" == typeof e2 && (e2 = e2(Jr({}, i), this.props)), e2 && Jr(i, e2), null != e2 && this.__v && (t2 && this._sb.push(t2), ts$1(this));
}, Qr.prototype.forceUpdate = function(e2) {
  this.__v && (this.__e = true, e2 && this.__h.push(e2), ts$1(this));
}, Qr.prototype.render = Xr, qr = [], Hr = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, Ur = function(e2, t2) {
  return e2.__v.__b - t2.__v.__b;
}, is$1.__r = 0, zr = 0;
!function(e2, t2) {
  var i = { __c: t2 = "__cC" + zr++, __: e2, Consumer: function(e3, t3) {
    return e3.children(t3);
  }, Provider: function(e3) {
    var i2, n2;
    return this.getChildContext || (i2 = [], (n2 = {})[t2] = this, this.getChildContext = function() {
      return n2;
    }, this.shouldComponentUpdate = function(e4) {
      this.props.value !== e4.value && i2.some(function(e5) {
        e5.__e = true, ts$1(e5);
      });
    }, this.sub = function(e4) {
      i2.push(e4);
      var t3 = e4.componentWillUnmount;
      e4.componentWillUnmount = function() {
        i2.splice(i2.indexOf(e4), 1), t3 && t3.call(e4);
      };
    }), e3.children;
  } };
  i.Provider.__ = i.Consumer.contextType = i;
}({ isPreviewMode: false, previewPageIndex: 0, handleCloseSurveyPopup: () => {
}, isPopup: true });
var fs = B$2("[Surveys]"), ms = { icontains: (e2) => !!t$2 && t$2.location.href.toLowerCase().indexOf(e2.toLowerCase()) > -1, not_icontains: (e2) => !!t$2 && -1 === t$2.location.href.toLowerCase().indexOf(e2.toLowerCase()), regex: (e2) => !!t$2 && gt(t$2.location.href, e2), not_regex: (e2) => !!t$2 && !gt(t$2.location.href, e2), exact: (e2) => (null == t$2 ? void 0 : t$2.location.href) === e2, is_not: (e2) => (null == t$2 ? void 0 : t$2.location.href) !== e2 };
class bs {
  constructor(e2) {
    this.instance = e2, this._surveyEventReceiver = null;
  }
  onRemoteConfig(e2) {
    this._decideServerResponse = !!e2.surveys, this.loadIfEnabled();
  }
  reset() {
    localStorage.removeItem("lastSeenSurveyDate");
    var e2 = (() => {
      for (var e3 = [], t2 = 0; t2 < localStorage.length; t2++) {
        var i = localStorage.key(t2);
        null != i && i.startsWith("seenSurvey_") && e3.push(i);
      }
      return e3;
    })();
    e2.forEach((e3) => localStorage.removeItem(e3));
  }
  loadIfEnabled() {
    var e2, t2, i, n2 = null == _$1 || null === (e2 = _$1.__PosthogExtensions__) || void 0 === e2 ? void 0 : e2.generateSurveys;
    this.instance.config.disable_surveys || !this._decideServerResponse || n2 || (null == this._surveyEventReceiver && (this._surveyEventReceiver = new Mr(this.instance)), null === (t2 = _$1.__PosthogExtensions__) || void 0 === t2 || null === (i = t2.loadExternalDependency) || void 0 === i || i.call(t2, this.instance, "surveys", (e3) => {
      var t3, i2;
      if (e3) return fs.error("Could not load surveys script", e3);
      this._surveyManager = null === (t3 = _$1.__PosthogExtensions__) || void 0 === t3 || null === (i2 = t3.generateSurveys) || void 0 === i2 ? void 0 : i2.call(t3, this.instance);
    }));
  }
  getSurveys(e2) {
    var t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    if (this.instance.config.disable_surveys) return e2([]);
    null == this._surveyEventReceiver && (this._surveyEventReceiver = new Mr(this.instance));
    var i = this.instance.get_property(Pe);
    if (i && !t2) return e2(i);
    this.instance._send_request({ url: this.instance.requestRouter.endpointFor("api", "/api/surveys/?token=".concat(this.instance.config.token)), method: "GET", callback: (t3) => {
      var i2;
      if (200 !== t3.statusCode || !t3.json) return e2([]);
      var n2, r2 = t3.json.surveys || [], s2 = r2.filter((e3) => {
        var t4, i3, n3, r3, s3, o2, a2, l2, u2, c6, d2, h2;
        return (null === (t4 = e3.conditions) || void 0 === t4 ? void 0 : t4.events) && (null === (i3 = e3.conditions) || void 0 === i3 || null === (n3 = i3.events) || void 0 === n3 ? void 0 : n3.values) && (null === (r3 = e3.conditions) || void 0 === r3 || null === (s3 = r3.events) || void 0 === s3 || null === (o2 = s3.values) || void 0 === o2 ? void 0 : o2.length) > 0 || (null === (a2 = e3.conditions) || void 0 === a2 ? void 0 : a2.actions) && (null === (l2 = e3.conditions) || void 0 === l2 || null === (u2 = l2.actions) || void 0 === u2 ? void 0 : u2.values) && (null === (c6 = e3.conditions) || void 0 === c6 || null === (d2 = c6.actions) || void 0 === d2 || null === (h2 = d2.values) || void 0 === h2 ? void 0 : h2.length) > 0;
      });
      s2.length > 0 && (null === (n2 = this._surveyEventReceiver) || void 0 === n2 || n2.register(s2));
      return null === (i2 = this.instance.persistence) || void 0 === i2 || i2.register({ [Pe]: r2 }), e2(r2);
    } });
  }
  getActiveMatchingSurveys(e2) {
    var t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    this.getSurveys((t3) => {
      var i, n2 = t3.filter((e3) => !(!e3.start_date || e3.end_date)).filter((e3) => {
        var t4, i2, n3, r3;
        if (!e3.conditions) return true;
        var s3 = null === (t4 = e3.conditions) || void 0 === t4 || !t4.url || ms[null !== (i2 = null === (n3 = e3.conditions) || void 0 === n3 ? void 0 : n3.urlMatchType) && void 0 !== i2 ? i2 : "icontains"](e3.conditions.url), o2 = null === (r3 = e3.conditions) || void 0 === r3 || !r3.selector || (null == a$1 ? void 0 : a$1.querySelector(e3.conditions.selector));
        return s3 && o2;
      }), r2 = null === (i = this._surveyEventReceiver) || void 0 === i ? void 0 : i.getSurveys(), s2 = n2.filter((e3) => {
        var t4, i2, n3, s3, o2, a2, l2, u2, c6, d2, h2;
        if (!(e3.linked_flag_key || e3.targeting_flag_key || e3.internal_targeting_flag_key || null !== (t4 = e3.feature_flag_keys) && void 0 !== t4 && t4.length)) return true;
        var _2 = !e3.linked_flag_key || this.instance.featureFlags.isFeatureEnabled(e3.linked_flag_key), p2 = !e3.targeting_flag_key || this.instance.featureFlags.isFeatureEnabled(e3.targeting_flag_key), v2 = (null === (i2 = e3.conditions) || void 0 === i2 ? void 0 : i2.events) && (null === (n3 = e3.conditions) || void 0 === n3 || null === (s3 = n3.events) || void 0 === s3 ? void 0 : s3.values) && (null === (o2 = e3.conditions) || void 0 === o2 || null === (a2 = o2.events) || void 0 === a2 ? void 0 : a2.values.length) > 0, g2 = (null === (l2 = e3.conditions) || void 0 === l2 ? void 0 : l2.actions) && (null === (u2 = e3.conditions) || void 0 === u2 || null === (c6 = u2.actions) || void 0 === c6 ? void 0 : c6.values) && (null === (d2 = e3.conditions) || void 0 === d2 || null === (h2 = d2.actions) || void 0 === h2 ? void 0 : h2.values.length) > 0, f2 = !v2 && !g2 || (null == r2 ? void 0 : r2.includes(e3.id)), m2 = this._canActivateRepeatedly(e3), b2 = !(e3.internal_targeting_flag_key && !m2) || this.instance.featureFlags.isFeatureEnabled(e3.internal_targeting_flag_key), y2 = this.checkFlags(e3);
        return _2 && p2 && b2 && f2 && y2;
      });
      return e2(s2);
    }, t2);
  }
  checkFlags(e2) {
    var t2;
    return null === (t2 = e2.feature_flag_keys) || void 0 === t2 || !t2.length || e2.feature_flag_keys.every((e3) => {
      var { key: t3, value: i } = e3;
      return !t3 || !i || this.instance.featureFlags.isFeatureEnabled(i);
    });
  }
  getNextSurveyStep(e2, t2, i) {
    var n2, r2 = e2.questions[t2], s2 = t2 + 1;
    if (null === (n2 = r2.branching) || void 0 === n2 || !n2.type) return t2 === e2.questions.length - 1 ? Rr.End : s2;
    if (r2.branching.type === Rr.End) return Rr.End;
    if (r2.branching.type === Rr.SpecificQuestion) {
      if (Number.isInteger(r2.branching.index)) return r2.branching.index;
    } else if (r2.branching.type === Rr.ResponseBased) {
      if (r2.type === Pr.SingleChoice) {
        var o2, a2, l2 = r2.choices.indexOf("".concat(i));
        if (null !== (o2 = r2.branching) && void 0 !== o2 && null !== (a2 = o2.responseValues) && void 0 !== a2 && a2.hasOwnProperty(l2)) {
          var u2 = r2.branching.responseValues[l2];
          return Number.isInteger(u2) ? u2 : u2 === Rr.End ? Rr.End : s2;
        }
      } else if (r2.type === Pr.Rating) {
        var c6, d2;
        if ("number" != typeof i || !Number.isInteger(i)) throw new Error("The response type must be an integer");
        var h2 = function(e3, t3) {
          if (3 === t3) {
            if (e3 < 1 || e3 > 3) throw new Error("The response must be in range 1-3");
            return 1 === e3 ? "negative" : 2 === e3 ? "neutral" : "positive";
          }
          if (5 === t3) {
            if (e3 < 1 || e3 > 5) throw new Error("The response must be in range 1-5");
            return e3 <= 2 ? "negative" : 3 === e3 ? "neutral" : "positive";
          }
          if (7 === t3) {
            if (e3 < 1 || e3 > 7) throw new Error("The response must be in range 1-7");
            return e3 <= 3 ? "negative" : 4 === e3 ? "neutral" : "positive";
          }
          if (10 === t3) {
            if (e3 < 0 || e3 > 10) throw new Error("The response must be in range 0-10");
            return e3 <= 6 ? "detractors" : e3 <= 8 ? "passives" : "promoters";
          }
          throw new Error("The scale must be one of: 3, 5, 7, 10");
        }(i, r2.scale);
        if (null !== (c6 = r2.branching) && void 0 !== c6 && null !== (d2 = c6.responseValues) && void 0 !== d2 && d2.hasOwnProperty(h2)) {
          var _2 = r2.branching.responseValues[h2];
          return Number.isInteger(_2) ? _2 : _2 === Rr.End ? Rr.End : s2;
        }
      }
      return s2;
    }
    return fs.warn("Falling back to next question index due to unexpected branching type"), s2;
  }
  _canActivateRepeatedly(e2) {
    var t2;
    return O$1(null === (t2 = _$1.__PosthogExtensions__) || void 0 === t2 ? void 0 : t2.canActivateRepeatedly) ? (fs.warn("init was not called"), false) : _$1.__PosthogExtensions__.canActivateRepeatedly(e2);
  }
  canRenderSurvey(e2) {
    O$1(this._surveyManager) ? fs.warn("init was not called") : this.getSurveys((t2) => {
      var i = t2.filter((t3) => t3.id === e2)[0];
      this._surveyManager.canRenderSurvey(i);
    });
  }
  renderSurvey(e2, t2) {
    O$1(this._surveyManager) ? fs.warn("init was not called") : this.getSurveys((i) => {
      var n2 = i.filter((t3) => t3.id === e2)[0];
      this._surveyManager.renderSurvey(n2, null == a$1 ? void 0 : a$1.querySelector(t2));
    });
  }
}
var ys = B$2("[RateLimiter]");
let ws$1 = class ws {
  constructor(e2) {
    var t2, i;
    W$1(this, "serverLimits", {}), W$1(this, "lastEventRateLimited", false), W$1(this, "checkForLimiting", (e3) => {
      var t3 = e3.text;
      if (t3 && t3.length) try {
        (JSON.parse(t3).quota_limited || []).forEach((e4) => {
          ys.info("".concat(e4 || "events", " is quota limited.")), this.serverLimits[e4] = (/* @__PURE__ */ new Date()).getTime() + 6e4;
        });
      } catch (e4) {
        return void ys.warn('could not rate limit - continuing. Error: "'.concat(null == e4 ? void 0 : e4.message, '"'), { text: t3 });
      }
    }), this.instance = e2, this.captureEventsPerSecond = (null === (t2 = e2.config.rate_limiting) || void 0 === t2 ? void 0 : t2.events_per_second) || 10, this.captureEventsBurstLimit = Math.max((null === (i = e2.config.rate_limiting) || void 0 === i ? void 0 : i.events_burst_limit) || 10 * this.captureEventsPerSecond, this.captureEventsPerSecond), this.lastEventRateLimited = this.clientRateLimitContext(true).isRateLimited;
  }
  clientRateLimitContext() {
    var e2, t2, i, n2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], r2 = (/* @__PURE__ */ new Date()).getTime(), s2 = null !== (e2 = null === (t2 = this.instance.persistence) || void 0 === t2 ? void 0 : t2.get_property(Oe)) && void 0 !== e2 ? e2 : { tokens: this.captureEventsBurstLimit, last: r2 };
    s2.tokens += (r2 - s2.last) / 1e3 * this.captureEventsPerSecond, s2.last = r2, s2.tokens > this.captureEventsBurstLimit && (s2.tokens = this.captureEventsBurstLimit);
    var o2 = s2.tokens < 1;
    return o2 || n2 || (s2.tokens = Math.max(0, s2.tokens - 1)), !o2 || this.lastEventRateLimited || n2 || this.instance.capture("$$client_ingestion_warning", { $$client_ingestion_warning_message: "posthog-js client rate limited. Config is set to ".concat(this.captureEventsPerSecond, " events per second and ").concat(this.captureEventsBurstLimit, " events burst limit.") }, { skip_client_rate_limiting: true }), this.lastEventRateLimited = o2, null === (i = this.instance.persistence) || void 0 === i || i.set_property(Oe, s2), { isRateLimited: o2, remainingTokens: s2.tokens };
  }
  isServerRateLimited(e2) {
    var t2 = this.serverLimits[e2 || "events"] || false;
    return false !== t2 && (/* @__PURE__ */ new Date()).getTime() < t2;
  }
};
var Ss = () => j$2({ initialPathName: (null == l$2 ? void 0 : l$2.pathname) || "", referringDomain: fi.referringDomain() }, fi.campaignParams());
class Es {
  constructor(e2, t2, i) {
    W$1(this, "_onSessionIdCallback", (e3) => {
      var t3 = this._getStoredProps();
      if (!t3 || t3.sessionId !== e3) {
        var i2 = { sessionId: e3, props: this._sessionSourceParamGenerator() };
        this._persistence.register({ [$e]: i2 });
      }
    }), this._sessionIdManager = e2, this._persistence = t2, this._sessionSourceParamGenerator = i || Ss, this._sessionIdManager.onSessionId(this._onSessionIdCallback);
  }
  _getStoredProps() {
    return this._persistence.props[$e];
  }
  getSessionProps() {
    var e2, t2 = null === (e2 = this._getStoredProps()) || void 0 === e2 ? void 0 : e2.props;
    return t2 ? { $client_session_initial_referring_host: t2.referringDomain, $client_session_initial_pathname: t2.initialPathName, $client_session_initial_utm_source: t2.utm_source, $client_session_initial_utm_campaign: t2.utm_campaign, $client_session_initial_utm_medium: t2.utm_medium, $client_session_initial_utm_content: t2.utm_content, $client_session_initial_utm_term: t2.utm_term } : {};
  }
}
var ks = ["ahrefsbot", "ahrefssiteaudit", "applebot", "baiduspider", "bingbot", "bingpreview", "bot.htm", "bot.php", "crawler", "deepscan", "duckduckbot", "facebookexternal", "facebookcatalog", "gptbot", "http://yandex.com/bots", "hubspot", "ia_archiver", "linkedinbot", "mj12bot", "msnbot", "nessus", "petalbot", "pinterest", "prerender", "rogerbot", "screaming frog", "semrushbot", "sitebulb", "slurp", "turnitin", "twitterbot", "vercelbot", "yahoo! slurp", "yandexbot", "headlesschrome", "cypress", "Google-HotelAdsVerifier", "adsbot-google", "apis-google", "duplexweb-google", "feedfetcher-google", "google favicon", "google web preview", "google-read-aloud", "googlebot", "googleweblight", "mediapartners-google", "storebot-google", "Bytespider;"], xs = function(e2, t2) {
  if (!e2) return false;
  var i = e2.toLowerCase();
  return ks.concat(t2 || []).some((e3) => {
    var t3 = e3.toLowerCase();
    return -1 !== i.indexOf(t3);
  });
}, Is = function(e2, t2) {
  if (!e2) return false;
  var i = e2.userAgent;
  if (i && xs(i, t2)) return true;
  try {
    var n2 = null == e2 ? void 0 : e2.userAgentData;
    if (null != n2 && n2.brands && n2.brands.some((e3) => xs(null == e3 ? void 0 : e3.brand, t2))) return true;
  } catch (e3) {
  }
  return !!e2.webdriver;
};
class Cs {
  constructor() {
    this.clicks = [];
  }
  isRageClick(e2, t2, i) {
    var n2 = this.clicks[this.clicks.length - 1];
    if (n2 && Math.abs(e2 - n2.x) + Math.abs(t2 - n2.y) < 30 && i - n2.timestamp < 1e3) {
      if (this.clicks.push({ x: e2, y: t2, timestamp: i }), 3 === this.clicks.length) return true;
    } else this.clicks = [{ x: e2, y: t2, timestamp: i }];
    return false;
  }
}
var Ps = B$2("[Dead Clicks]"), Rs = () => true, Fs = (e2) => {
  var t2, i = !(null === (t2 = e2.instance.persistence) || void 0 === t2 || !t2.get_property(de)), n2 = e2.instance.config.capture_dead_clicks;
  return M$1(n2) ? n2 : i;
};
class Ts {
  get lazyLoadedDeadClicksAutocapture() {
    return this._lazyLoadedDeadClicksAutocapture;
  }
  constructor(e2, t2, i) {
    this.instance = e2, this.isEnabled = t2, this.onCapture = i, this.startIfEnabled();
  }
  onRemoteConfig(e2) {
    this.instance.persistence && this.instance.persistence.register({ [de]: null == e2 ? void 0 : e2.captureDeadClicks }), this.startIfEnabled();
  }
  startIfEnabled() {
    this.isEnabled(this) && this.loadScript(() => {
      this.start();
    });
  }
  loadScript(e2) {
    var t2, i, n2;
    null !== (t2 = _$1.__PosthogExtensions__) && void 0 !== t2 && t2.initDeadClicksAutocapture && e2(), null === (i = _$1.__PosthogExtensions__) || void 0 === i || null === (n2 = i.loadExternalDependency) || void 0 === n2 || n2.call(i, this.instance, "dead-clicks-autocapture", (t3) => {
      t3 ? Ps.error("failed to load script", t3) : e2();
    });
  }
  start() {
    var e2;
    if (a$1) {
      if (!this._lazyLoadedDeadClicksAutocapture && null !== (e2 = _$1.__PosthogExtensions__) && void 0 !== e2 && e2.initDeadClicksAutocapture) {
        var t2 = C$2(this.instance.config.capture_dead_clicks) ? this.instance.config.capture_dead_clicks : {};
        t2.__onCapture = this.onCapture, this._lazyLoadedDeadClicksAutocapture = _$1.__PosthogExtensions__.initDeadClicksAutocapture(this.instance, t2), this._lazyLoadedDeadClicksAutocapture.start(a$1), Ps.info("starting...");
      }
    } else Ps.error("`document` not found. Cannot start.");
  }
  stop() {
    this._lazyLoadedDeadClicksAutocapture && (this._lazyLoadedDeadClicksAutocapture.stop(), this._lazyLoadedDeadClicksAutocapture = void 0, Ps.info("stopping..."));
  }
}
var $s = B$2("[Heatmaps]");
function Os(e2) {
  return C$2(e2) && "clientX" in e2 && "clientY" in e2 && L$1(e2.clientX) && L$1(e2.clientY);
}
class Ls {
  constructor(e2) {
    var i;
    W$1(this, "rageclicks", new Cs()), W$1(this, "_enabledServerSide", false), W$1(this, "_initialized", false), W$1(this, "_flushInterval", null), this.instance = e2, this._enabledServerSide = !(null === (i = this.instance.persistence) || void 0 === i || !i.props[le]), null == t$2 || t$2.addEventListener("beforeunload", () => {
      this.flush();
    });
  }
  get flushIntervalMilliseconds() {
    var e2 = 5e3;
    return C$2(this.instance.config.capture_heatmaps) && this.instance.config.capture_heatmaps.flush_interval_milliseconds && (e2 = this.instance.config.capture_heatmaps.flush_interval_milliseconds), e2;
  }
  get isEnabled() {
    return R$1(this.instance.config.capture_heatmaps) ? R$1(this.instance.config.enable_heatmaps) ? this._enabledServerSide : this.instance.config.enable_heatmaps : false !== this.instance.config.capture_heatmaps;
  }
  startIfEnabled() {
    if (this.isEnabled) {
      if (this._initialized) return;
      $s.info("starting..."), this._setupListeners(), this._flushInterval = setInterval(this.flush.bind(this), this.flushIntervalMilliseconds);
    } else {
      var e2, t2;
      clearInterval(null !== (e2 = this._flushInterval) && void 0 !== e2 ? e2 : void 0), null === (t2 = this.deadClicksCapture) || void 0 === t2 || t2.stop(), this.getAndClearBuffer();
    }
  }
  onRemoteConfig(e2) {
    var t2 = !!e2.heatmaps;
    this.instance.persistence && this.instance.persistence.register({ [le]: t2 }), this._enabledServerSide = t2, this.startIfEnabled();
  }
  getAndClearBuffer() {
    var e2 = this.buffer;
    return this.buffer = void 0, e2;
  }
  _onDeadClick(e2) {
    this._onClick(e2.originalEvent, "deadclick");
  }
  _setupListeners() {
    t$2 && a$1 && (ie(a$1, "click", (e2) => this._onClick(e2 || (null == t$2 ? void 0 : t$2.event)), false, true), ie(a$1, "mousemove", (e2) => this._onMouseMove(e2 || (null == t$2 ? void 0 : t$2.event)), false, true), this.deadClicksCapture = new Ts(this.instance, Rs, this._onDeadClick.bind(this)), this.deadClicksCapture.startIfEnabled(), this._initialized = true);
  }
  _getProperties(e2, i) {
    var n2 = this.instance.scrollManager.scrollY(), r2 = this.instance.scrollManager.scrollX(), s2 = this.instance.scrollManager.scrollElement(), o2 = function(e3, i2, n3) {
      for (var r3 = e3; r3 && xi(r3) && !Ii(r3, "body"); ) {
        if (r3 === n3) return false;
        if (m$2(i2, null == t$2 ? void 0 : t$2.getComputedStyle(r3).position)) return true;
        r3 = Ai(r3);
      }
      return false;
    }(Li(e2), ["fixed", "sticky"], s2);
    return { x: e2.clientX + (o2 ? 0 : r2), y: e2.clientY + (o2 ? 0 : n2), target_fixed: o2, type: i };
  }
  _onClick(e2) {
    var t2, i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "click";
    if (!ki(e2.target) && Os(e2)) {
      var n2 = this._getProperties(e2, i);
      null !== (t2 = this.rageclicks) && void 0 !== t2 && t2.isRageClick(e2.clientX, e2.clientY, (/* @__PURE__ */ new Date()).getTime()) && this._capture(j$2(j$2({}, n2), {}, { type: "rageclick" })), this._capture(n2);
    }
  }
  _onMouseMove(e2) {
    !ki(e2.target) && Os(e2) && (clearTimeout(this._mouseMoveTimeout), this._mouseMoveTimeout = setTimeout(() => {
      this._capture(this._getProperties(e2, "mousemove"));
    }, 500));
  }
  _capture(e2) {
    if (t$2) {
      var i = t$2.location.href;
      this.buffer = this.buffer || {}, this.buffer[i] || (this.buffer[i] = []), this.buffer[i].push(e2);
    }
  }
  flush() {
    this.buffer && !P$2(this.buffer) && this.instance.capture("$$heatmap", { $heatmap_data: this.getAndClearBuffer() });
  }
}
class Ms {
  constructor(e2) {
    W$1(this, "_updateScrollData", () => {
      var e3, t2, i, n2;
      this.context || (this.context = {});
      var r2 = this.scrollElement(), s2 = this.scrollY(), o2 = r2 ? Math.max(0, r2.scrollHeight - r2.clientHeight) : 0, a2 = s2 + ((null == r2 ? void 0 : r2.clientHeight) || 0), l2 = (null == r2 ? void 0 : r2.scrollHeight) || 0;
      this.context.lastScrollY = Math.ceil(s2), this.context.maxScrollY = Math.max(s2, null !== (e3 = this.context.maxScrollY) && void 0 !== e3 ? e3 : 0), this.context.maxScrollHeight = Math.max(o2, null !== (t2 = this.context.maxScrollHeight) && void 0 !== t2 ? t2 : 0), this.context.lastContentY = a2, this.context.maxContentY = Math.max(a2, null !== (i = this.context.maxContentY) && void 0 !== i ? i : 0), this.context.maxContentHeight = Math.max(l2, null !== (n2 = this.context.maxContentHeight) && void 0 !== n2 ? n2 : 0);
    }), this.instance = e2;
  }
  getContext() {
    return this.context;
  }
  resetContext() {
    var e2 = this.context;
    return setTimeout(this._updateScrollData, 0), e2;
  }
  startMeasuringScrollPosition() {
    null == t$2 || t$2.addEventListener("scroll", this._updateScrollData, true), null == t$2 || t$2.addEventListener("scrollend", this._updateScrollData, true), null == t$2 || t$2.addEventListener("resize", this._updateScrollData);
  }
  scrollElement() {
    if (!this.instance.config.scroll_root_selector) return null == t$2 ? void 0 : t$2.document.documentElement;
    var e2 = x$3(this.instance.config.scroll_root_selector) ? this.instance.config.scroll_root_selector : [this.instance.config.scroll_root_selector];
    for (var i of e2) {
      var n2 = null == t$2 ? void 0 : t$2.document.querySelector(i);
      if (n2) return n2;
    }
  }
  scrollY() {
    if (this.instance.config.scroll_root_selector) {
      var e2 = this.scrollElement();
      return e2 && e2.scrollTop || 0;
    }
    return t$2 && (t$2.scrollY || t$2.pageYOffset || t$2.document.documentElement.scrollTop) || 0;
  }
  scrollX() {
    if (this.instance.config.scroll_root_selector) {
      var e2 = this.scrollElement();
      return e2 && e2.scrollLeft || 0;
    }
    return t$2 && (t$2.scrollX || t$2.pageXOffset || t$2.document.documentElement.scrollLeft) || 0;
  }
}
var As = B$2("[AutoCapture]");
function Ds(e2, t2) {
  return t2.length > e2 ? t2.slice(0, e2) + "..." : t2;
}
function Ns(e2) {
  if (e2.previousElementSibling) return e2.previousElementSibling;
  var t2 = e2;
  do {
    t2 = t2.previousSibling;
  } while (t2 && !xi(t2));
  return t2;
}
function qs(e2, t2, i, n2) {
  var r2 = e2.tagName.toLowerCase(), s2 = { tag_name: r2 };
  Mi.indexOf(r2) > -1 && !i && ("a" === r2.toLowerCase() || "button" === r2.toLowerCase() ? s2.$el_text = Ds(1024, Vi(e2)) : s2.$el_text = Ds(1024, Oi(e2)));
  var o2 = Ti(e2);
  o2.length > 0 && (s2.classes = o2.filter(function(e3) {
    return "" !== e3;
  })), Y$1(e2.attributes, function(i2) {
    var r3;
    if ((!qi(e2) || -1 !== ["name", "id", "class", "aria-label"].indexOf(i2.name)) && ((null == n2 || !n2.includes(i2.name)) && !t2 && Gi(i2.value) && (r3 = i2.name, !F$2(r3) || "_ngcontent" !== r3.substring(0, 10) && "_nghost" !== r3.substring(0, 7)))) {
      var o3 = i2.value;
      "class" === i2.name && (o3 = Ri(o3).join(" ")), s2["attr__" + i2.name] = Ds(1024, o3);
    }
  });
  for (var a2 = 1, l2 = 1, u2 = e2; u2 = Ns(u2); ) a2++, u2.tagName === e2.tagName && l2++;
  return s2.nth_child = a2, s2.nth_of_type = l2, s2;
}
function Bs(e2, i) {
  for (var n2, r2, { e: s2, maskAllElementAttributes: o2, maskAllText: a2, elementAttributeIgnoreList: l2, elementsChainAsString: u2 } = i, c6 = [e2], d2 = e2; d2.parentNode && !Ii(d2, "body"); ) Pi(d2.parentNode) ? (c6.push(d2.parentNode.host), d2 = d2.parentNode.host) : (c6.push(d2.parentNode), d2 = d2.parentNode);
  var h2, _2 = [], p2 = {}, v2 = false, g2 = false;
  if (Y$1(c6, (e3) => {
    var t2 = Ni(e3);
    "a" === e3.tagName.toLowerCase() && (v2 = e3.getAttribute("href"), v2 = t2 && v2 && Gi(v2) && v2), m$2(Ti(e3), "ph-no-capture") && (g2 = true), _2.push(qs(e3, o2, a2, l2));
    var i2 = function(e4) {
      if (!Ni(e4)) return {};
      var t3 = {};
      return Y$1(e4.attributes, function(e5) {
        if (e5.name && 0 === e5.name.indexOf("data-ph-capture-attribute")) {
          var i3 = e5.name.replace("data-ph-capture-attribute-", ""), n3 = e5.value;
          i3 && n3 && Gi(n3) && (t3[i3] = n3);
        }
      }), t3;
    }(e3);
    K$1(p2, i2);
  }), g2) return { props: {}, explicitNoCapture: g2 };
  if (a2 || ("a" === e2.tagName.toLowerCase() || "button" === e2.tagName.toLowerCase() ? _2[0].$el_text = Vi(e2) : _2[0].$el_text = Oi(e2)), v2) {
    var f2, b2;
    _2[0].attr__href = v2;
    var y2 = null === (f2 = vt(v2)) || void 0 === f2 ? void 0 : f2.host, w2 = null == t$2 || null === (b2 = t$2.location) || void 0 === b2 ? void 0 : b2.host;
    y2 && w2 && y2 !== w2 && (h2 = v2);
  }
  return { props: K$1({ $event_type: s2.type, $ce_version: 1 }, u2 ? {} : { $elements: _2 }, { $elements_chain: Yi(_2) }, null !== (n2 = _2[0]) && void 0 !== n2 && n2.$el_text ? { $el_text: null === (r2 = _2[0]) || void 0 === r2 ? void 0 : r2.$el_text } : {}, h2 && "click" === s2.type ? { $external_click_url: h2 } : {}, p2) };
}
class Hs {
  constructor(e2) {
    W$1(this, "_initialized", false), W$1(this, "_isDisabledServerSide", null), W$1(this, "rageclicks", new Cs()), W$1(this, "_elementsChainAsString", false), this.instance = e2, this._elementSelectors = null;
  }
  get config() {
    var e2, t2, i = C$2(this.instance.config.autocapture) ? this.instance.config.autocapture : {};
    return i.url_allowlist = null === (e2 = i.url_allowlist) || void 0 === e2 ? void 0 : e2.map((e3) => new RegExp(e3)), i.url_ignorelist = null === (t2 = i.url_ignorelist) || void 0 === t2 ? void 0 : t2.map((e3) => new RegExp(e3)), i;
  }
  _addDomEventHandlers() {
    if (this.isBrowserSupported()) {
      if (t$2 && a$1) {
        var e2 = (e3) => {
          e3 = e3 || (null == t$2 ? void 0 : t$2.event);
          try {
            this._captureEvent(e3);
          } catch (e4) {
            As.error("Failed to capture event", e4);
          }
        }, i = (e3) => {
          e3 = e3 || (null == t$2 ? void 0 : t$2.event), this._captureEvent(e3, v$2);
        };
        ie(a$1, "submit", e2, false, true), ie(a$1, "change", e2, false, true), ie(a$1, "click", e2, false, true), this.config.capture_copied_text && (ie(a$1, "copy", i, false, true), ie(a$1, "cut", i, false, true));
      }
    } else As.info("Disabling Automatic Event Collection because this browser is not supported");
  }
  startIfEnabled() {
    this.isEnabled && !this._initialized && (this._addDomEventHandlers(), this._initialized = true);
  }
  onRemoteConfig(e2) {
    e2.elementsChainAsString && (this._elementsChainAsString = e2.elementsChainAsString), this.instance.persistence && this.instance.persistence.register({ [ae]: !!e2.autocapture_opt_out }), this._isDisabledServerSide = !!e2.autocapture_opt_out, this.startIfEnabled();
  }
  setElementSelectors(e2) {
    this._elementSelectors = e2;
  }
  getElementSelectors(e2) {
    var t2, i = [];
    return null === (t2 = this._elementSelectors) || void 0 === t2 || t2.forEach((t3) => {
      var n2 = null == a$1 ? void 0 : a$1.querySelectorAll(t3);
      null == n2 || n2.forEach((n3) => {
        e2 === n3 && i.push(t3);
      });
    }), i;
  }
  get isEnabled() {
    var e2, t2, i = null === (e2 = this.instance.persistence) || void 0 === e2 ? void 0 : e2.props[ae], n2 = this._isDisabledServerSide;
    if ($$1(n2) && !M$1(i) && !this.instance.config.advanced_disable_decide) return false;
    var r2 = null !== (t2 = this._isDisabledServerSide) && void 0 !== t2 ? t2 : !!i;
    return !!this.instance.config.autocapture && !r2;
  }
  _captureEvent(e2) {
    var i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "$autocapture";
    if (this.isEnabled) {
      var n2, r2 = Li(e2);
      if (Ci(r2) && (r2 = r2.parentNode || null), "$autocapture" === i && "click" === e2.type && e2 instanceof MouseEvent) this.instance.config.rageclick && null !== (n2 = this.rageclicks) && void 0 !== n2 && n2.isRageClick(e2.clientX, e2.clientY, (/* @__PURE__ */ new Date()).getTime()) && this._captureEvent(e2, "$rageclick");
      var s2 = i === v$2;
      if (r2 && Di(r2, e2, this.config, s2, s2 ? ["copy", "cut"] : void 0)) {
        var { props: o2, explicitNoCapture: a2 } = Bs(r2, { e: e2, maskAllElementAttributes: this.instance.config.mask_all_element_attributes, maskAllText: this.instance.config.mask_all_text, elementAttributeIgnoreList: this.config.element_attribute_ignorelist, elementsChainAsString: this._elementsChainAsString });
        if (a2) return false;
        var l2 = this.getElementSelectors(r2);
        if (l2 && l2.length > 0 && (o2.$element_selectors = l2), i === v$2) {
          var u2, c6 = $i(null == t$2 || null === (u2 = t$2.getSelection()) || void 0 === u2 ? void 0 : u2.toString()), d2 = e2.type || "clipboard";
          if (!c6) return false;
          o2.$selected_content = c6, o2.$copy_type = d2;
        }
        return this.instance.capture(i, o2), true;
      }
    }
  }
  isBrowserSupported() {
    return I$1(null == a$1 ? void 0 : a$1.querySelectorAll);
  }
}
var Us = B$2("[TracingHeaders]");
class zs {
  constructor(e2) {
    W$1(this, "_restoreXHRPatch", void 0), W$1(this, "_restoreFetchPatch", void 0), W$1(this, "_startCapturing", () => {
      var e3, t2, i, n2;
      R$1(this._restoreXHRPatch) && (null === (e3 = _$1.__PosthogExtensions__) || void 0 === e3 || null === (t2 = e3.tracingHeadersPatchFns) || void 0 === t2 || t2._patchXHR(this.instance.sessionManager));
      R$1(this._restoreFetchPatch) && (null === (i = _$1.__PosthogExtensions__) || void 0 === i || null === (n2 = i.tracingHeadersPatchFns) || void 0 === n2 || n2._patchFetch(this.instance.sessionManager));
    }), this.instance = e2;
  }
  _loadScript(e2) {
    var t2, i, n2;
    null !== (t2 = _$1.__PosthogExtensions__) && void 0 !== t2 && t2.tracingHeadersPatchFns && e2(), null === (i = _$1.__PosthogExtensions__) || void 0 === i || null === (n2 = i.loadExternalDependency) || void 0 === n2 || n2.call(i, this.instance, "tracing-headers", (t3) => {
      if (t3) return Us.error("failed to load script", t3);
      e2();
    });
  }
  startIfEnabledOrStop() {
    var e2, t2;
    this.instance.config.__add_tracing_headers ? this._loadScript(this._startCapturing) : (null === (e2 = this._restoreXHRPatch) || void 0 === e2 || e2.call(this), null === (t2 = this._restoreFetchPatch) || void 0 === t2 || t2.call(this), this._restoreXHRPatch = void 0, this._restoreFetchPatch = void 0);
  }
}
var js;
!function(e2) {
  e2[e2.PENDING = -1] = "PENDING", e2[e2.DENIED = 0] = "DENIED", e2[e2.GRANTED = 1] = "GRANTED";
}(js || (js = {}));
class Ws {
  constructor(e2) {
    this.instance = e2;
  }
  get config() {
    return this.instance.config;
  }
  get consent() {
    return this.getDnt() ? js.DENIED : this.storedConsent;
  }
  isOptedOut() {
    return this.consent === js.DENIED || this.consent === js.PENDING && this.config.opt_out_capturing_by_default;
  }
  isOptedIn() {
    return !this.isOptedOut();
  }
  optInOut(e2) {
    this.storage.set(this.storageKey, e2 ? 1 : 0, this.config.cookie_expiration, this.config.cross_subdomain_cookie, this.config.secure_cookie);
  }
  reset() {
    this.storage.remove(this.storageKey, this.config.cross_subdomain_cookie);
  }
  get storageKey() {
    var { token: e2, opt_out_capturing_cookie_prefix: t2 } = this.instance.config;
    return (t2 || "__ph_opt_in_out_") + e2;
  }
  get storedConsent() {
    var e2 = this.storage.get(this.storageKey);
    return "1" === e2 ? js.GRANTED : "0" === e2 ? js.DENIED : js.PENDING;
  }
  get storage() {
    if (!this._storage) {
      var e2 = this.config.opt_out_capturing_persistence_type;
      this._storage = "localStorage" === e2 ? at : st;
      var t2 = "localStorage" === e2 ? st : at;
      t2.get(this.storageKey) && (this._storage.get(this.storageKey) || this.optInOut("1" === t2.get(this.storageKey)), t2.remove(this.storageKey, this.config.cross_subdomain_cookie));
    }
    return this._storage;
  }
  getDnt() {
    return !!this.config.respect_dnt && !!ne([null == o$1 ? void 0 : o$1.doNotTrack, null == o$1 ? void 0 : o$1.msDoNotTrack, _$1.doNotTrack], (e2) => m$2([true, 1, "1", "yes"], e2));
  }
}
var Gs = B$2("[ExceptionAutocapture]");
class Vs {
  constructor(e2) {
    var i;
    W$1(this, "originalOnUnhandledRejectionHandler", void 0), W$1(this, "startCapturing", () => {
      var e3, i2, n2, r2;
      if (t$2 && this.isEnabled && !this.hasHandlers && !this.isCapturing) {
        var s2 = null === (e3 = _$1.__PosthogExtensions__) || void 0 === e3 || null === (i2 = e3.errorWrappingFunctions) || void 0 === i2 ? void 0 : i2.wrapOnError, o2 = null === (n2 = _$1.__PosthogExtensions__) || void 0 === n2 || null === (r2 = n2.errorWrappingFunctions) || void 0 === r2 ? void 0 : r2.wrapUnhandledRejection;
        if (s2 && o2) try {
          this.unwrapOnError = s2(this.captureException.bind(this)), this.unwrapUnhandledRejection = o2(this.captureException.bind(this));
        } catch (e4) {
          Gs.error("failed to start", e4), this.stopCapturing();
        }
        else Gs.error("failed to load error wrapping functions - cannot start");
      }
    }), this.instance = e2, this.remoteEnabled = !(null === (i = this.instance.persistence) || void 0 === i || !i.props[ue]), this.startIfEnabled();
  }
  get isEnabled() {
    var e2;
    return null !== (e2 = this.remoteEnabled) && void 0 !== e2 && e2;
  }
  get isCapturing() {
    var e2;
    return !(null == t$2 || null === (e2 = t$2.onerror) || void 0 === e2 || !e2.__POSTHOG_INSTRUMENTED__);
  }
  get hasHandlers() {
    return this.originalOnUnhandledRejectionHandler || this.unwrapOnError;
  }
  startIfEnabled() {
    this.isEnabled && !this.isCapturing && (Gs.info("enabled, starting..."), this.loadScript(this.startCapturing));
  }
  loadScript(e2) {
    var t2, i;
    this.hasHandlers && e2(), null === (t2 = _$1.__PosthogExtensions__) || void 0 === t2 || null === (i = t2.loadExternalDependency) || void 0 === i || i.call(t2, this.instance, "exception-autocapture", (t3) => {
      if (t3) return Gs.error("failed to load script", t3);
      e2();
    });
  }
  stopCapturing() {
    var e2, t2;
    null === (e2 = this.unwrapOnError) || void 0 === e2 || e2.call(this), null === (t2 = this.unwrapUnhandledRejection) || void 0 === t2 || t2.call(this);
  }
  onRemoteConfig(e2) {
    var t2 = e2.autocaptureExceptions;
    this.remoteEnabled = !!t2 || false, this.instance.persistence && this.instance.persistence.register({ [ue]: this.remoteEnabled }), this.startIfEnabled();
  }
  captureException(e2) {
    var t2 = this.instance.requestRouter.endpointFor("ui");
    e2.$exception_personURL = "".concat(t2, "/project/").concat(this.instance.config.token, "/person/").concat(this.instance.get_distinct_id()), this.instance.exceptions.sendExceptionEvent(e2);
  }
}
var Js = B$2("[Web Vitals]"), Ys = 9e5;
class Ks {
  constructor(e2) {
    var t2;
    W$1(this, "_enabledServerSide", false), W$1(this, "_initialized", false), W$1(this, "buffer", { url: void 0, metrics: [], firstMetricTimestamp: void 0 }), W$1(this, "_flushToCapture", () => {
      clearTimeout(this._delayedFlushTimer), 0 !== this.buffer.metrics.length && (this.instance.capture("$web_vitals", this.buffer.metrics.reduce((e3, t3) => j$2(j$2({}, e3), {}, { ["$web_vitals_".concat(t3.name, "_event")]: j$2({}, t3), ["$web_vitals_".concat(t3.name, "_value")]: t3.value }), {})), this.buffer = { url: void 0, metrics: [], firstMetricTimestamp: void 0 });
    }), W$1(this, "_addToBuffer", (e3) => {
      var t3, i = null === (t3 = this.instance.sessionManager) || void 0 === t3 ? void 0 : t3.checkAndGetSessionAndWindowId(true);
      if (R$1(i)) Js.error("Could not read session ID. Dropping metrics!");
      else {
        this.buffer = this.buffer || { url: void 0, metrics: [], firstMetricTimestamp: void 0 };
        var n2 = this._currentURL();
        if (!R$1(n2)) if (O$1(null == e3 ? void 0 : e3.name) || O$1(null == e3 ? void 0 : e3.value)) Js.error("Invalid metric received", e3);
        else if (this._maxAllowedValue && e3.value >= this._maxAllowedValue) Js.error("Ignoring metric with value >= " + this._maxAllowedValue, e3);
        else this.buffer.url !== n2 && (this._flushToCapture(), this._delayedFlushTimer = setTimeout(this._flushToCapture, this.flushToCaptureTimeoutMs)), R$1(this.buffer.url) && (this.buffer.url = n2), this.buffer.firstMetricTimestamp = R$1(this.buffer.firstMetricTimestamp) ? Date.now() : this.buffer.firstMetricTimestamp, e3.attribution && e3.attribution.interactionTargetElement && (e3.attribution.interactionTargetElement = void 0), this.buffer.metrics.push(j$2(j$2({}, e3), {}, { $current_url: n2, $session_id: i.sessionId, $window_id: i.windowId, timestamp: Date.now() })), this.buffer.metrics.length === this.allowedMetrics.length && this._flushToCapture();
      }
    }), W$1(this, "_startCapturing", () => {
      var e3, t3, i, n2, r2 = _$1.__PosthogExtensions__;
      R$1(r2) || R$1(r2.postHogWebVitalsCallbacks) || ({ onLCP: e3, onCLS: t3, onFCP: i, onINP: n2 } = r2.postHogWebVitalsCallbacks), e3 && t3 && i && n2 ? (this.allowedMetrics.indexOf("LCP") > -1 && e3(this._addToBuffer.bind(this)), this.allowedMetrics.indexOf("CLS") > -1 && t3(this._addToBuffer.bind(this)), this.allowedMetrics.indexOf("FCP") > -1 && i(this._addToBuffer.bind(this)), this.allowedMetrics.indexOf("INP") > -1 && n2(this._addToBuffer.bind(this)), this._initialized = true) : Js.error("web vitals callbacks not loaded - not starting");
    }), this.instance = e2, this._enabledServerSide = !(null === (t2 = this.instance.persistence) || void 0 === t2 || !t2.props[ce]), this.startIfEnabled();
  }
  get allowedMetrics() {
    var e2, t2, i = C$2(this.instance.config.capture_performance) ? null === (e2 = this.instance.config.capture_performance) || void 0 === e2 ? void 0 : e2.web_vitals_allowed_metrics : void 0;
    return R$1(i) ? (null === (t2 = this.instance.persistence) || void 0 === t2 ? void 0 : t2.props[he]) || ["CLS", "FCP", "INP", "LCP"] : i;
  }
  get flushToCaptureTimeoutMs() {
    return (C$2(this.instance.config.capture_performance) ? this.instance.config.capture_performance.web_vitals_delayed_flush_ms : void 0) || 5e3;
  }
  get _maxAllowedValue() {
    var e2 = C$2(this.instance.config.capture_performance) && L$1(this.instance.config.capture_performance.__web_vitals_max_value) ? this.instance.config.capture_performance.__web_vitals_max_value : Ys;
    return 0 < e2 && e2 <= 6e4 ? Ys : e2;
  }
  get isEnabled() {
    var e2 = C$2(this.instance.config.capture_performance) ? this.instance.config.capture_performance.web_vitals : void 0;
    return M$1(e2) ? e2 : this._enabledServerSide;
  }
  startIfEnabled() {
    this.isEnabled && !this._initialized && (Js.info("enabled, starting..."), this.loadScript(this._startCapturing));
  }
  onRemoteConfig(e2) {
    var t2 = C$2(e2.capturePerformance) && !!e2.capturePerformance.web_vitals, i = C$2(e2.capturePerformance) ? e2.capturePerformance.web_vitals_allowed_metrics : void 0;
    this.instance.persistence && (this.instance.persistence.register({ [ce]: t2 }), this.instance.persistence.register({ [he]: i })), this._enabledServerSide = t2, this.startIfEnabled();
  }
  loadScript(e2) {
    var t2, i, n2;
    null !== (t2 = _$1.__PosthogExtensions__) && void 0 !== t2 && t2.postHogWebVitalsCallbacks && e2(), null === (i = _$1.__PosthogExtensions__) || void 0 === i || null === (n2 = i.loadExternalDependency) || void 0 === n2 || n2.call(i, this.instance, "web-vitals", (t3) => {
      t3 ? Js.error("failed to load script", t3) : e2();
    });
  }
  _currentURL() {
    var e2 = t$2 ? t$2.location.href : void 0;
    return e2 || Js.error("Could not determine current URL"), e2;
  }
}
var Xs = { icontains: (e2, i) => !!t$2 && i.href.toLowerCase().indexOf(e2.toLowerCase()) > -1, not_icontains: (e2, i) => !!t$2 && -1 === i.href.toLowerCase().indexOf(e2.toLowerCase()), regex: (e2, i) => !!t$2 && gt(i.href, e2), not_regex: (e2, i) => !!t$2 && !gt(i.href, e2), exact: (e2, t2) => t2.href === e2, is_not: (e2, t2) => t2.href !== e2 };
class Qs {
  constructor(e2) {
    var t2 = this;
    W$1(this, "getWebExperimentsAndEvaluateDisplayLogic", function() {
      var e3 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
      t2.getWebExperiments((e4) => {
        Qs.logInfo("retrieved web experiments from the server"), t2._flagToExperiments = /* @__PURE__ */ new Map(), e4.forEach((e5) => {
          if (e5.feature_flag_key) {
            var i;
            if (t2._flagToExperiments) Qs.logInfo("setting flag key ", e5.feature_flag_key, " to web experiment ", e5), null === (i = t2._flagToExperiments) || void 0 === i || i.set(e5.feature_flag_key, e5);
            var n2 = t2.instance.getFeatureFlag(e5.feature_flag_key);
            F$2(n2) && e5.variants[n2] && t2.applyTransforms(e5.name, n2, e5.variants[n2].transforms);
          } else if (e5.variants) for (var r2 in e5.variants) {
            var s2 = e5.variants[r2];
            Qs.matchesTestVariant(s2) && t2.applyTransforms(e5.name, r2, s2.transforms);
          }
        });
      }, e3);
    }), this.instance = e2, this.instance.onFeatureFlags((e3) => {
      this.onFeatureFlags(e3);
    });
  }
  onFeatureFlags(e2) {
    if (this._is_bot()) Qs.logInfo("Refusing to render web experiment since the viewer is a likely bot");
    else if (!this.instance.config.disable_web_experiments) {
      if (O$1(this._flagToExperiments)) return this._flagToExperiments = /* @__PURE__ */ new Map(), this.loadIfEnabled(), void this.previewWebExperiment();
      Qs.logInfo("applying feature flags", e2), e2.forEach((e3) => {
        var t2;
        if (this._flagToExperiments && null !== (t2 = this._flagToExperiments) && void 0 !== t2 && t2.has(e3)) {
          var i, n2 = this.instance.getFeatureFlag(e3), r2 = null === (i = this._flagToExperiments) || void 0 === i ? void 0 : i.get(e3);
          n2 && null != r2 && r2.variants[n2] && this.applyTransforms(r2.name, n2, r2.variants[n2].transforms);
        }
      });
    }
  }
  previewWebExperiment() {
    var e2 = Qs.getWindowLocation();
    if (null != e2 && e2.search) {
      var t2 = mt(null == e2 ? void 0 : e2.search, "__experiment_id"), i = mt(null == e2 ? void 0 : e2.search, "__experiment_variant");
      t2 && i && (Qs.logInfo("previewing web experiments ".concat(t2, " && ").concat(i)), this.getWebExperiments((e3) => {
        this.showPreviewWebExperiment(parseInt(t2), i, e3);
      }, false, true));
    }
  }
  loadIfEnabled() {
    this.instance.config.disable_web_experiments || this.getWebExperimentsAndEvaluateDisplayLogic();
  }
  getWebExperiments(e2, t2, i) {
    if (this.instance.config.disable_web_experiments && !i) return e2([]);
    var n2 = this.instance.get_property("$web_experiments");
    if (n2 && !t2) return e2(n2);
    this.instance._send_request({ url: this.instance.requestRouter.endpointFor("api", "/api/web_experiments/?token=".concat(this.instance.config.token)), method: "GET", callback: (t3) => {
      if (200 !== t3.statusCode || !t3.json) return e2([]);
      var i2 = t3.json.experiments || [];
      return e2(i2);
    } });
  }
  showPreviewWebExperiment(e2, t2, i) {
    var n2 = i.filter((t3) => t3.id === e2);
    n2 && n2.length > 0 && (Qs.logInfo("Previewing web experiment [".concat(n2[0].name, "] with variant [").concat(t2, "]")), this.applyTransforms(n2[0].name, t2, n2[0].variants[t2].transforms, true));
  }
  static matchesTestVariant(e2) {
    return !O$1(e2.conditions) && (Qs.matchUrlConditions(e2) && Qs.matchUTMConditions(e2));
  }
  static matchUrlConditions(e2) {
    var t2;
    if (O$1(e2.conditions) || O$1(null === (t2 = e2.conditions) || void 0 === t2 ? void 0 : t2.url)) return true;
    var i, n2, r2, s2 = Qs.getWindowLocation();
    return !!s2 && (null === (i = e2.conditions) || void 0 === i || !i.url || Xs[null !== (n2 = null === (r2 = e2.conditions) || void 0 === r2 ? void 0 : r2.urlMatchType) && void 0 !== n2 ? n2 : "icontains"](e2.conditions.url, s2));
  }
  static getWindowLocation() {
    return null == t$2 ? void 0 : t$2.location;
  }
  static matchUTMConditions(e2) {
    var t2;
    if (O$1(e2.conditions) || O$1(null === (t2 = e2.conditions) || void 0 === t2 ? void 0 : t2.utm)) return true;
    var i = fi.campaignParams();
    if (i.utm_source) {
      var n2, r2, s2, o2, a2, l2, u2, c6, d2, h2, _2, p2, v2, g2, f2, m2, b2 = null === (n2 = e2.conditions) || void 0 === n2 || null === (r2 = n2.utm) || void 0 === r2 || !r2.utm_campaign || (null === (s2 = e2.conditions) || void 0 === s2 || null === (o2 = s2.utm) || void 0 === o2 ? void 0 : o2.utm_campaign) == i.utm_campaign, y2 = null === (a2 = e2.conditions) || void 0 === a2 || null === (l2 = a2.utm) || void 0 === l2 || !l2.utm_source || (null === (u2 = e2.conditions) || void 0 === u2 || null === (c6 = u2.utm) || void 0 === c6 ? void 0 : c6.utm_source) == i.utm_source, w2 = null === (d2 = e2.conditions) || void 0 === d2 || null === (h2 = d2.utm) || void 0 === h2 || !h2.utm_medium || (null === (_2 = e2.conditions) || void 0 === _2 || null === (p2 = _2.utm) || void 0 === p2 ? void 0 : p2.utm_medium) == i.utm_medium, S2 = null === (v2 = e2.conditions) || void 0 === v2 || null === (g2 = v2.utm) || void 0 === g2 || !g2.utm_term || (null === (f2 = e2.conditions) || void 0 === f2 || null === (m2 = f2.utm) || void 0 === m2 ? void 0 : m2.utm_term) == i.utm_term;
      return b2 && w2 && S2 && y2;
    }
    return false;
  }
  static logInfo(e2) {
    for (var t2 = arguments.length, i = new Array(t2 > 1 ? t2 - 1 : 0), n2 = 1; n2 < t2; n2++) i[n2 - 1] = arguments[n2];
    q$3.info("[WebExperiments] ".concat(e2), i);
  }
  applyTransforms(e2, t2, i, n2) {
    var r2;
    this._is_bot() ? Qs.logInfo("Refusing to render web experiment since the viewer is a likely bot") : "control" !== t2 ? i.forEach((i2) => {
      if (i2.selector) {
        var r3;
        Qs.logInfo("applying transform of variant ".concat(t2, " for experiment ").concat(e2, " "), i2);
        var s2, o2 = 0, a2 = null === (r3 = document) || void 0 === r3 ? void 0 : r3.querySelectorAll(i2.selector);
        if (null == a2 || a2.forEach((e3) => {
          var t3 = e3;
          o2 += 1, i2.attributes && i2.attributes.forEach((e4) => {
            switch (e4.name) {
              case "text":
                t3.innerText = e4.value;
                break;
              case "html":
                t3.innerHTML = e4.value;
                break;
              case "cssClass":
                t3.className = e4.value;
                break;
              default:
                t3.setAttribute(e4.name, e4.value);
            }
          }), i2.text && (t3.innerText = i2.text), i2.html && (t3.parentElement ? t3.parentElement.innerHTML = i2.html : t3.innerHTML = i2.html), i2.css && t3.setAttribute("style", i2.css);
        }), this.instance && this.instance.capture) this.instance.capture("$web_experiment_applied", { $web_experiment_name: e2, $web_experiment_variant: t2, $web_experiment_preview: n2, $web_experiment_document_url: null === (s2 = Qs.getWindowLocation()) || void 0 === s2 ? void 0 : s2.href, $web_experiment_elements_modified: o2 });
      }
    }) : (Qs.logInfo("Control variants leave the page unmodified."), this.instance && this.instance.capture && this.instance.capture("$web_experiment_applied", { $web_experiment_name: e2, $web_experiment_preview: n2, $web_experiment_variant: t2, $web_experiment_document_url: null === (r2 = Qs.getWindowLocation()) || void 0 === r2 ? void 0 : r2.href, $web_experiment_elements_modified: 0 }));
  }
  _is_bot() {
    return o$1 && this.instance ? Is(o$1, this.instance.config.custom_blocked_useragents) : void 0;
  }
}
class Zs {
  constructor(e2) {
    this.instance = e2;
  }
  sendExceptionEvent(e2) {
    this.instance.capture("$exception", e2, { _noTruncate: true, _batchKey: "exceptionEvent" });
  }
}
var eo = ["$set_once", "$set"], to$1 = B$2("[SiteApps]");
class io {
  constructor(e2) {
    this.instance = e2, this.bufferedInvocations = [], this.apps = {};
  }
  get isEnabled() {
    return !!this.instance.config.opt_in_site_apps;
  }
  eventCollector(e2, t2) {
    if (t2) {
      var i = this.globalsForEvent(t2);
      this.bufferedInvocations.push(i), this.bufferedInvocations.length > 1e3 && (this.bufferedInvocations = this.bufferedInvocations.slice(10));
    }
  }
  get siteAppLoaders() {
    var e2, t2;
    return null === (e2 = _$1._POSTHOG_REMOTE_CONFIG) || void 0 === e2 || null === (t2 = e2[this.instance.config.token]) || void 0 === t2 ? void 0 : t2.siteApps;
  }
  init() {
    if (this.isEnabled) {
      var e2 = this.instance._addCaptureHook(this.eventCollector.bind(this));
      this.stopBuffering = () => {
        e2(), this.bufferedInvocations = [], this.stopBuffering = void 0;
      };
    }
  }
  globalsForEvent(e2) {
    var t2, i, n2, r2, s2, o2, a2;
    if (!e2) throw new Error("Event payload is required");
    var l2 = {}, u2 = this.instance.get_property("$groups") || [], c6 = this.instance.get_property("$stored_group_properties") || {};
    for (var [d2, h2] of Object.entries(c6)) l2[d2] = { id: u2[d2], type: d2, properties: h2 };
    var { $set_once: _2, $set: p2 } = e2;
    return { event: j$2(j$2({}, G$1(e2, eo)), {}, { properties: j$2(j$2(j$2({}, e2.properties), p2 ? { $set: j$2(j$2({}, null !== (t2 = null === (i = e2.properties) || void 0 === i ? void 0 : i.$set) && void 0 !== t2 ? t2 : {}), p2) } : {}), _2 ? { $set_once: j$2(j$2({}, null !== (n2 = null === (r2 = e2.properties) || void 0 === r2 ? void 0 : r2.$set_once) && void 0 !== n2 ? n2 : {}), _2) } : {}), elements_chain: null !== (s2 = null === (o2 = e2.properties) || void 0 === o2 ? void 0 : o2.$elements_chain) && void 0 !== s2 ? s2 : "", distinct_id: null === (a2 = e2.properties) || void 0 === a2 ? void 0 : a2.distinct_id }), person: { properties: this.instance.get_property("$stored_person_properties") }, groups: l2 };
  }
  setupSiteApp(e2) {
    var t2 = { id: e2.id, loaded: false, errored: false };
    this.apps[e2.id] = t2;
    var i = (i2) => {
      var n3;
      for (var r2 of (this.apps[e2.id].errored = !i2, this.apps[e2.id].loaded = true, to$1.info("Site app with id ".concat(e2.id, " ").concat(i2 ? "loaded" : "errored")), i2 && this.bufferedInvocations.length && (to$1.info("Processing ".concat(this.bufferedInvocations.length, " events for site app with id ").concat(e2.id)), this.bufferedInvocations.forEach((e3) => {
        var i3;
        return null === (i3 = t2.processEvent) || void 0 === i3 ? void 0 : i3.call(t2, e3);
      })), Object.values(this.apps))) if (!r2.loaded) return;
      null === (n3 = this.stopBuffering) || void 0 === n3 || n3.call(this);
    };
    try {
      var { processEvent: n2 } = e2.init({ posthog: this.instance, callback: (e3) => {
        i(e3);
      } });
      n2 && (t2.processEvent = n2);
    } catch (t3) {
      to$1.error("Error while initializing PostHog app with config id ".concat(e2.id), t3), i(false);
    }
  }
  onCapturedEvent(e2) {
    if (0 !== Object.keys(this.apps).length) {
      var t2 = this.globalsForEvent(e2);
      for (var i of Object.values(this.apps)) try {
        var n2;
        null === (n2 = i.processEvent) || void 0 === n2 || n2.call(i, t2);
      } catch (t3) {
        to$1.error("Error while processing event ".concat(e2.event, " for site app ").concat(i.id), t3);
      }
    }
  }
  onRemoteConfig(e2) {
    var t2, i, n2, r2 = this;
    if (null !== (t2 = this.siteAppLoaders) && void 0 !== t2 && t2.length) {
      if (!this.isEnabled) return void to$1.error('PostHog site apps are disabled. Enable the "opt_in_site_apps" config to proceed.');
      for (var s2 of this.siteAppLoaders) this.setupSiteApp(s2);
      this.instance.on("eventCaptured", (e3) => this.onCapturedEvent(e3));
    } else if (null === (i = this.stopBuffering) || void 0 === i || i.call(this), null !== (n2 = e2.siteApps) && void 0 !== n2 && n2.length) if (this.isEnabled) {
      var o2 = function(e3, t3) {
        var i2, n3;
        _$1["__$$ph_site_app_".concat(e3)] = r2.instance, null === (i2 = _$1.__PosthogExtensions__) || void 0 === i2 || null === (n3 = i2.loadSiteApp) || void 0 === n3 || n3.call(i2, r2.instance, t3, (t4) => {
          if (t4) return to$1.error("Error while initializing PostHog app with config id ".concat(e3), t4);
        });
      };
      for (var { id: a2, url: l2 } of e2.siteApps) o2(a2, l2);
    } else to$1.error('PostHog site apps are disabled. Enable the "opt_in_site_apps" config to proceed.');
  }
}
var no = {}, ro = () => {
}, so = "posthog", oo = !dr && -1 === (null == h$2 ? void 0 : h$2.indexOf("MSIE")) && -1 === (null == h$2 ? void 0 : h$2.indexOf("Mozilla")), ao = () => {
  var e2, i, n2;
  return { api_host: "https://us.i.posthog.com", ui_host: null, token: "", autocapture: true, rageclick: true, cross_subdomain_cookie: (i = null == a$1 ? void 0 : a$1.location, n2 = null == i ? void 0 : i.hostname, !!F$2(n2) && "herokuapp.com" !== n2.split(".").slice(-2).join(".")), persistence: "localStorage+cookie", persistence_name: "", loaded: ro, store_google: true, custom_campaign_params: [], custom_blocked_useragents: [], save_referrer: true, capture_pageview: true, capture_pageleave: "if_capture_pageview", debug: l$2 && F$2(null == l$2 ? void 0 : l$2.search) && -1 !== l$2.search.indexOf("__posthog_debug=true") || false, verbose: false, cookie_expiration: 365, upgrade: false, disable_session_recording: false, disable_persistence: false, disable_web_experiments: true, disable_surveys: false, enable_recording_console_log: void 0, secure_cookie: "https:" === (null == t$2 || null === (e2 = t$2.location) || void 0 === e2 ? void 0 : e2.protocol), ip: true, opt_out_capturing_by_default: false, opt_out_persistence_by_default: false, opt_out_useragent_filter: false, opt_out_capturing_persistence_type: "localStorage", opt_out_capturing_cookie_prefix: null, opt_in_site_apps: false, property_denylist: [], respect_dnt: false, sanitize_properties: null, request_headers: {}, inapp_protocol: "//", inapp_link_new_window: false, request_batching: true, properties_string_max_length: 65535, session_recording: {}, mask_all_element_attributes: false, mask_all_text: false, advanced_disable_decide: false, advanced_disable_feature_flags: false, advanced_disable_feature_flags_on_first_load: false, advanced_disable_toolbar_metrics: false, feature_flag_request_timeout_ms: 3e3, on_request_error: (e3) => {
    var t2 = "Bad HTTP status: " + e3.statusCode + " " + e3.text;
    q$3.error(t2);
  }, get_device_id: (e3) => e3, _onCapture: ro, capture_performance: void 0, name: "posthog", bootstrap: {}, disable_compression: false, session_idle_timeout_seconds: 1800, person_profiles: "identified_only", __add_tracing_headers: false, before_send: void 0 };
}, lo = (e2) => {
  var t2 = {};
  R$1(e2.process_person) || (t2.person_profiles = e2.process_person), R$1(e2.xhr_headers) || (t2.request_headers = e2.xhr_headers), R$1(e2.cookie_name) || (t2.persistence_name = e2.cookie_name), R$1(e2.disable_cookie) || (t2.disable_persistence = e2.disable_cookie);
  var i = K$1({}, t2, e2);
  return x$3(e2.property_blacklist) && (R$1(e2.property_denylist) ? i.property_denylist = e2.property_blacklist : x$3(e2.property_denylist) ? i.property_denylist = [...e2.property_blacklist, ...e2.property_denylist] : q$3.error("Invalid value for property_denylist config: " + e2.property_denylist)), i;
};
class uo {
  constructor() {
    W$1(this, "__forceAllowLocalhost", false);
  }
  get _forceAllowLocalhost() {
    return this.__forceAllowLocalhost;
  }
  set _forceAllowLocalhost(e2) {
    q$3.error("WebPerformanceObserver is deprecated and has no impact on network capture. Use `_forceAllowLocalhostNetworkCapture` on `posthog.sessionRecording`"), this.__forceAllowLocalhost = e2;
  }
}
class co {
  get decideEndpointWasHit() {
    var e2, t2;
    return null !== (e2 = null === (t2 = this.featureFlags) || void 0 === t2 ? void 0 : t2.hasLoadedFlags) && void 0 !== e2 && e2;
  }
  constructor() {
    W$1(this, "webPerformance", new uo()), W$1(this, "version", p$2.LIB_VERSION), W$1(this, "_internalEventEmitter", new Or()), this.config = ao(), this.SentryIntegration = Ir, this.sentryIntegration = (e2) => function(e3, t2) {
      var i = xr(e3, t2);
      return { name: kr, processEvent: (e4) => i(e4) };
    }(this, e2), this.__request_queue = [], this.__loaded = false, this.analyticsDefaultEndpoint = "/e/", this._initialPageviewCaptured = false, this._initialPersonProfilesConfig = null, this.featureFlags = new Ge(this), this.toolbar = new lr(this), this.scrollManager = new Ms(this), this.pageViewManager = new $r(this), this.surveys = new bs(this), this.experiments = new Qs(this), this.exceptions = new Zs(this), this.rateLimiter = new ws$1(this), this.requestRouter = new Er(this), this.consent = new Ws(this), this.people = { set: (e2, t2, i) => {
      var n2 = F$2(e2) ? { [e2]: t2 } : e2;
      this.setPersonProperties(n2), null == i || i({});
    }, set_once: (e2, t2, i) => {
      var n2 = F$2(e2) ? { [e2]: t2 } : e2;
      this.setPersonProperties(void 0, n2), null == i || i({});
    } }, this.on("eventCaptured", (e2) => q$3.info('send "'.concat(null == e2 ? void 0 : e2.event, '"'), e2));
  }
  init(e2, t2, i) {
    if (i && i !== so) {
      var n2, r2 = null !== (n2 = no[i]) && void 0 !== n2 ? n2 : new co();
      return r2._init(e2, t2, i), no[i] = r2, no[so][i] = r2, r2;
    }
    return this._init(e2, t2, i);
  }
  _init(i) {
    var n2, r2, s2, o2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, a2 = arguments.length > 2 ? arguments[2] : void 0;
    if (R$1(i) || T$2(i)) return q$3.critical("PostHog was initialized without a token. This likely indicates a misconfiguration. Please check the first argument passed to posthog.init()"), this;
    if (this.__loaded) return q$3.warn("You have already initialized PostHog! Re-initializing is a no-op"), this;
    this.__loaded = true, this.config = {}, this._triggered_notifs = [], o2.person_profiles && (this._initialPersonProfilesConfig = o2.person_profiles), this.set_config(K$1({}, ao(), lo(o2), { name: a2, token: i })), this.config.on_xhr_error && q$3.error("on_xhr_error is deprecated. Use on_request_error instead"), this.compression = o2.disable_compression ? void 0 : e$2.GZipJS, this.persistence = new bi(this.config), this.sessionPersistence = "sessionStorage" === this.config.persistence || "memory" === this.config.persistence ? this.persistence : new bi(j$2(j$2({}, this.config), {}, { persistence: "sessionStorage" }));
    var l2 = j$2({}, this.persistence.props), u2 = j$2({}, this.sessionPersistence.props);
    if (this._requestQueue = new ur((e2) => this._send_retriable_request(e2)), this._retryQueue = new mr(this), this.__request_queue = [], this.config.__preview_experimental_cookieless_mode || (this.sessionManager = new wr(this), this.sessionPropsManager = new Es(this.sessionManager, this.persistence)), new zs(this).startIfEnabledOrStop(), this.siteApps = new io(this), null === (n2 = this.siteApps) || void 0 === n2 || n2.init(), this.config.__preview_experimental_cookieless_mode || (this.sessionRecording = new ir(this), this.sessionRecording.startIfEnabledOrStop()), this.config.disable_scroll_properties || this.scrollManager.startMeasuringScrollPosition(), this.autocapture = new Hs(this), this.autocapture.startIfEnabled(), this.surveys.loadIfEnabled(), this.heatmaps = new Ls(this), this.heatmaps.startIfEnabled(), this.webVitalsAutocapture = new Ks(this), this.exceptionObserver = new Vs(this), this.exceptionObserver.startIfEnabled(), this.deadClicksAutocapture = new Ts(this, Fs), this.deadClicksAutocapture.startIfEnabled(), p$2.DEBUG = p$2.DEBUG || this.config.debug, p$2.DEBUG && q$3.info("Starting in debug mode", { this: this, config: o2, thisC: j$2({}, this.config), p: l2, s: u2 }), this._sync_opt_out_with_persistence(), void 0 !== (null === (r2 = o2.bootstrap) || void 0 === r2 ? void 0 : r2.distinctID)) {
      var c6, d2, h2 = this.config.get_device_id(Ze()), _2 = null !== (c6 = o2.bootstrap) && void 0 !== c6 && c6.isIdentifiedID ? h2 : o2.bootstrap.distinctID;
      this.persistence.set_property(Te, null !== (d2 = o2.bootstrap) && void 0 !== d2 && d2.isIdentifiedID ? "identified" : "anonymous"), this.register({ distinct_id: o2.bootstrap.distinctID, $device_id: _2 });
    }
    if (this._hasBootstrappedFeatureFlags()) {
      var v2, g2, f2 = Object.keys((null === (v2 = o2.bootstrap) || void 0 === v2 ? void 0 : v2.featureFlags) || {}).filter((e2) => {
        var t2, i2;
        return !(null === (t2 = o2.bootstrap) || void 0 === t2 || null === (i2 = t2.featureFlags) || void 0 === i2 || !i2[e2]);
      }).reduce((e2, t2) => {
        var i2, n3;
        return e2[t2] = (null === (i2 = o2.bootstrap) || void 0 === i2 || null === (n3 = i2.featureFlags) || void 0 === n3 ? void 0 : n3[t2]) || false, e2;
      }, {}), m2 = Object.keys((null === (g2 = o2.bootstrap) || void 0 === g2 ? void 0 : g2.featureFlagPayloads) || {}).filter((e2) => f2[e2]).reduce((e2, t2) => {
        var i2, n3, r3, s3;
        null !== (i2 = o2.bootstrap) && void 0 !== i2 && null !== (n3 = i2.featureFlagPayloads) && void 0 !== n3 && n3[t2] && (e2[t2] = null === (r3 = o2.bootstrap) || void 0 === r3 || null === (s3 = r3.featureFlagPayloads) || void 0 === s3 ? void 0 : s3[t2]);
        return e2;
      }, {});
      this.featureFlags.receivedFeatureFlags({ featureFlags: f2, featureFlagPayloads: m2 });
    }
    if (this.config.__preview_experimental_cookieless_mode) this.register_once({ distinct_id: qe, $device_id: null }, "");
    else if (!this.get_distinct_id()) {
      var b2 = this.config.get_device_id(Ze());
      this.register_once({ distinct_id: b2, $device_id: b2 }, ""), this.persistence.set_property(Te, "anonymous");
    }
    return null == t$2 || null === (s2 = t$2.addEventListener) || void 0 === s2 || s2.call(t$2, "onpagehide" in self ? "pagehide" : "unload", this._handle_unload.bind(this)), this.toolbar.maybeLoadToolbar(), o2.segment ? Tr(this, () => this._loaded()) : this._loaded(), I$1(this.config._onCapture) && this.config._onCapture !== ro && (q$3.warn("onCapture is deprecated. Please use `before_send` instead"), this.on("eventCaptured", (e2) => this.config._onCapture(e2.event, e2))), this;
  }
  _onRemoteConfig(t2) {
    var i, n2, r2, s2, o2, l2, u2, c6, d2;
    if (!a$1 || !a$1.body) return q$3.info("document not ready yet, trying again in 500 milliseconds..."), void setTimeout(() => {
      this._onRemoteConfig(t2);
    }, 500);
    this.compression = void 0, t2.supportedCompression && !this.config.disable_compression && (this.compression = m$2(t2.supportedCompression, e$2.GZipJS) ? e$2.GZipJS : m$2(t2.supportedCompression, e$2.Base64) ? e$2.Base64 : void 0), null !== (i = t2.analytics) && void 0 !== i && i.endpoint && (this.analyticsDefaultEndpoint = t2.analytics.endpoint), this.set_config({ person_profiles: this._initialPersonProfilesConfig ? this._initialPersonProfilesConfig : t2.defaultIdentifiedOnly ? "identified_only" : "always" }), null === (n2 = this.siteApps) || void 0 === n2 || n2.onRemoteConfig(t2), null === (r2 = this.sessionRecording) || void 0 === r2 || r2.onRemoteConfig(t2), null === (s2 = this.autocapture) || void 0 === s2 || s2.onRemoteConfig(t2), null === (o2 = this.heatmaps) || void 0 === o2 || o2.onRemoteConfig(t2), null === (l2 = this.surveys) || void 0 === l2 || l2.onRemoteConfig(t2), null === (u2 = this.webVitalsAutocapture) || void 0 === u2 || u2.onRemoteConfig(t2), null === (c6 = this.exceptionObserver) || void 0 === c6 || c6.onRemoteConfig(t2), null === (d2 = this.deadClicksAutocapture) || void 0 === d2 || d2.onRemoteConfig(t2);
  }
  _loaded() {
    try {
      this.config.loaded(this);
    } catch (e2) {
      q$3.critical("`loaded` function failed", e2);
    }
    this._start_queue_if_opted_in(), this.config.capture_pageview && setTimeout(() => {
      this.consent.isOptedIn() && this._captureInitialPageview();
    }, 1), new rr(this).load(), this.featureFlags.decide();
  }
  _start_queue_if_opted_in() {
    var e2;
    this.has_opted_out_capturing() || this.config.request_batching && (null === (e2 = this._requestQueue) || void 0 === e2 || e2.enable());
  }
  _dom_loaded() {
    this.has_opted_out_capturing() || J$1(this.__request_queue, (e2) => this._send_retriable_request(e2)), this.__request_queue = [], this._start_queue_if_opted_in();
  }
  _handle_unload() {
    var e2, t2;
    this.config.request_batching ? (this._shouldCapturePageleave() && this.capture("$pageleave"), null === (e2 = this._requestQueue) || void 0 === e2 || e2.unload(), null === (t2 = this._retryQueue) || void 0 === t2 || t2.unload()) : this._shouldCapturePageleave() && this.capture("$pageleave", null, { transport: "sendBeacon" });
  }
  _send_request(e2) {
    this.__loaded && (oo ? this.__request_queue.push(e2) : this.rateLimiter.isServerRateLimited(e2.batchKey) || (e2.transport = e2.transport || this.config.api_transport, e2.url = _r(e2.url, { ip: this.config.ip ? 1 : 0 }), e2.headers = j$2({}, this.config.request_headers), e2.compression = "best-available" === e2.compression ? this.compression : e2.compression, e2.fetchOptions = e2.fetchOptions || this.config.fetch_options, ((e3) => {
      var t2, i, n2, r2 = j$2({}, e3);
      r2.timeout = r2.timeout || 6e4, r2.url = _r(r2.url, { _: (/* @__PURE__ */ new Date()).getTime().toString(), ver: p$2.LIB_VERSION, compression: r2.compression });
      var s2 = null !== (t2 = r2.transport) && void 0 !== t2 ? t2 : "fetch", o2 = null !== (i = null === (n2 = ne(gr, (e4) => e4.transport === s2)) || void 0 === n2 ? void 0 : n2.method) && void 0 !== i ? i : gr[0].method;
      if (!o2) throw new Error("No available transport method");
      o2(r2);
    })(j$2(j$2({}, e2), {}, { callback: (t2) => {
      var i, n2, r2;
      (this.rateLimiter.checkForLimiting(t2), t2.statusCode >= 400) && (null === (n2 = (r2 = this.config).on_request_error) || void 0 === n2 || n2.call(r2, t2));
      null === (i = e2.callback) || void 0 === i || i.call(e2, t2);
    } }))));
  }
  _send_retriable_request(e2) {
    this._retryQueue ? this._retryQueue.retriableRequest(e2) : this._send_request(e2);
  }
  _execute_array(e2) {
    var t2, i = [], n2 = [], r2 = [];
    J$1(e2, (e3) => {
      e3 && (t2 = e3[0], x$3(t2) ? r2.push(e3) : I$1(e3) ? e3.call(this) : x$3(e3) && "alias" === t2 ? i.push(e3) : x$3(e3) && -1 !== t2.indexOf("capture") && I$1(this[t2]) ? r2.push(e3) : n2.push(e3));
    });
    var s2 = function(e3, t3) {
      J$1(e3, function(e4) {
        if (x$3(e4[0])) {
          var i2 = t3;
          Y$1(e4, function(e5) {
            i2 = i2[e5[0]].apply(i2, e5.slice(1));
          });
        } else this[e4[0]].apply(this, e4.slice(1));
      }, t3);
    };
    s2(i, this), s2(n2, this), s2(r2, this);
  }
  _hasBootstrappedFeatureFlags() {
    var e2, t2;
    return (null === (e2 = this.config.bootstrap) || void 0 === e2 ? void 0 : e2.featureFlags) && Object.keys(null === (t2 = this.config.bootstrap) || void 0 === t2 ? void 0 : t2.featureFlags).length > 0 || false;
  }
  push(e2) {
    this._execute_array([e2]);
  }
  capture(e2, t2, i) {
    var n2;
    if (this.__loaded && this.persistence && this.sessionPersistence && this._requestQueue) {
      if (!this.consent.isOptedOut()) if (!R$1(e2) && F$2(e2)) {
        if (this.config.opt_out_useragent_filter || !this._is_bot()) {
          var r2 = null != i && i.skip_client_rate_limiting ? void 0 : this.rateLimiter.clientRateLimitContext();
          if (null == r2 || !r2.isRateLimited) {
            this.sessionPersistence.update_search_keyword(), this.config.store_google && this.sessionPersistence.update_campaign_params(), this.config.save_referrer && this.sessionPersistence.update_referrer_info(), (this.config.store_google || this.config.save_referrer) && this.persistence.set_initial_person_info();
            var s2 = /* @__PURE__ */ new Date(), o2 = (null == i ? void 0 : i.timestamp) || s2, a2 = { uuid: Ze(), event: e2, properties: this._calculate_event_properties(e2, t2 || {}, o2) };
            r2 && (a2.properties.$lib_rate_limit_remaining_tokens = r2.remainingTokens), (null == i ? void 0 : i.$set) && (a2.$set = null == i ? void 0 : i.$set);
            var l2 = this._calculate_set_once_properties(null == i ? void 0 : i.$set_once);
            l2 && (a2.$set_once = l2), (a2 = te(a2, null != i && i._noTruncate ? null : this.config.properties_string_max_length)).timestamp = o2, R$1(null == i ? void 0 : i.timestamp) || (a2.properties.$event_time_override_provided = true, a2.properties.$event_time_override_system_time = s2);
            var u2 = j$2(j$2({}, a2.properties.$set), a2.$set);
            if (P$2(u2) || this.setPersonPropertiesForFlags(u2), !O$1(this.config.before_send)) {
              var c6 = this._runBeforeSend(a2);
              if (!c6) return;
              a2 = c6;
            }
            this._internalEventEmitter.emit("eventCaptured", a2);
            var d2 = { method: "POST", url: null !== (n2 = null == i ? void 0 : i._url) && void 0 !== n2 ? n2 : this.requestRouter.endpointFor("api", this.analyticsDefaultEndpoint), data: a2, compression: "best-available", batchKey: null == i ? void 0 : i._batchKey };
            return !this.config.request_batching || i && (null == i || !i._batchKey) || null != i && i.send_instantly ? this._send_retriable_request(d2) : this._requestQueue.enqueue(d2), a2;
          }
          q$3.critical("This capture call is ignored due to client rate limiting.");
        }
      } else q$3.error("No event name provided to posthog.capture");
    } else q$3.uninitializedWarning("posthog.capture");
  }
  _addCaptureHook(e2) {
    return this.on("eventCaptured", (t2) => e2(t2.event, t2));
  }
  _calculate_event_properties(e2, t2, i) {
    if (i = i || /* @__PURE__ */ new Date(), !this.persistence || !this.sessionPersistence) return t2;
    var n2 = this.persistence.remove_event_timer(e2), r2 = j$2({}, t2);
    if (r2.token = this.config.token, this.config.__preview_experimental_cookieless_mode && (r2.$cklsh_mode = true), "$snapshot" === e2) {
      var s2 = j$2(j$2({}, this.persistence.properties()), this.sessionPersistence.properties());
      return r2.distinct_id = s2.distinct_id, (!F$2(r2.distinct_id) && !L$1(r2.distinct_id) || T$2(r2.distinct_id)) && q$3.error("Invalid distinct_id for replay event. This indicates a bug in your implementation"), r2;
    }
    var o2 = fi.properties();
    if (this.sessionManager) {
      var { sessionId: l2, windowId: u2 } = this.sessionManager.checkAndGetSessionAndWindowId();
      r2.$session_id = l2, r2.$window_id = u2;
    }
    if (this.sessionRecording && (r2.$recording_status = this.sessionRecording.status), this.requestRouter.region === br.CUSTOM && (r2.$lib_custom_api_host = this.config.api_host), this.sessionPropsManager && this.config.__preview_send_client_session_params && ("$pageview" === e2 || "$pageleave" === e2 || "$autocapture" === e2)) {
      var c6 = this.sessionPropsManager.getSessionProps();
      r2 = K$1(r2, c6);
    }
    if (!this.config.disable_scroll_properties) {
      var d2 = {};
      "$pageview" === e2 ? d2 = this.pageViewManager.doPageView(i) : "$pageleave" === e2 && (d2 = this.pageViewManager.doPageLeave(i)), r2 = K$1(r2, d2);
    }
    if ("$pageview" === e2 && a$1 && (r2.title = a$1.title), !R$1(n2)) {
      var _2 = i.getTime() - n2;
      r2.$duration = parseFloat((_2 / 1e3).toFixed(3));
    }
    h$2 && this.config.opt_out_useragent_filter && (r2.$browser_type = this._is_bot() ? "bot" : "browser"), (r2 = K$1({}, o2, this.persistence.properties(), this.sessionPersistence.properties(), r2)).$is_identified = this._isIdentified(), x$3(this.config.property_denylist) ? Y$1(this.config.property_denylist, function(e3) {
      delete r2[e3];
    }) : q$3.error("Invalid value for property_denylist config: " + this.config.property_denylist + " or property_blacklist config: " + this.config.property_blacklist);
    var p2 = this.config.sanitize_properties;
    p2 && (r2 = p2(r2, e2));
    var v2 = this._hasPersonProcessing();
    return r2.$process_person_profile = v2, v2 && this._requirePersonProcessing("_calculate_event_properties"), r2;
  }
  _calculate_set_once_properties(e2) {
    if (!this.persistence || !this._hasPersonProcessing()) return e2;
    var t2 = K$1({}, this.persistence.get_initial_props(), e2 || {}), i = this.config.sanitize_properties;
    return i && (t2 = i(t2, "$set_once")), P$2(t2) ? void 0 : t2;
  }
  register(e2, t2) {
    var i;
    null === (i = this.persistence) || void 0 === i || i.register(e2, t2);
  }
  register_once(e2, t2, i) {
    var n2;
    null === (n2 = this.persistence) || void 0 === n2 || n2.register_once(e2, t2, i);
  }
  register_for_session(e2) {
    var t2;
    null === (t2 = this.sessionPersistence) || void 0 === t2 || t2.register(e2);
  }
  unregister(e2) {
    var t2;
    null === (t2 = this.persistence) || void 0 === t2 || t2.unregister(e2);
  }
  unregister_for_session(e2) {
    var t2;
    null === (t2 = this.sessionPersistence) || void 0 === t2 || t2.unregister(e2);
  }
  _register_single(e2, t2) {
    this.register({ [e2]: t2 });
  }
  getFeatureFlag(e2, t2) {
    return this.featureFlags.getFeatureFlag(e2, t2);
  }
  getFeatureFlagPayload(e2) {
    var t2 = this.featureFlags.getFeatureFlagPayload(e2);
    try {
      return JSON.parse(t2);
    } catch (e3) {
      return t2;
    }
  }
  isFeatureEnabled(e2, t2) {
    return this.featureFlags.isFeatureEnabled(e2, t2);
  }
  reloadFeatureFlags() {
    this.featureFlags.reloadFeatureFlags();
  }
  updateEarlyAccessFeatureEnrollment(e2, t2) {
    this.featureFlags.updateEarlyAccessFeatureEnrollment(e2, t2);
  }
  getEarlyAccessFeatures(e2) {
    var t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    return this.featureFlags.getEarlyAccessFeatures(e2, t2);
  }
  on(e2, t2) {
    return this._internalEventEmitter.on(e2, t2);
  }
  onFeatureFlags(e2) {
    return this.featureFlags.onFeatureFlags(e2);
  }
  onSessionId(e2) {
    var t2, i;
    return null !== (t2 = null === (i = this.sessionManager) || void 0 === i ? void 0 : i.onSessionId(e2)) && void 0 !== t2 ? t2 : () => {
    };
  }
  getSurveys(e2) {
    var t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    this.surveys.getSurveys(e2, t2);
  }
  getActiveMatchingSurveys(e2) {
    var t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    this.surveys.getActiveMatchingSurveys(e2, t2);
  }
  renderSurvey(e2, t2) {
    this.surveys.renderSurvey(e2, t2);
  }
  canRenderSurvey(e2) {
    this.surveys.canRenderSurvey(e2);
  }
  getNextSurveyStep(e2, t2, i) {
    return this.surveys.getNextSurveyStep(e2, t2, i);
  }
  identify(e2, t2, i) {
    if (!this.__loaded || !this.persistence) return q$3.uninitializedWarning("posthog.identify");
    if (L$1(e2) && (e2 = e2.toString(), q$3.warn("The first argument to posthog.identify was a number, but it should be a string. It has been converted to a string.")), e2) {
      if (["distinct_id", "distinctid"].includes(e2.toLowerCase())) q$3.critical('The string "'.concat(e2, '" was set in posthog.identify which indicates an error. This ID should be unique to the user and not a hardcoded string.'));
      else if (this._requirePersonProcessing("posthog.identify")) {
        var n2 = this.get_distinct_id();
        if (this.register({ $user_id: e2 }), !this.get_property("$device_id")) {
          var r2 = n2;
          this.register_once({ $had_persisted_distinct_id: true, $device_id: r2 }, "");
        }
        e2 !== n2 && e2 !== this.get_property(se) && (this.unregister(se), this.register({ distinct_id: e2 }));
        var s2 = "anonymous" === (this.persistence.get_property(Te) || "anonymous");
        e2 !== n2 && s2 ? (this.persistence.set_property(Te, "identified"), this.setPersonPropertiesForFlags(t2 || {}, false), this.capture("$identify", { distinct_id: e2, $anon_distinct_id: n2 }, { $set: t2 || {}, $set_once: i || {} }), this.featureFlags.setAnonymousDistinctId(n2)) : (t2 || i) && this.setPersonProperties(t2, i), e2 !== n2 && (this.reloadFeatureFlags(), this.unregister(Fe));
      }
    } else q$3.error("Unique user id has not been set in posthog.identify");
  }
  setPersonProperties(e2, t2) {
    (e2 || t2) && this._requirePersonProcessing("posthog.setPersonProperties") && (this.setPersonPropertiesForFlags(e2 || {}), this.capture("$set", { $set: e2 || {}, $set_once: t2 || {} }));
  }
  group(e2, t2, i) {
    if (e2 && t2) {
      if (this._requirePersonProcessing("posthog.group")) {
        var n2 = this.getGroups();
        n2[e2] !== t2 && this.resetGroupPropertiesForFlags(e2), this.register({ $groups: j$2(j$2({}, n2), {}, { [e2]: t2 }) }), i && (this.capture("$groupidentify", { $group_type: e2, $group_key: t2, $group_set: i }), this.setGroupPropertiesForFlags({ [e2]: i })), n2[e2] === t2 || i || this.reloadFeatureFlags();
      }
    } else q$3.error("posthog.group requires a group type and group key");
  }
  resetGroups() {
    this.register({ $groups: {} }), this.resetGroupPropertiesForFlags(), this.reloadFeatureFlags();
  }
  setPersonPropertiesForFlags(e2) {
    var t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    this.featureFlags.setPersonPropertiesForFlags(e2, t2);
  }
  resetPersonPropertiesForFlags() {
    this.featureFlags.resetPersonPropertiesForFlags();
  }
  setGroupPropertiesForFlags(e2) {
    var t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    this._requirePersonProcessing("posthog.setGroupPropertiesForFlags") && this.featureFlags.setGroupPropertiesForFlags(e2, t2);
  }
  resetGroupPropertiesForFlags(e2) {
    this.featureFlags.resetGroupPropertiesForFlags(e2);
  }
  reset(e2) {
    var t2, i, n2, r2, s2;
    if (q$3.info("reset"), !this.__loaded) return q$3.uninitializedWarning("posthog.reset");
    var o2 = this.get_property("$device_id");
    if (this.consent.reset(), null === (t2 = this.persistence) || void 0 === t2 || t2.clear(), null === (i = this.sessionPersistence) || void 0 === i || i.clear(), null === (n2 = this.surveys) || void 0 === n2 || n2.reset(), null === (r2 = this.persistence) || void 0 === r2 || r2.set_property(Te, "anonymous"), null === (s2 = this.sessionManager) || void 0 === s2 || s2.resetSessionId(), this.config.__preview_experimental_cookieless_mode) this.register_once({ distinct_id: qe, $device_id: null }, "");
    else {
      var a2 = this.config.get_device_id(Ze());
      this.register_once({ distinct_id: a2, $device_id: e2 ? a2 : o2 }, "");
    }
  }
  get_distinct_id() {
    return this.get_property("distinct_id");
  }
  getGroups() {
    return this.get_property("$groups") || {};
  }
  get_session_id() {
    var e2, t2;
    return null !== (e2 = null === (t2 = this.sessionManager) || void 0 === t2 ? void 0 : t2.checkAndGetSessionAndWindowId(true).sessionId) && void 0 !== e2 ? e2 : "";
  }
  get_session_replay_url(e2) {
    if (!this.sessionManager) return "";
    var { sessionId: t2, sessionStartTimestamp: i } = this.sessionManager.checkAndGetSessionAndWindowId(true), n2 = this.requestRouter.endpointFor("ui", "/project/".concat(this.config.token, "/replay/").concat(t2));
    if (null != e2 && e2.withTimestamp && i) {
      var r2, s2 = null !== (r2 = e2.timestampLookBack) && void 0 !== r2 ? r2 : 10;
      if (!i) return n2;
      var o2 = Math.max(Math.floor(((/* @__PURE__ */ new Date()).getTime() - i) / 1e3) - s2, 0);
      n2 += "?t=".concat(o2);
    }
    return n2;
  }
  alias(e2, t2) {
    return e2 === this.get_property(re$2) ? (q$3.critical("Attempting to create alias for existing People user - aborting."), -2) : this._requirePersonProcessing("posthog.alias") ? (R$1(t2) && (t2 = this.get_distinct_id()), e2 !== t2 ? (this._register_single(se, e2), this.capture("$create_alias", { alias: e2, distinct_id: t2 })) : (q$3.warn("alias matches current distinct_id - skipping api call."), this.identify(e2), -1)) : void 0;
  }
  set_config(e2) {
    var t2, i, n2, r2, s2 = j$2({}, this.config);
    C$2(e2) && (K$1(this.config, lo(e2)), null === (t2 = this.persistence) || void 0 === t2 || t2.update_config(this.config, s2), this.sessionPersistence = "sessionStorage" === this.config.persistence || "memory" === this.config.persistence ? this.persistence : new bi(j$2(j$2({}, this.config), {}, { persistence: "sessionStorage" })), at.is_supported() && "true" === at.get("ph_debug") && (this.config.debug = true), this.config.debug && (p$2.DEBUG = true, q$3.info("set_config", { config: e2, oldConfig: s2, newConfig: j$2({}, this.config) })), null === (i = this.sessionRecording) || void 0 === i || i.startIfEnabledOrStop(), null === (n2 = this.autocapture) || void 0 === n2 || n2.startIfEnabled(), null === (r2 = this.heatmaps) || void 0 === r2 || r2.startIfEnabled(), this.surveys.loadIfEnabled(), this._sync_opt_out_with_persistence());
  }
  startSessionRecording(e2) {
    var t2 = true === e2, i = { sampling: t2 || !(null == e2 || !e2.sampling), linked_flag: t2 || !(null == e2 || !e2.linked_flag), url_trigger: t2 || !(null == e2 || !e2.url_trigger), event_trigger: t2 || !(null == e2 || !e2.event_trigger) };
    if (Object.values(i).some(Boolean)) {
      var n2, r2, s2, o2, a2;
      if (null === (n2 = this.sessionManager) || void 0 === n2 || n2.checkAndGetSessionAndWindowId(), i.sampling) null === (r2 = this.sessionRecording) || void 0 === r2 || r2.overrideSampling();
      if (i.linked_flag) null === (s2 = this.sessionRecording) || void 0 === s2 || s2.overrideLinkedFlag();
      if (i.url_trigger) null === (o2 = this.sessionRecording) || void 0 === o2 || o2.overrideTrigger("url");
      if (i.event_trigger) null === (a2 = this.sessionRecording) || void 0 === a2 || a2.overrideTrigger("event");
    }
    this.set_config({ disable_session_recording: false });
  }
  stopSessionRecording() {
    this.set_config({ disable_session_recording: true });
  }
  sessionRecordingStarted() {
    var e2;
    return !(null === (e2 = this.sessionRecording) || void 0 === e2 || !e2.started);
  }
  captureException(e2, t2) {
    var i, n2 = new Error("PostHog syntheticException"), r2 = I$1(null === (i = _$1.__PosthogExtensions__) || void 0 === i ? void 0 : i.parseErrorAsProperties) ? _$1.__PosthogExtensions__.parseErrorAsProperties([e2.message, void 0, void 0, void 0, e2], { syntheticException: n2 }) : j$2({ $exception_level: "error", $exception_list: [{ type: e2.name, value: e2.message, mechanism: { handled: true, synthetic: false } }] }, t2);
    this.exceptions.sendExceptionEvent(r2);
  }
  loadToolbar(e2) {
    return this.toolbar.loadToolbar(e2);
  }
  get_property(e2) {
    var t2;
    return null === (t2 = this.persistence) || void 0 === t2 ? void 0 : t2.props[e2];
  }
  getSessionProperty(e2) {
    var t2;
    return null === (t2 = this.sessionPersistence) || void 0 === t2 ? void 0 : t2.props[e2];
  }
  toString() {
    var e2, t2 = null !== (e2 = this.config.name) && void 0 !== e2 ? e2 : so;
    return t2 !== so && (t2 = so + "." + t2), t2;
  }
  _isIdentified() {
    var e2, t2;
    return "identified" === (null === (e2 = this.persistence) || void 0 === e2 ? void 0 : e2.get_property(Te)) || "identified" === (null === (t2 = this.sessionPersistence) || void 0 === t2 ? void 0 : t2.get_property(Te));
  }
  _hasPersonProcessing() {
    var e2, t2, i, n2;
    return !("never" === this.config.person_profiles || "identified_only" === this.config.person_profiles && !this._isIdentified() && P$2(this.getGroups()) && (null === (e2 = this.persistence) || void 0 === e2 || null === (t2 = e2.props) || void 0 === t2 || !t2[se]) && (null === (i = this.persistence) || void 0 === i || null === (n2 = i.props) || void 0 === n2 || !n2[De]));
  }
  _shouldCapturePageleave() {
    return true === this.config.capture_pageleave || "if_capture_pageview" === this.config.capture_pageleave && this.config.capture_pageview;
  }
  createPersonProfile() {
    this._hasPersonProcessing() || this._requirePersonProcessing("posthog.createPersonProfile") && this.setPersonProperties({}, {});
  }
  _requirePersonProcessing(e2) {
    return "never" === this.config.person_profiles ? (q$3.error(e2 + ' was called, but process_person is set to "never". This call will be ignored.'), false) : (this._register_single(De, true), true);
  }
  _sync_opt_out_with_persistence() {
    var e2, t2, i, n2, r2 = this.consent.isOptedOut(), s2 = this.config.opt_out_persistence_by_default, o2 = this.config.disable_persistence || r2 && !!s2;
    (null === (e2 = this.persistence) || void 0 === e2 ? void 0 : e2.disabled) !== o2 && (null === (i = this.persistence) || void 0 === i || i.set_disabled(o2));
    (null === (t2 = this.sessionPersistence) || void 0 === t2 ? void 0 : t2.disabled) !== o2 && (null === (n2 = this.sessionPersistence) || void 0 === n2 || n2.set_disabled(o2));
  }
  opt_in_capturing(e2) {
    var t2;
    (this.consent.optInOut(true), this._sync_opt_out_with_persistence(), R$1(null == e2 ? void 0 : e2.captureEventName) || null != e2 && e2.captureEventName) && this.capture(null !== (t2 = null == e2 ? void 0 : e2.captureEventName) && void 0 !== t2 ? t2 : "$opt_in", null == e2 ? void 0 : e2.captureProperties, { send_instantly: true });
    this.config.capture_pageview && this._captureInitialPageview();
  }
  opt_out_capturing() {
    this.consent.optInOut(false), this._sync_opt_out_with_persistence();
  }
  has_opted_in_capturing() {
    return this.consent.isOptedIn();
  }
  has_opted_out_capturing() {
    return this.consent.isOptedOut();
  }
  clear_opt_in_out_capturing() {
    this.consent.reset(), this._sync_opt_out_with_persistence();
  }
  _is_bot() {
    return o$1 ? Is(o$1, this.config.custom_blocked_useragents) : void 0;
  }
  _captureInitialPageview() {
    a$1 && !this._initialPageviewCaptured && (this._initialPageviewCaptured = true, this.capture("$pageview", { title: a$1.title }, { send_instantly: true }));
  }
  debug(e2) {
    false === e2 ? (null == t$2 || t$2.console.log("You've disabled debug mode."), localStorage && localStorage.removeItem("ph_debug"), this.set_config({ debug: false })) : (null == t$2 || t$2.console.log("You're now in debug mode. All calls to PostHog will be logged in your console.\nYou can disable this with `posthog.debug(false)`."), localStorage && localStorage.setItem("ph_debug", "true"), this.set_config({ debug: true }));
  }
  _runBeforeSend(e2) {
    if (O$1(this.config.before_send)) return e2;
    var t2 = x$3(this.config.before_send) ? this.config.before_send : [this.config.before_send], i = e2;
    for (var n2 of t2) {
      if (i = n2(i), O$1(i)) {
        var r2 = "Event '".concat(e2.event, "' was rejected in beforeSend function");
        return D$2(e2.event) ? q$3.warn("".concat(r2, ". This can cause unexpected behavior.")) : q$3.info(r2), null;
      }
      i.properties && !P$2(i.properties) || q$3.warn("Event '".concat(e2.event, "' has no properties after beforeSend function, this is likely an error."));
    }
    return i;
  }
}
!function(e2, t2) {
  for (var i = 0; i < t2.length; i++) e2.prototype[t2[i]] = Z$1(e2.prototype[t2[i]]);
}(co, ["identify"]);
var ho, _o = (ho = no[so] = new co(), function() {
  function e2() {
    e2.done || (e2.done = true, oo = false, Y$1(no, function(e3) {
      e3._dom_loaded();
    }));
  }
  null != a$1 && a$1.addEventListener && ("complete" === a$1.readyState ? e2() : a$1.addEventListener("DOMContentLoaded", e2, false)), t$2 && ie(t$2, "load", e2, true);
}(), ho);
var t$1, r$1, u, i$1, o = 0, f$1 = [], c$1 = [], e$1 = l$3, a = e$1.__b, v$1 = e$1.__r, l$1 = e$1.diffed, m$1 = e$1.__c, s = e$1.unmount, d$1 = e$1.__;
function h$1(n2, t2) {
  e$1.__h && e$1.__h(r$1, n2, o || t2), o = 0;
  var u2 = r$1.__H || (r$1.__H = { __: [], __h: [] });
  return n2 >= u2.__.length && u2.__.push({ __V: c$1 }), u2.__[n2];
}
function p$1(n2) {
  return o = 1, y$1(D$1, n2);
}
function y$1(n2, u2, i) {
  var o2 = h$1(t$1++, 2);
  if (o2.t = n2, !o2.__c && (o2.__ = [i ? i(u2) : D$1(void 0, u2), function(n3) {
    var t2 = o2.__N ? o2.__N[0] : o2.__[0], r2 = o2.t(t2, n3);
    t2 !== r2 && (o2.__N = [r2, o2.__[1]], o2.__c.setState({}));
  }], o2.__c = r$1, !r$1.u)) {
    var f2 = function(n3, t2, r2) {
      if (!o2.__c.__H) return true;
      var u3 = o2.__c.__H.__.filter(function(n4) {
        return !!n4.__c;
      });
      if (u3.every(function(n4) {
        return !n4.__N;
      })) return !c6 || c6.call(this, n3, t2, r2);
      var i2 = false;
      return u3.forEach(function(n4) {
        if (n4.__N) {
          var t3 = n4.__[0];
          n4.__ = n4.__N, n4.__N = void 0, t3 !== n4.__[0] && (i2 = true);
        }
      }), !(!i2 && o2.__c.props === n3) && (!c6 || c6.call(this, n3, t2, r2));
    };
    r$1.u = true;
    var c6 = r$1.shouldComponentUpdate, e2 = r$1.componentWillUpdate;
    r$1.componentWillUpdate = function(n3, t2, r2) {
      if (this.__e) {
        var u3 = c6;
        c6 = void 0, f2(n3, t2, r2), c6 = u3;
      }
      e2 && e2.call(this, n3, t2, r2);
    }, r$1.shouldComponentUpdate = f2;
  }
  return o2.__N || o2.__;
}
function _(n2, u2) {
  var i = h$1(t$1++, 3);
  !e$1.__s && C$1(i.__H, u2) && (i.__ = n2, i.i = u2, r$1.__H.__h.push(i));
}
function A$2(n2, u2) {
  var i = h$1(t$1++, 4);
  !e$1.__s && C$1(i.__H, u2) && (i.__ = n2, i.i = u2, r$1.__h.push(i));
}
function F$1(n2) {
  return o = 5, q$2(function() {
    return { current: n2 };
  }, []);
}
function T$1(n2, t2, r2) {
  o = 6, A$2(function() {
    return "function" == typeof n2 ? (n2(t2()), function() {
      return n2(null);
    }) : n2 ? (n2.current = t2(), function() {
      return n2.current = null;
    }) : void 0;
  }, null == r2 ? r2 : r2.concat(n2));
}
function q$2(n2, r2) {
  var u2 = h$1(t$1++, 7);
  return C$1(u2.__H, r2) ? (u2.__V = n2(), u2.i = r2, u2.__h = n2, u2.__V) : u2.__;
}
function x$2(n2, t2) {
  return o = 8, q$2(function() {
    return n2;
  }, t2);
}
function P$1(n2) {
  var u2 = r$1.context[n2.__c], i = h$1(t$1++, 9);
  return i.c = n2, u2 ? (null == i.__ && (i.__ = true, u2.sub(r$1)), u2.props.value) : n2.__;
}
function V$1(n2, t2) {
  e$1.useDebugValue && e$1.useDebugValue(t2 ? t2(n2) : n2);
}
function b$1(n2) {
  var u2 = h$1(t$1++, 10), i = p$1();
  return u2.__ = n2, r$1.componentDidCatch || (r$1.componentDidCatch = function(n3, t2) {
    u2.__ && u2.__(n3, t2), i[1](n3);
  }), [i[0], function() {
    i[1](void 0);
  }];
}
function g$1() {
  var n2 = h$1(t$1++, 11);
  if (!n2.__) {
    for (var u2 = r$1.__v; null !== u2 && !u2.__m && null !== u2.__; ) u2 = u2.__;
    var i = u2.__m || (u2.__m = [0, 0]);
    n2.__ = "P" + i[0] + "-" + i[1]++;
  }
  return n2.__;
}
function j$1() {
  for (var n2; n2 = f$1.shift(); ) if (n2.__P && n2.__H) try {
    n2.__H.__h.forEach(z$2), n2.__H.__h.forEach(B$1), n2.__H.__h = [];
  } catch (t2) {
    n2.__H.__h = [], e$1.__e(t2, n2.__v);
  }
}
e$1.__b = function(n2) {
  r$1 = null, a && a(n2);
}, e$1.__ = function(n2, t2) {
  n2 && t2.__k && t2.__k.__m && (n2.__m = t2.__k.__m), d$1 && d$1(n2, t2);
}, e$1.__r = function(n2) {
  v$1 && v$1(n2), t$1 = 0;
  var i = (r$1 = n2.__c).__H;
  i && (u === r$1 ? (i.__h = [], r$1.__h = [], i.__.forEach(function(n3) {
    n3.__N && (n3.__ = n3.__N), n3.__V = c$1, n3.__N = n3.i = void 0;
  })) : (i.__h.forEach(z$2), i.__h.forEach(B$1), i.__h = [], t$1 = 0)), u = r$1;
}, e$1.diffed = function(n2) {
  l$1 && l$1(n2);
  var t2 = n2.__c;
  t2 && t2.__H && (t2.__H.__h.length && (1 !== f$1.push(t2) && i$1 === e$1.requestAnimationFrame || ((i$1 = e$1.requestAnimationFrame) || w$2)(j$1)), t2.__H.__.forEach(function(n3) {
    n3.i && (n3.__H = n3.i), n3.__V !== c$1 && (n3.__ = n3.__V), n3.i = void 0, n3.__V = c$1;
  })), u = r$1 = null;
}, e$1.__c = function(n2, t2) {
  t2.some(function(n3) {
    try {
      n3.__h.forEach(z$2), n3.__h = n3.__h.filter(function(n4) {
        return !n4.__ || B$1(n4);
      });
    } catch (r2) {
      t2.some(function(n4) {
        n4.__h && (n4.__h = []);
      }), t2 = [], e$1.__e(r2, n3.__v);
    }
  }), m$1 && m$1(n2, t2);
}, e$1.unmount = function(n2) {
  s && s(n2);
  var t2, r2 = n2.__c;
  r2 && r2.__H && (r2.__H.__.forEach(function(n3) {
    try {
      z$2(n3);
    } catch (n4) {
      t2 = n4;
    }
  }), r2.__H = void 0, t2 && e$1.__e(t2, r2.__v));
};
var k$2 = "function" == typeof requestAnimationFrame;
function w$2(n2) {
  var t2, r2 = function() {
    clearTimeout(u2), k$2 && cancelAnimationFrame(t2), setTimeout(n2);
  }, u2 = setTimeout(r2, 100);
  k$2 && (t2 = requestAnimationFrame(r2));
}
function z$2(n2) {
  var t2 = r$1, u2 = n2.__c;
  "function" == typeof u2 && (n2.__c = void 0, u2()), r$1 = t2;
}
function B$1(n2) {
  var t2 = r$1;
  n2.__c = n2.__(), r$1 = t2;
}
function C$1(n2, t2) {
  return !n2 || n2.length !== t2.length || t2.some(function(t3, r2) {
    return t3 !== n2[r2];
  });
}
function D$1(n2, t2) {
  return "function" == typeof t2 ? t2(n2) : t2;
}
function S(n2, t2) {
  for (var e2 in t2) n2[e2] = t2[e2];
  return n2;
}
function C(n2, t2) {
  for (var e2 in n2) if ("__source" !== e2 && !(e2 in t2)) return true;
  for (var r2 in t2) if ("__source" !== r2 && n2[r2] !== t2[r2]) return true;
  return false;
}
function E(n2, t2) {
  this.props = n2, this.context = t2;
}
function w$1(n2, e2) {
  function r2(n3) {
    var t2 = this.props.ref, r3 = t2 == n3.ref;
    return !r3 && t2 && (t2.call ? t2(null) : t2.current = null), e2 ? !e2(this.props, n3) || !r3 : C(this.props, n3);
  }
  function u2(e3) {
    return this.shouldComponentUpdate = r2, y$3(n2, e3);
  }
  return u2.displayName = "Memo(" + (n2.displayName || n2.name) + ")", u2.prototype.isReactComponent = true, u2.__f = true, u2;
}
(E.prototype = new b$3()).isPureReactComponent = true, E.prototype.shouldComponentUpdate = function(n2, t2) {
  return C(this.props, n2) || C(this.state, t2);
};
var x$1 = l$3.__b;
l$3.__b = function(n2) {
  n2.type && n2.type.__f && n2.ref && (n2.props.ref = n2.ref, n2.ref = null), x$1 && x$1(n2);
};
var R = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.forward_ref") || 3911;
function N(n2) {
  function t2(t3) {
    var e2 = S({}, t3);
    return delete e2.ref, n2(e2, t3.ref || null);
  }
  return t2.$$typeof = R, t2.render = t2, t2.prototype.isReactComponent = t2.__f = true, t2.displayName = "ForwardRef(" + (n2.displayName || n2.name) + ")", t2;
}
var k$1 = function(n2, t2) {
  return null == n2 ? null : $$2($$2(n2).map(t2));
}, A$1 = { map: k$1, forEach: k$1, count: function(n2) {
  return n2 ? $$2(n2).length : 0;
}, only: function(n2) {
  var t2 = $$2(n2);
  if (1 !== t2.length) throw "Children.only";
  return t2[0];
}, toArray: $$2 }, M = l$3.__e;
l$3.__e = function(n2, t2, e2, r2) {
  if (n2.then) {
    for (var u2, o2 = t2; o2 = o2.__; ) if ((u2 = o2.__c) && u2.__c) return null == t2.__e && (t2.__e = e2.__e, t2.__k = e2.__k), u2.__c(n2, t2);
  }
  M(n2, t2, e2, r2);
};
var O = l$3.unmount;
function T(n2, t2, e2) {
  return n2 && (n2.__c && n2.__c.__H && (n2.__c.__H.__.forEach(function(n3) {
    "function" == typeof n3.__c && n3.__c();
  }), n2.__c.__H = null), null != (n2 = S({}, n2)).__c && (n2.__c.__P === e2 && (n2.__c.__P = t2), n2.__c = null), n2.__k = n2.__k && n2.__k.map(function(n3) {
    return T(n3, t2, e2);
  })), n2;
}
function F(n2, t2, e2) {
  return n2 && e2 && (n2.__v = null, n2.__k = n2.__k && n2.__k.map(function(n3) {
    return F(n3, t2, e2);
  }), n2.__c && n2.__c.__P === t2 && (n2.__e && e2.appendChild(n2.__e), n2.__c.__e = true, n2.__c.__P = e2)), n2;
}
function I() {
  this.__u = 0, this.t = null, this.__b = null;
}
function L(n2) {
  var t2 = n2.__.__c;
  return t2 && t2.__a && t2.__a(n2);
}
function U(n2) {
  var e2, r2, u2;
  function o2(o3) {
    if (e2 || (e2 = n2()).then(function(n3) {
      r2 = n3.default || n3;
    }, function(n3) {
      u2 = n3;
    }), u2) throw u2;
    if (!r2) throw e2;
    return y$3(r2, o3);
  }
  return o2.displayName = "Lazy", o2.__f = true, o2;
}
function D() {
  this.u = null, this.o = null;
}
l$3.unmount = function(n2) {
  var t2 = n2.__c;
  t2 && t2.__R && t2.__R(), t2 && 32 & n2.__u && (n2.type = null), O && O(n2);
}, (I.prototype = new b$3()).__c = function(n2, t2) {
  var e2 = t2.__c, r2 = this;
  null == r2.t && (r2.t = []), r2.t.push(e2);
  var u2 = L(r2.__v), o2 = false, i = function() {
    o2 || (o2 = true, e2.__R = null, u2 ? u2(l2) : l2());
  };
  e2.__R = i;
  var l2 = function() {
    if (!--r2.__u) {
      if (r2.state.__a) {
        var n3 = r2.state.__a;
        r2.__v.__k[0] = F(n3, n3.__c.__P, n3.__c.__O);
      }
      var t3;
      for (r2.setState({ __a: r2.__b = null }); t3 = r2.t.pop(); ) t3.forceUpdate();
    }
  };
  r2.__u++ || 32 & t2.__u || r2.setState({ __a: r2.__b = r2.__v.__k[0] }), n2.then(i, i);
}, I.prototype.componentWillUnmount = function() {
  this.t = [];
}, I.prototype.render = function(n2, e2) {
  if (this.__b) {
    if (this.__v.__k) {
      var r2 = document.createElement("div"), o2 = this.__v.__k[0].__c;
      this.__v.__k[0] = T(this.__b, r2, o2.__O = o2.__P);
    }
    this.__b = null;
  }
  var i = e2.__a && y$3(g$3, null, n2.fallback);
  return i && (i.__u &= -33), [y$3(g$3, null, e2.__a ? null : n2.children), i];
};
var V = function(n2, t2, e2) {
  if (++e2[1] === e2[0] && n2.o.delete(t2), n2.props.revealOrder && ("t" !== n2.props.revealOrder[0] || !n2.o.size)) for (e2 = n2.u; e2; ) {
    for (; e2.length > 3; ) e2.pop()();
    if (e2[1] < e2[0]) break;
    n2.u = e2 = e2[2];
  }
};
function W(n2) {
  return this.getChildContext = function() {
    return n2.context;
  }, n2.children;
}
function P(n2) {
  var e2 = this, r2 = n2.i;
  e2.componentWillUnmount = function() {
    N$2(null, e2.l), e2.l = null, e2.i = null;
  }, e2.i && e2.i !== r2 && e2.componentWillUnmount(), e2.l || (e2.i = r2, e2.l = { nodeType: 1, parentNode: r2, childNodes: [], appendChild: function(n3) {
    this.childNodes.push(n3), e2.i.appendChild(n3);
  }, insertBefore: function(n3, t2) {
    this.childNodes.push(n3), e2.i.appendChild(n3);
  }, removeChild: function(n3) {
    this.childNodes.splice(this.childNodes.indexOf(n3) >>> 1, 1), e2.i.removeChild(n3);
  } }), N$2(y$3(W, { context: e2.context }, n2.__v), e2.l);
}
function j(n2, e2) {
  var r2 = y$3(P, { __v: n2, i: e2 });
  return r2.containerInfo = e2, r2;
}
(D.prototype = new b$3()).__a = function(n2) {
  var t2 = this, e2 = L(t2.__v), r2 = t2.o.get(n2);
  return r2[0]++, function(u2) {
    var o2 = function() {
      t2.props.revealOrder ? (r2.push(u2), V(t2, n2, r2)) : u2();
    };
    e2 ? e2(o2) : o2();
  };
}, D.prototype.render = function(n2) {
  this.u = null, this.o = /* @__PURE__ */ new Map();
  var t2 = $$2(n2.children);
  n2.revealOrder && "b" === n2.revealOrder[0] && t2.reverse();
  for (var e2 = t2.length; e2--; ) this.o.set(t2[e2], this.u = [1, 0, this.u]);
  return n2.children;
}, D.prototype.componentDidUpdate = D.prototype.componentDidMount = function() {
  var n2 = this;
  this.o.forEach(function(t2, e2) {
    V(n2, e2, t2);
  });
};
var z$1 = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103, B = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image(!S)|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/, H = /^on(Ani|Tra|Tou|BeforeInp|Compo)/, Z = /[A-Z0-9]/g, Y = "undefined" != typeof document, $ = function(n2) {
  return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/ : /fil|che|ra/).test(n2);
};
function q$1(n2, t2, e2) {
  return null == t2.__k && (t2.textContent = ""), N$2(n2, t2), "function" == typeof e2 && e2(), n2 ? n2.__c : null;
}
function G(n2, t2, e2) {
  return q$4(n2, t2), "function" == typeof e2 && e2(), n2 ? n2.__c : null;
}
b$3.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function(t2) {
  Object.defineProperty(b$3.prototype, t2, { configurable: true, get: function() {
    return this["UNSAFE_" + t2];
  }, set: function(n2) {
    Object.defineProperty(this, t2, { configurable: true, writable: true, value: n2 });
  } });
});
var J = l$3.event;
function K() {
}
function Q() {
  return this.cancelBubble;
}
function X() {
  return this.defaultPrevented;
}
l$3.event = function(n2) {
  return J && (n2 = J(n2)), n2.persist = K, n2.isPropagationStopped = Q, n2.isDefaultPrevented = X, n2.nativeEvent = n2;
};
var nn, tn = { enumerable: false, configurable: true, get: function() {
  return this.class;
} }, en = l$3.vnode;
l$3.vnode = function(n2) {
  "string" == typeof n2.type && function(n3) {
    var t2 = n3.props, e2 = n3.type, u2 = {};
    for (var o2 in t2) {
      var i = t2[o2];
      if (!("value" === o2 && "defaultValue" in t2 && null == i || Y && "children" === o2 && "noscript" === e2 || "class" === o2 || "className" === o2)) {
        var l2 = o2.toLowerCase();
        "defaultValue" === o2 && "value" in t2 && null == t2.value ? o2 = "value" : "download" === o2 && true === i ? i = "" : "translate" === l2 && "no" === i ? i = false : "ondoubleclick" === l2 ? o2 = "ondblclick" : "onchange" !== l2 || "input" !== e2 && "textarea" !== e2 || $(t2.type) ? "onfocus" === l2 ? o2 = "onfocusin" : "onblur" === l2 ? o2 = "onfocusout" : H.test(o2) ? o2 = l2 : -1 === e2.indexOf("-") && B.test(o2) ? o2 = o2.replace(Z, "-$&").toLowerCase() : null === i && (i = void 0) : l2 = o2 = "oninput", "oninput" === l2 && u2[o2 = l2] && (o2 = "oninputCapture"), u2[o2] = i;
      }
    }
    "select" == e2 && u2.multiple && Array.isArray(u2.value) && (u2.value = $$2(t2.children).forEach(function(n4) {
      n4.props.selected = -1 != u2.value.indexOf(n4.props.value);
    })), "select" == e2 && null != u2.defaultValue && (u2.value = $$2(t2.children).forEach(function(n4) {
      n4.props.selected = u2.multiple ? -1 != u2.defaultValue.indexOf(n4.props.value) : u2.defaultValue == n4.props.value;
    })), t2.class && !t2.className ? (u2.class = t2.class, Object.defineProperty(u2, "className", tn)) : (t2.className && !t2.class || t2.class && t2.className) && (u2.class = u2.className = t2.className), n3.props = u2;
  }(n2), n2.$$typeof = z$1, en && en(n2);
};
var rn = l$3.__r;
l$3.__r = function(n2) {
  rn && rn(n2), nn = n2.__c;
};
var un2 = l$3.diffed;
l$3.diffed = function(n2) {
  un2 && un2(n2);
  var t2 = n2.props, e2 = n2.__e;
  null != e2 && "textarea" === n2.type && "value" in t2 && t2.value !== e2.value && (e2.value = null == t2.value ? "" : t2.value), nn = null;
};
var on = { ReactCurrentDispatcher: { current: { readContext: function(n2) {
  return nn.__n[n2.__c].props.value;
} } } }, ln = "17.0.2";
function cn(n2) {
  return y$3.bind(null, n2);
}
function fn(n2) {
  return !!n2 && n2.$$typeof === z$1;
}
function an(n2) {
  return fn(n2) && n2.type === g$3;
}
function sn(n2) {
  return !!n2 && !!n2.displayName && ("string" == typeof n2.displayName || n2.displayName instanceof String) && n2.displayName.startsWith("Memo(");
}
function hn(n2) {
  return fn(n2) ? B$3.apply(null, arguments) : n2;
}
function vn(n2) {
  return !!n2.__k && (N$2(null, n2), true);
}
function dn(n2) {
  return n2 && (n2.base || 1 === n2.nodeType && n2) || null;
}
var pn = function(n2, t2) {
  return n2(t2);
}, mn = function(n2, t2) {
  return n2(t2);
}, yn = g$3;
function _n(n2) {
  n2();
}
function bn(n2) {
  return n2;
}
function gn() {
  return [false, _n];
}
var Sn = A$2, Cn = fn;
function En(n2, t2) {
  var e2 = t2(), r2 = p$1({ h: { __: e2, v: t2 } }), u2 = r2[0].h, o2 = r2[1];
  return A$2(function() {
    u2.__ = e2, u2.v = t2, wn(u2) && o2({ h: u2 });
  }, [n2, e2, t2]), _(function() {
    return wn(u2) && o2({ h: u2 }), n2(function() {
      wn(u2) && o2({ h: u2 });
    });
  }, [n2]), e2;
}
function wn(n2) {
  var t2, e2, r2 = n2.v, u2 = n2.__;
  try {
    var o2 = r2();
    return !((t2 = u2) === (e2 = o2) && (0 !== t2 || 1 / t2 == 1 / e2) || t2 != t2 && e2 != e2);
  } catch (n3) {
    return true;
  }
}
var xn = { useState: p$1, useId: g$1, useReducer: y$1, useEffect: _, useLayoutEffect: A$2, useInsertionEffect: Sn, useTransition: gn, useDeferredValue: bn, useSyncExternalStore: En, startTransition: _n, useRef: F$1, useImperativeHandle: T$1, useMemo: q$2, useCallback: x$2, useContext: P$1, useDebugValue: V$1, version: "17.0.2", Children: A$1, render: q$1, hydrate: G, unmountComponentAtNode: vn, createPortal: j, createElement: y$3, createContext: E$2, createFactory: cn, cloneElement: hn, createRef: _$2, Fragment: g$3, isValidElement: fn, isElement: Cn, isFragment: an, isMemo: sn, findDOMNode: dn, Component: b$3, PureComponent: E, memo: w$1, forwardRef: N, flushSync: mn, unstable_batchedUpdates: pn, StrictMode: yn, Suspense: I, SuspenseList: D, lazy: U, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: on };
const React = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Children: A$1,
  Component: b$3,
  Fragment: g$3,
  PureComponent: E,
  StrictMode: yn,
  Suspense: I,
  SuspenseList: D,
  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: on,
  cloneElement: hn,
  createContext: E$2,
  createElement: y$3,
  createFactory: cn,
  createPortal: j,
  createRef: _$2,
  default: xn,
  findDOMNode: dn,
  flushSync: mn,
  forwardRef: N,
  hydrate: G,
  isElement: Cn,
  isFragment: an,
  isMemo: sn,
  isValidElement: fn,
  lazy: U,
  memo: w$1,
  render: q$1,
  startTransition: _n,
  unmountComponentAtNode: vn,
  unstable_batchedUpdates: pn,
  useCallback: x$2,
  useContext: P$1,
  useDebugValue: V$1,
  useDeferredValue: bn,
  useEffect: _,
  useErrorBoundary: b$1,
  useId: g$1,
  useImperativeHandle: T$1,
  useInsertionEffect: Sn,
  useLayoutEffect: A$2,
  useMemo: q$2,
  useReducer: y$1,
  useRef: F$1,
  useState: p$1,
  useSyncExternalStore: En,
  useTransition: gn,
  version: ln
}, Symbol.toStringTag, { value: "Module" }));
var PostHogContext = E$2({ client: _o });
function PostHogProvider(_a3) {
  var children = _a3.children, client = _a3.client, apiKey2 = _a3.apiKey, options = _a3.options;
  var posthog = q$2(function() {
    if (client && apiKey2) {
      console.warn("[PostHog.js] You have provided both a client and an apiKey to PostHogProvider. The apiKey will be ignored in favour of the client.");
    }
    if (client && options) {
      console.warn("[PostHog.js] You have provided both a client and options to PostHogProvider. The options will be ignored in favour of the client.");
    }
    if (client) {
      return client;
    }
    if (apiKey2) {
      if (_o.__loaded) {
        console.warn("[PostHog.js] was already loaded elsewhere. This may cause issues.");
      }
      _o.init(apiKey2, options);
    }
    return _o;
  }, [client, apiKey2]);
  return xn.createElement(PostHogContext.Provider, { value: { client: posthog } }, children);
}
var usePostHog = function() {
  var client = P$1(PostHogContext).client;
  return client;
};
function _arrayLikeToArray(r2, a2) {
  (null == a2 || a2 > r2.length) && (a2 = r2.length);
  for (var e2 = 0, n2 = Array(a2); e2 < a2; e2++) n2[e2] = r2[e2];
  return n2;
}
function _arrayWithoutHoles(r2) {
  if (Array.isArray(r2)) return _arrayLikeToArray(r2);
}
function _iterableToArray(r2) {
  if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"]) return Array.from(r2);
}
function _unsupportedIterableToArray(r2, a2) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray(r2, a2);
    var t2 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray(r2, a2) : void 0;
  }
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toConsumableArray(r2) {
  return _arrayWithoutHoles(r2) || _iterableToArray(r2) || _unsupportedIterableToArray(r2) || _nonIterableSpread();
}
function _arrayWithHoles(r2) {
  if (Array.isArray(r2)) return r2;
}
function _iterableToArrayLimit(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e2, n2, i, u2, a2 = [], f2 = true, o2 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) ;
      else for (; !(f2 = (e2 = i.call(t2)).done) && (a2.push(e2.value), a2.length !== l2); f2 = true) ;
    } catch (r3) {
      o2 = true, n2 = r3;
    } finally {
      try {
        if (!f2 && null != t2["return"] && (u2 = t2["return"](), Object(u2) !== u2)) return;
      } finally {
        if (o2) throw n2;
      }
    }
    return a2;
  }
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _slicedToArray(r2, e2) {
  return _arrayWithHoles(r2) || _iterableToArrayLimit(r2, e2) || _unsupportedIterableToArray(r2, e2) || _nonIterableRest();
}
var isDevelopment$1 = false;
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i = 0; i < document.styleSheets.length; i++) {
    if (document.styleSheets[i].ownerNode === tag) {
      return document.styleSheets[i];
    }
  }
  return void 0;
}
function createStyleElement(options) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options.key);
  if (options.nonce !== void 0) {
    tag.setAttribute("nonce", options.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  tag.setAttribute("data-s", "");
  return tag;
}
var StyleSheet = /* @__PURE__ */ function() {
  function StyleSheet2(options) {
    var _this = this;
    this._insertTag = function(tag) {
      var before;
      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag, before);
      _this.tags.push(tag);
    };
    this.isSpeedy = options.speedy === void 0 ? !isDevelopment$1 : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce;
    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.insertionPoint = options.insertionPoint;
    this.before = null;
  }
  var _proto = StyleSheet2.prototype;
  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert(rule) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);
      try {
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e2) {
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush2() {
    this.tags.forEach(function(tag) {
      var _tag$parentNode;
      return (_tag$parentNode = tag.parentNode) == null ? void 0 : _tag$parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
  };
  return StyleSheet2;
}();
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";
var abs = Math.abs;
var from = String.fromCharCode;
var assign$1 = Object.assign;
function hash(value, length2) {
  return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
function trim$2(value) {
  return value.trim();
}
function match(value, pattern2) {
  return (value = pattern2.exec(value)) ? value[0] : value;
}
function replace$1(value, pattern2, replacement) {
  return value.replace(pattern2, replacement);
}
function indexof(value, search2) {
  return value.indexOf(search2);
}
function charat(value, index2) {
  return value.charCodeAt(index2) | 0;
}
function substr(value, begin, end) {
  return value.slice(begin, end);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append(value, array) {
  return array.push(value), value;
}
function combine(array, callback) {
  return array.map(callback).join("");
}
var line = 1;
var column = 1;
var length = 0;
var position$2 = 0;
var character = 0;
var characters = "";
function node$1(value, root2, parent, type2, props, children, length2) {
  return { value, root: root2, parent, type: type2, props, children, line, column, length: length2, return: "" };
}
function copy(root2, props) {
  return assign$1(node$1("", null, null, "", null, null, 0), root2, { length: -root2.length }, props);
}
function char() {
  return character;
}
function prev() {
  character = position$2 > 0 ? charat(characters, --position$2) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position$2 < length ? charat(characters, position$2++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position$2);
}
function caret() {
  return position$2;
}
function slice(begin, end) {
  return substr(characters, begin, end);
}
function token(type2) {
  switch (type2) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position$2 = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type2) {
  return trim$2(slice(position$2 - 1, delimiter(type2 === 91 ? type2 + 2 : type2 === 40 ? type2 + 1 : type2)));
}
function whitespace$1(type2) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type2) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index2, count) {
  while (--count && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index2, caret() + (count < 6 && peek() == 32 && next() == 32));
}
function delimiter(type2) {
  while (next())
    switch (character) {
      case type2:
        return position$2;
      case 34:
      case 39:
        if (type2 !== 34 && type2 !== 39)
          delimiter(character);
        break;
      case 40:
        if (type2 === 41)
          delimiter(type2);
        break;
      case 92:
        next();
        break;
    }
  return position$2;
}
function commenter(type2, index2) {
  while (next())
    if (type2 + character === 47 + 10)
      break;
    else if (type2 + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index2, position$2 - 1) + "*" + from(type2 === 47 ? type2 : next());
}
function identifier(index2) {
  while (!token(peek()))
    next();
  return slice(index2, position$2);
}
function compile$1(value) {
  return dealloc(parse$3("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse$3(value, root2, parent, rule, rules2, rulesets, pseudo, points, declarations) {
  var index2 = 0;
  var offset = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property2 = 0;
  var previous2 = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type2 = "";
  var props = rules2;
  var children = rulesets;
  var reference = rule;
  var characters2 = type2;
  while (scanning)
    switch (previous2 = character2, character2 = next()) {
      case 40:
        if (previous2 != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace$1(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace$1(previous2);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root2, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index2++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset:
            if (ampersand == -1) characters2 = replace$1(characters2, /\f/g, "");
            if (property2 > 0 && strlen(characters2) - length2)
              append(property2 > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace$1(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append(reference = ruleset(characters2, root2, parent, index2, offset, rules2, points, type2, props = [], children = [], length2), rulesets);
            if (character2 === 123)
              if (offset === 0)
                parse$3(characters2, root2, reference, reference, props, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse$3(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules2, points, type2, rules2, props = [], length2), children), rules2, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse$3(characters2, reference, reference, reference, [""], children, 0, points, children);
                }
        }
        index2 = offset = property2 = 0, variable = ampersand = 1, type2 = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen(characters2), property2 = previous2;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          case 38:
            ampersand = offset > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset = length2 = strlen(type2 = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            if (previous2 === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root2, parent, index2, offset, rules2, points, type2, props, children, length2) {
  var post = offset - 1;
  var rule = offset === 0 ? rules2 : [""];
  var size = sizeof(rule);
  for (var i = 0, j2 = 0, k2 = 0; i < index2; ++i)
    for (var x2 = 0, y2 = substr(value, post + 1, post = abs(j2 = points[i])), z2 = value; x2 < size; ++x2)
      if (z2 = trim$2(j2 > 0 ? rule[x2] + " " + y2 : replace$1(y2, /&\f/g, rule[x2])))
        props[k2++] = z2;
  return node$1(value, root2, parent, offset === 0 ? RULESET : type2, props, children, length2);
}
function comment(value, root2, parent) {
  return node$1(value, root2, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
}
function declaration(value, root2, parent, length2) {
  return node$1(value, root2, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
}
function serialize$3(children, callback) {
  var output = "";
  var length2 = sizeof(children);
  for (var i = 0; i < length2; i++)
    output += callback(children[i], i, children, callback) || "";
  return output;
}
function stringify$2(element2, index2, children, callback) {
  switch (element2.type) {
    case LAYER:
      if (element2.children.length) break;
    case IMPORT:
    case DECLARATION:
      return element2.return = element2.return || element2.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element2.return = element2.value + "{" + serialize$3(element2.children, callback) + "}";
    case RULESET:
      element2.value = element2.props.join(",");
  }
  return strlen(children = serialize$3(element2.children, callback)) ? element2.return = element2.value + "{" + children + "}" : "";
}
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element2, index2, children, callback) {
    var output = "";
    for (var i = 0; i < length2; i++)
      output += collection[i](element2, index2, children, callback) || "";
    return output;
  };
}
function rulesheet(callback) {
  return function(element2) {
    if (!element2.root) {
      if (element2 = element2.return)
        callback(element2);
    }
  };
}
var weakMemoize = function weakMemoize2(func) {
  var cache = /* @__PURE__ */ new WeakMap();
  return function(arg) {
    if (cache.has(arg)) {
      return cache.get(arg);
    }
    var ret = func(arg);
    cache.set(arg, ret);
    return ret;
  };
};
function memoize$3(fn2) {
  var cache = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    if (cache[arg] === void 0) cache[arg] = fn2(arg);
    return cache[arg];
  };
}
var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index2) {
  var previous2 = 0;
  var character2 = 0;
  while (true) {
    previous2 = character2;
    character2 = peek();
    if (previous2 === 38 && character2 === 12) {
      points[index2] = 1;
    }
    if (token(character2)) {
      break;
    }
    next();
  }
  return slice(begin, position$2);
};
var toRules = function toRules2(parsed, points) {
  var index2 = -1;
  var character2 = 44;
  do {
    switch (token(character2)) {
      case 0:
        if (character2 === 38 && peek() === 12) {
          points[index2] = 1;
        }
        parsed[index2] += identifierWithPointTracking(position$2 - 1, points, index2);
        break;
      case 2:
        parsed[index2] += delimit(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index2] = peek() === 58 ? "&\f" : "";
          points[index2] = parsed[index2].length;
          break;
        }
      default:
        parsed[index2] += from(character2);
    }
  } while (character2 = next());
  return parsed;
};
var getRules$1 = function getRules(value, points) {
  return dealloc(toRules(alloc(value), points));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat2(element2) {
  if (element2.type !== "rule" || !element2.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element2.length < 1) {
    return;
  }
  var value = element2.value;
  var parent = element2.parent;
  var isImplicitRule = element2.column === parent.column && element2.line === parent.line;
  while (parent.type !== "rule") {
    parent = parent.parent;
    if (!parent) return;
  }
  if (element2.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element2, true);
  var points = [];
  var rules2 = getRules$1(value, points);
  var parentRules = parent.props;
  for (var i = 0, k2 = 0; i < rules2.length; i++) {
    for (var j2 = 0; j2 < parentRules.length; j2++, k2++) {
      element2.props[k2] = points[i] ? rules2[i].replace(/&\f/g, parentRules[j2]) : parentRules[j2] + " " + rules2[i];
    }
  }
};
var removeLabel = function removeLabel2(element2) {
  if (element2.type === "decl") {
    var value = element2.value;
    if (
      // charcode for l
      value.charCodeAt(0) === 108 && // charcode for b
      value.charCodeAt(2) === 98
    ) {
      element2["return"] = "";
      element2.value = "";
    }
  }
};
function prefix$1(value, length2) {
  switch (hash(value, length2)) {
    case 5103:
      return WEBKIT + "print-" + value + value;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    case 6828:
    case 4268:
      return WEBKIT + value + MS + value + value;
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    case 5187:
      return WEBKIT + value + replace$1(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace$1(value, /flex-|-self/, "") + value;
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace$1(value, /align-content|flex-|-self/, "") + value;
    case 5548:
      return WEBKIT + value + MS + replace$1(value, "shrink", "negative") + value;
    case 5292:
      return WEBKIT + value + MS + replace$1(value, "basis", "preferred-size") + value;
    case 6060:
      return WEBKIT + "box-" + replace$1(value, "-grow", "") + WEBKIT + value + MS + replace$1(value, "grow", "positive") + value;
    case 4554:
      return WEBKIT + replace$1(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    case 6187:
      return replace$1(replace$1(replace$1(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    case 5495:
    case 3959:
      return replace$1(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace$1(replace$1(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace$1(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6) switch (charat(value, length2 + 1)) {
        case 109:
          if (charat(value, length2 + 4) !== 45) break;
        case 102:
          return replace$1(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
        case 115:
          return ~indexof(value, "stretch") ? prefix$1(replace$1(value, "stretch", "fill-available"), length2) + value : value;
      }
      break;
    case 4949:
      if (charat(value, length2 + 1) !== 115) break;
    case 6444:
      switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
        case 107:
          return replace$1(value, ":", ":" + WEBKIT) + value;
        case 101:
          return replace$1(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
      }
      break;
    case 5936:
      switch (charat(value, length2 + 11)) {
        case 114:
          return WEBKIT + value + MS + replace$1(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        case 108:
          return WEBKIT + value + MS + replace$1(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        case 45:
          return WEBKIT + value + MS + replace$1(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
      return WEBKIT + value + MS + value + value;
  }
  return value;
}
var prefixer = function prefixer2(element2, index2, children, callback) {
  if (element2.length > -1) {
    if (!element2["return"]) switch (element2.type) {
      case DECLARATION:
        element2["return"] = prefix$1(element2.value, element2.length);
        break;
      case KEYFRAMES:
        return serialize$3([copy(element2, {
          value: replace$1(element2.value, "@", "@" + WEBKIT)
        })], callback);
      case RULESET:
        if (element2.length) return combine(element2.props, function(value) {
          switch (match(value, /(::plac\w+|:read-\w+)/)) {
            case ":read-only":
            case ":read-write":
              return serialize$3([copy(element2, {
                props: [replace$1(value, /:(read-\w+)/, ":" + MOZ + "$1")]
              })], callback);
            case "::placeholder":
              return serialize$3([copy(element2, {
                props: [replace$1(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
              }), copy(element2, {
                props: [replace$1(value, /:(plac\w+)/, ":" + MOZ + "$1")]
              }), copy(element2, {
                props: [replace$1(value, /:(plac\w+)/, MS + "input-$1")]
              })], callback);
          }
          return "";
        });
    }
  }
};
var defaultStylisPlugins = [prefixer];
var createCache = function createCache2(options) {
  var key = options.key;
  if (key === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node2) {
      var dataEmotionAttribute = node2.getAttribute("data-emotion");
      if (dataEmotionAttribute.indexOf(" ") === -1) {
        return;
      }
      document.head.appendChild(node2);
      node2.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
  var inserted = {};
  var container;
  var nodesToHydrate = [];
  {
    container = options.container || document.head;
    Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
      function(node2) {
        var attrib = node2.getAttribute("data-emotion").split(" ");
        for (var i = 1; i < attrib.length; i++) {
          inserted[attrib[i]] = true;
        }
        nodesToHydrate.push(node2);
      }
    );
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  {
    var currentSheet;
    var finalizingPlugins = [stringify$2, rulesheet(function(rule) {
      currentSheet.insert(rule);
    })];
    var serializer2 = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis2(styles) {
      return serialize$3(compile$1(styles), serializer2);
    };
    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache.inserted[serialized.name] = true;
      }
    };
  }
  var cache = {
    key,
    sheet: new StyleSheet({
      key,
      container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend,
      insertionPoint: options.insertionPoint
    }),
    nonce: options.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache.sheet.hydrate(nodesToHydrate);
  return cache;
};
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var t2 = arguments[e2];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends.apply(null, arguments);
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
var reactIs$1 = { exports: {} };
var reactIs_production_min = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b = "function" === typeof Symbol && Symbol.for, c = b ? Symbol.for("react.element") : 60103, d = b ? Symbol.for("react.portal") : 60106, e = b ? Symbol.for("react.fragment") : 60107, f = b ? Symbol.for("react.strict_mode") : 60108, g = b ? Symbol.for("react.profiler") : 60114, h = b ? Symbol.for("react.provider") : 60109, k = b ? Symbol.for("react.context") : 60110, l = b ? Symbol.for("react.async_mode") : 60111, m = b ? Symbol.for("react.concurrent_mode") : 60111, n = b ? Symbol.for("react.forward_ref") : 60112, p = b ? Symbol.for("react.suspense") : 60113, q = b ? Symbol.for("react.suspense_list") : 60120, r = b ? Symbol.for("react.memo") : 60115, t = b ? Symbol.for("react.lazy") : 60116, v = b ? Symbol.for("react.block") : 60121, w = b ? Symbol.for("react.fundamental") : 60117, x = b ? Symbol.for("react.responder") : 60118, y = b ? Symbol.for("react.scope") : 60119;
function z(a2) {
  if ("object" === typeof a2 && null !== a2) {
    var u2 = a2.$$typeof;
    switch (u2) {
      case c:
        switch (a2 = a2.type, a2) {
          case l:
          case m:
          case e:
          case g:
          case f:
          case p:
            return a2;
          default:
            switch (a2 = a2 && a2.$$typeof, a2) {
              case k:
              case n:
              case t:
              case r:
              case h:
                return a2;
              default:
                return u2;
            }
        }
      case d:
        return u2;
    }
  }
}
function A(a2) {
  return z(a2) === m;
}
reactIs_production_min.AsyncMode = l;
reactIs_production_min.ConcurrentMode = m;
reactIs_production_min.ContextConsumer = k;
reactIs_production_min.ContextProvider = h;
reactIs_production_min.Element = c;
reactIs_production_min.ForwardRef = n;
reactIs_production_min.Fragment = e;
reactIs_production_min.Lazy = t;
reactIs_production_min.Memo = r;
reactIs_production_min.Portal = d;
reactIs_production_min.Profiler = g;
reactIs_production_min.StrictMode = f;
reactIs_production_min.Suspense = p;
reactIs_production_min.isAsyncMode = function(a2) {
  return A(a2) || z(a2) === l;
};
reactIs_production_min.isConcurrentMode = A;
reactIs_production_min.isContextConsumer = function(a2) {
  return z(a2) === k;
};
reactIs_production_min.isContextProvider = function(a2) {
  return z(a2) === h;
};
reactIs_production_min.isElement = function(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === c;
};
reactIs_production_min.isForwardRef = function(a2) {
  return z(a2) === n;
};
reactIs_production_min.isFragment = function(a2) {
  return z(a2) === e;
};
reactIs_production_min.isLazy = function(a2) {
  return z(a2) === t;
};
reactIs_production_min.isMemo = function(a2) {
  return z(a2) === r;
};
reactIs_production_min.isPortal = function(a2) {
  return z(a2) === d;
};
reactIs_production_min.isProfiler = function(a2) {
  return z(a2) === g;
};
reactIs_production_min.isStrictMode = function(a2) {
  return z(a2) === f;
};
reactIs_production_min.isSuspense = function(a2) {
  return z(a2) === p;
};
reactIs_production_min.isValidElementType = function(a2) {
  return "string" === typeof a2 || "function" === typeof a2 || a2 === e || a2 === m || a2 === g || a2 === f || a2 === p || a2 === q || "object" === typeof a2 && null !== a2 && (a2.$$typeof === t || a2.$$typeof === r || a2.$$typeof === h || a2.$$typeof === k || a2.$$typeof === n || a2.$$typeof === w || a2.$$typeof === x || a2.$$typeof === y || a2.$$typeof === v);
};
reactIs_production_min.typeOf = z;
{
  reactIs$1.exports = reactIs_production_min;
}
var reactIsExports = reactIs$1.exports;
var reactIs = reactIsExports;
var REACT_STATICS = {
  childContextTypes: true,
  contextType: true,
  contextTypes: true,
  defaultProps: true,
  displayName: true,
  getDefaultProps: true,
  getDerivedStateFromError: true,
  getDerivedStateFromProps: true,
  mixins: true,
  propTypes: true,
  type: true
};
var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};
var FORWARD_REF_STATICS = {
  "$$typeof": true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  "$$typeof": true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
function getStatics(component) {
  if (reactIs.isMemo(component)) {
    return MEMO_STATICS;
  }
  return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
}
var defineProperty$3 = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;
var getPrototypeOf$2 = Object.getPrototypeOf;
var objectPrototype = Object.prototype;
function hoistNonReactStatics$1(targetComponent, sourceComponent, blacklist) {
  if (typeof sourceComponent !== "string") {
    if (objectPrototype) {
      var inheritedComponent = getPrototypeOf$2(sourceComponent);
      if (inheritedComponent && inheritedComponent !== objectPrototype) {
        hoistNonReactStatics$1(targetComponent, inheritedComponent, blacklist);
      }
    }
    var keys2 = getOwnPropertyNames(sourceComponent);
    if (getOwnPropertySymbols) {
      keys2 = keys2.concat(getOwnPropertySymbols(sourceComponent));
    }
    var targetStatics = getStatics(targetComponent);
    var sourceStatics = getStatics(sourceComponent);
    for (var i = 0; i < keys2.length; ++i) {
      var key = keys2[i];
      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
        var descriptor = getOwnPropertyDescriptor$1(sourceComponent, key);
        try {
          defineProperty$3(targetComponent, key, descriptor);
        } catch (e2) {
        }
      }
    }
  }
  return targetComponent;
}
var hoistNonReactStatics_cjs = hoistNonReactStatics$1;
const hoistNonReactStatics$2 = /* @__PURE__ */ getDefaultExportFromCjs(hoistNonReactStatics_cjs);
var hoistNonReactStatics = function(targetComponent, sourceComponent) {
  return hoistNonReactStatics$2(targetComponent, sourceComponent);
};
var isBrowser = true;
function getRegisteredStyles(registered, registeredStyles, classNames) {
  var rawClassName = "";
  classNames.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else if (className) {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles2(cache, serialized, isStringTag) {
  var className = cache.key + "-" + serialized.name;
  if (
    // we only need to add the styles to the registered cache if the
    // class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (isStringTag === false || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    isBrowser === false) && cache.registered[className] === void 0
  ) {
    cache.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles2(cache, serialized, isStringTag) {
  registerStyles(cache, serialized, isStringTag);
  var className = cache.key + "-" + serialized.name;
  if (cache.inserted[serialized.name] === void 0) {
    var current = serialized;
    do {
      cache.insert(serialized === current ? "." + className : "", current, cache.sheet, true);
      current = current.next;
    } while (current !== void 0);
  }
};
function murmur2(str) {
  var h2 = 0;
  var k2, i = 0, len = str.length;
  for (; len >= 4; ++i, len -= 4) {
    k2 = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
    k2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
    k2 ^= /* k >>> r: */
    k2 >>> 24;
    h2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h2 ^= (str.charCodeAt(i + 2) & 255) << 16;
    case 2:
      h2 ^= (str.charCodeAt(i + 1) & 255) << 8;
    case 1:
      h2 ^= str.charCodeAt(i) & 255;
      h2 = /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  h2 ^= h2 >>> 13;
  h2 = /* Math.imul(h, m): */
  (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
}
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty2(property2) {
  return property2.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue2(value) {
  return value != null && typeof value !== "boolean";
};
var processStyleName = /* @__PURE__ */ memoize$3(function(styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = function processStyleValue2(key, value) {
  switch (key) {
    case "animation":
    case "animationName": {
      if (typeof value === "string") {
        return value.replace(animationRegex, function(match2, p1, p2) {
          cursor = {
            name: p1,
            styles: p2,
            next: cursor
          };
          return p1;
        });
      }
    }
  }
  if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
    return value + "px";
  }
  return value;
};
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  var componentSelector = interpolation;
  if (componentSelector.__emotion_styles !== void 0) {
    return componentSelector;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      var keyframes2 = interpolation;
      if (keyframes2.anim === 1) {
        cursor = {
          name: keyframes2.name,
          styles: keyframes2.styles,
          next: cursor
        };
        return keyframes2.name;
      }
      var serializedStyles = interpolation;
      if (serializedStyles.styles !== void 0) {
        var next2 = serializedStyles.next;
        if (next2 !== void 0) {
          while (next2 !== void 0) {
            cursor = {
              name: next2.name,
              styles: next2.styles,
              next: cursor
            };
            next2 = next2.next;
          }
        }
        var styles = serializedStyles.styles + ";";
        return styles;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor;
        var result = interpolation(mergedProps);
        cursor = previousCursor;
        return handleInterpolation(mergedProps, registered, result);
      }
      break;
    }
  }
  var asString = interpolation;
  {
    return asString;
  }
}
function createStringFromObject(mergedProps, registered, obj) {
  var string2 = "";
  if (Array.isArray(obj)) {
    for (var i = 0; i < obj.length; i++) {
      string2 += handleInterpolation(mergedProps, registered, obj[i]) + ";";
    }
  } else {
    for (var key in obj) {
      var value = obj[key];
      if (typeof value !== "object") {
        var asString = value;
        if (isProcessableValue(asString)) {
          string2 += processStyleName(key) + ":" + processStyleValue(key, asString) + ";";
        }
      } else {
        if (Array.isArray(value) && typeof value[0] === "string" && registered == null) {
          for (var _i2 = 0; _i2 < value.length; _i2++) {
            if (isProcessableValue(value[_i2])) {
              string2 += processStyleName(key) + ":" + processStyleValue(key, value[_i2]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);
          switch (key) {
            case "animation":
            case "animationName": {
              string2 += processStyleName(key) + ":" + interpolated + ";";
              break;
            }
            default: {
              string2 += key + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string2;
}
var labelPattern = /label:\s*([^\s;{]+)\s*(;|$)/g;
var cursor;
function serializeStyles(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
    return args[0];
  }
  var stringMode = true;
  var styles = "";
  cursor = void 0;
  var strings = args[0];
  if (strings == null || strings.raw === void 0) {
    stringMode = false;
    styles += handleInterpolation(mergedProps, registered, strings);
  } else {
    var asTemplateStringsArr = strings;
    styles += asTemplateStringsArr[0];
  }
  for (var i = 1; i < args.length; i++) {
    styles += handleInterpolation(mergedProps, registered, args[i]);
    if (stringMode) {
      var templateStringsArr = strings;
      styles += templateStringsArr[i];
    }
  }
  labelPattern.lastIndex = 0;
  var identifierName = "";
  var match2;
  while ((match2 = labelPattern.exec(styles)) !== null) {
    identifierName += "-" + match2[1];
  }
  var name2 = murmur2(styles) + identifierName;
  return {
    name: name2,
    styles,
    next: cursor
  };
}
var syncFallback = function syncFallback2(create3) {
  return create3();
};
var useInsertionEffect = React["useInsertionEffect"] ? React["useInsertionEffect"] : false;
var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
var isDevelopment = false;
var EmotionCacheContext = /* @__PURE__ */ E$2(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache({
    key: "css"
  }) : null
);
EmotionCacheContext.Provider;
var withEmotionCache = function withEmotionCache2(func) {
  return /* @__PURE__ */ N(function(props, ref2) {
    var cache = P$1(EmotionCacheContext);
    return func(props, cache, ref2);
  });
};
var ThemeContext$1 = /* @__PURE__ */ E$2({});
var getTheme = function getTheme2(outerTheme, theme2) {
  if (typeof theme2 === "function") {
    var mergedTheme = theme2(outerTheme);
    return mergedTheme;
  }
  return _extends({}, outerTheme, theme2);
};
var createCacheWithTheme = /* @__PURE__ */ weakMemoize(function(outerTheme) {
  return weakMemoize(function(theme2) {
    return getTheme(outerTheme, theme2);
  });
});
var ThemeProvider$1 = function ThemeProvider(props) {
  var theme2 = P$1(ThemeContext$1);
  if (props.theme !== theme2) {
    theme2 = createCacheWithTheme(theme2)(props.theme);
  }
  return /* @__PURE__ */ y$3(ThemeContext$1.Provider, {
    value: theme2
  }, props.children);
};
function withTheme(Component) {
  var componentName = Component.displayName || Component.name || "Component";
  var WithTheme = /* @__PURE__ */ N(function render(props, ref2) {
    var theme2 = P$1(ThemeContext$1);
    return /* @__PURE__ */ y$3(Component, _extends({
      theme: theme2,
      ref: ref2
    }, props));
  });
  WithTheme.displayName = "WithTheme(" + componentName + ")";
  return hoistNonReactStatics(WithTheme, Component);
}
var hasOwn$1 = {}.hasOwnProperty;
var typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__";
var createEmotionProps = function createEmotionProps2(type2, props) {
  var newProps = {};
  for (var _key in props) {
    if (hasOwn$1.call(props, _key)) {
      newProps[_key] = props[_key];
    }
  }
  newProps[typePropName] = type2;
  return newProps;
};
var Insertion = function Insertion2(_ref3) {
  var cache = _ref3.cache, serialized = _ref3.serialized, isStringTag = _ref3.isStringTag;
  registerStyles(cache, serialized, isStringTag);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache, serialized, isStringTag);
  });
  return null;
};
var Emotion = /* @__PURE__ */ withEmotionCache(function(props, cache, ref2) {
  var cssProp = props.css;
  if (typeof cssProp === "string" && cache.registered[cssProp] !== void 0) {
    cssProp = cache.registered[cssProp];
  }
  var WrappedComponent = props[typePropName];
  var registeredStyles = [cssProp];
  var className = "";
  if (typeof props.className === "string") {
    className = getRegisteredStyles(cache.registered, registeredStyles, props.className);
  } else if (props.className != null) {
    className = props.className + " ";
  }
  var serialized = serializeStyles(registeredStyles, void 0, P$1(ThemeContext$1));
  className += cache.key + "-" + serialized.name;
  var newProps = {};
  for (var _key2 in props) {
    if (hasOwn$1.call(props, _key2) && _key2 !== "css" && _key2 !== typePropName && !isDevelopment) {
      newProps[_key2] = props[_key2];
    }
  }
  newProps.className = className;
  if (ref2) {
    newProps.ref = ref2;
  }
  return /* @__PURE__ */ y$3(g$3, null, /* @__PURE__ */ y$3(Insertion, {
    cache,
    serialized,
    isStringTag: typeof WrappedComponent === "string"
  }), /* @__PURE__ */ y$3(WrappedComponent, newProps));
});
var Emotion$1 = Emotion;
var jsx$1 = function jsx(type2, props) {
  var args = arguments;
  if (props == null || !hasOwn$1.call(props, "css")) {
    return y$3.apply(void 0, args);
  }
  var argsLength = args.length;
  var createElementArgArray = new Array(argsLength);
  createElementArgArray[0] = Emotion$1;
  createElementArgArray[1] = createEmotionProps(type2, props);
  for (var i = 2; i < argsLength; i++) {
    createElementArgArray[i] = args[i];
  }
  return y$3.apply(null, createElementArgArray);
};
(function(_jsx) {
  var JSX;
  /* @__PURE__ */ (function(_JSX) {
  })(JSX || (JSX = _jsx.JSX || (_jsx.JSX = {})));
})(jsx$1);
function css() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return serializeStyles(args);
}
function keyframes() {
  var insertable = css.apply(void 0, arguments);
  var name2 = "animation-" + insertable.name;
  return {
    name: name2,
    styles: "@keyframes " + name2 + "{" + insertable.styles + "}",
    anim: 1,
    toString: function toString3() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
}
function _setPrototypeOf(t2, e2) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t3, e3) {
    return t3.__proto__ = e3, t3;
  }, _setPrototypeOf(t2, e2);
}
function _inheritsLoose(t2, o2) {
  t2.prototype = Object.create(o2.prototype), t2.prototype.constructor = t2, _setPrototypeOf(t2, o2);
}
var UNIT_TYPE = "px";
var UNIT = 8;
var SMALL_UNIT = 4;
var getSmallSpacing = function getSmallSpacing2(factor) {
  return "".concat(factor * SMALL_UNIT).concat(UNIT_TYPE);
};
var getSmallSpacingNumber = function getSmallSpacingNumber2(factor) {
  return factor * SMALL_UNIT;
};
var spacings = {
  xxs: getSmallSpacing(0.5),
  xs: getSmallSpacing(1),
  sm: getSmallSpacing(2),
  md: getSmallSpacing(3),
  lg: getSmallSpacing(4),
  xl: getSmallSpacing(5),
  xxl: getSmallSpacing(6),
  xxxl: getSmallSpacing(8)
};
function _taggedTemplateLiteral(e2, t2) {
  return t2 || (t2 = e2.slice(0)), Object.freeze(Object.defineProperties(e2, {
    raw: {
      value: Object.freeze(t2)
    }
  }));
}
var palette = {
  custom: {
    primaryColor: "#181825",
    ctaTextColor: "#ffffff",
    backgroundColor: "#ffffff",
    ctaBorderType: "rounded"
  },
  classic: {
    black: "#181825",
    white: "#ffffff"
  },
  primary: {
    main: "#242433",
    primary700: "#181825",
    dark: "#241F65",
    light: "#3E35A7"
  },
  secondary: {
    main: "#E5E9EB",
    dark: "#878787",
    light: "#979797",
    secondaryLight: "#C4C4C4"
  },
  success: {
    main: "#2FC875"
  },
  error: {
    main: "#ed403b"
  },
  text: {
    primary: "#181825",
    secondary: "#111827"
  },
  black: "#181825",
  lightBlue50: "#EFFAFF",
  lightBlue100: "#D1E6F6",
  lightBlue300: "#9CBDD7",
  lightBlue600: "#265E91",
  grey50: "#F8F8FA",
  grey100: "#EDEDF1",
  grey150: "#E5E7EB",
  grey200: "#DDDCE2",
  grey300: "#CDCCD4",
  grey400: "#A09FAA",
  grey500: "#6D6C79",
  grey550: "#6C6C6C",
  grey600: "#575665",
  grey700: "#484758",
  grey800: "#323241",
  grey900: "#242433",
  purple50: "#F5F5FC",
  purple100: "#E5E5F8",
  purple200: "#C5C4F0",
  purple300: "#8483E0",
  purple400: "#8483E0",
  purple500: "#6463D7",
  purple600: "#4745CC",
  purple700: "#3331A8",
  purple800: "#27267B",
  purple900: "#1A194F",
  green50: "#F6FAF3",
  green100: "#E9F5E3",
  green200: "#D4E9C9",
  green300: "#B0D79E",
  green400: "#86BC6C",
  green500: "#629D47",
  green600: "#4E8237",
  green700: "#40672E",
  green800: "#355328",
  green900: "#355328",
  red50: "#FEF2F2",
  red100: "#FEE2E2",
  red200: "#FECACA",
  red300: "#FDA4A4",
  red400: "#F97070",
  red500: "#F03E3E",
  red600: "#C92222",
  red700: "#AB2121",
  red800: "#951F1F",
  red900: "#801C1C",
  orange50: "#FEEED8",
  orange100: "#FEE3BF",
  orange200: "#FDCE8D",
  orange300: "#FCB85B",
  orange400: "#FAA32A",
  orange500: "#EC8B05",
  orange600: "#AF6704",
  orange700: "#875003",
  orange800: "#693E02",
  orange900: "#4C2D02",
  lila50: "#FBF3FF",
  lila100: "#EEDBFE",
  lila300: "#BFA5DA",
  lila600: "#8650BB",
  pink600: "#FF5EAB"
};
var theme = {
  capitalizeCtas: false,
  highlightProductName: false,
  spacing: UNIT,
  typography: {
    fontFamily: "Inter, sans-serif",
    h1: {
      fontWeight: 800,
      fontSize: 18
    },
    h2: {
      fontWeight: 700,
      fontSize: 17
    },
    h3: {
      fontWeight: 600,
      fontSize: 16
    },
    body1: {
      fontWeight: 500,
      fontSize: 15
    },
    body2: {
      fontWeight: 400,
      fontSize: 14,
      lineHeight: "20px"
    },
    body3: {
      fontWeight: 400,
      fontSize: 12
    },
    badge: {
      fontWeight: 500,
      fontSize: 12,
      lineHeight: "16px"
    }
  },
  borderRadius: {
    xs: "4px",
    sm: "6px",
    md: "8px",
    lg: "10px",
    lgx: "16px",
    xl: "18px",
    xxl: "24px",
    xxxl: "32px",
    max: "100%"
  },
  zIndex: {
    highest: 2147483648,
    high: 9999,
    low: 1,
    lowest: -1,
    "default": 0
  },
  shadow: {
    xs: "0px 2px 3px -2px rgba(24, 24, 37, 0.12)",
    sm: " 0px 1px 2px 0px rgba(0, 0, 0, 0.05)",
    md: "0px 6px 12px -6px rgba(0, 0, 0, 0.12), 0px 3px 6px -3px rgba(24, 24, 37, 0.06)",
    lg: "0px 16px 32px -16px rgba(0, 0, 0, 0.12), 0px 8px 16px -8px rgba(24, 24, 37, 0.08)",
    selected: "0px 0px 0px 2px rgba(100, 99, 215, 0.5)",
    error: "0px 0px 0px 2px rgba(240, 62, 62, 0.5)"
  },
  palette
};
var _templateObject$3;
var backgroundAnim = keyframes(_templateObject$3 || (_templateObject$3 = _taggedTemplateLiteral(["\n  0% {\n      background: ", ";\n  }\n\n  50% {\n      background: ", "\n  }\n\n  100% {\n      background: ", ";\n  }\n"])), theme.palette.grey50, theme.palette.grey100, theme.palette.grey50);
var skeletonAnimationStyle = /* @__PURE__ */ css({
  animation: "".concat(backgroundAnim, " 2s ease infinite"),
  border: "unset",
  borderRadius: theme.borderRadius.md,
  color: "transparent",
  minHeight: "8px"
}, "", "", "", "");
({
  animation: "".concat(backgroundAnim, " 2s ease infinite"),
  border: "unset",
  borderRadius: theme.borderRadius.md,
  color: "transparent",
  minHeight: "8px"
});
var SMALL_MOBILE_BP = "375px";
var MEDIUM_MOBILE_BP = "425px";
var TABLET_BP = "768px";
var TABLET_BP_NUMBER = parseInt(TABLET_BP.replace("px", ""));
var MEDIUM_MOBILE_NUMBER = parseInt(MEDIUM_MOBILE_BP.replace("px", ""));
var SMALL_MOBILE_NUMBER = parseInt(SMALL_MOBILE_BP.replace("px", ""));
var TYPOGRAPHY_VARIANTS = {
  xxxxl: {
    fontFamily: "Inter",
    fontWeight: 500,
    fontSize: "32px",
    lineHeight: "48px"
  },
  xxxl: {
    fontFamily: "Inter",
    fontWeight: 500,
    fontSize: "30px",
    lineHeight: "36px"
  },
  xxl: {
    fontFamily: "Inter",
    fontWeight: 500,
    fontSize: "24px",
    lineHeight: "32px"
  },
  xl: {
    fontFamily: "Inter",
    fontWeight: 500,
    fontSize: "20px",
    lineHeight: "28px"
  },
  lg: {
    fontFamily: "Inter",
    fontWeight: 500,
    fontSize: "18px",
    lineHeight: "28px"
  },
  "base-md": {
    fontFamily: "Inter",
    fontWeight: 500,
    fontSize: "16px",
    lineHeight: "24px"
  },
  "base-reg": {
    fontFamily: "Inter",
    fontWeight: 400,
    fontSize: "16px",
    lineHeight: "24px"
  },
  "sm-md": {
    fontFamily: "Inter",
    fontWeight: 500,
    fontSize: "14px",
    lineHeight: "20px"
  },
  "paragraph-reg": {
    fontFamily: "Inter",
    fontWeight: 400,
    fontSize: "14px",
    lineHeight: "24px"
  },
  "sm-paragraph": {
    fontFamily: "Inter",
    fontWeight: 400,
    fontSize: "14px",
    lineHeight: "18px"
  },
  "sm-reg": {
    fontFamily: "Inter",
    fontWeight: 400,
    fontSize: "14px",
    lineHeight: "20px"
  },
  "xs-md": {
    fontFamily: "Inter",
    fontWeight: 500,
    fontSize: "12px",
    lineHeight: "16px"
  },
  "xs-reg": {
    fontFamily: "Inter",
    fontWeight: 400,
    fontSize: "12px",
    lineHeight: "16px"
  },
  // TODO: Normalize typo
  "xs-lg": {
    fontFamily: "Inter",
    fontWeight: 600,
    fontSize: "13px",
    lineHeight: "18px"
  },
  "xs-base": {
    fontFamily: "Inter",
    fontWeight: 500,
    fontSize: "13px",
    lineHeight: "20px"
  },
  "xs-xs": {
    fontFamily: "Inter",
    fontWeight: 500,
    fontSize: "14px",
    lineHeight: "20px"
  },
  "lg-paragraph": {
    fontFamily: "Inter",
    fontWeight: 600,
    fontSize: "14px",
    lineHeight: "18px"
  },
  "md-paragraph": {
    fontFamily: "Inter",
    fontWeight: 400,
    fontSize: "16px",
    lineHeight: "18px"
  },
  "xs-paragraph": {
    fontFamily: "Inter",
    fontWeight: 400,
    fontSize: "12px",
    lineHeight: "21px"
  },
  md: {
    fontFamily: "Inter",
    lineHeight: "21px",
    fontSize: "15px",
    fontWeight: 400
  },
  "lg-md": {
    fontFamily: "Inter",
    fontWeight: 500,
    fontSize: "18px",
    lineHeight: "21px"
  },
  "lg-lg": {
    fontFamily: "Inter",
    fontWeight: 600,
    fontSize: "18px",
    lineHeight: "21px"
  },
  "xl-sm": {
    fontFamily: "Inter",
    fontWeight: 400,
    fontSize: "18px",
    lineHeight: "23px"
  },
  "base-sm": {
    fontFamily: "Inter",
    fontWeight: 600,
    fontSize: "15px",
    lineHeight: "18px"
  }
};
var spanStyle = function spanStyle2(_ref3) {
  var variant = _ref3.variant, color2 = _ref3.color;
  return /* @__PURE__ */ css({
    color: color2 !== null && color2 !== void 0 ? color2 : theme.palette.classic.black,
    fontFamily: TYPOGRAPHY_VARIANTS[variant].fontFamily,
    fontSize: TYPOGRAPHY_VARIANTS[variant].fontSize,
    fontWeight: TYPOGRAPHY_VARIANTS[variant].fontWeight,
    lineHeight: TYPOGRAPHY_VARIANTS[variant].lineHeight,
    wordBreak: "break-word",
    width: "fit-content",
    letterSpacing: "0"
  }, "", "", "", "");
};
var noWrapCssRules = {
  name: "6farjd",
  styles: "text-overflow:ellipsis;overflow:hidden;white-space:nowrap;width:inherit;display:inline-block"
};
var Typography = function Typography2(_ref22) {
  var variant = _ref22.variant, children = _ref22.children, customCss = _ref22.customCss, title2 = _ref22.title, _ref2$noWrap = _ref22.noWrap, noWrap = _ref2$noWrap === void 0 ? false : _ref2$noWrap, color2 = _ref22.color, _ref2$enableDangerous = _ref22.enableDangerousInnerHTML, enableDangerousInnerHTML = _ref2$enableDangerous === void 0 ? false : _ref2$enableDangerous;
  return jsx$1("span", {
    css: [spanStyle({
      variant,
      color: color2
    })].concat(_toConsumableArray(noWrap ? [noWrapCssRules] : []), [customCss, "", ""]),
    title: title2,
    dangerouslySetInnerHTML: enableDangerousInnerHTML && children !== void 0 ? {
      __html: children
    } : void 0
  }, !enableDangerousInnerHTML && children);
};
var CarretDownIcon = function CarretDownIcon2(_ref3) {
  var _ref$color = _ref3.color, color2 = _ref$color === void 0 ? "black" : _ref$color, customCss = _ref3.customCss;
  return jsx$1("svg", {
    width: "20",
    css: customCss,
    height: "20",
    viewBox: "0 0 20 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, jsx$1("path", {
    d: "M5 7.5L10 12.5L15 7.5",
    stroke: color2,
    strokeWidth: "1.5",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }));
};
var SpinnerIcon = function SpinnerIcon2(_ref3) {
  var _ref$color = _ref3.color, color2 = _ref$color === void 0 ? "black" : _ref$color, customCss = _ref3.customCss;
  return jsx$1("svg", {
    css: customCss,
    width: "20",
    height: "20",
    viewBox: "0 0 20 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, jsx$1("path", {
    d: "M18 10C18 11.5823 17.5308 13.129 16.6518 14.4446C15.7727 15.7602 14.5233 16.7855 13.0615 17.391C11.5997 17.9965 9.99113 18.155 8.43928 17.8463C6.88743 17.5376 5.46197 16.7757 4.34315 15.6569C3.22433 14.538 2.4624 13.1126 2.15372 11.5607C1.84504 10.0089 2.00346 8.40034 2.60896 6.93853C3.21446 5.47672 4.23985 4.22729 5.55544 3.34824C6.87103 2.46919 8.41775 2 10 2",
    stroke: color2,
    strokeWidth: "1.5",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }));
};
var BUTTON_SIZES = {
  lg: {
    height: 48,
    padding: "".concat(spacings.md, " ").concat(spacings.xl),
    iconMargin: spacings.sm,
    paddingIcon: spacings.md,
    typographySize: "base-md"
  },
  md: {
    height: 44,
    padding: "".concat(spacings.md, " ").concat(spacings.xl),
    iconMargin: spacings.sm,
    paddingIcon: spacings.md,
    typographySize: "sm-md"
  },
  sm: {
    height: 36,
    padding: "".concat(spacings.sm, " ").concat(spacings.lg),
    iconMargin: spacings.sm,
    paddingIcon: spacings.sm,
    typographySize: "sm-md"
  },
  xs: {
    height: 28,
    padding: "".concat(spacings.xs, " ").concat(spacings.sm),
    iconMargin: spacings.xs,
    paddingIcon: spacings.xs,
    typographySize: "sm-md"
  }
};
var BUTTON_VARIANTS = {
  primary: {
    background: {
      "default": theme.palette.primary.main,
      hover: theme.palette.primary.primary700,
      disabled: theme.palette.grey200
    },
    color: {
      "default": theme.palette.classic.white,
      hover: theme.palette.classic.white,
      disabled: theme.palette.classic.white
    },
    border: {
      "default": "unset",
      disabled: "unset"
    },
    borderRadius: "100px",
    shadow: "unset"
  },
  secondary: {
    background: {
      "default": theme.palette.classic.white,
      hover: theme.palette.grey100,
      disabled: theme.palette.classic.white
    },
    color: {
      "default": theme.palette.classic.black,
      hover: theme.palette.classic.black,
      disabled: theme.palette.grey300
    },
    border: {
      "default": "1px solid ".concat(theme.palette.grey300),
      disabled: "1px solid ".concat(theme.palette.grey100)
    },
    borderRadius: "100px",
    shadow: "unset"
  },
  blank: {
    background: {
      "default": "unset",
      hover: theme.palette.grey100,
      disabled: theme.palette.classic.white
    },
    color: {
      "default": theme.palette.grey600,
      hover: theme.palette.grey600,
      disabled: theme.palette.grey300
    },
    border: {
      "default": "unset",
      disabled: "unset"
    },
    borderRadius: theme.borderRadius.md,
    shadow: "unset"
  },
  success: {
    background: {
      "default": theme.palette.green600,
      hover: theme.palette.green200,
      disabled: theme.palette.green200
    },
    color: {
      "default": theme.palette.classic.white,
      hover: theme.palette.classic.white,
      disabled: theme.palette.classic.white
    },
    border: {
      "default": "unset",
      disabled: "unset"
    },
    borderRadius: theme.borderRadius.md,
    shadow: theme.shadow.xs
  },
  validState: {
    background: {
      "default": theme.palette.green100,
      hover: theme.palette.green200,
      disabled: theme.palette.green50
    },
    color: {
      "default": theme.palette.green600,
      hover: theme.palette.green600,
      disabled: theme.palette.green600
    },
    border: {
      "default": "unset",
      disabled: "unset"
    },
    borderRadius: theme.borderRadius.md,
    shadow: theme.shadow.xs
  },
  warningState: {
    background: {
      "default": theme.palette.red100,
      hover: theme.palette.red200,
      disabled: theme.palette.red50
    },
    color: {
      "default": theme.palette.red600,
      hover: theme.palette.red600,
      disabled: theme.palette.red600
    },
    border: {
      "default": "unset",
      disabled: "unset"
    },
    borderRadius: theme.borderRadius.md,
    shadow: theme.shadow.xs
  },
  error: {
    background: {
      "default": theme.palette.red600,
      hover: theme.palette.red700,
      disabled: theme.palette.red200
    },
    color: {
      "default": theme.palette.classic.white,
      hover: theme.palette.classic.white,
      disabled: theme.palette.classic.white
    },
    border: {
      "default": "unset",
      disabled: "unset"
    },
    borderRadius: theme.borderRadius.md,
    shadow: theme.shadow.xs
  }
};
var PlusIcon = function PlusIcon2(_ref3) {
  var _ref$color = _ref3.color, color2 = _ref$color === void 0 ? theme.palette.classic.white : _ref$color, customCss = _ref3.customCss;
  return jsx$1("svg", {
    css: customCss,
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, jsx$1("path", {
    d: "M7 1.16669V12.8334M1.16667 7.00002H12.8333",
    stroke: color2,
    strokeWidth: "1.5",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }));
};
var _ref$7 = {
  name: "1qxlct9",
  styles: "fill:none;max-width:unset;margin:0 auto"
};
var Svg = function Svg2(_ref22) {
  var children = _ref22.children;
  var svgProps = {
    resetCss: _ref$7
  };
  return children(svgProps);
};
var CarretRightIcon = function CarretRightIcon2(_ref3) {
  var _ref$color = _ref3.color, color2 = _ref$color === void 0 ? "black" : _ref$color, customCss = _ref3.customCss;
  return jsx$1(Svg, null, function(_ref22) {
    var resetCss = _ref22.resetCss;
    return jsx$1("svg", {
      css: [resetCss, customCss, "", "", "", ""],
      width: "20",
      height: "20",
      viewBox: "0 0 20 20",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, jsx$1("path", {
      d: "M7.5 15.0005L12.5 10.0005L7.5 5.00049",
      stroke: color2,
      strokeWidth: "1.5",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }));
  });
};
var CarretLeftIcon = function CarretLeftIcon2(_ref3) {
  var _ref$color = _ref3.color, color2 = _ref$color === void 0 ? "black" : _ref$color, customCss = _ref3.customCss;
  return jsx$1(Svg, null, function(_ref22) {
    var resetCss = _ref22.resetCss;
    return jsx$1("svg", {
      css: [resetCss, customCss, "", "", "", ""],
      width: "20",
      height: "20",
      viewBox: "0 0 20 20",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, jsx$1("path", {
      d: "M12.5 15L7.5 10L12.5 5",
      stroke: color2,
      strokeWidth: "1.5",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }));
  });
};
var LinkIcon = function LinkIcon2(_ref3) {
  var _ref$color = _ref3.color, color2 = _ref$color === void 0 ? "black" : _ref$color;
  return jsx$1("svg", {
    width: "20",
    height: "20",
    viewBox: "0 0 20 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, jsx$1("path", {
    d: "M10.5896 15.3037L9.41112 16.4822C7.78394 18.1094 5.14575 18.1094 3.51856 16.4822C1.89138 14.855 1.89138 12.2169 3.51856 10.5897L4.69708 9.41116M15.3037 10.5897L16.4822 9.41116C18.1094 7.78398 18.1094 5.14579 16.4822 3.51861C14.855 1.89142 12.2168 1.89142 10.5896 3.51861L9.41112 4.69712M7.08371 12.9171L12.917 7.08373",
    stroke: color2,
    strokeWidth: "1.5",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }));
};
var CheckIcon = function CheckIcon2(_ref3) {
  var _ref$color = _ref3.color, color2 = _ref$color === void 0 ? "black" : _ref$color, customCss = _ref3.customCss;
  return jsx$1("svg", {
    css: customCss,
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, jsx$1("path", {
    d: "M13.3337 4L6.00033 11.3333L2.66699 8",
    stroke: color2,
    strokeWidth: "1.5",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }));
};
var CrossIcon = function CrossIcon2(_ref3) {
  var _ref$color = _ref3.color, color2 = _ref$color === void 0 ? "black" : _ref$color, customCss = _ref3.customCss;
  return jsx$1(Svg, null, function(_ref22) {
    var resetCss = _ref22.resetCss;
    return jsx$1("svg", {
      css: [resetCss, customCss, "", "", "", ""],
      width: "20",
      height: "20",
      viewBox: "0 0 20 20",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, jsx$1("path", {
      d: "M15 5L5 15M5 5L15 15",
      stroke: color2,
      strokeWidth: "1.5",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }));
  });
};
var InformationCircleIcon = function InformationCircleIcon2(_ref3) {
  var _ref$color = _ref3.color, color2 = _ref$color === void 0 ? "black" : _ref$color, customCss = _ref3.customCss;
  return jsx$1("svg", {
    css: customCss,
    width: "20",
    height: "20",
    viewBox: "0 0 20 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, jsx$1("g", {
    clipPath: "url(#clip0_113_4775)"
  }, jsx$1("path", {
    d: "M10 13.3334V10.0001M10 6.66675H10.0084M18.3334 10.0001C18.3334 14.6025 14.6024 18.3334 10 18.3334C5.39765 18.3334 1.66669 14.6025 1.66669 10.0001C1.66669 5.39771 5.39765 1.66675 10 1.66675C14.6024 1.66675 18.3334 5.39771 18.3334 10.0001Z",
    stroke: color2,
    strokeWidth: "1.5",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  })), jsx$1("defs", null, jsx$1("clipPath", {
    id: "clip0_113_4775"
  }, jsx$1("rect", {
    width: "20",
    height: "20",
    fill: "white"
  }))));
};
var StarsIcon = function StarsIcon2(_ref3) {
  var _ref$color = _ref3.color, color2 = _ref$color === void 0 ? "black" : _ref$color;
  return jsx$1("svg", {
    width: "20",
    height: "20",
    viewBox: "0 0 20 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, jsx$1("g", {
    clipPath: "url(#clip0_4771_250)"
  }, jsx$1("path", {
    d: "M5.41666 10.8333L6.07037 12.1408C6.29161 12.5832 6.40223 12.8045 6.55002 12.9962C6.68115 13.1663 6.83366 13.3188 7.00378 13.45C7.1955 13.5977 7.41674 13.7084 7.85923 13.9296L9.16666 14.5833L7.85923 15.237C7.41674 15.4583 7.1955 15.5689 7.00378 15.7167C6.83366 15.8478 6.68115 16.0003 6.55002 16.1704C6.40223 16.3622 6.29161 16.5834 6.07037 17.0259L5.41666 18.3333L4.76294 17.0259C4.5417 16.5834 4.43108 16.3622 4.2833 16.1704C4.15216 16.0003 3.99965 15.8478 3.82953 15.7167C3.63781 15.5689 3.41657 15.4583 2.97409 15.237L1.66666 14.5833L2.97409 13.9296C3.41657 13.7084 3.63781 13.5977 3.82953 13.45C3.99965 13.3188 4.15216 13.1663 4.2833 12.9962C4.43108 12.8045 4.5417 12.5832 4.76294 12.1408L5.41666 10.8333Z",
    stroke: color2,
    strokeWidth: "1.5",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), jsx$1("path", {
    d: "M12.5 1.66666L13.4822 4.22034C13.7172 4.83136 13.8347 5.13688 14.0174 5.39386C14.1794 5.62162 14.3784 5.82061 14.6061 5.98256C14.8631 6.16529 15.1686 6.2828 15.7796 6.5178L18.3333 7.49999L15.7796 8.48217C15.1686 8.71718 14.8631 8.83469 14.6061 9.01742C14.3784 9.17937 14.1794 9.37836 14.0174 9.60612C13.8347 9.8631 13.7172 10.1686 13.4822 10.7796L12.5 13.3333L11.5178 10.7796C11.2828 10.1686 11.1653 9.8631 10.9826 9.60612C10.8206 9.37836 10.6216 9.17937 10.3939 9.01742C10.1369 8.83469 9.83136 8.71718 9.22034 8.48217L6.66666 7.49999L9.22034 6.5178C9.83136 6.28279 10.1369 6.16529 10.3939 5.98256C10.6216 5.82061 10.8206 5.62162 10.9826 5.39386C11.1653 5.13688 11.2828 4.83136 11.5178 4.22034L12.5 1.66666Z",
    stroke: color2,
    strokeWidth: "1.5",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  })), jsx$1("defs", null, jsx$1("clipPath", {
    id: "clip0_4771_250"
  }, jsx$1("rect", {
    width: "20",
    height: "20",
    fill: "white"
  }))));
};
var UploadIcon = function UploadIcon2(_ref3) {
  var _ref$color = _ref3.color, color2 = _ref$color === void 0 ? "black" : _ref$color, customCss = _ref3.customCss;
  return jsx$1("svg", {
    css: customCss,
    width: "20",
    height: "20",
    viewBox: "0 0 20 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, jsx$1("path", {
    d: "M17.5 12.5V13.5C17.5 14.9001 17.5 15.6002 17.2275 16.135C16.9878 16.6054 16.6054 16.9878 16.135 17.2275C15.6002 17.5 14.9001 17.5 13.5 17.5H6.5C5.09987 17.5 4.3998 17.5 3.86502 17.2275C3.39462 16.9878 3.01217 16.6054 2.77248 16.135C2.5 15.6002 2.5 14.9001 2.5 13.5V12.5M14.1667 6.66667L10 2.5M10 2.5L5.83333 6.66667M10 2.5V12.5",
    stroke: color2,
    strokeWidth: "1.5",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }));
};
var ShoppingCartIcon = function ShoppingCartIcon2(_ref3) {
  var _ref$color = _ref3.color, color2 = _ref$color === void 0 ? theme.palette.primary.main : _ref$color, customCss = _ref3.customCss;
  return jsx$1("svg", {
    css: customCss,
    width: "20",
    height: "20",
    viewBox: "0 0 20 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, jsx$1("path", {
    d: "M1.6665 1.66663H2.75497C2.95999 1.66663 3.0625 1.66663 3.14499 1.70433C3.21769 1.73755 3.27929 1.79098 3.32246 1.85825C3.37145 1.93458 3.38595 2.03606 3.41494 2.23901L3.80936 4.99996M3.80936 4.99996L4.68594 11.4428C4.79718 12.2604 4.85279 12.6692 5.04825 12.9769C5.22049 13.2481 5.46741 13.4637 5.7593 13.5978C6.09056 13.75 6.50312 13.75 7.32826 13.75H14.4598C15.2453 13.75 15.638 13.75 15.959 13.6086C16.242 13.484 16.4847 13.2832 16.6601 13.0285C16.8589 12.7396 16.9324 12.3538 17.0794 11.5823L18.1824 5.79137C18.2342 5.5198 18.26 5.38401 18.2225 5.27788C18.1897 5.18477 18.1248 5.10636 18.0395 5.05664C17.9422 4.99996 17.804 4.99996 17.5275 4.99996H3.80936ZM8.33317 17.5C8.33317 17.9602 7.96007 18.3333 7.49984 18.3333C7.0396 18.3333 6.6665 17.9602 6.6665 17.5C6.6665 17.0397 7.0396 16.6666 7.49984 16.6666C7.96007 16.6666 8.33317 17.0397 8.33317 17.5ZM14.9998 17.5C14.9998 17.9602 14.6267 18.3333 14.1665 18.3333C13.7063 18.3333 13.3332 17.9602 13.3332 17.5C13.3332 17.0397 13.7063 16.6666 14.1665 16.6666C14.6267 16.6666 14.9998 17.0397 14.9998 17.5Z",
    stroke: color2,
    strokeWidth: "1.5",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }));
};
var CircleCheckIcon = function CircleCheckIcon2(_ref3) {
  var _ref$color = _ref3.color, color2 = _ref$color === void 0 ? "black" : _ref$color, customCss = _ref3.customCss;
  return jsx$1("svg", {
    css: customCss,
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, jsx$1("path", {
    d: "M7.5 12L10.5 15L16.5 9M22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12Z",
    stroke: color2,
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }));
};
var RefreshIcon = function RefreshIcon2(_ref3) {
  var _ref$color = _ref3.color, color2 = _ref$color === void 0 ? "black" : _ref$color, customCss = _ref3.customCss;
  return jsx$1("svg", {
    css: customCss,
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, jsx$1("path", {
    d: "M2 10C2 10 4.00498 7.26822 5.63384 5.63824C7.26269 4.00827 9.5136 3 12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.89691 21 4.43511 18.2543 3.35177 14.5M2 10V4M2 10H8",
    stroke: color2,
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }));
};
var SelectorIcon = function SelectorIcon2(_ref3) {
  var _ref$color = _ref3.color, color2 = _ref$color === void 0 ? "black" : _ref$color, customCss = _ref3.customCss;
  return jsx$1("svg", {
    css: customCss,
    width: "20",
    height: "20",
    viewBox: "0 0 20 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, jsx$1("path", {
    d: "M13 7L10 4L7 7",
    stroke: color2,
    strokeWidth: "1.5",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), jsx$1("path", {
    d: "M7 13L10 16L13 13",
    stroke: color2,
    strokeWidth: "1.5",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }));
};
var ArrowUpIcon = function ArrowUpIcon2(_ref3) {
  var _ref$color = _ref3.color, color2 = _ref$color === void 0 ? "black" : _ref$color, customCss = _ref3.customCss;
  return jsx$1("svg", {
    css: customCss,
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, jsx$1("path", {
    d: "M12 19V5M12 5L5 12M12 5L19 12",
    stroke: color2,
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }));
};
var ArrowRightIcon = function ArrowRightIcon2(_ref3) {
  var _ref$color = _ref3.color, color2 = _ref$color === void 0 ? "black" : _ref$color, customCss = _ref3.customCss;
  return jsx$1("svg", {
    width: "20",
    height: "20",
    viewBox: "0 0 20 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    css: customCss
  }, jsx$1("path", {
    d: "M3.3335 10H16.6668M16.6668 10L11.6668 5M16.6668 10L11.6668 15",
    stroke: color2,
    strokeWidth: "1.5",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }));
};
var Dialog = function Dialog2(_ref3) {
  var customCss = _ref3.customCss, _ref$color = _ref3.color, color2 = _ref$color === void 0 ? theme.palette.grey600 : _ref$color;
  return jsx$1("svg", {
    css: customCss,
    width: "51",
    height: "17",
    viewBox: "0 0 51 17",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, jsx$1("g", {
    clipPath: "url(#clip0_12625_628)"
  }, jsx$1("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M49.4779 12.1543C48.991 11.7394 48.2906 11.5321 47.3766 11.5321H44.0584C43.8258 11.5321 43.6419 11.4694 43.5066 11.3439C43.3769 11.2184 43.312 11.0519 43.312 10.8445C43.312 10.4952 43.4824 10.2497 43.8231 10.1077C44.3423 10.3315 44.9183 10.4434 45.5511 10.4434C46.6059 10.4434 47.4659 10.1541 48.131 9.57565C48.8018 8.99718 49.137 8.20854 49.137 7.2099C49.137 6.69146 49.0449 6.24936 48.8611 5.88377C49.9374 5.43623 50.4836 4.5085 50.5 3.10059H48.4229C48.4229 3.91915 48.158 4.3939 47.6278 4.525C47.033 4.19206 46.3405 4.02559 45.551 4.02559C44.507 4.02559 43.6497 4.31755 42.9791 4.90146C42.3138 5.47993 41.9812 6.26041 41.9812 7.24272C41.9812 8.01214 42.1814 8.65625 42.5816 9.1747C41.8947 9.51307 41.5512 10.0642 41.5512 10.8283C41.5512 11.1613 41.6242 11.4587 41.7703 11.7207C41.9217 11.9825 42.1407 12.1845 42.4274 12.3264C42 12.4301 41.6675 12.6374 41.4294 12.9485C41.1968 13.2541 41.0806 13.6443 41.0806 14.1191C41.0806 14.9868 41.4537 15.6826 42.2002 16.2065C42.9466 16.7358 44.0149 17.0005 45.4049 17.0005H45.4861C46.9519 17.0005 48.1037 16.7222 48.9421 16.1655C49.7859 15.6144 50.2078 14.853 50.2078 13.8815C50.2078 13.1395 49.9644 12.5637 49.4775 12.1543H49.4779ZM44.4559 6.19477C44.7208 5.93274 45.086 5.80182 45.5511 5.80182C46.0163 5.80182 46.3894 5.93002 46.6546 6.18661C46.9249 6.44303 47.0603 6.79518 47.0603 7.24255C47.0603 7.68992 46.9249 8.02575 46.6546 8.28217C46.3895 8.53858 46.0218 8.66696 45.5511 8.66696C45.0805 8.66696 44.7208 8.53875 44.4559 8.28217C44.191 8.02575 44.0584 7.67921 44.0584 7.24255C44.0584 6.80589 44.1908 6.45663 44.4559 6.19477ZM47.4984 14.9293C47.0387 15.1476 46.3949 15.2568 45.5675 15.2568H45.5188C44.7346 15.2568 44.1396 15.1504 43.734 14.9375C43.3283 14.7302 43.1254 14.4299 43.1254 14.0369C43.1254 13.8297 43.1849 13.6632 43.3039 13.5377C43.4229 13.4121 43.5852 13.3495 43.7907 13.3495H47.5309C47.7311 13.3495 47.8906 13.4095 48.0095 13.5295C48.1341 13.6552 48.1961 13.8188 48.1961 14.0208C48.1961 14.4137 47.9635 14.7166 47.4984 14.9295V14.9293Z",
    fill: color2
  }), jsx$1("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M36.2195 4.02539C34.9052 4.02539 33.8614 4.44283 33.0878 5.27789C32.3143 6.11278 31.9277 7.22619 31.9277 8.61779C31.9277 10.0094 32.3143 11.1199 33.0878 11.9658C33.8614 12.8063 34.9052 13.2265 36.2195 13.2265C37.5338 13.2265 38.5749 12.8063 39.3431 11.9658C40.1166 11.1199 40.5033 10.0039 40.5033 8.61779C40.5033 7.23163 40.1166 6.11278 39.3431 5.27789C38.5751 4.44283 37.534 4.02539 36.2195 4.02539ZM36.2195 11.1636C34.7916 11.1636 34.0776 10.3149 34.0776 8.61779C34.0776 6.92063 34.7916 6.0883 36.2195 6.0883C37.6474 6.0883 38.3614 6.93152 38.3614 8.61779C38.3614 10.3041 37.6474 11.1636 36.2195 11.1636Z",
    fill: color2
  }), jsx$1("path", {
    d: "M30.5727 0.890625H28.4795V13.1286H30.5727V0.890625Z",
    fill: color2
  }), jsx$1("path", {
    d: "M17.3579 4.65186H15.2646V13.1284H17.3579V4.65186Z",
    fill: color2
  }), jsx$1("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M25.8179 4.87056C25.1741 4.30842 24.2493 4.02734 23.0432 4.02734C22.1021 4.02734 21.2907 4.20741 20.6092 4.56756C19.9277 4.92226 19.4383 5.43526 19.1407 6.10657L20.6903 7.09705C20.912 6.72602 21.1987 6.45583 21.5502 6.28664C21.9072 6.11201 22.3561 6.02461 22.8971 6.02461C23.8806 6.02461 24.4589 6.31861 24.6334 6.90592C24.6964 7.15877 24.569 7.3453 24.3164 7.49613C24.0622 7.63607 23.7051 7.74693 23.2451 7.82855L22.2644 8.02103C21.5986 8.14924 21.0297 8.3067 20.5576 8.4934C20.0856 8.66837 19.6921 8.93652 19.3773 9.29819C19.0625 9.65969 18.9053 10.1438 18.9053 10.7502C18.9053 11.5782 19.1897 12.2081 19.7587 12.6394C20.3397 13.071 21.0357 13.2868 21.8468 13.2868C22.44 13.2868 23.0029 13.1761 23.5356 12.9544C24.0599 12.7248 24.4608 12.4046 24.7389 11.9942V13.1303H26.7834V7.34292C26.7834 6.25689 26.4615 5.43288 25.8179 4.87073V4.87056ZM24.6976 9.3975C24.6976 9.87071 24.5761 10.2744 24.3332 10.6083C24.0902 10.9425 23.7714 11.1929 23.3765 11.3599C22.9817 11.5269 22.5489 11.6104 22.0782 11.6104C21.638 11.6104 21.2885 11.5408 21.0305 11.4016C20.7723 11.2485 20.6432 11.0188 20.6432 10.7126C20.6432 10.4898 20.7115 10.3089 20.8483 10.1698C21.0002 10.0307 21.2051 9.91934 21.4633 9.83586C21.7215 9.73842 22.0555 9.64796 22.4655 9.56447C22.4807 9.55053 22.5034 9.54356 22.5337 9.54356L23.4448 9.33475C23.9005 9.22831 24.3167 9.10503 24.6935 8.96475L24.6974 8.96305V9.39733L24.6976 9.3975Z",
    fill: color2
  }), jsx$1("path", {
    d: "M17.6428 1.67714C17.6428 0.935066 17.0466 0.333496 16.3112 0.333496C15.5757 0.333496 14.9795 0.935066 14.9795 1.67714V1.75672C14.9795 2.49879 15.5757 3.10036 16.3112 3.10036C17.0466 3.10036 17.6428 2.49879 17.6428 1.75672V1.67714Z",
    fill: color2
  }), jsx$1("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M7.8309 1.38965H0.5V13.1284H2.66686V11.0329H2.66619V3.48537H7.91213C9.08033 3.48537 9.95935 3.79909 10.5488 4.4267C11.1383 5.04887 11.4332 5.96572 11.4332 7.17724C11.4332 8.38877 11.1222 9.39012 10.5003 10.0506C9.87829 10.7054 8.96692 11.0329 7.76619 11.0329H4.74913L2.66703 13.1284H7.62834C9.50518 13.1284 10.9791 12.6018 12.05 11.5486C13.1264 10.4899 13.6645 9.0327 13.6645 7.17724C13.6645 5.32179 13.148 3.94107 12.1149 2.9205C11.0819 1.89993 9.65398 1.38965 7.83124 1.38965H7.8309Z",
    fill: color2
  })), jsx$1("defs", null, jsx$1("clipPath", {
    id: "clip0_12625_628"
  }, jsx$1("rect", {
    width: "50",
    height: "16.6667",
    fill: "white",
    transform: "translate(0.5 0.333496)"
  }))));
};
var DialogIconBlank = function DialogIconBlank2(_ref3) {
  var _ref$color = _ref3.color, color2 = _ref$color === void 0 ? theme.palette.primary.main : _ref$color, customCss = _ref3.customCss;
  return jsx$1("svg", {
    width: "32",
    height: "32",
    viewBox: "0 0 32 32",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    css: customCss
  }, jsx$1("path", {
    d: "M4 4.80005V27.5556H8.21385V23.4932H8.2125V8.86241H18.414C20.6859 8.86241 22.3951 9.4707 23.5416 10.6873C24.688 11.8933 25.2613 13.6706 25.2613 16.0191C25.2613 18.4523 24.6565 20.309 23.4469 21.589C22.2373 22.8585 20.465 23.4932 18.13 23.4932H12.2629L8.22399 27.5556H17.8618C21.5116 27.5556 24.3778 26.5347 26.4603 24.493C28.5534 22.4406 29.6 19.616 29.6 16.0191C29.6 12.4963 28.5955 9.74576 26.5866 7.76748C24.5776 5.78919 21.8008 4.80005 18.2562 4.80005H4Z",
    fill: color2
  }));
};
var ShoppingBagIcon = function ShoppingBagIcon2(_ref3) {
  var _ref$color = _ref3.color, color2 = _ref$color === void 0 ? theme.palette.primary.main : _ref$color, customCss = _ref3.customCss;
  return jsx$1("svg", {
    css: customCss,
    width: "20",
    height: "20",
    viewBox: "0 0 20 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, jsx$1("path", {
    d: "M13.3335 7.49996V4.99996C13.3335 3.15901 11.8411 1.66663 10.0001 1.66663C8.1592 1.66663 6.66681 3.15901 6.66681 4.99996V7.49996M2.99348 8.6266L2.49348 13.9599C2.35132 15.4763 2.28023 16.2346 2.53185 16.8202C2.75289 17.3346 3.14024 17.76 3.63183 18.0281C4.19142 18.3333 4.95295 18.3333 6.47602 18.3333H13.5243C15.0473 18.3333 15.8089 18.3333 16.3685 18.0281C16.86 17.76 17.2474 17.3346 17.4684 16.8202C17.7201 16.2346 17.649 15.4763 17.5068 13.9599L17.0068 8.6266C16.8868 7.34608 16.8267 6.70582 16.5388 6.22176C16.2851 5.79545 15.9104 5.45422 15.4623 5.2415C14.9535 4.99996 14.3104 4.99996 13.0243 4.99996L6.97602 4.99996C5.68989 4.99996 5.04682 4.99996 4.53799 5.24149C4.08987 5.45422 3.71515 5.79545 3.46153 6.22176C3.17355 6.70582 3.11353 7.34608 2.99348 8.6266Z",
    stroke: color2,
    strokeWidth: "1.5",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }));
};
var ThumbDownIcon = function ThumbDownIcon2(_ref3) {
  var _ref$color = _ref3.color, color2 = _ref$color === void 0 ? theme.palette.primary.main : _ref$color, customCss = _ref3.customCss;
  return jsx$1("svg", {
    css: customCss,
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, jsx$1("g", {
    clipPath: "url(#clip0_825_521)"
  }, jsx$1("path", {
    d: "M11.3333 1.33334V8.66668M14.6666 6.53334V3.46668C14.6666 2.71994 14.6666 2.34657 14.5213 2.06136C14.3935 1.81047 14.1895 1.6065 13.9386 1.47867C13.6534 1.33334 13.28 1.33334 12.5333 1.33334H5.41196C4.43764 1.33334 3.95048 1.33334 3.55701 1.51163C3.21022 1.66877 2.91549 1.92163 2.70745 2.24049C2.4714 2.60227 2.39732 3.08377 2.24917 4.04676L1.90045 6.31343C1.70505 7.58355 1.60735 8.21861 1.79582 8.71276C1.96125 9.14647 2.27239 9.50914 2.6759 9.73859C3.13564 10 3.77818 10 5.06324 10H5.59995C5.97332 10 6.16001 10 6.30261 10.0727C6.42806 10.1366 6.53004 10.2386 6.59396 10.364C6.66662 10.5066 6.66662 10.6933 6.66662 11.0667V13.0228C6.66662 13.9307 7.40262 14.6667 8.31051 14.6667C8.52706 14.6667 8.7233 14.5391 8.81125 14.3413L11.0518 9.30013C11.1537 9.07084 11.2046 8.9562 11.2852 8.87214C11.3563 8.79783 11.4438 8.74101 11.5406 8.70614C11.6501 8.66668 11.7756 8.66668 12.0265 8.66668H12.5333C13.28 8.66668 13.6534 8.66668 13.9386 8.52135C14.1895 8.39352 14.3935 8.18955 14.5213 7.93866C14.6666 7.65345 14.6666 7.28008 14.6666 6.53334Z",
    stroke: color2,
    strokeWidth: "1.5",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  })), jsx$1("defs", null, jsx$1("clipPath", {
    id: "clip0_825_521"
  }, jsx$1("rect", {
    width: "16",
    height: "16",
    fill: "white"
  }))));
};
var ThumbUpIcon = function ThumbUpIcon2(_ref3) {
  var _ref$color = _ref3.color, color2 = _ref$color === void 0 ? theme.palette.primary.main : _ref$color, customCss = _ref3.customCss;
  return jsx$1("svg", {
    css: customCss,
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, jsx$1("g", {
    clipPath: "url(#clip0_825_1817)"
  }, jsx$1("path", {
    d: "M4.66659 14.6667V7.33334M1.33325 8.66668V13.3333C1.33325 14.0697 1.93021 14.6667 2.66659 14.6667H11.6174C12.6046 14.6667 13.4441 13.9465 13.5942 12.9708L14.3121 8.30413C14.4985 7.09261 13.5611 6.00001 12.3354 6.00001H9.99992C9.63173 6.00001 9.33325 5.70153 9.33325 5.33334V2.97724C9.33325 2.06934 8.59726 1.33334 7.68936 1.33334C7.47281 1.33334 7.27657 1.46087 7.18862 1.65876L4.84254 6.93744C4.73554 7.17819 4.4968 7.33334 4.23334 7.33334H2.66659C1.93021 7.33334 1.33325 7.9303 1.33325 8.66668Z",
    stroke: color2,
    strokeWidth: "1.5",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  })), jsx$1("defs", null, jsx$1("clipPath", {
    id: "clip0_825_1817"
  }, jsx$1("rect", {
    width: "16",
    height: "16",
    fill: "white"
  }))));
};
var CameraIcon = function CameraIcon2(_ref3) {
  var _ref$color = _ref3.color, color2 = _ref$color === void 0 ? "black" : _ref$color, customCss = _ref3.customCss;
  return jsx$1("svg", {
    css: customCss,
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, jsx$1("path", {
    d: "M1.33301 5.58473C1.33301 5.35119 1.33301 5.23442 1.34275 5.13606C1.43674 4.18743 2.18719 3.43699 3.13582 3.343C3.23417 3.33325 3.35725 3.33325 3.6034 3.33325C3.69824 3.33325 3.74567 3.33325 3.78593 3.33081C4.30008 3.29968 4.75031 2.97517 4.94244 2.49725C4.95748 2.45982 4.97155 2.41763 4.99967 2.33325C5.0278 2.24887 5.04187 2.20668 5.05691 2.16925C5.24904 1.69133 5.69927 1.36683 6.21342 1.33569C6.25368 1.33325 6.29816 1.33325 6.3871 1.33325H9.61225C9.7012 1.33325 9.74567 1.33325 9.78593 1.33569C10.3001 1.36683 10.7503 1.69133 10.9424 2.16925C10.9575 2.20668 10.9715 2.24887 10.9997 2.33325C11.0278 2.41763 11.0419 2.45982 11.0569 2.49725C11.249 2.97517 11.6993 3.29968 12.2134 3.33081C12.2537 3.33325 12.3011 3.33325 12.396 3.33325C12.6421 3.33325 12.7652 3.33325 12.8635 3.343C13.8122 3.43699 14.5626 4.18743 14.6566 5.13606C14.6663 5.23442 14.6663 5.35119 14.6663 5.58473V10.7999C14.6663 11.92 14.6663 12.4801 14.4484 12.9079C14.2566 13.2842 13.9506 13.5902 13.5743 13.7819C13.1465 13.9999 12.5864 13.9999 11.4663 13.9999H4.53301C3.4129 13.9999 2.85285 13.9999 2.42503 13.7819C2.0487 13.5902 1.74274 13.2842 1.55099 12.9079C1.33301 12.4801 1.33301 11.92 1.33301 10.7999V5.58473Z",
    stroke: color2,
    "stroke-width": "1.5",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }), jsx$1("path", {
    d: "M7.99968 10.9999C9.47243 10.9999 10.6663 9.80601 10.6663 8.33325C10.6663 6.86049 9.47243 5.66659 7.99968 5.66659C6.52692 5.66659 5.33301 6.86049 5.33301 8.33325C5.33301 9.80601 6.52692 10.9999 7.99968 10.9999Z",
    stroke: color2,
    "stroke-width": "1.5",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }));
};
var ArrowLeftIcon = function ArrowLeftIcon2(_ref3) {
  var _ref$color = _ref3.color, color2 = _ref$color === void 0 ? "black" : _ref$color, customCss = _ref3.customCss;
  return jsx$1("svg", {
    css: customCss,
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, jsx$1("path", {
    d: "M20 12H4M4 12L10 18M4 12L10 6",
    stroke: color2,
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }));
};
function _typeof(o2) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof(o2);
}
function toPrimitive(t2, r2) {
  if ("object" != _typeof(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i = e2.call(t2, r2 || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function toPropertyKey(t2) {
  var i = toPrimitive(t2, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}
function _defineProperty$1(e2, r2, t2) {
  return (r2 = toPropertyKey(r2)) in e2 ? Object.defineProperty(e2, r2, {
    value: t2,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e2[r2] = t2, e2;
}
var _templateObject$2;
function ownKeys$2(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e2);
    r2 && (o2 = o2.filter(function(r22) {
      return Object.getOwnPropertyDescriptor(e2, r22).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$2(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$2(Object(t2), true).forEach(function(r22) {
      _defineProperty$1(e2, r22, t2[r22]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$2(Object(t2)).forEach(function(r22) {
      Object.defineProperty(e2, r22, Object.getOwnPropertyDescriptor(t2, r22));
    });
  }
  return e2;
}
var cleanIconOnlyStyle = {
  name: "7lkcnl",
  styles: "background:unset;padding:0;margin:0;box-shadow:unset;height:auto;width:fit-content;&:hover{background:unset;}"
};
var buttonStyle$1 = function buttonStyle2(_ref3) {
  var size = _ref3.size, variant = _ref3.variant, onlyIcon = _ref3.onlyIcon;
  return /* @__PURE__ */ css({
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    outline: "unset",
    cursor: "pointer",
    border: BUTTON_VARIANTS[variant].border["default"],
    backgroundColor: BUTTON_VARIANTS[variant].background["default"],
    color: BUTTON_VARIANTS[variant].color["default"],
    borderRadius: BUTTON_VARIANTS[variant].borderRadius,
    padding: onlyIcon ? BUTTON_SIZES[size].paddingIcon : BUTTON_SIZES[size].padding,
    height: "".concat(BUTTON_SIZES[size].height, "px"),
    width: onlyIcon ? "".concat(BUTTON_SIZES[size].height, "px") : "auto",
    fontFamily: theme.typography.fontFamily,
    boxShadow: BUTTON_VARIANTS[variant].shadow,
    whiteSpace: "pre",
    "&:hover": {
      backgroundColor: BUTTON_VARIANTS[variant].background.hover,
      color: BUTTON_VARIANTS[variant].color.hover
    },
    "&:disabled": {
      backgroundColor: BUTTON_VARIANTS[variant].background.disabled,
      cursor: "not-allowed",
      border: BUTTON_VARIANTS[variant].border.disabled,
      color: BUTTON_VARIANTS[variant].color.disabled,
      boxShadow: "unset",
      "svg > path": {
        stroke: BUTTON_VARIANTS[variant].color.disabled
      },
      span: {
        color: BUTTON_VARIANTS[variant].color.disabled,
        cursor: "not-allowed"
      }
    }
  }, "", "", "", "");
};
var defaultButtonSpanStyle = function defaultButtonSpanStyle2(_ref22) {
  var variant = _ref22.variant, size = _ref22.size;
  return /* @__PURE__ */ css(_objectSpread$2(_objectSpread$2({
    color: BUTTON_VARIANTS[variant].color["default"],
    cursor: "pointer"
  }, TYPOGRAPHY_VARIANTS[BUTTON_SIZES[size].typographySize]), {}, {
    "&:hover": {
      color: BUTTON_VARIANTS[variant].color.hover
    },
    "&:disabled": {
      color: BUTTON_VARIANTS[variant].color.disabled
    }
  }), "", "", "", "");
};
var buttonRotation = keyframes(_templateObject$2 || (_templateObject$2 = _taggedTemplateLiteral(["\n  from {\n    transform: rotate(0deg);\n  }\n\n  to {\n    transform: rotate(360deg);\n  }\n"])));
var LoadingButton = function LoadingButton2(_ref3) {
  var _ref$size = _ref3.size, size = _ref$size === void 0 ? "sm" : _ref$size, _ref$variant = _ref3.variant, variant = _ref$variant === void 0 ? "primary" : _ref$variant, customCss = _ref3.customCss;
  return jsx$1("button", {
    disabled: true,
    css: [buttonStyle$1({
      size,
      variant,
      onlyIcon: false
    }), customCss, "", "", "", ""]
  }, jsx$1("div", {
    css: /* @__PURE__ */ css({
      display: "flex",
      alignItems: "center",
      margin: "0 auto",
      svg: {
        animation: "".concat(buttonRotation, " linear 0.7s infinite")
      }
    }, "", "", "", "")
  }, jsx$1(SpinnerIcon, null)));
};
var _ref$6 = {
  name: "0",
  styles: ""
};
var Button = function Button2(_ref22) {
  var id2 = _ref22.id, onClick = _ref22.onClick, onMouseOver = _ref22.onMouseOver, onFocus = _ref22.onFocus, iconLeft = _ref22.iconLeft, iconRight = _ref22.iconRight, customCss = _ref22.customCss, labelCss = _ref22.labelCss, children = _ref22.children, disabled = _ref22.disabled, _ref2$type = _ref22.type, type2 = _ref2$type === void 0 ? "button" : _ref2$type, _ref2$loading = _ref22.loading, loading = _ref2$loading === void 0 ? false : _ref2$loading, _ref2$size = _ref22.size, size = _ref2$size === void 0 ? "sm" : _ref2$size, _ref2$variant = _ref22.variant, variant = _ref2$variant === void 0 ? "primary" : _ref2$variant, enableCleanIconOnlyStyle = _ref22.enableCleanIconOnlyStyle;
  if (loading) {
    return jsx$1(LoadingButton, {
      size,
      variant,
      customCss
    });
  }
  return jsx$1("button", {
    id: id2,
    disabled,
    onClick,
    css: [buttonStyle$1({
      size,
      variant,
      onlyIcon: children === void 0
    }), enableCleanIconOnlyStyle === true ? cleanIconOnlyStyle : _ref$6, customCss, "", "", "", ""],
    onMouseOver,
    onFocus,
    type: type2
  }, iconLeft ? jsx$1("span", {
    css: /* @__PURE__ */ css({
      display: "inherit",
      verticalAlign: "middle",
      marginRight: children !== void 0 ? BUTTON_SIZES[size].iconMargin : "0px"
    }, "", "", "", "")
  }, iconLeft) : null, enableCleanIconOnlyStyle === false || enableCleanIconOnlyStyle === void 0 ? jsx$1("span", {
    css: [defaultButtonSpanStyle({
      variant,
      size
    }), labelCss, "", "", "", ""]
  }, children) : children, iconRight ? jsx$1("span", {
    css: /* @__PURE__ */ css({
      display: "inherit",
      verticalAlign: "middle",
      marginLeft: children !== void 0 ? BUTTON_SIZES[size].iconMargin : "0px"
    }, "", "", "", "")
  }, iconRight) : null);
};
var useIsMobile = function useIsMobile2(_ref3) {
  var size = _ref3.size;
  var _useState = p$1(window.innerWidth < size), _useState2 = _slicedToArray(_useState, 2), isMobile = _useState2[0], setIsMobile = _useState2[1];
  A$2(function() {
    var handleIsMobile = function handleIsMobile2() {
      setIsMobile(window.innerWidth <= size);
    };
    window.addEventListener("resize", handleIsMobile);
    return function() {
      return window.removeEventListener("resize", handleIsMobile);
    };
  }, [size]);
  return isMobile;
};
var useForwardRef = function useForwardRef2(ref2) {
  var targetRef = F$1(null);
  _(function() {
    if (!ref2) return;
    if (typeof ref2 === "function") {
      ref2(targetRef.current);
    } else {
      ref2.current = targetRef.current;
    }
  }, [ref2]);
  return targetRef;
};
var getWebSocketUrl = function getWebSocketUrl2(baseWebSocketUrl, sessionId, apiKey2) {
  return "".concat(baseWebSocketUrl, "?sessionId=").concat(sessionId, "&apiKey=").concat(apiKey2);
};
var HEARTBEAT_INTERVAL = 6e4;
var WebSocketContext = /* @__PURE__ */ E$2({
  activateWebSocket: function activateWebSocket() {
    return console.error("WebSocket context is not well initialized");
  }
});
var WebSocketProvider = function WebSocketProvider2(props) {
  var sessionId = props.sessionId, apiKey2 = props.apiKey, baseWebSocketUrl = props.baseWebSocketUrl;
  var _useState = p$1(), _useState2 = _slicedToArray(_useState, 2), ws3 = _useState2[0], setWs = _useState2[1];
  var hearbeatRef = F$1(void 0);
  var _useState3 = p$1(false), _useState4 = _slicedToArray(_useState3, 2), wsActivated = _useState4[0], setWsActivated = _useState4[1];
  var activateWebSocket2 = x$2(function() {
    setWsActivated(true);
  }, []);
  _(function() {
    if (!wsActivated) return;
    setWs(new WebSocket(getWebSocketUrl(baseWebSocketUrl, sessionId, apiKey2)));
  }, [apiKey2, baseWebSocketUrl, sessionId, wsActivated]);
  _(function() {
    if (ws3 === void 0) return;
    var onClose = function onClose2() {
      setWs(new WebSocket(getWebSocketUrl(baseWebSocketUrl, sessionId, apiKey2)));
    };
    ws3.addEventListener("close", onClose);
    var onOpen = function onOpen2() {
      hearbeatRef.current = setInterval(function() {
        if (ws3.readyState === WebSocket.OPEN) {
          ws3.send(JSON.stringify({
            action: "heartbeat"
          }));
        }
      }, HEARTBEAT_INTERVAL);
    };
    ws3.addEventListener("open", onOpen);
    var onOnline = function onOnline2() {
      if (wsActivated && // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      (ws3 === void 0 || ws3.readyState === WebSocket.CLOSED)) {
        setWs(new WebSocket(getWebSocketUrl(baseWebSocketUrl, sessionId, apiKey2)));
      }
    };
    var onOffline = function onOffline2() {
      ws3.close();
    };
    window.addEventListener("online", onOnline);
    window.addEventListener("offline", onOffline);
    return function() {
      ws3.removeEventListener("close", onClose);
      ws3.removeEventListener("open", onOpen);
      window.removeEventListener("online", onOnline);
      window.removeEventListener("offline", onOffline);
      clearInterval(hearbeatRef.current);
    };
  }, [apiKey2, baseWebSocketUrl, sessionId, ws3, wsActivated]);
  return jsx$1(WebSocketContext.Provider, {
    value: {
      webSocket: ws3,
      activateWebSocket: activateWebSocket2
    }
  }, props.children);
};
var formatMessageEvent = function formatMessageEvent2(event) {
  var data = JSON.parse(event.data);
  return data;
};
var useWebSocket = function useWebSocket2(_ref3) {
  var topic = _ref3.topic, onMessage = _ref3.onMessage;
  var _useContext = P$1(WebSocketContext), webSocket = _useContext.webSocket;
  var handleNewMessage = x$2(function(event) {
    var data = formatMessageEvent(event);
    if (data === void 0 || !topic.includes(data.topic)) return;
    onMessage(data);
  }, [onMessage, topic]);
  _(function() {
    if (webSocket === void 0) return;
    webSocket.addEventListener("message", handleNewMessage);
    return function() {
      return webSocket.removeEventListener("message", handleNewMessage);
    };
  }, [webSocket, handleNewMessage]);
};
var extendStatics = function(d2, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d3[p2] = b3[p2];
  };
  return extendStatics(d2, b2);
};
function __extends(d2, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __rest(s2, e2) {
  var t2 = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
    t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
}
function __spreadArray(to2, from2, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l2 = from2.length, ar2; i < l2; i++) {
    if (ar2 || !(i in from2)) {
      if (!ar2) ar2 = Array.prototype.slice.call(from2, 0, i);
      ar2[i] = from2[i];
    }
  }
  return to2.concat(ar2 || Array.prototype.slice.call(from2));
}
typeof SuppressedError === "function" ? SuppressedError : function(error2, suppressed, message) {
  var e2 = new Error(message);
  return e2.name = "SuppressedError", e2.error = error2, e2.suppressed = suppressed, e2;
};
function invariant(condition, message, Err) {
  if (Err === void 0) {
    Err = Error;
  }
  if (!condition) {
    throw new Err(message);
  }
}
var ErrorKind;
(function(ErrorKind2) {
  ErrorKind2[ErrorKind2["EXPECT_ARGUMENT_CLOSING_BRACE"] = 1] = "EXPECT_ARGUMENT_CLOSING_BRACE";
  ErrorKind2[ErrorKind2["EMPTY_ARGUMENT"] = 2] = "EMPTY_ARGUMENT";
  ErrorKind2[ErrorKind2["MALFORMED_ARGUMENT"] = 3] = "MALFORMED_ARGUMENT";
  ErrorKind2[ErrorKind2["EXPECT_ARGUMENT_TYPE"] = 4] = "EXPECT_ARGUMENT_TYPE";
  ErrorKind2[ErrorKind2["INVALID_ARGUMENT_TYPE"] = 5] = "INVALID_ARGUMENT_TYPE";
  ErrorKind2[ErrorKind2["EXPECT_ARGUMENT_STYLE"] = 6] = "EXPECT_ARGUMENT_STYLE";
  ErrorKind2[ErrorKind2["INVALID_NUMBER_SKELETON"] = 7] = "INVALID_NUMBER_SKELETON";
  ErrorKind2[ErrorKind2["INVALID_DATE_TIME_SKELETON"] = 8] = "INVALID_DATE_TIME_SKELETON";
  ErrorKind2[ErrorKind2["EXPECT_NUMBER_SKELETON"] = 9] = "EXPECT_NUMBER_SKELETON";
  ErrorKind2[ErrorKind2["EXPECT_DATE_TIME_SKELETON"] = 10] = "EXPECT_DATE_TIME_SKELETON";
  ErrorKind2[ErrorKind2["UNCLOSED_QUOTE_IN_ARGUMENT_STYLE"] = 11] = "UNCLOSED_QUOTE_IN_ARGUMENT_STYLE";
  ErrorKind2[ErrorKind2["EXPECT_SELECT_ARGUMENT_OPTIONS"] = 12] = "EXPECT_SELECT_ARGUMENT_OPTIONS";
  ErrorKind2[ErrorKind2["EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE"] = 13] = "EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE";
  ErrorKind2[ErrorKind2["INVALID_PLURAL_ARGUMENT_OFFSET_VALUE"] = 14] = "INVALID_PLURAL_ARGUMENT_OFFSET_VALUE";
  ErrorKind2[ErrorKind2["EXPECT_SELECT_ARGUMENT_SELECTOR"] = 15] = "EXPECT_SELECT_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["EXPECT_PLURAL_ARGUMENT_SELECTOR"] = 16] = "EXPECT_PLURAL_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT"] = 17] = "EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT";
  ErrorKind2[ErrorKind2["EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT"] = 18] = "EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT";
  ErrorKind2[ErrorKind2["INVALID_PLURAL_ARGUMENT_SELECTOR"] = 19] = "INVALID_PLURAL_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["DUPLICATE_PLURAL_ARGUMENT_SELECTOR"] = 20] = "DUPLICATE_PLURAL_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["DUPLICATE_SELECT_ARGUMENT_SELECTOR"] = 21] = "DUPLICATE_SELECT_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["MISSING_OTHER_CLAUSE"] = 22] = "MISSING_OTHER_CLAUSE";
  ErrorKind2[ErrorKind2["INVALID_TAG"] = 23] = "INVALID_TAG";
  ErrorKind2[ErrorKind2["INVALID_TAG_NAME"] = 25] = "INVALID_TAG_NAME";
  ErrorKind2[ErrorKind2["UNMATCHED_CLOSING_TAG"] = 26] = "UNMATCHED_CLOSING_TAG";
  ErrorKind2[ErrorKind2["UNCLOSED_TAG"] = 27] = "UNCLOSED_TAG";
})(ErrorKind || (ErrorKind = {}));
var TYPE;
(function(TYPE2) {
  TYPE2[TYPE2["literal"] = 0] = "literal";
  TYPE2[TYPE2["argument"] = 1] = "argument";
  TYPE2[TYPE2["number"] = 2] = "number";
  TYPE2[TYPE2["date"] = 3] = "date";
  TYPE2[TYPE2["time"] = 4] = "time";
  TYPE2[TYPE2["select"] = 5] = "select";
  TYPE2[TYPE2["plural"] = 6] = "plural";
  TYPE2[TYPE2["pound"] = 7] = "pound";
  TYPE2[TYPE2["tag"] = 8] = "tag";
})(TYPE || (TYPE = {}));
var SKELETON_TYPE;
(function(SKELETON_TYPE2) {
  SKELETON_TYPE2[SKELETON_TYPE2["number"] = 0] = "number";
  SKELETON_TYPE2[SKELETON_TYPE2["dateTime"] = 1] = "dateTime";
})(SKELETON_TYPE || (SKELETON_TYPE = {}));
function isLiteralElement(el) {
  return el.type === TYPE.literal;
}
function isArgumentElement(el) {
  return el.type === TYPE.argument;
}
function isNumberElement(el) {
  return el.type === TYPE.number;
}
function isDateElement(el) {
  return el.type === TYPE.date;
}
function isTimeElement(el) {
  return el.type === TYPE.time;
}
function isSelectElement(el) {
  return el.type === TYPE.select;
}
function isPluralElement(el) {
  return el.type === TYPE.plural;
}
function isPoundElement(el) {
  return el.type === TYPE.pound;
}
function isTagElement(el) {
  return el.type === TYPE.tag;
}
function isNumberSkeleton(el) {
  return !!(el && typeof el === "object" && el.type === SKELETON_TYPE.number);
}
function isDateTimeSkeleton(el) {
  return !!(el && typeof el === "object" && el.type === SKELETON_TYPE.dateTime);
}
var SPACE_SEPARATOR_REGEX = /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/;
var DATE_TIME_REGEX = /(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvVxX]{1,4})(?=([^']*'[^']*')*[^']*$)/g;
function parseDateTimeSkeleton(skeleton) {
  var result = {};
  skeleton.replace(DATE_TIME_REGEX, function(match2) {
    var len = match2.length;
    switch (match2[0]) {
      case "G":
        result.era = len === 4 ? "long" : len === 5 ? "narrow" : "short";
        break;
      case "y":
        result.year = len === 2 ? "2-digit" : "numeric";
        break;
      case "Y":
      case "u":
      case "U":
      case "r":
        throw new RangeError("`Y/u/U/r` (year) patterns are not supported, use `y` instead");
      case "q":
      case "Q":
        throw new RangeError("`q/Q` (quarter) patterns are not supported");
      case "M":
      case "L":
        result.month = ["numeric", "2-digit", "short", "long", "narrow"][len - 1];
        break;
      case "w":
      case "W":
        throw new RangeError("`w/W` (week) patterns are not supported");
      case "d":
        result.day = ["numeric", "2-digit"][len - 1];
        break;
      case "D":
      case "F":
      case "g":
        throw new RangeError("`D/F/g` (day) patterns are not supported, use `d` instead");
      case "E":
        result.weekday = len === 4 ? "short" : len === 5 ? "narrow" : "short";
        break;
      case "e":
        if (len < 4) {
          throw new RangeError("`e..eee` (weekday) patterns are not supported");
        }
        result.weekday = ["short", "long", "narrow", "short"][len - 4];
        break;
      case "c":
        if (len < 4) {
          throw new RangeError("`c..ccc` (weekday) patterns are not supported");
        }
        result.weekday = ["short", "long", "narrow", "short"][len - 4];
        break;
      case "a":
        result.hour12 = true;
        break;
      case "b":
      case "B":
        throw new RangeError("`b/B` (period) patterns are not supported, use `a` instead");
      case "h":
        result.hourCycle = "h12";
        result.hour = ["numeric", "2-digit"][len - 1];
        break;
      case "H":
        result.hourCycle = "h23";
        result.hour = ["numeric", "2-digit"][len - 1];
        break;
      case "K":
        result.hourCycle = "h11";
        result.hour = ["numeric", "2-digit"][len - 1];
        break;
      case "k":
        result.hourCycle = "h24";
        result.hour = ["numeric", "2-digit"][len - 1];
        break;
      case "j":
      case "J":
      case "C":
        throw new RangeError("`j/J/C` (hour) patterns are not supported, use `h/H/K/k` instead");
      case "m":
        result.minute = ["numeric", "2-digit"][len - 1];
        break;
      case "s":
        result.second = ["numeric", "2-digit"][len - 1];
        break;
      case "S":
      case "A":
        throw new RangeError("`S/A` (second) patterns are not supported, use `s` instead");
      case "z":
        result.timeZoneName = len < 4 ? "short" : "long";
        break;
      case "Z":
      case "O":
      case "v":
      case "V":
      case "X":
      case "x":
        throw new RangeError("`Z/O/v/V/X/x` (timeZone) patterns are not supported, use `z` instead");
    }
    return "";
  });
  return result;
}
var WHITE_SPACE_REGEX = /[\t-\r \x85\u200E\u200F\u2028\u2029]/i;
function parseNumberSkeletonFromString(skeleton) {
  if (skeleton.length === 0) {
    throw new Error("Number skeleton cannot be empty");
  }
  var stringTokens = skeleton.split(WHITE_SPACE_REGEX).filter(function(x2) {
    return x2.length > 0;
  });
  var tokens = [];
  for (var _i2 = 0, stringTokens_1 = stringTokens; _i2 < stringTokens_1.length; _i2++) {
    var stringToken = stringTokens_1[_i2];
    var stemAndOptions = stringToken.split("/");
    if (stemAndOptions.length === 0) {
      throw new Error("Invalid number skeleton");
    }
    var stem = stemAndOptions[0], options = stemAndOptions.slice(1);
    for (var _a3 = 0, options_1 = options; _a3 < options_1.length; _a3++) {
      var option = options_1[_a3];
      if (option.length === 0) {
        throw new Error("Invalid number skeleton");
      }
    }
    tokens.push({ stem, options });
  }
  return tokens;
}
function icuUnitToEcma(unit) {
  return unit.replace(/^(.*?)-/, "");
}
var FRACTION_PRECISION_REGEX = /^\.(?:(0+)(\*)?|(#+)|(0+)(#+))$/g;
var SIGNIFICANT_PRECISION_REGEX = /^(@+)?(\+|#+)?[rs]?$/g;
var INTEGER_WIDTH_REGEX = /(\*)(0+)|(#+)(0+)|(0+)/g;
var CONCISE_INTEGER_WIDTH_REGEX = /^(0+)$/;
function parseSignificantPrecision(str) {
  var result = {};
  if (str[str.length - 1] === "r") {
    result.roundingPriority = "morePrecision";
  } else if (str[str.length - 1] === "s") {
    result.roundingPriority = "lessPrecision";
  }
  str.replace(SIGNIFICANT_PRECISION_REGEX, function(_2, g1, g2) {
    if (typeof g2 !== "string") {
      result.minimumSignificantDigits = g1.length;
      result.maximumSignificantDigits = g1.length;
    } else if (g2 === "+") {
      result.minimumSignificantDigits = g1.length;
    } else if (g1[0] === "#") {
      result.maximumSignificantDigits = g1.length;
    } else {
      result.minimumSignificantDigits = g1.length;
      result.maximumSignificantDigits = g1.length + (typeof g2 === "string" ? g2.length : 0);
    }
    return "";
  });
  return result;
}
function parseSign(str) {
  switch (str) {
    case "sign-auto":
      return {
        signDisplay: "auto"
      };
    case "sign-accounting":
    case "()":
      return {
        currencySign: "accounting"
      };
    case "sign-always":
    case "+!":
      return {
        signDisplay: "always"
      };
    case "sign-accounting-always":
    case "()!":
      return {
        signDisplay: "always",
        currencySign: "accounting"
      };
    case "sign-except-zero":
    case "+?":
      return {
        signDisplay: "exceptZero"
      };
    case "sign-accounting-except-zero":
    case "()?":
      return {
        signDisplay: "exceptZero",
        currencySign: "accounting"
      };
    case "sign-never":
    case "+_":
      return {
        signDisplay: "never"
      };
  }
}
function parseConciseScientificAndEngineeringStem(stem) {
  var result;
  if (stem[0] === "E" && stem[1] === "E") {
    result = {
      notation: "engineering"
    };
    stem = stem.slice(2);
  } else if (stem[0] === "E") {
    result = {
      notation: "scientific"
    };
    stem = stem.slice(1);
  }
  if (result) {
    var signDisplay = stem.slice(0, 2);
    if (signDisplay === "+!") {
      result.signDisplay = "always";
      stem = stem.slice(2);
    } else if (signDisplay === "+?") {
      result.signDisplay = "exceptZero";
      stem = stem.slice(2);
    }
    if (!CONCISE_INTEGER_WIDTH_REGEX.test(stem)) {
      throw new Error("Malformed concise eng/scientific notation");
    }
    result.minimumIntegerDigits = stem.length;
  }
  return result;
}
function parseNotationOptions(opt) {
  var result = {};
  var signOpts = parseSign(opt);
  if (signOpts) {
    return signOpts;
  }
  return result;
}
function parseNumberSkeleton(tokens) {
  var result = {};
  for (var _i2 = 0, tokens_1 = tokens; _i2 < tokens_1.length; _i2++) {
    var token2 = tokens_1[_i2];
    switch (token2.stem) {
      case "percent":
      case "%":
        result.style = "percent";
        continue;
      case "%x100":
        result.style = "percent";
        result.scale = 100;
        continue;
      case "currency":
        result.style = "currency";
        result.currency = token2.options[0];
        continue;
      case "group-off":
      case ",_":
        result.useGrouping = false;
        continue;
      case "precision-integer":
      case ".":
        result.maximumFractionDigits = 0;
        continue;
      case "measure-unit":
      case "unit":
        result.style = "unit";
        result.unit = icuUnitToEcma(token2.options[0]);
        continue;
      case "compact-short":
      case "K":
        result.notation = "compact";
        result.compactDisplay = "short";
        continue;
      case "compact-long":
      case "KK":
        result.notation = "compact";
        result.compactDisplay = "long";
        continue;
      case "scientific":
        result = __assign(__assign(__assign({}, result), { notation: "scientific" }), token2.options.reduce(function(all3, opt2) {
          return __assign(__assign({}, all3), parseNotationOptions(opt2));
        }, {}));
        continue;
      case "engineering":
        result = __assign(__assign(__assign({}, result), { notation: "engineering" }), token2.options.reduce(function(all3, opt2) {
          return __assign(__assign({}, all3), parseNotationOptions(opt2));
        }, {}));
        continue;
      case "notation-simple":
        result.notation = "standard";
        continue;
      case "unit-width-narrow":
        result.currencyDisplay = "narrowSymbol";
        result.unitDisplay = "narrow";
        continue;
      case "unit-width-short":
        result.currencyDisplay = "code";
        result.unitDisplay = "short";
        continue;
      case "unit-width-full-name":
        result.currencyDisplay = "name";
        result.unitDisplay = "long";
        continue;
      case "unit-width-iso-code":
        result.currencyDisplay = "symbol";
        continue;
      case "scale":
        result.scale = parseFloat(token2.options[0]);
        continue;
      case "integer-width":
        if (token2.options.length > 1) {
          throw new RangeError("integer-width stems only accept a single optional option");
        }
        token2.options[0].replace(INTEGER_WIDTH_REGEX, function(_2, g1, g2, g3, g4, g5) {
          if (g1) {
            result.minimumIntegerDigits = g2.length;
          } else if (g3 && g4) {
            throw new Error("We currently do not support maximum integer digits");
          } else if (g5) {
            throw new Error("We currently do not support exact integer digits");
          }
          return "";
        });
        continue;
    }
    if (CONCISE_INTEGER_WIDTH_REGEX.test(token2.stem)) {
      result.minimumIntegerDigits = token2.stem.length;
      continue;
    }
    if (FRACTION_PRECISION_REGEX.test(token2.stem)) {
      if (token2.options.length > 1) {
        throw new RangeError("Fraction-precision stems only accept a single optional option");
      }
      token2.stem.replace(FRACTION_PRECISION_REGEX, function(_2, g1, g2, g3, g4, g5) {
        if (g2 === "*") {
          result.minimumFractionDigits = g1.length;
        } else if (g3 && g3[0] === "#") {
          result.maximumFractionDigits = g3.length;
        } else if (g4 && g5) {
          result.minimumFractionDigits = g4.length;
          result.maximumFractionDigits = g4.length + g5.length;
        } else {
          result.minimumFractionDigits = g1.length;
          result.maximumFractionDigits = g1.length;
        }
        return "";
      });
      var opt = token2.options[0];
      if (opt === "w") {
        result = __assign(__assign({}, result), { trailingZeroDisplay: "stripIfInteger" });
      } else if (opt) {
        result = __assign(__assign({}, result), parseSignificantPrecision(opt));
      }
      continue;
    }
    if (SIGNIFICANT_PRECISION_REGEX.test(token2.stem)) {
      result = __assign(__assign({}, result), parseSignificantPrecision(token2.stem));
      continue;
    }
    var signOpts = parseSign(token2.stem);
    if (signOpts) {
      result = __assign(__assign({}, result), signOpts);
    }
    var conciseScientificAndEngineeringOpts = parseConciseScientificAndEngineeringStem(token2.stem);
    if (conciseScientificAndEngineeringOpts) {
      result = __assign(__assign({}, result), conciseScientificAndEngineeringOpts);
    }
  }
  return result;
}
var timeData = {
  "AX": [
    "H"
  ],
  "BQ": [
    "H"
  ],
  "CP": [
    "H"
  ],
  "CZ": [
    "H"
  ],
  "DK": [
    "H"
  ],
  "FI": [
    "H"
  ],
  "ID": [
    "H"
  ],
  "IS": [
    "H"
  ],
  "ML": [
    "H"
  ],
  "NE": [
    "H"
  ],
  "RU": [
    "H"
  ],
  "SE": [
    "H"
  ],
  "SJ": [
    "H"
  ],
  "SK": [
    "H"
  ],
  "AS": [
    "h",
    "H"
  ],
  "BT": [
    "h",
    "H"
  ],
  "DJ": [
    "h",
    "H"
  ],
  "ER": [
    "h",
    "H"
  ],
  "GH": [
    "h",
    "H"
  ],
  "IN": [
    "h",
    "H"
  ],
  "LS": [
    "h",
    "H"
  ],
  "PG": [
    "h",
    "H"
  ],
  "PW": [
    "h",
    "H"
  ],
  "SO": [
    "h",
    "H"
  ],
  "TO": [
    "h",
    "H"
  ],
  "VU": [
    "h",
    "H"
  ],
  "WS": [
    "h",
    "H"
  ],
  "001": [
    "H",
    "h"
  ],
  "AL": [
    "h",
    "H",
    "hB"
  ],
  "TD": [
    "h",
    "H",
    "hB"
  ],
  "ca-ES": [
    "H",
    "h",
    "hB"
  ],
  "CF": [
    "H",
    "h",
    "hB"
  ],
  "CM": [
    "H",
    "h",
    "hB"
  ],
  "fr-CA": [
    "H",
    "h",
    "hB"
  ],
  "gl-ES": [
    "H",
    "h",
    "hB"
  ],
  "it-CH": [
    "H",
    "h",
    "hB"
  ],
  "it-IT": [
    "H",
    "h",
    "hB"
  ],
  "LU": [
    "H",
    "h",
    "hB"
  ],
  "NP": [
    "H",
    "h",
    "hB"
  ],
  "PF": [
    "H",
    "h",
    "hB"
  ],
  "SC": [
    "H",
    "h",
    "hB"
  ],
  "SM": [
    "H",
    "h",
    "hB"
  ],
  "SN": [
    "H",
    "h",
    "hB"
  ],
  "TF": [
    "H",
    "h",
    "hB"
  ],
  "VA": [
    "H",
    "h",
    "hB"
  ],
  "CY": [
    "h",
    "H",
    "hb",
    "hB"
  ],
  "GR": [
    "h",
    "H",
    "hb",
    "hB"
  ],
  "CO": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "DO": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "KP": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "KR": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "NA": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "PA": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "PR": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "VE": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "AC": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "AI": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "BW": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "BZ": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "CC": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "CK": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "CX": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "DG": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "FK": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "GB": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "GG": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "GI": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "IE": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "IM": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "IO": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "JE": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "LT": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "MK": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "MN": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "MS": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "NF": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "NG": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "NR": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "NU": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "PN": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "SH": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "SX": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "TA": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "ZA": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "af-ZA": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "AR": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "CL": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "CR": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "CU": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "EA": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "es-BO": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "es-BR": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "es-EC": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "es-ES": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "es-GQ": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "es-PE": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "GT": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "HN": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "IC": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "KG": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "KM": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "LK": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "MA": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "MX": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "NI": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "PY": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "SV": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "UY": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "JP": [
    "H",
    "h",
    "K"
  ],
  "AD": [
    "H",
    "hB"
  ],
  "AM": [
    "H",
    "hB"
  ],
  "AO": [
    "H",
    "hB"
  ],
  "AT": [
    "H",
    "hB"
  ],
  "AW": [
    "H",
    "hB"
  ],
  "BE": [
    "H",
    "hB"
  ],
  "BF": [
    "H",
    "hB"
  ],
  "BJ": [
    "H",
    "hB"
  ],
  "BL": [
    "H",
    "hB"
  ],
  "BR": [
    "H",
    "hB"
  ],
  "CG": [
    "H",
    "hB"
  ],
  "CI": [
    "H",
    "hB"
  ],
  "CV": [
    "H",
    "hB"
  ],
  "DE": [
    "H",
    "hB"
  ],
  "EE": [
    "H",
    "hB"
  ],
  "FR": [
    "H",
    "hB"
  ],
  "GA": [
    "H",
    "hB"
  ],
  "GF": [
    "H",
    "hB"
  ],
  "GN": [
    "H",
    "hB"
  ],
  "GP": [
    "H",
    "hB"
  ],
  "GW": [
    "H",
    "hB"
  ],
  "HR": [
    "H",
    "hB"
  ],
  "IL": [
    "H",
    "hB"
  ],
  "IT": [
    "H",
    "hB"
  ],
  "KZ": [
    "H",
    "hB"
  ],
  "MC": [
    "H",
    "hB"
  ],
  "MD": [
    "H",
    "hB"
  ],
  "MF": [
    "H",
    "hB"
  ],
  "MQ": [
    "H",
    "hB"
  ],
  "MZ": [
    "H",
    "hB"
  ],
  "NC": [
    "H",
    "hB"
  ],
  "NL": [
    "H",
    "hB"
  ],
  "PM": [
    "H",
    "hB"
  ],
  "PT": [
    "H",
    "hB"
  ],
  "RE": [
    "H",
    "hB"
  ],
  "RO": [
    "H",
    "hB"
  ],
  "SI": [
    "H",
    "hB"
  ],
  "SR": [
    "H",
    "hB"
  ],
  "ST": [
    "H",
    "hB"
  ],
  "TG": [
    "H",
    "hB"
  ],
  "TR": [
    "H",
    "hB"
  ],
  "WF": [
    "H",
    "hB"
  ],
  "YT": [
    "H",
    "hB"
  ],
  "BD": [
    "h",
    "hB",
    "H"
  ],
  "PK": [
    "h",
    "hB",
    "H"
  ],
  "AZ": [
    "H",
    "hB",
    "h"
  ],
  "BA": [
    "H",
    "hB",
    "h"
  ],
  "BG": [
    "H",
    "hB",
    "h"
  ],
  "CH": [
    "H",
    "hB",
    "h"
  ],
  "GE": [
    "H",
    "hB",
    "h"
  ],
  "LI": [
    "H",
    "hB",
    "h"
  ],
  "ME": [
    "H",
    "hB",
    "h"
  ],
  "RS": [
    "H",
    "hB",
    "h"
  ],
  "UA": [
    "H",
    "hB",
    "h"
  ],
  "UZ": [
    "H",
    "hB",
    "h"
  ],
  "XK": [
    "H",
    "hB",
    "h"
  ],
  "AG": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "AU": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "BB": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "BM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "BS": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "CA": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "DM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "en-001": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "FJ": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "FM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "GD": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "GM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "GU": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "GY": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "JM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "KI": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "KN": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "KY": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "LC": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "LR": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "MH": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "MP": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "MW": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "NZ": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "SB": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "SG": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "SL": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "SS": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "SZ": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "TC": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "TT": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "UM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "US": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "VC": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "VG": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "VI": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "ZM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "BO": [
    "H",
    "hB",
    "h",
    "hb"
  ],
  "EC": [
    "H",
    "hB",
    "h",
    "hb"
  ],
  "ES": [
    "H",
    "hB",
    "h",
    "hb"
  ],
  "GQ": [
    "H",
    "hB",
    "h",
    "hb"
  ],
  "PE": [
    "H",
    "hB",
    "h",
    "hb"
  ],
  "AE": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "ar-001": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "BH": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "DZ": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "EG": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "EH": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "HK": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "IQ": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "JO": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "KW": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "LB": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "LY": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "MO": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "MR": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "OM": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "PH": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "PS": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "QA": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "SA": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "SD": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "SY": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "TN": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "YE": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "AF": [
    "H",
    "hb",
    "hB",
    "h"
  ],
  "LA": [
    "H",
    "hb",
    "hB",
    "h"
  ],
  "CN": [
    "H",
    "hB",
    "hb",
    "h"
  ],
  "LV": [
    "H",
    "hB",
    "hb",
    "h"
  ],
  "TL": [
    "H",
    "hB",
    "hb",
    "h"
  ],
  "zu-ZA": [
    "H",
    "hB",
    "hb",
    "h"
  ],
  "CD": [
    "hB",
    "H"
  ],
  "IR": [
    "hB",
    "H"
  ],
  "hi-IN": [
    "hB",
    "h",
    "H"
  ],
  "kn-IN": [
    "hB",
    "h",
    "H"
  ],
  "ml-IN": [
    "hB",
    "h",
    "H"
  ],
  "te-IN": [
    "hB",
    "h",
    "H"
  ],
  "KH": [
    "hB",
    "h",
    "H",
    "hb"
  ],
  "ta-IN": [
    "hB",
    "h",
    "hb",
    "H"
  ],
  "BN": [
    "hb",
    "hB",
    "h",
    "H"
  ],
  "MY": [
    "hb",
    "hB",
    "h",
    "H"
  ],
  "ET": [
    "hB",
    "hb",
    "h",
    "H"
  ],
  "gu-IN": [
    "hB",
    "hb",
    "h",
    "H"
  ],
  "mr-IN": [
    "hB",
    "hb",
    "h",
    "H"
  ],
  "pa-IN": [
    "hB",
    "hb",
    "h",
    "H"
  ],
  "TW": [
    "hB",
    "hb",
    "h",
    "H"
  ],
  "KE": [
    "hB",
    "hb",
    "H",
    "h"
  ],
  "MM": [
    "hB",
    "hb",
    "H",
    "h"
  ],
  "TZ": [
    "hB",
    "hb",
    "H",
    "h"
  ],
  "UG": [
    "hB",
    "hb",
    "H",
    "h"
  ]
};
function getBestPattern(skeleton, locale2) {
  var skeletonCopy = "";
  for (var patternPos = 0; patternPos < skeleton.length; patternPos++) {
    var patternChar = skeleton.charAt(patternPos);
    if (patternChar === "j") {
      var extraLength = 0;
      while (patternPos + 1 < skeleton.length && skeleton.charAt(patternPos + 1) === patternChar) {
        extraLength++;
        patternPos++;
      }
      var hourLen = 1 + (extraLength & 1);
      var dayPeriodLen = extraLength < 2 ? 1 : 3 + (extraLength >> 1);
      var dayPeriodChar = "a";
      var hourChar = getDefaultHourSymbolFromLocale(locale2);
      if (hourChar == "H" || hourChar == "k") {
        dayPeriodLen = 0;
      }
      while (dayPeriodLen-- > 0) {
        skeletonCopy += dayPeriodChar;
      }
      while (hourLen-- > 0) {
        skeletonCopy = hourChar + skeletonCopy;
      }
    } else if (patternChar === "J") {
      skeletonCopy += "H";
    } else {
      skeletonCopy += patternChar;
    }
  }
  return skeletonCopy;
}
function getDefaultHourSymbolFromLocale(locale2) {
  var hourCycle = locale2.hourCycle;
  if (hourCycle === void 0 && // @ts-ignore hourCycle(s) is not identified yet
  locale2.hourCycles && // @ts-ignore
  locale2.hourCycles.length) {
    hourCycle = locale2.hourCycles[0];
  }
  if (hourCycle) {
    switch (hourCycle) {
      case "h24":
        return "k";
      case "h23":
        return "H";
      case "h12":
        return "h";
      case "h11":
        return "K";
      default:
        throw new Error("Invalid hourCycle");
    }
  }
  var languageTag = locale2.language;
  var regionTag;
  if (languageTag !== "root") {
    regionTag = locale2.maximize().region;
  }
  var hourCycles = timeData[regionTag || ""] || timeData[languageTag || ""] || timeData["".concat(languageTag, "-001")] || timeData["001"];
  return hourCycles[0];
}
var _a;
var SPACE_SEPARATOR_START_REGEX = new RegExp("^".concat(SPACE_SEPARATOR_REGEX.source, "*"));
var SPACE_SEPARATOR_END_REGEX = new RegExp("".concat(SPACE_SEPARATOR_REGEX.source, "*$"));
function createLocation(start2, end) {
  return { start: start2, end };
}
var hasNativeStartsWith = !!String.prototype.startsWith;
var hasNativeFromCodePoint = !!String.fromCodePoint;
var hasNativeFromEntries = !!Object.fromEntries;
var hasNativeCodePointAt = !!String.prototype.codePointAt;
var hasTrimStart = !!String.prototype.trimStart;
var hasTrimEnd = !!String.prototype.trimEnd;
var hasNativeIsSafeInteger = !!Number.isSafeInteger;
var isSafeInteger = hasNativeIsSafeInteger ? Number.isSafeInteger : function(n2) {
  return typeof n2 === "number" && isFinite(n2) && Math.floor(n2) === n2 && Math.abs(n2) <= 9007199254740991;
};
var REGEX_SUPPORTS_U_AND_Y = true;
try {
  var re$1 = RE("([^\\p{White_Space}\\p{Pattern_Syntax}]*)", "yu");
  REGEX_SUPPORTS_U_AND_Y = ((_a = re$1.exec("a")) === null || _a === void 0 ? void 0 : _a[0]) === "a";
} catch (_2) {
  REGEX_SUPPORTS_U_AND_Y = false;
}
var startsWith = hasNativeStartsWith ? (
  // Native
  function startsWith2(s2, search2, position2) {
    return s2.startsWith(search2, position2);
  }
) : (
  // For IE11
  function startsWith3(s2, search2, position2) {
    return s2.slice(position2, position2 + search2.length) === search2;
  }
);
var fromCodePoint = hasNativeFromCodePoint ? String.fromCodePoint : (
  // IE11
  function fromCodePoint2() {
    var codePoints = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      codePoints[_i2] = arguments[_i2];
    }
    var elements = "";
    var length2 = codePoints.length;
    var i = 0;
    var code2;
    while (length2 > i) {
      code2 = codePoints[i++];
      if (code2 > 1114111)
        throw RangeError(code2 + " is not a valid code point");
      elements += code2 < 65536 ? String.fromCharCode(code2) : String.fromCharCode(((code2 -= 65536) >> 10) + 55296, code2 % 1024 + 56320);
    }
    return elements;
  }
);
var fromEntries = (
  // native
  hasNativeFromEntries ? Object.fromEntries : (
    // Ponyfill
    function fromEntries2(entries2) {
      var obj = {};
      for (var _i2 = 0, entries_1 = entries2; _i2 < entries_1.length; _i2++) {
        var _a3 = entries_1[_i2], k2 = _a3[0], v2 = _a3[1];
        obj[k2] = v2;
      }
      return obj;
    }
  )
);
var codePointAt = hasNativeCodePointAt ? (
  // Native
  function codePointAt2(s2, index2) {
    return s2.codePointAt(index2);
  }
) : (
  // IE 11
  function codePointAt3(s2, index2) {
    var size = s2.length;
    if (index2 < 0 || index2 >= size) {
      return void 0;
    }
    var first = s2.charCodeAt(index2);
    var second;
    return first < 55296 || first > 56319 || index2 + 1 === size || (second = s2.charCodeAt(index2 + 1)) < 56320 || second > 57343 ? first : (first - 55296 << 10) + (second - 56320) + 65536;
  }
);
var trimStart = hasTrimStart ? (
  // Native
  function trimStart2(s2) {
    return s2.trimStart();
  }
) : (
  // Ponyfill
  function trimStart3(s2) {
    return s2.replace(SPACE_SEPARATOR_START_REGEX, "");
  }
);
var trimEnd = hasTrimEnd ? (
  // Native
  function trimEnd2(s2) {
    return s2.trimEnd();
  }
) : (
  // Ponyfill
  function trimEnd3(s2) {
    return s2.replace(SPACE_SEPARATOR_END_REGEX, "");
  }
);
function RE(s2, flag) {
  return new RegExp(s2, flag);
}
var matchIdentifierAtIndex;
if (REGEX_SUPPORTS_U_AND_Y) {
  var IDENTIFIER_PREFIX_RE_1 = RE("([^\\p{White_Space}\\p{Pattern_Syntax}]*)", "yu");
  matchIdentifierAtIndex = function matchIdentifierAtIndex2(s2, index2) {
    var _a3;
    IDENTIFIER_PREFIX_RE_1.lastIndex = index2;
    var match2 = IDENTIFIER_PREFIX_RE_1.exec(s2);
    return (_a3 = match2[1]) !== null && _a3 !== void 0 ? _a3 : "";
  };
} else {
  matchIdentifierAtIndex = function matchIdentifierAtIndex2(s2, index2) {
    var match2 = [];
    while (true) {
      var c6 = codePointAt(s2, index2);
      if (c6 === void 0 || _isWhiteSpace(c6) || _isPatternSyntax(c6)) {
        break;
      }
      match2.push(c6);
      index2 += c6 >= 65536 ? 2 : 1;
    }
    return fromCodePoint.apply(void 0, match2);
  };
}
var Parser = (
  /** @class */
  function() {
    function Parser2(message, options) {
      if (options === void 0) {
        options = {};
      }
      this.message = message;
      this.position = { offset: 0, line: 1, column: 1 };
      this.ignoreTag = !!options.ignoreTag;
      this.locale = options.locale;
      this.requiresOtherClause = !!options.requiresOtherClause;
      this.shouldParseSkeletons = !!options.shouldParseSkeletons;
    }
    Parser2.prototype.parse = function() {
      if (this.offset() !== 0) {
        throw Error("parser can only be used once");
      }
      return this.parseMessage(0, "", false);
    };
    Parser2.prototype.parseMessage = function(nestingLevel, parentArgType, expectingCloseTag) {
      var elements = [];
      while (!this.isEOF()) {
        var char2 = this.char();
        if (char2 === 123) {
          var result = this.parseArgument(nestingLevel, expectingCloseTag);
          if (result.err) {
            return result;
          }
          elements.push(result.val);
        } else if (char2 === 125 && nestingLevel > 0) {
          break;
        } else if (char2 === 35 && (parentArgType === "plural" || parentArgType === "selectordinal")) {
          var position2 = this.clonePosition();
          this.bump();
          elements.push({
            type: TYPE.pound,
            location: createLocation(position2, this.clonePosition())
          });
        } else if (char2 === 60 && !this.ignoreTag && this.peek() === 47) {
          if (expectingCloseTag) {
            break;
          } else {
            return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(this.clonePosition(), this.clonePosition()));
          }
        } else if (char2 === 60 && !this.ignoreTag && _isAlpha(this.peek() || 0)) {
          var result = this.parseTag(nestingLevel, parentArgType);
          if (result.err) {
            return result;
          }
          elements.push(result.val);
        } else {
          var result = this.parseLiteral(nestingLevel, parentArgType);
          if (result.err) {
            return result;
          }
          elements.push(result.val);
        }
      }
      return { val: elements, err: null };
    };
    Parser2.prototype.parseTag = function(nestingLevel, parentArgType) {
      var startPosition = this.clonePosition();
      this.bump();
      var tagName = this.parseTagName();
      this.bumpSpace();
      if (this.bumpIf("/>")) {
        return {
          val: {
            type: TYPE.literal,
            value: "<".concat(tagName, "/>"),
            location: createLocation(startPosition, this.clonePosition())
          },
          err: null
        };
      } else if (this.bumpIf(">")) {
        var childrenResult = this.parseMessage(nestingLevel + 1, parentArgType, true);
        if (childrenResult.err) {
          return childrenResult;
        }
        var children = childrenResult.val;
        var endTagStartPosition = this.clonePosition();
        if (this.bumpIf("</")) {
          if (this.isEOF() || !_isAlpha(this.char())) {
            return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));
          }
          var closingTagNameStartPosition = this.clonePosition();
          var closingTagName = this.parseTagName();
          if (tagName !== closingTagName) {
            return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(closingTagNameStartPosition, this.clonePosition()));
          }
          this.bumpSpace();
          if (!this.bumpIf(">")) {
            return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));
          }
          return {
            val: {
              type: TYPE.tag,
              value: tagName,
              children,
              location: createLocation(startPosition, this.clonePosition())
            },
            err: null
          };
        } else {
          return this.error(ErrorKind.UNCLOSED_TAG, createLocation(startPosition, this.clonePosition()));
        }
      } else {
        return this.error(ErrorKind.INVALID_TAG, createLocation(startPosition, this.clonePosition()));
      }
    };
    Parser2.prototype.parseTagName = function() {
      var startOffset = this.offset();
      this.bump();
      while (!this.isEOF() && _isPotentialElementNameChar(this.char())) {
        this.bump();
      }
      return this.message.slice(startOffset, this.offset());
    };
    Parser2.prototype.parseLiteral = function(nestingLevel, parentArgType) {
      var start2 = this.clonePosition();
      var value = "";
      while (true) {
        var parseQuoteResult = this.tryParseQuote(parentArgType);
        if (parseQuoteResult) {
          value += parseQuoteResult;
          continue;
        }
        var parseUnquotedResult = this.tryParseUnquoted(nestingLevel, parentArgType);
        if (parseUnquotedResult) {
          value += parseUnquotedResult;
          continue;
        }
        var parseLeftAngleResult = this.tryParseLeftAngleBracket();
        if (parseLeftAngleResult) {
          value += parseLeftAngleResult;
          continue;
        }
        break;
      }
      var location2 = createLocation(start2, this.clonePosition());
      return {
        val: { type: TYPE.literal, value, location: location2 },
        err: null
      };
    };
    Parser2.prototype.tryParseLeftAngleBracket = function() {
      if (!this.isEOF() && this.char() === 60 && (this.ignoreTag || // If at the opening tag or closing tag position, bail.
      !_isAlphaOrSlash(this.peek() || 0))) {
        this.bump();
        return "<";
      }
      return null;
    };
    Parser2.prototype.tryParseQuote = function(parentArgType) {
      if (this.isEOF() || this.char() !== 39) {
        return null;
      }
      switch (this.peek()) {
        case 39:
          this.bump();
          this.bump();
          return "'";
        case 123:
        case 60:
        case 62:
        case 125:
          break;
        case 35:
          if (parentArgType === "plural" || parentArgType === "selectordinal") {
            break;
          }
          return null;
        default:
          return null;
      }
      this.bump();
      var codePoints = [this.char()];
      this.bump();
      while (!this.isEOF()) {
        var ch = this.char();
        if (ch === 39) {
          if (this.peek() === 39) {
            codePoints.push(39);
            this.bump();
          } else {
            this.bump();
            break;
          }
        } else {
          codePoints.push(ch);
        }
        this.bump();
      }
      return fromCodePoint.apply(void 0, codePoints);
    };
    Parser2.prototype.tryParseUnquoted = function(nestingLevel, parentArgType) {
      if (this.isEOF()) {
        return null;
      }
      var ch = this.char();
      if (ch === 60 || ch === 123 || ch === 35 && (parentArgType === "plural" || parentArgType === "selectordinal") || ch === 125 && nestingLevel > 0) {
        return null;
      } else {
        this.bump();
        return fromCodePoint(ch);
      }
    };
    Parser2.prototype.parseArgument = function(nestingLevel, expectingCloseTag) {
      var openingBracePosition = this.clonePosition();
      this.bump();
      this.bumpSpace();
      if (this.isEOF()) {
        return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
      }
      if (this.char() === 125) {
        this.bump();
        return this.error(ErrorKind.EMPTY_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
      }
      var value = this.parseIdentifierIfPossible().value;
      if (!value) {
        return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
      }
      this.bumpSpace();
      if (this.isEOF()) {
        return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
      }
      switch (this.char()) {
        case 125: {
          this.bump();
          return {
            val: {
              type: TYPE.argument,
              // value does not include the opening and closing braces.
              value,
              location: createLocation(openingBracePosition, this.clonePosition())
            },
            err: null
          };
        }
        case 44: {
          this.bump();
          this.bumpSpace();
          if (this.isEOF()) {
            return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
          }
          return this.parseArgumentOptions(nestingLevel, expectingCloseTag, value, openingBracePosition);
        }
        default:
          return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
      }
    };
    Parser2.prototype.parseIdentifierIfPossible = function() {
      var startingPosition = this.clonePosition();
      var startOffset = this.offset();
      var value = matchIdentifierAtIndex(this.message, startOffset);
      var endOffset = startOffset + value.length;
      this.bumpTo(endOffset);
      var endPosition = this.clonePosition();
      var location2 = createLocation(startingPosition, endPosition);
      return { value, location: location2 };
    };
    Parser2.prototype.parseArgumentOptions = function(nestingLevel, expectingCloseTag, value, openingBracePosition) {
      var _a3;
      var typeStartPosition = this.clonePosition();
      var argType = this.parseIdentifierIfPossible().value;
      var typeEndPosition = this.clonePosition();
      switch (argType) {
        case "":
          return this.error(ErrorKind.EXPECT_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));
        case "number":
        case "date":
        case "time": {
          this.bumpSpace();
          var styleAndLocation = null;
          if (this.bumpIf(",")) {
            this.bumpSpace();
            var styleStartPosition = this.clonePosition();
            var result = this.parseSimpleArgStyleIfPossible();
            if (result.err) {
              return result;
            }
            var style = trimEnd(result.val);
            if (style.length === 0) {
              return this.error(ErrorKind.EXPECT_ARGUMENT_STYLE, createLocation(this.clonePosition(), this.clonePosition()));
            }
            var styleLocation = createLocation(styleStartPosition, this.clonePosition());
            styleAndLocation = { style, styleLocation };
          }
          var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
          if (argCloseResult.err) {
            return argCloseResult;
          }
          var location_1 = createLocation(openingBracePosition, this.clonePosition());
          if (styleAndLocation && startsWith(styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style, "::", 0)) {
            var skeleton = trimStart(styleAndLocation.style.slice(2));
            if (argType === "number") {
              var result = this.parseNumberSkeletonFromString(skeleton, styleAndLocation.styleLocation);
              if (result.err) {
                return result;
              }
              return {
                val: { type: TYPE.number, value, location: location_1, style: result.val },
                err: null
              };
            } else {
              if (skeleton.length === 0) {
                return this.error(ErrorKind.EXPECT_DATE_TIME_SKELETON, location_1);
              }
              var dateTimePattern = skeleton;
              if (this.locale) {
                dateTimePattern = getBestPattern(skeleton, this.locale);
              }
              var style = {
                type: SKELETON_TYPE.dateTime,
                pattern: dateTimePattern,
                location: styleAndLocation.styleLocation,
                parsedOptions: this.shouldParseSkeletons ? parseDateTimeSkeleton(dateTimePattern) : {}
              };
              var type2 = argType === "date" ? TYPE.date : TYPE.time;
              return {
                val: { type: type2, value, location: location_1, style },
                err: null
              };
            }
          }
          return {
            val: {
              type: argType === "number" ? TYPE.number : argType === "date" ? TYPE.date : TYPE.time,
              value,
              location: location_1,
              style: (_a3 = styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style) !== null && _a3 !== void 0 ? _a3 : null
            },
            err: null
          };
        }
        case "plural":
        case "selectordinal":
        case "select": {
          var typeEndPosition_1 = this.clonePosition();
          this.bumpSpace();
          if (!this.bumpIf(",")) {
            return this.error(ErrorKind.EXPECT_SELECT_ARGUMENT_OPTIONS, createLocation(typeEndPosition_1, __assign({}, typeEndPosition_1)));
          }
          this.bumpSpace();
          var identifierAndLocation = this.parseIdentifierIfPossible();
          var pluralOffset = 0;
          if (argType !== "select" && identifierAndLocation.value === "offset") {
            if (!this.bumpIf(":")) {
              return this.error(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, createLocation(this.clonePosition(), this.clonePosition()));
            }
            this.bumpSpace();
            var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, ErrorKind.INVALID_PLURAL_ARGUMENT_OFFSET_VALUE);
            if (result.err) {
              return result;
            }
            this.bumpSpace();
            identifierAndLocation = this.parseIdentifierIfPossible();
            pluralOffset = result.val;
          }
          var optionsResult = this.tryParsePluralOrSelectOptions(nestingLevel, argType, expectingCloseTag, identifierAndLocation);
          if (optionsResult.err) {
            return optionsResult;
          }
          var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
          if (argCloseResult.err) {
            return argCloseResult;
          }
          var location_2 = createLocation(openingBracePosition, this.clonePosition());
          if (argType === "select") {
            return {
              val: {
                type: TYPE.select,
                value,
                options: fromEntries(optionsResult.val),
                location: location_2
              },
              err: null
            };
          } else {
            return {
              val: {
                type: TYPE.plural,
                value,
                options: fromEntries(optionsResult.val),
                offset: pluralOffset,
                pluralType: argType === "plural" ? "cardinal" : "ordinal",
                location: location_2
              },
              err: null
            };
          }
        }
        default:
          return this.error(ErrorKind.INVALID_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));
      }
    };
    Parser2.prototype.tryParseArgumentClose = function(openingBracePosition) {
      if (this.isEOF() || this.char() !== 125) {
        return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
      }
      this.bump();
      return { val: true, err: null };
    };
    Parser2.prototype.parseSimpleArgStyleIfPossible = function() {
      var nestedBraces = 0;
      var startPosition = this.clonePosition();
      while (!this.isEOF()) {
        var ch = this.char();
        switch (ch) {
          case 39: {
            this.bump();
            var apostrophePosition = this.clonePosition();
            if (!this.bumpUntil("'")) {
              return this.error(ErrorKind.UNCLOSED_QUOTE_IN_ARGUMENT_STYLE, createLocation(apostrophePosition, this.clonePosition()));
            }
            this.bump();
            break;
          }
          case 123: {
            nestedBraces += 1;
            this.bump();
            break;
          }
          case 125: {
            if (nestedBraces > 0) {
              nestedBraces -= 1;
            } else {
              return {
                val: this.message.slice(startPosition.offset, this.offset()),
                err: null
              };
            }
            break;
          }
          default:
            this.bump();
            break;
        }
      }
      return {
        val: this.message.slice(startPosition.offset, this.offset()),
        err: null
      };
    };
    Parser2.prototype.parseNumberSkeletonFromString = function(skeleton, location2) {
      var tokens = [];
      try {
        tokens = parseNumberSkeletonFromString(skeleton);
      } catch (e2) {
        return this.error(ErrorKind.INVALID_NUMBER_SKELETON, location2);
      }
      return {
        val: {
          type: SKELETON_TYPE.number,
          tokens,
          location: location2,
          parsedOptions: this.shouldParseSkeletons ? parseNumberSkeleton(tokens) : {}
        },
        err: null
      };
    };
    Parser2.prototype.tryParsePluralOrSelectOptions = function(nestingLevel, parentArgType, expectCloseTag, parsedFirstIdentifier) {
      var _a3;
      var hasOtherClause = false;
      var options = [];
      var parsedSelectors = /* @__PURE__ */ new Set();
      var selector = parsedFirstIdentifier.value, selectorLocation = parsedFirstIdentifier.location;
      while (true) {
        if (selector.length === 0) {
          var startPosition = this.clonePosition();
          if (parentArgType !== "select" && this.bumpIf("=")) {
            var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, ErrorKind.INVALID_PLURAL_ARGUMENT_SELECTOR);
            if (result.err) {
              return result;
            }
            selectorLocation = createLocation(startPosition, this.clonePosition());
            selector = this.message.slice(startPosition.offset, this.offset());
          } else {
            break;
          }
        }
        if (parsedSelectors.has(selector)) {
          return this.error(parentArgType === "select" ? ErrorKind.DUPLICATE_SELECT_ARGUMENT_SELECTOR : ErrorKind.DUPLICATE_PLURAL_ARGUMENT_SELECTOR, selectorLocation);
        }
        if (selector === "other") {
          hasOtherClause = true;
        }
        this.bumpSpace();
        var openingBracePosition = this.clonePosition();
        if (!this.bumpIf("{")) {
          return this.error(parentArgType === "select" ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT, createLocation(this.clonePosition(), this.clonePosition()));
        }
        var fragmentResult = this.parseMessage(nestingLevel + 1, parentArgType, expectCloseTag);
        if (fragmentResult.err) {
          return fragmentResult;
        }
        var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
        if (argCloseResult.err) {
          return argCloseResult;
        }
        options.push([
          selector,
          {
            value: fragmentResult.val,
            location: createLocation(openingBracePosition, this.clonePosition())
          }
        ]);
        parsedSelectors.add(selector);
        this.bumpSpace();
        _a3 = this.parseIdentifierIfPossible(), selector = _a3.value, selectorLocation = _a3.location;
      }
      if (options.length === 0) {
        return this.error(parentArgType === "select" ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, createLocation(this.clonePosition(), this.clonePosition()));
      }
      if (this.requiresOtherClause && !hasOtherClause) {
        return this.error(ErrorKind.MISSING_OTHER_CLAUSE, createLocation(this.clonePosition(), this.clonePosition()));
      }
      return { val: options, err: null };
    };
    Parser2.prototype.tryParseDecimalInteger = function(expectNumberError, invalidNumberError) {
      var sign = 1;
      var startingPosition = this.clonePosition();
      if (this.bumpIf("+")) ;
      else if (this.bumpIf("-")) {
        sign = -1;
      }
      var hasDigits = false;
      var decimal = 0;
      while (!this.isEOF()) {
        var ch = this.char();
        if (ch >= 48 && ch <= 57) {
          hasDigits = true;
          decimal = decimal * 10 + (ch - 48);
          this.bump();
        } else {
          break;
        }
      }
      var location2 = createLocation(startingPosition, this.clonePosition());
      if (!hasDigits) {
        return this.error(expectNumberError, location2);
      }
      decimal *= sign;
      if (!isSafeInteger(decimal)) {
        return this.error(invalidNumberError, location2);
      }
      return { val: decimal, err: null };
    };
    Parser2.prototype.offset = function() {
      return this.position.offset;
    };
    Parser2.prototype.isEOF = function() {
      return this.offset() === this.message.length;
    };
    Parser2.prototype.clonePosition = function() {
      return {
        offset: this.position.offset,
        line: this.position.line,
        column: this.position.column
      };
    };
    Parser2.prototype.char = function() {
      var offset = this.position.offset;
      if (offset >= this.message.length) {
        throw Error("out of bound");
      }
      var code2 = codePointAt(this.message, offset);
      if (code2 === void 0) {
        throw Error("Offset ".concat(offset, " is at invalid UTF-16 code unit boundary"));
      }
      return code2;
    };
    Parser2.prototype.error = function(kind, location2) {
      return {
        val: null,
        err: {
          kind,
          message: this.message,
          location: location2
        }
      };
    };
    Parser2.prototype.bump = function() {
      if (this.isEOF()) {
        return;
      }
      var code2 = this.char();
      if (code2 === 10) {
        this.position.line += 1;
        this.position.column = 1;
        this.position.offset += 1;
      } else {
        this.position.column += 1;
        this.position.offset += code2 < 65536 ? 1 : 2;
      }
    };
    Parser2.prototype.bumpIf = function(prefix2) {
      if (startsWith(this.message, prefix2, this.offset())) {
        for (var i = 0; i < prefix2.length; i++) {
          this.bump();
        }
        return true;
      }
      return false;
    };
    Parser2.prototype.bumpUntil = function(pattern2) {
      var currentOffset = this.offset();
      var index2 = this.message.indexOf(pattern2, currentOffset);
      if (index2 >= 0) {
        this.bumpTo(index2);
        return true;
      } else {
        this.bumpTo(this.message.length);
        return false;
      }
    };
    Parser2.prototype.bumpTo = function(targetOffset) {
      if (this.offset() > targetOffset) {
        throw Error("targetOffset ".concat(targetOffset, " must be greater than or equal to the current offset ").concat(this.offset()));
      }
      targetOffset = Math.min(targetOffset, this.message.length);
      while (true) {
        var offset = this.offset();
        if (offset === targetOffset) {
          break;
        }
        if (offset > targetOffset) {
          throw Error("targetOffset ".concat(targetOffset, " is at invalid UTF-16 code unit boundary"));
        }
        this.bump();
        if (this.isEOF()) {
          break;
        }
      }
    };
    Parser2.prototype.bumpSpace = function() {
      while (!this.isEOF() && _isWhiteSpace(this.char())) {
        this.bump();
      }
    };
    Parser2.prototype.peek = function() {
      if (this.isEOF()) {
        return null;
      }
      var code2 = this.char();
      var offset = this.offset();
      var nextCode = this.message.charCodeAt(offset + (code2 >= 65536 ? 2 : 1));
      return nextCode !== null && nextCode !== void 0 ? nextCode : null;
    };
    return Parser2;
  }()
);
function _isAlpha(codepoint) {
  return codepoint >= 97 && codepoint <= 122 || codepoint >= 65 && codepoint <= 90;
}
function _isAlphaOrSlash(codepoint) {
  return _isAlpha(codepoint) || codepoint === 47;
}
function _isPotentialElementNameChar(c6) {
  return c6 === 45 || c6 === 46 || c6 >= 48 && c6 <= 57 || c6 === 95 || c6 >= 97 && c6 <= 122 || c6 >= 65 && c6 <= 90 || c6 == 183 || c6 >= 192 && c6 <= 214 || c6 >= 216 && c6 <= 246 || c6 >= 248 && c6 <= 893 || c6 >= 895 && c6 <= 8191 || c6 >= 8204 && c6 <= 8205 || c6 >= 8255 && c6 <= 8256 || c6 >= 8304 && c6 <= 8591 || c6 >= 11264 && c6 <= 12271 || c6 >= 12289 && c6 <= 55295 || c6 >= 63744 && c6 <= 64975 || c6 >= 65008 && c6 <= 65533 || c6 >= 65536 && c6 <= 983039;
}
function _isWhiteSpace(c6) {
  return c6 >= 9 && c6 <= 13 || c6 === 32 || c6 === 133 || c6 >= 8206 && c6 <= 8207 || c6 === 8232 || c6 === 8233;
}
function _isPatternSyntax(c6) {
  return c6 >= 33 && c6 <= 35 || c6 === 36 || c6 >= 37 && c6 <= 39 || c6 === 40 || c6 === 41 || c6 === 42 || c6 === 43 || c6 === 44 || c6 === 45 || c6 >= 46 && c6 <= 47 || c6 >= 58 && c6 <= 59 || c6 >= 60 && c6 <= 62 || c6 >= 63 && c6 <= 64 || c6 === 91 || c6 === 92 || c6 === 93 || c6 === 94 || c6 === 96 || c6 === 123 || c6 === 124 || c6 === 125 || c6 === 126 || c6 === 161 || c6 >= 162 && c6 <= 165 || c6 === 166 || c6 === 167 || c6 === 169 || c6 === 171 || c6 === 172 || c6 === 174 || c6 === 176 || c6 === 177 || c6 === 182 || c6 === 187 || c6 === 191 || c6 === 215 || c6 === 247 || c6 >= 8208 && c6 <= 8213 || c6 >= 8214 && c6 <= 8215 || c6 === 8216 || c6 === 8217 || c6 === 8218 || c6 >= 8219 && c6 <= 8220 || c6 === 8221 || c6 === 8222 || c6 === 8223 || c6 >= 8224 && c6 <= 8231 || c6 >= 8240 && c6 <= 8248 || c6 === 8249 || c6 === 8250 || c6 >= 8251 && c6 <= 8254 || c6 >= 8257 && c6 <= 8259 || c6 === 8260 || c6 === 8261 || c6 === 8262 || c6 >= 8263 && c6 <= 8273 || c6 === 8274 || c6 === 8275 || c6 >= 8277 && c6 <= 8286 || c6 >= 8592 && c6 <= 8596 || c6 >= 8597 && c6 <= 8601 || c6 >= 8602 && c6 <= 8603 || c6 >= 8604 && c6 <= 8607 || c6 === 8608 || c6 >= 8609 && c6 <= 8610 || c6 === 8611 || c6 >= 8612 && c6 <= 8613 || c6 === 8614 || c6 >= 8615 && c6 <= 8621 || c6 === 8622 || c6 >= 8623 && c6 <= 8653 || c6 >= 8654 && c6 <= 8655 || c6 >= 8656 && c6 <= 8657 || c6 === 8658 || c6 === 8659 || c6 === 8660 || c6 >= 8661 && c6 <= 8691 || c6 >= 8692 && c6 <= 8959 || c6 >= 8960 && c6 <= 8967 || c6 === 8968 || c6 === 8969 || c6 === 8970 || c6 === 8971 || c6 >= 8972 && c6 <= 8991 || c6 >= 8992 && c6 <= 8993 || c6 >= 8994 && c6 <= 9e3 || c6 === 9001 || c6 === 9002 || c6 >= 9003 && c6 <= 9083 || c6 === 9084 || c6 >= 9085 && c6 <= 9114 || c6 >= 9115 && c6 <= 9139 || c6 >= 9140 && c6 <= 9179 || c6 >= 9180 && c6 <= 9185 || c6 >= 9186 && c6 <= 9254 || c6 >= 9255 && c6 <= 9279 || c6 >= 9280 && c6 <= 9290 || c6 >= 9291 && c6 <= 9311 || c6 >= 9472 && c6 <= 9654 || c6 === 9655 || c6 >= 9656 && c6 <= 9664 || c6 === 9665 || c6 >= 9666 && c6 <= 9719 || c6 >= 9720 && c6 <= 9727 || c6 >= 9728 && c6 <= 9838 || c6 === 9839 || c6 >= 9840 && c6 <= 10087 || c6 === 10088 || c6 === 10089 || c6 === 10090 || c6 === 10091 || c6 === 10092 || c6 === 10093 || c6 === 10094 || c6 === 10095 || c6 === 10096 || c6 === 10097 || c6 === 10098 || c6 === 10099 || c6 === 10100 || c6 === 10101 || c6 >= 10132 && c6 <= 10175 || c6 >= 10176 && c6 <= 10180 || c6 === 10181 || c6 === 10182 || c6 >= 10183 && c6 <= 10213 || c6 === 10214 || c6 === 10215 || c6 === 10216 || c6 === 10217 || c6 === 10218 || c6 === 10219 || c6 === 10220 || c6 === 10221 || c6 === 10222 || c6 === 10223 || c6 >= 10224 && c6 <= 10239 || c6 >= 10240 && c6 <= 10495 || c6 >= 10496 && c6 <= 10626 || c6 === 10627 || c6 === 10628 || c6 === 10629 || c6 === 10630 || c6 === 10631 || c6 === 10632 || c6 === 10633 || c6 === 10634 || c6 === 10635 || c6 === 10636 || c6 === 10637 || c6 === 10638 || c6 === 10639 || c6 === 10640 || c6 === 10641 || c6 === 10642 || c6 === 10643 || c6 === 10644 || c6 === 10645 || c6 === 10646 || c6 === 10647 || c6 === 10648 || c6 >= 10649 && c6 <= 10711 || c6 === 10712 || c6 === 10713 || c6 === 10714 || c6 === 10715 || c6 >= 10716 && c6 <= 10747 || c6 === 10748 || c6 === 10749 || c6 >= 10750 && c6 <= 11007 || c6 >= 11008 && c6 <= 11055 || c6 >= 11056 && c6 <= 11076 || c6 >= 11077 && c6 <= 11078 || c6 >= 11079 && c6 <= 11084 || c6 >= 11085 && c6 <= 11123 || c6 >= 11124 && c6 <= 11125 || c6 >= 11126 && c6 <= 11157 || c6 === 11158 || c6 >= 11159 && c6 <= 11263 || c6 >= 11776 && c6 <= 11777 || c6 === 11778 || c6 === 11779 || c6 === 11780 || c6 === 11781 || c6 >= 11782 && c6 <= 11784 || c6 === 11785 || c6 === 11786 || c6 === 11787 || c6 === 11788 || c6 === 11789 || c6 >= 11790 && c6 <= 11798 || c6 === 11799 || c6 >= 11800 && c6 <= 11801 || c6 === 11802 || c6 === 11803 || c6 === 11804 || c6 === 11805 || c6 >= 11806 && c6 <= 11807 || c6 === 11808 || c6 === 11809 || c6 === 11810 || c6 === 11811 || c6 === 11812 || c6 === 11813 || c6 === 11814 || c6 === 11815 || c6 === 11816 || c6 === 11817 || c6 >= 11818 && c6 <= 11822 || c6 === 11823 || c6 >= 11824 && c6 <= 11833 || c6 >= 11834 && c6 <= 11835 || c6 >= 11836 && c6 <= 11839 || c6 === 11840 || c6 === 11841 || c6 === 11842 || c6 >= 11843 && c6 <= 11855 || c6 >= 11856 && c6 <= 11857 || c6 === 11858 || c6 >= 11859 && c6 <= 11903 || c6 >= 12289 && c6 <= 12291 || c6 === 12296 || c6 === 12297 || c6 === 12298 || c6 === 12299 || c6 === 12300 || c6 === 12301 || c6 === 12302 || c6 === 12303 || c6 === 12304 || c6 === 12305 || c6 >= 12306 && c6 <= 12307 || c6 === 12308 || c6 === 12309 || c6 === 12310 || c6 === 12311 || c6 === 12312 || c6 === 12313 || c6 === 12314 || c6 === 12315 || c6 === 12316 || c6 === 12317 || c6 >= 12318 && c6 <= 12319 || c6 === 12320 || c6 === 12336 || c6 === 64830 || c6 === 64831 || c6 >= 65093 && c6 <= 65094;
}
function pruneLocation(els) {
  els.forEach(function(el) {
    delete el.location;
    if (isSelectElement(el) || isPluralElement(el)) {
      for (var k2 in el.options) {
        delete el.options[k2].location;
        pruneLocation(el.options[k2].value);
      }
    } else if (isNumberElement(el) && isNumberSkeleton(el.style)) {
      delete el.style.location;
    } else if ((isDateElement(el) || isTimeElement(el)) && isDateTimeSkeleton(el.style)) {
      delete el.style.location;
    } else if (isTagElement(el)) {
      pruneLocation(el.children);
    }
  });
}
function parse$2(message, opts) {
  if (opts === void 0) {
    opts = {};
  }
  opts = __assign({ shouldParseSkeletons: true, requiresOtherClause: true }, opts);
  var result = new Parser(message, opts).parse();
  if (result.err) {
    var error2 = SyntaxError(ErrorKind[result.err.kind]);
    error2.location = result.err.location;
    error2.originalMessage = result.err.message;
    throw error2;
  }
  if (!(opts === null || opts === void 0 ? void 0 : opts.captureLocation)) {
    pruneLocation(result.val);
  }
  return result.val;
}
function memoize$2(fn2, options) {
  var cache = options && options.cache ? options.cache : cacheDefault;
  var serializer2 = options && options.serializer ? options.serializer : serializerDefault;
  var strategy = options && options.strategy ? options.strategy : strategyDefault;
  return strategy(fn2, {
    cache,
    serializer: serializer2
  });
}
function isPrimitive(value) {
  return value == null || typeof value === "number" || typeof value === "boolean";
}
function monadic(fn2, cache, serializer2, arg) {
  var cacheKey2 = isPrimitive(arg) ? arg : serializer2(arg);
  var computedValue = cache.get(cacheKey2);
  if (typeof computedValue === "undefined") {
    computedValue = fn2.call(this, arg);
    cache.set(cacheKey2, computedValue);
  }
  return computedValue;
}
function variadic(fn2, cache, serializer2) {
  var args = Array.prototype.slice.call(arguments, 3);
  var cacheKey2 = serializer2(args);
  var computedValue = cache.get(cacheKey2);
  if (typeof computedValue === "undefined") {
    computedValue = fn2.apply(this, args);
    cache.set(cacheKey2, computedValue);
  }
  return computedValue;
}
function assemble(fn2, context, strategy, cache, serialize2) {
  return strategy.bind(context, fn2, cache, serialize2);
}
function strategyDefault(fn2, options) {
  var strategy = fn2.length === 1 ? monadic : variadic;
  return assemble(fn2, this, strategy, options.cache.create(), options.serializer);
}
function strategyVariadic(fn2, options) {
  return assemble(fn2, this, variadic, options.cache.create(), options.serializer);
}
function strategyMonadic(fn2, options) {
  return assemble(fn2, this, monadic, options.cache.create(), options.serializer);
}
var serializerDefault = function() {
  return JSON.stringify(arguments);
};
function ObjectWithoutPrototypeCache() {
  this.cache = /* @__PURE__ */ Object.create(null);
}
ObjectWithoutPrototypeCache.prototype.get = function(key) {
  return this.cache[key];
};
ObjectWithoutPrototypeCache.prototype.set = function(key, value) {
  this.cache[key] = value;
};
var cacheDefault = {
  create: function create() {
    return new ObjectWithoutPrototypeCache();
  }
};
var strategies = {
  variadic: strategyVariadic,
  monadic: strategyMonadic
};
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2["MISSING_VALUE"] = "MISSING_VALUE";
  ErrorCode2["INVALID_VALUE"] = "INVALID_VALUE";
  ErrorCode2["MISSING_INTL_API"] = "MISSING_INTL_API";
})(ErrorCode || (ErrorCode = {}));
var FormatError = (
  /** @class */
  function(_super) {
    __extends(FormatError2, _super);
    function FormatError2(msg, code2, originalMessage) {
      var _this = _super.call(this, msg) || this;
      _this.code = code2;
      _this.originalMessage = originalMessage;
      return _this;
    }
    FormatError2.prototype.toString = function() {
      return "[formatjs Error: ".concat(this.code, "] ").concat(this.message);
    };
    return FormatError2;
  }(Error)
);
var InvalidValueError = (
  /** @class */
  function(_super) {
    __extends(InvalidValueError2, _super);
    function InvalidValueError2(variableId, value, options, originalMessage) {
      return _super.call(this, 'Invalid values for "'.concat(variableId, '": "').concat(value, '". Options are "').concat(Object.keys(options).join('", "'), '"'), ErrorCode.INVALID_VALUE, originalMessage) || this;
    }
    return InvalidValueError2;
  }(FormatError)
);
var InvalidValueTypeError = (
  /** @class */
  function(_super) {
    __extends(InvalidValueTypeError2, _super);
    function InvalidValueTypeError2(value, type2, originalMessage) {
      return _super.call(this, 'Value for "'.concat(value, '" must be of type ').concat(type2), ErrorCode.INVALID_VALUE, originalMessage) || this;
    }
    return InvalidValueTypeError2;
  }(FormatError)
);
var MissingValueError = (
  /** @class */
  function(_super) {
    __extends(MissingValueError2, _super);
    function MissingValueError2(variableId, originalMessage) {
      return _super.call(this, 'The intl string context variable "'.concat(variableId, '" was not provided to the string "').concat(originalMessage, '"'), ErrorCode.MISSING_VALUE, originalMessage) || this;
    }
    return MissingValueError2;
  }(FormatError)
);
var PART_TYPE;
(function(PART_TYPE2) {
  PART_TYPE2[PART_TYPE2["literal"] = 0] = "literal";
  PART_TYPE2[PART_TYPE2["object"] = 1] = "object";
})(PART_TYPE || (PART_TYPE = {}));
function mergeLiteral(parts) {
  if (parts.length < 2) {
    return parts;
  }
  return parts.reduce(function(all3, part) {
    var lastPart = all3[all3.length - 1];
    if (!lastPart || lastPart.type !== PART_TYPE.literal || part.type !== PART_TYPE.literal) {
      all3.push(part);
    } else {
      lastPart.value += part.value;
    }
    return all3;
  }, []);
}
function isFormatXMLElementFn(el) {
  return typeof el === "function";
}
function formatToParts(els, locales, formatters, formats, values, currentPluralValue, originalMessage) {
  if (els.length === 1 && isLiteralElement(els[0])) {
    return [
      {
        type: PART_TYPE.literal,
        value: els[0].value
      }
    ];
  }
  var result = [];
  for (var _i2 = 0, els_1 = els; _i2 < els_1.length; _i2++) {
    var el = els_1[_i2];
    if (isLiteralElement(el)) {
      result.push({
        type: PART_TYPE.literal,
        value: el.value
      });
      continue;
    }
    if (isPoundElement(el)) {
      if (typeof currentPluralValue === "number") {
        result.push({
          type: PART_TYPE.literal,
          value: formatters.getNumberFormat(locales).format(currentPluralValue)
        });
      }
      continue;
    }
    var varName = el.value;
    if (!(values && varName in values)) {
      throw new MissingValueError(varName, originalMessage);
    }
    var value = values[varName];
    if (isArgumentElement(el)) {
      if (!value || typeof value === "string" || typeof value === "number") {
        value = typeof value === "string" || typeof value === "number" ? String(value) : "";
      }
      result.push({
        type: typeof value === "string" ? PART_TYPE.literal : PART_TYPE.object,
        value
      });
      continue;
    }
    if (isDateElement(el)) {
      var style = typeof el.style === "string" ? formats.date[el.style] : isDateTimeSkeleton(el.style) ? el.style.parsedOptions : void 0;
      result.push({
        type: PART_TYPE.literal,
        value: formatters.getDateTimeFormat(locales, style).format(value)
      });
      continue;
    }
    if (isTimeElement(el)) {
      var style = typeof el.style === "string" ? formats.time[el.style] : isDateTimeSkeleton(el.style) ? el.style.parsedOptions : formats.time.medium;
      result.push({
        type: PART_TYPE.literal,
        value: formatters.getDateTimeFormat(locales, style).format(value)
      });
      continue;
    }
    if (isNumberElement(el)) {
      var style = typeof el.style === "string" ? formats.number[el.style] : isNumberSkeleton(el.style) ? el.style.parsedOptions : void 0;
      if (style && style.scale) {
        value = value * (style.scale || 1);
      }
      result.push({
        type: PART_TYPE.literal,
        value: formatters.getNumberFormat(locales, style).format(value)
      });
      continue;
    }
    if (isTagElement(el)) {
      var children = el.children, value_1 = el.value;
      var formatFn = values[value_1];
      if (!isFormatXMLElementFn(formatFn)) {
        throw new InvalidValueTypeError(value_1, "function", originalMessage);
      }
      var parts = formatToParts(children, locales, formatters, formats, values, currentPluralValue);
      var chunks = formatFn(parts.map(function(p2) {
        return p2.value;
      }));
      if (!Array.isArray(chunks)) {
        chunks = [chunks];
      }
      result.push.apply(result, chunks.map(function(c6) {
        return {
          type: typeof c6 === "string" ? PART_TYPE.literal : PART_TYPE.object,
          value: c6
        };
      }));
    }
    if (isSelectElement(el)) {
      var opt = el.options[value] || el.options.other;
      if (!opt) {
        throw new InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);
      }
      result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values));
      continue;
    }
    if (isPluralElement(el)) {
      var opt = el.options["=".concat(value)];
      if (!opt) {
        if (!Intl.PluralRules) {
          throw new FormatError('Intl.PluralRules is not available in this environment.\nTry polyfilling it using "@formatjs/intl-pluralrules"\n', ErrorCode.MISSING_INTL_API, originalMessage);
        }
        var rule = formatters.getPluralRules(locales, { type: el.pluralType }).select(value - (el.offset || 0));
        opt = el.options[rule] || el.options.other;
      }
      if (!opt) {
        throw new InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);
      }
      result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values, value - (el.offset || 0)));
      continue;
    }
  }
  return mergeLiteral(result);
}
function mergeConfig$2(c12, c22) {
  if (!c22) {
    return c12;
  }
  return __assign(__assign(__assign({}, c12 || {}), c22 || {}), Object.keys(c12).reduce(function(all3, k2) {
    all3[k2] = __assign(__assign({}, c12[k2]), c22[k2] || {});
    return all3;
  }, {}));
}
function mergeConfigs(defaultConfig, configs) {
  if (!configs) {
    return defaultConfig;
  }
  return Object.keys(defaultConfig).reduce(function(all3, k2) {
    all3[k2] = mergeConfig$2(defaultConfig[k2], configs[k2]);
    return all3;
  }, __assign({}, defaultConfig));
}
function createFastMemoizeCache$1(store) {
  return {
    create: function() {
      return {
        get: function(key) {
          return store[key];
        },
        set: function(key, value) {
          store[key] = value;
        }
      };
    }
  };
}
function createDefaultFormatters(cache) {
  if (cache === void 0) {
    cache = {
      number: {},
      dateTime: {},
      pluralRules: {}
    };
  }
  return {
    getNumberFormat: memoize$2(function() {
      var _a3;
      var args = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        args[_i2] = arguments[_i2];
      }
      return new ((_a3 = Intl.NumberFormat).bind.apply(_a3, __spreadArray([void 0], args, false)))();
    }, {
      cache: createFastMemoizeCache$1(cache.number),
      strategy: strategies.variadic
    }),
    getDateTimeFormat: memoize$2(function() {
      var _a3;
      var args = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        args[_i2] = arguments[_i2];
      }
      return new ((_a3 = Intl.DateTimeFormat).bind.apply(_a3, __spreadArray([void 0], args, false)))();
    }, {
      cache: createFastMemoizeCache$1(cache.dateTime),
      strategy: strategies.variadic
    }),
    getPluralRules: memoize$2(function() {
      var _a3;
      var args = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        args[_i2] = arguments[_i2];
      }
      return new ((_a3 = Intl.PluralRules).bind.apply(_a3, __spreadArray([void 0], args, false)))();
    }, {
      cache: createFastMemoizeCache$1(cache.pluralRules),
      strategy: strategies.variadic
    })
  };
}
var IntlMessageFormat = (
  /** @class */
  function() {
    function IntlMessageFormat2(message, locales, overrideFormats, opts) {
      var _this = this;
      if (locales === void 0) {
        locales = IntlMessageFormat2.defaultLocale;
      }
      this.formatterCache = {
        number: {},
        dateTime: {},
        pluralRules: {}
      };
      this.format = function(values) {
        var parts = _this.formatToParts(values);
        if (parts.length === 1) {
          return parts[0].value;
        }
        var result = parts.reduce(function(all3, part) {
          if (!all3.length || part.type !== PART_TYPE.literal || typeof all3[all3.length - 1] !== "string") {
            all3.push(part.value);
          } else {
            all3[all3.length - 1] += part.value;
          }
          return all3;
        }, []);
        if (result.length <= 1) {
          return result[0] || "";
        }
        return result;
      };
      this.formatToParts = function(values) {
        return formatToParts(_this.ast, _this.locales, _this.formatters, _this.formats, values, void 0, _this.message);
      };
      this.resolvedOptions = function() {
        return {
          locale: _this.resolvedLocale.toString()
        };
      };
      this.getAst = function() {
        return _this.ast;
      };
      this.locales = locales;
      this.resolvedLocale = IntlMessageFormat2.resolveLocale(locales);
      if (typeof message === "string") {
        this.message = message;
        if (!IntlMessageFormat2.__parse) {
          throw new TypeError("IntlMessageFormat.__parse must be set to process `message` of type `string`");
        }
        this.ast = IntlMessageFormat2.__parse(message, {
          ignoreTag: opts === null || opts === void 0 ? void 0 : opts.ignoreTag,
          locale: this.resolvedLocale
        });
      } else {
        this.ast = message;
      }
      if (!Array.isArray(this.ast)) {
        throw new TypeError("A message must be provided as a String or AST.");
      }
      this.formats = mergeConfigs(IntlMessageFormat2.formats, overrideFormats);
      this.formatters = opts && opts.formatters || createDefaultFormatters(this.formatterCache);
    }
    Object.defineProperty(IntlMessageFormat2, "defaultLocale", {
      get: function() {
        if (!IntlMessageFormat2.memoizedDefaultLocale) {
          IntlMessageFormat2.memoizedDefaultLocale = new Intl.NumberFormat().resolvedOptions().locale;
        }
        return IntlMessageFormat2.memoizedDefaultLocale;
      },
      enumerable: false,
      configurable: true
    });
    IntlMessageFormat2.memoizedDefaultLocale = null;
    IntlMessageFormat2.resolveLocale = function(locales) {
      var supportedLocales = Intl.NumberFormat.supportedLocalesOf(locales);
      if (supportedLocales.length > 0) {
        return new Intl.Locale(supportedLocales[0]);
      }
      return new Intl.Locale(typeof locales === "string" ? locales : locales[0]);
    };
    IntlMessageFormat2.__parse = parse$2;
    IntlMessageFormat2.formats = {
      number: {
        integer: {
          maximumFractionDigits: 0
        },
        currency: {
          style: "currency"
        },
        percent: {
          style: "percent"
        }
      },
      date: {
        short: {
          month: "numeric",
          day: "numeric",
          year: "2-digit"
        },
        medium: {
          month: "short",
          day: "numeric",
          year: "numeric"
        },
        long: {
          month: "long",
          day: "numeric",
          year: "numeric"
        },
        full: {
          weekday: "long",
          month: "long",
          day: "numeric",
          year: "numeric"
        }
      },
      time: {
        short: {
          hour: "numeric",
          minute: "numeric"
        },
        medium: {
          hour: "numeric",
          minute: "numeric",
          second: "numeric"
        },
        long: {
          hour: "numeric",
          minute: "numeric",
          second: "numeric",
          timeZoneName: "short"
        },
        full: {
          hour: "numeric",
          minute: "numeric",
          second: "numeric",
          timeZoneName: "short"
        }
      }
    };
    return IntlMessageFormat2;
  }()
);
var IntlErrorCode;
(function(IntlErrorCode2) {
  IntlErrorCode2["FORMAT_ERROR"] = "FORMAT_ERROR";
  IntlErrorCode2["UNSUPPORTED_FORMATTER"] = "UNSUPPORTED_FORMATTER";
  IntlErrorCode2["INVALID_CONFIG"] = "INVALID_CONFIG";
  IntlErrorCode2["MISSING_DATA"] = "MISSING_DATA";
  IntlErrorCode2["MISSING_TRANSLATION"] = "MISSING_TRANSLATION";
})(IntlErrorCode || (IntlErrorCode = {}));
var IntlError = (
  /** @class */
  function(_super) {
    __extends(IntlError2, _super);
    function IntlError2(code2, message, exception) {
      var _this = this;
      var err = exception ? exception instanceof Error ? exception : new Error(String(exception)) : void 0;
      _this = _super.call(this, "[@formatjs/intl Error ".concat(code2, "] ").concat(message, " \n").concat(err ? "\n".concat(err.message, "\n").concat(err.stack) : "")) || this;
      _this.code = code2;
      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(_this, IntlError2);
      }
      return _this;
    }
    return IntlError2;
  }(Error)
);
var UnsupportedFormatterError = (
  /** @class */
  function(_super) {
    __extends(UnsupportedFormatterError2, _super);
    function UnsupportedFormatterError2(message, exception) {
      return _super.call(this, IntlErrorCode.UNSUPPORTED_FORMATTER, message, exception) || this;
    }
    return UnsupportedFormatterError2;
  }(IntlError)
);
var InvalidConfigError = (
  /** @class */
  function(_super) {
    __extends(InvalidConfigError2, _super);
    function InvalidConfigError2(message, exception) {
      return _super.call(this, IntlErrorCode.INVALID_CONFIG, message, exception) || this;
    }
    return InvalidConfigError2;
  }(IntlError)
);
var MissingDataError = (
  /** @class */
  function(_super) {
    __extends(MissingDataError2, _super);
    function MissingDataError2(message, exception) {
      return _super.call(this, IntlErrorCode.MISSING_DATA, message, exception) || this;
    }
    return MissingDataError2;
  }(IntlError)
);
var IntlFormatError = (
  /** @class */
  function(_super) {
    __extends(IntlFormatError2, _super);
    function IntlFormatError2(message, locale2, exception) {
      return _super.call(this, IntlErrorCode.FORMAT_ERROR, "".concat(message, " \nLocale: ").concat(locale2, "\n"), exception) || this;
    }
    return IntlFormatError2;
  }(IntlError)
);
var MessageFormatError = (
  /** @class */
  function(_super) {
    __extends(MessageFormatError2, _super);
    function MessageFormatError2(message, locale2, descriptor, exception) {
      var _this = _super.call(this, "".concat(message, " \nMessageID: ").concat(descriptor === null || descriptor === void 0 ? void 0 : descriptor.id, "\nDefault Message: ").concat(descriptor === null || descriptor === void 0 ? void 0 : descriptor.defaultMessage, "\nDescription: ").concat(descriptor === null || descriptor === void 0 ? void 0 : descriptor.description, " \n"), locale2, exception) || this;
      _this.descriptor = descriptor;
      return _this;
    }
    return MessageFormatError2;
  }(IntlFormatError)
);
var MissingTranslationError = (
  /** @class */
  function(_super) {
    __extends(MissingTranslationError2, _super);
    function MissingTranslationError2(descriptor, locale2) {
      var _this = _super.call(this, IntlErrorCode.MISSING_TRANSLATION, 'Missing message: "'.concat(descriptor.id, '" for locale "').concat(locale2, '", using ').concat(descriptor.defaultMessage ? "default message" : "id", " as fallback.")) || this;
      _this.descriptor = descriptor;
      return _this;
    }
    return MissingTranslationError2;
  }(IntlError)
);
function filterProps(props, allowlist, defaults2) {
  if (defaults2 === void 0) {
    defaults2 = {};
  }
  return allowlist.reduce(function(filtered, name2) {
    if (name2 in props) {
      filtered[name2] = props[name2];
    } else if (name2 in defaults2) {
      filtered[name2] = defaults2[name2];
    }
    return filtered;
  }, {});
}
var defaultErrorHandler = function(error2) {
};
var defaultWarnHandler = function(warning) {
};
var DEFAULT_INTL_CONFIG$1 = {
  formats: {},
  messages: {},
  timeZone: void 0,
  defaultLocale: "en",
  defaultFormats: {},
  fallbackOnEmptyString: true,
  onError: defaultErrorHandler,
  onWarn: defaultWarnHandler
};
function createIntlCache() {
  return {
    dateTime: {},
    number: {},
    message: {},
    relativeTime: {},
    pluralRules: {},
    list: {},
    displayNames: {}
  };
}
function createFastMemoizeCache(store) {
  return {
    create: function() {
      return {
        get: function(key) {
          return store[key];
        },
        set: function(key, value) {
          store[key] = value;
        }
      };
    }
  };
}
function createFormatters(cache) {
  if (cache === void 0) {
    cache = createIntlCache();
  }
  var RelativeTimeFormat = Intl.RelativeTimeFormat;
  var ListFormat = Intl.ListFormat;
  var DisplayNames = Intl.DisplayNames;
  var getDateTimeFormat = memoize$2(function() {
    var _a3;
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    return new ((_a3 = Intl.DateTimeFormat).bind.apply(_a3, __spreadArray([void 0], args, false)))();
  }, {
    cache: createFastMemoizeCache(cache.dateTime),
    strategy: strategies.variadic
  });
  var getNumberFormat = memoize$2(function() {
    var _a3;
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    return new ((_a3 = Intl.NumberFormat).bind.apply(_a3, __spreadArray([void 0], args, false)))();
  }, {
    cache: createFastMemoizeCache(cache.number),
    strategy: strategies.variadic
  });
  var getPluralRules = memoize$2(function() {
    var _a3;
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    return new ((_a3 = Intl.PluralRules).bind.apply(_a3, __spreadArray([void 0], args, false)))();
  }, {
    cache: createFastMemoizeCache(cache.pluralRules),
    strategy: strategies.variadic
  });
  return {
    getDateTimeFormat,
    getNumberFormat,
    getMessageFormat: memoize$2(function(message, locales, overrideFormats, opts) {
      return new IntlMessageFormat(message, locales, overrideFormats, __assign({ formatters: {
        getNumberFormat,
        getDateTimeFormat,
        getPluralRules
      } }, opts || {}));
    }, {
      cache: createFastMemoizeCache(cache.message),
      strategy: strategies.variadic
    }),
    getRelativeTimeFormat: memoize$2(function() {
      var args = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        args[_i2] = arguments[_i2];
      }
      return new (RelativeTimeFormat.bind.apply(RelativeTimeFormat, __spreadArray([void 0], args, false)))();
    }, {
      cache: createFastMemoizeCache(cache.relativeTime),
      strategy: strategies.variadic
    }),
    getPluralRules,
    getListFormat: memoize$2(function() {
      var args = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        args[_i2] = arguments[_i2];
      }
      return new (ListFormat.bind.apply(ListFormat, __spreadArray([void 0], args, false)))();
    }, {
      cache: createFastMemoizeCache(cache.list),
      strategy: strategies.variadic
    }),
    getDisplayNames: memoize$2(function() {
      var args = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        args[_i2] = arguments[_i2];
      }
      return new (DisplayNames.bind.apply(DisplayNames, __spreadArray([void 0], args, false)))();
    }, {
      cache: createFastMemoizeCache(cache.displayNames),
      strategy: strategies.variadic
    })
  };
}
function getNamedFormat(formats, type2, name2, onError) {
  var formatType = formats && formats[type2];
  var format2;
  if (formatType) {
    format2 = formatType[name2];
  }
  if (format2) {
    return format2;
  }
  onError(new UnsupportedFormatterError("No ".concat(type2, " format named: ").concat(name2)));
}
function setTimeZoneInOptions(opts, timeZone) {
  return Object.keys(opts).reduce(function(all3, k2) {
    all3[k2] = __assign({ timeZone }, opts[k2]);
    return all3;
  }, {});
}
function deepMergeOptions(opts1, opts2) {
  var keys2 = Object.keys(__assign(__assign({}, opts1), opts2));
  return keys2.reduce(function(all3, k2) {
    all3[k2] = __assign(__assign({}, opts1[k2] || {}), opts2[k2] || {});
    return all3;
  }, {});
}
function deepMergeFormatsAndSetTimeZone(f1, timeZone) {
  if (!timeZone) {
    return f1;
  }
  var mfFormats = IntlMessageFormat.formats;
  return __assign(__assign(__assign({}, mfFormats), f1), { date: deepMergeOptions(setTimeZoneInOptions(mfFormats.date, timeZone), setTimeZoneInOptions(f1.date || {}, timeZone)), time: deepMergeOptions(setTimeZoneInOptions(mfFormats.time, timeZone), setTimeZoneInOptions(f1.time || {}, timeZone)) });
}
function formatMessage$1(_a3, state, messageDescriptor, values, opts) {
  var locale2 = _a3.locale, formats = _a3.formats, messages = _a3.messages, defaultLocale = _a3.defaultLocale, defaultFormats = _a3.defaultFormats, fallbackOnEmptyString = _a3.fallbackOnEmptyString, onError = _a3.onError, timeZone = _a3.timeZone, defaultRichTextElements = _a3.defaultRichTextElements;
  if (messageDescriptor === void 0) {
    messageDescriptor = { id: "" };
  }
  var msgId = messageDescriptor.id, defaultMessage = messageDescriptor.defaultMessage;
  invariant(!!msgId, "[@formatjs/intl] An `id` must be provided to format a message. You can either:\n1. Configure your build toolchain with [babel-plugin-formatjs](https://formatjs.io/docs/tooling/babel-plugin)\nor [@formatjs/ts-transformer](https://formatjs.io/docs/tooling/ts-transformer) OR\n2. Configure your `eslint` config to include [eslint-plugin-formatjs](https://formatjs.io/docs/tooling/linter#enforce-id)\nto autofix this issue");
  var id2 = String(msgId);
  var message = (
    // In case messages is Object.create(null)
    // e.g import('foo.json') from webpack)
    // See https://github.com/formatjs/formatjs/issues/1914
    messages && Object.prototype.hasOwnProperty.call(messages, id2) && messages[id2]
  );
  if (Array.isArray(message) && message.length === 1 && message[0].type === TYPE.literal) {
    return message[0].value;
  }
  if (!values && message && typeof message === "string" && !defaultRichTextElements) {
    return message.replace(/'\{(.*?)\}'/gi, "{$1}");
  }
  values = __assign(__assign({}, defaultRichTextElements), values || {});
  formats = deepMergeFormatsAndSetTimeZone(formats, timeZone);
  defaultFormats = deepMergeFormatsAndSetTimeZone(defaultFormats, timeZone);
  if (!message) {
    if (fallbackOnEmptyString === false && message === "") {
      return message;
    }
    if (!defaultMessage || locale2 && locale2.toLowerCase() !== defaultLocale.toLowerCase()) {
      onError(new MissingTranslationError(messageDescriptor, locale2));
    }
    if (defaultMessage) {
      try {
        var formatter = state.getMessageFormat(defaultMessage, defaultLocale, defaultFormats, opts);
        return formatter.format(values);
      } catch (e2) {
        onError(new MessageFormatError('Error formatting default message for: "'.concat(id2, '", rendering default message verbatim'), locale2, messageDescriptor, e2));
        return typeof defaultMessage === "string" ? defaultMessage : id2;
      }
    }
    return id2;
  }
  try {
    var formatter = state.getMessageFormat(message, locale2, formats, __assign({ formatters: state }, opts || {}));
    return formatter.format(values);
  } catch (e2) {
    onError(new MessageFormatError('Error formatting message: "'.concat(id2, '", using ').concat(defaultMessage ? "default message" : "id", " as fallback."), locale2, messageDescriptor, e2));
  }
  if (defaultMessage) {
    try {
      var formatter = state.getMessageFormat(defaultMessage, defaultLocale, defaultFormats, opts);
      return formatter.format(values);
    } catch (e2) {
      onError(new MessageFormatError('Error formatting the default message for: "'.concat(id2, '", rendering message verbatim'), locale2, messageDescriptor, e2));
    }
  }
  if (typeof message === "string") {
    return message;
  }
  if (typeof defaultMessage === "string") {
    return defaultMessage;
  }
  return id2;
}
var DATE_TIME_FORMAT_OPTIONS = [
  "localeMatcher",
  "formatMatcher",
  "timeZone",
  "hour12",
  "weekday",
  "era",
  "year",
  "month",
  "day",
  "hour",
  "minute",
  "second",
  "timeZoneName",
  "hourCycle",
  "dateStyle",
  "timeStyle",
  "calendar",
  // 'dayPeriod',
  "numberingSystem"
];
function getFormatter$2(_a3, type2, getDateTimeFormat, options) {
  var locale2 = _a3.locale, formats = _a3.formats, onError = _a3.onError, timeZone = _a3.timeZone;
  if (options === void 0) {
    options = {};
  }
  var format2 = options.format;
  var defaults2 = __assign(__assign({}, timeZone && { timeZone }), format2 && getNamedFormat(formats, type2, format2, onError));
  var filteredOptions = filterProps(options, DATE_TIME_FORMAT_OPTIONS, defaults2);
  if (type2 === "time" && !filteredOptions.hour && !filteredOptions.minute && !filteredOptions.second && !filteredOptions.timeStyle && !filteredOptions.dateStyle) {
    filteredOptions = __assign(__assign({}, filteredOptions), { hour: "numeric", minute: "numeric" });
  }
  return getDateTimeFormat(locale2, filteredOptions);
}
function formatDate(config2, getDateTimeFormat) {
  var _a3 = [];
  for (var _i2 = 2; _i2 < arguments.length; _i2++) {
    _a3[_i2 - 2] = arguments[_i2];
  }
  var value = _a3[0], _b2 = _a3[1], options = _b2 === void 0 ? {} : _b2;
  var date = typeof value === "string" ? new Date(value || 0) : value;
  try {
    return getFormatter$2(config2, "date", getDateTimeFormat, options).format(date);
  } catch (e2) {
    config2.onError(new IntlError(IntlErrorCode.FORMAT_ERROR, "Error formatting date.", e2));
  }
  return String(date);
}
function formatTime(config2, getDateTimeFormat) {
  var _a3 = [];
  for (var _i2 = 2; _i2 < arguments.length; _i2++) {
    _a3[_i2 - 2] = arguments[_i2];
  }
  var value = _a3[0], _b2 = _a3[1], options = _b2 === void 0 ? {} : _b2;
  var date = typeof value === "string" ? new Date(value || 0) : value;
  try {
    return getFormatter$2(config2, "time", getDateTimeFormat, options).format(date);
  } catch (e2) {
    config2.onError(new IntlError(IntlErrorCode.FORMAT_ERROR, "Error formatting time.", e2));
  }
  return String(date);
}
function formatDateTimeRange(config2, getDateTimeFormat) {
  var _a3 = [];
  for (var _i2 = 2; _i2 < arguments.length; _i2++) {
    _a3[_i2 - 2] = arguments[_i2];
  }
  var from2 = _a3[0], to2 = _a3[1], _b2 = _a3[2], options = _b2 === void 0 ? {} : _b2;
  var timeZone = config2.timeZone, locale2 = config2.locale, onError = config2.onError;
  var filteredOptions = filterProps(options, DATE_TIME_FORMAT_OPTIONS, timeZone ? { timeZone } : {});
  try {
    return getDateTimeFormat(locale2, filteredOptions).formatRange(from2, to2);
  } catch (e2) {
    onError(new IntlError(IntlErrorCode.FORMAT_ERROR, "Error formatting date time range.", e2));
  }
  return String(from2);
}
function formatDateToParts(config2, getDateTimeFormat) {
  var _a3 = [];
  for (var _i2 = 2; _i2 < arguments.length; _i2++) {
    _a3[_i2 - 2] = arguments[_i2];
  }
  var value = _a3[0], _b2 = _a3[1], options = _b2 === void 0 ? {} : _b2;
  var date = typeof value === "string" ? new Date(value || 0) : value;
  try {
    return getFormatter$2(config2, "date", getDateTimeFormat, options).formatToParts(date);
  } catch (e2) {
    config2.onError(new IntlError(IntlErrorCode.FORMAT_ERROR, "Error formatting date.", e2));
  }
  return [];
}
function formatTimeToParts(config2, getDateTimeFormat) {
  var _a3 = [];
  for (var _i2 = 2; _i2 < arguments.length; _i2++) {
    _a3[_i2 - 2] = arguments[_i2];
  }
  var value = _a3[0], _b2 = _a3[1], options = _b2 === void 0 ? {} : _b2;
  var date = typeof value === "string" ? new Date(value || 0) : value;
  try {
    return getFormatter$2(config2, "time", getDateTimeFormat, options).formatToParts(date);
  } catch (e2) {
    config2.onError(new IntlError(IntlErrorCode.FORMAT_ERROR, "Error formatting time.", e2));
  }
  return [];
}
var DISPLAY_NAMES_OPTONS = [
  "localeMatcher",
  "style",
  "type",
  "fallback"
];
function formatDisplayName(_a3, getDisplayNames, value, options) {
  var locale2 = _a3.locale, onError = _a3.onError;
  var DisplayNames = Intl.DisplayNames;
  if (!DisplayNames) {
    onError(new FormatError('Intl.DisplayNames is not available in this environment.\nTry polyfilling it using "@formatjs/intl-displaynames"\n', ErrorCode.MISSING_INTL_API));
  }
  var filteredOptions = filterProps(options, DISPLAY_NAMES_OPTONS);
  try {
    return getDisplayNames(locale2, filteredOptions).of(value);
  } catch (e2) {
    onError(new IntlError(IntlErrorCode.FORMAT_ERROR, "Error formatting display name.", e2));
  }
}
var LIST_FORMAT_OPTIONS = [
  "localeMatcher",
  "type",
  "style"
];
var now = Date.now();
function generateToken(i) {
  return "".concat(now, "_").concat(i, "_").concat(now);
}
function formatList(opts, getListFormat, values, options) {
  if (options === void 0) {
    options = {};
  }
  var results = formatListToParts(opts, getListFormat, values, options).reduce(function(all3, el) {
    var val = el.value;
    if (typeof val !== "string") {
      all3.push(val);
    } else if (typeof all3[all3.length - 1] === "string") {
      all3[all3.length - 1] += val;
    } else {
      all3.push(val);
    }
    return all3;
  }, []);
  return results.length === 1 ? results[0] : results;
}
function formatListToParts(_a3, getListFormat, values, options) {
  var locale2 = _a3.locale, onError = _a3.onError;
  if (options === void 0) {
    options = {};
  }
  var ListFormat = Intl.ListFormat;
  if (!ListFormat) {
    onError(new FormatError('Intl.ListFormat is not available in this environment.\nTry polyfilling it using "@formatjs/intl-listformat"\n', ErrorCode.MISSING_INTL_API));
  }
  var filteredOptions = filterProps(options, LIST_FORMAT_OPTIONS);
  try {
    var richValues_1 = {};
    var serializedValues = values.map(function(v2, i) {
      if (typeof v2 === "object") {
        var id2 = generateToken(i);
        richValues_1[id2] = v2;
        return id2;
      }
      return String(v2);
    });
    return getListFormat(locale2, filteredOptions).formatToParts(serializedValues).map(function(part) {
      return part.type === "literal" ? part : __assign(__assign({}, part), { value: richValues_1[part.value] || part.value });
    });
  } catch (e2) {
    onError(new IntlError(IntlErrorCode.FORMAT_ERROR, "Error formatting list.", e2));
  }
  return values;
}
var PLURAL_FORMAT_OPTIONS = [
  "localeMatcher",
  "type"
];
function formatPlural(_a3, getPluralRules, value, options) {
  var locale2 = _a3.locale, onError = _a3.onError;
  if (options === void 0) {
    options = {};
  }
  if (!Intl.PluralRules) {
    onError(new FormatError('Intl.PluralRules is not available in this environment.\nTry polyfilling it using "@formatjs/intl-pluralrules"\n', ErrorCode.MISSING_INTL_API));
  }
  var filteredOptions = filterProps(options, PLURAL_FORMAT_OPTIONS);
  try {
    return getPluralRules(locale2, filteredOptions).select(value);
  } catch (e2) {
    onError(new IntlFormatError("Error formatting plural.", locale2, e2));
  }
  return "other";
}
var RELATIVE_TIME_FORMAT_OPTIONS = ["numeric", "style"];
function getFormatter$1(_a3, getRelativeTimeFormat, options) {
  var locale2 = _a3.locale, formats = _a3.formats, onError = _a3.onError;
  if (options === void 0) {
    options = {};
  }
  var format2 = options.format;
  var defaults2 = !!format2 && getNamedFormat(formats, "relative", format2, onError) || {};
  var filteredOptions = filterProps(options, RELATIVE_TIME_FORMAT_OPTIONS, defaults2);
  return getRelativeTimeFormat(locale2, filteredOptions);
}
function formatRelativeTime(config2, getRelativeTimeFormat, value, unit, options) {
  if (options === void 0) {
    options = {};
  }
  if (!unit) {
    unit = "second";
  }
  var RelativeTimeFormat = Intl.RelativeTimeFormat;
  if (!RelativeTimeFormat) {
    config2.onError(new FormatError('Intl.RelativeTimeFormat is not available in this environment.\nTry polyfilling it using "@formatjs/intl-relativetimeformat"\n', ErrorCode.MISSING_INTL_API));
  }
  try {
    return getFormatter$1(config2, getRelativeTimeFormat, options).format(value, unit);
  } catch (e2) {
    config2.onError(new IntlFormatError("Error formatting relative time.", config2.locale, e2));
  }
  return String(value);
}
var NUMBER_FORMAT_OPTIONS = [
  "localeMatcher",
  "style",
  "currency",
  "currencyDisplay",
  "unit",
  "unitDisplay",
  "useGrouping",
  "minimumIntegerDigits",
  "minimumFractionDigits",
  "maximumFractionDigits",
  "minimumSignificantDigits",
  "maximumSignificantDigits",
  // ES2020 NumberFormat
  "compactDisplay",
  "currencyDisplay",
  "currencySign",
  "notation",
  "signDisplay",
  "unit",
  "unitDisplay",
  "numberingSystem"
];
function getFormatter(_a3, getNumberFormat, options) {
  var locale2 = _a3.locale, formats = _a3.formats, onError = _a3.onError;
  if (options === void 0) {
    options = {};
  }
  var format2 = options.format;
  var defaults2 = format2 && getNamedFormat(formats, "number", format2, onError) || {};
  var filteredOptions = filterProps(options, NUMBER_FORMAT_OPTIONS, defaults2);
  return getNumberFormat(locale2, filteredOptions);
}
function formatNumber(config2, getNumberFormat, value, options) {
  if (options === void 0) {
    options = {};
  }
  try {
    return getFormatter(config2, getNumberFormat, options).format(value);
  } catch (e2) {
    config2.onError(new IntlError(IntlErrorCode.FORMAT_ERROR, "Error formatting number.", e2));
  }
  return String(value);
}
function formatNumberToParts(config2, getNumberFormat, value, options) {
  if (options === void 0) {
    options = {};
  }
  try {
    return getFormatter(config2, getNumberFormat, options).formatToParts(value);
  } catch (e2) {
    config2.onError(new IntlError(IntlErrorCode.FORMAT_ERROR, "Error formatting number.", e2));
  }
  return [];
}
function messagesContainString(messages) {
  var firstMessage = messages[Object.keys(messages)[0]];
  return typeof firstMessage === "string";
}
function verifyConfigMessages(config2) {
  if (config2.onWarn && config2.defaultRichTextElements && messagesContainString(config2.messages || {})) {
    config2.onWarn('[@formatjs/intl] "defaultRichTextElements" was specified but "message" was not pre-compiled. \nPlease consider using "@formatjs/cli" to pre-compile your messages for performance.\nFor more details see https://formatjs.io/docs/getting-started/message-distribution');
  }
}
function createIntl$1(config2, cache) {
  var formatters = createFormatters(cache);
  var resolvedConfig = __assign(__assign({}, DEFAULT_INTL_CONFIG$1), config2);
  var locale2 = resolvedConfig.locale, defaultLocale = resolvedConfig.defaultLocale, onError = resolvedConfig.onError;
  if (!locale2) {
    if (onError) {
      onError(new InvalidConfigError('"locale" was not configured, using "'.concat(defaultLocale, '" as fallback. See https://formatjs.io/docs/react-intl/api#intlshape for more details')));
    }
    resolvedConfig.locale = resolvedConfig.defaultLocale || "en";
  } else if (!Intl.NumberFormat.supportedLocalesOf(locale2).length && onError) {
    onError(new MissingDataError('Missing locale data for locale: "'.concat(locale2, '" in Intl.NumberFormat. Using default locale: "').concat(defaultLocale, '" as fallback. See https://formatjs.io/docs/react-intl#runtime-requirements for more details')));
  } else if (!Intl.DateTimeFormat.supportedLocalesOf(locale2).length && onError) {
    onError(new MissingDataError('Missing locale data for locale: "'.concat(locale2, '" in Intl.DateTimeFormat. Using default locale: "').concat(defaultLocale, '" as fallback. See https://formatjs.io/docs/react-intl#runtime-requirements for more details')));
  }
  verifyConfigMessages(resolvedConfig);
  return __assign(__assign({}, resolvedConfig), { formatters, formatNumber: formatNumber.bind(null, resolvedConfig, formatters.getNumberFormat), formatNumberToParts: formatNumberToParts.bind(null, resolvedConfig, formatters.getNumberFormat), formatRelativeTime: formatRelativeTime.bind(null, resolvedConfig, formatters.getRelativeTimeFormat), formatDate: formatDate.bind(null, resolvedConfig, formatters.getDateTimeFormat), formatDateToParts: formatDateToParts.bind(null, resolvedConfig, formatters.getDateTimeFormat), formatTime: formatTime.bind(null, resolvedConfig, formatters.getDateTimeFormat), formatDateTimeRange: formatDateTimeRange.bind(null, resolvedConfig, formatters.getDateTimeFormat), formatTimeToParts: formatTimeToParts.bind(null, resolvedConfig, formatters.getDateTimeFormat), formatPlural: formatPlural.bind(null, resolvedConfig, formatters.getPluralRules), formatMessage: formatMessage$1.bind(null, resolvedConfig, formatters), $t: formatMessage$1.bind(null, resolvedConfig, formatters), formatList: formatList.bind(null, resolvedConfig, formatters.getListFormat), formatListToParts: formatListToParts.bind(null, resolvedConfig, formatters.getListFormat), formatDisplayName: formatDisplayName.bind(null, resolvedConfig, formatters.getDisplayNames) });
}
function invariantIntlContext(intl) {
  invariant(intl, "[React Intl] Could not find required `intl` object. <IntlProvider> needs to exist in the component ancestry.");
}
var DEFAULT_INTL_CONFIG = __assign(__assign({}, DEFAULT_INTL_CONFIG$1), { textComponent: g$3 });
function assignUniqueKeysToParts(formatXMLElementFn) {
  return function(parts) {
    return formatXMLElementFn(A$1.toArray(parts));
  };
}
function shallowEqual(objA, objB) {
  if (objA === objB) {
    return true;
  }
  if (!objA || !objB) {
    return false;
  }
  var aKeys = Object.keys(objA);
  var bKeys = Object.keys(objB);
  var len = aKeys.length;
  if (bKeys.length !== len) {
    return false;
  }
  for (var i = 0; i < len; i++) {
    var key = aKeys[i];
    if (objA[key] !== objB[key] || !Object.prototype.hasOwnProperty.call(objB, key)) {
      return false;
    }
  }
  return true;
}
var IntlContext = E$2(null);
IntlContext.Consumer;
var IntlProvider$1 = IntlContext.Provider;
var Provider = IntlProvider$1;
var Context = IntlContext;
function useIntl() {
  var intl = P$1(Context);
  invariantIntlContext(intl);
  return intl;
}
var DisplayName;
(function(DisplayName2) {
  DisplayName2["formatDate"] = "FormattedDate";
  DisplayName2["formatTime"] = "FormattedTime";
  DisplayName2["formatNumber"] = "FormattedNumber";
  DisplayName2["formatList"] = "FormattedList";
  DisplayName2["formatDisplayName"] = "FormattedDisplayName";
})(DisplayName || (DisplayName = {}));
var DisplayNameParts;
(function(DisplayNameParts2) {
  DisplayNameParts2["formatDate"] = "FormattedDateParts";
  DisplayNameParts2["formatTime"] = "FormattedTimeParts";
  DisplayNameParts2["formatNumber"] = "FormattedNumberParts";
  DisplayNameParts2["formatList"] = "FormattedListParts";
})(DisplayNameParts || (DisplayNameParts = {}));
function createFormattedDateTimePartsComponent(name2) {
  var ComponentParts = function(props) {
    var intl = useIntl();
    var value = props.value, children = props.children, formatProps = __rest(props, ["value", "children"]);
    var date = typeof value === "string" ? new Date(value || 0) : value;
    var formattedParts = name2 === "formatDate" ? intl.formatDateToParts(date, formatProps) : intl.formatTimeToParts(date, formatProps);
    return children(formattedParts);
  };
  ComponentParts.displayName = DisplayNameParts[name2];
  return ComponentParts;
}
function createFormattedComponent(name2) {
  var Component = function(props) {
    var intl = useIntl();
    var value = props.value, children = props.children, formatProps = __rest(
      props,
      ["value", "children"]
    );
    var formattedValue = intl[name2](value, formatProps);
    if (typeof children === "function") {
      return children(formattedValue);
    }
    var Text = intl.textComponent || g$3;
    return y$3(Text, null, formattedValue);
  };
  Component.displayName = DisplayName[name2];
  return Component;
}
function processIntlConfig(config2) {
  return {
    locale: config2.locale,
    timeZone: config2.timeZone,
    fallbackOnEmptyString: config2.fallbackOnEmptyString,
    formats: config2.formats,
    textComponent: config2.textComponent,
    messages: config2.messages,
    defaultLocale: config2.defaultLocale,
    defaultFormats: config2.defaultFormats,
    onError: config2.onError,
    onWarn: config2.onWarn,
    wrapRichTextChunksInFragment: config2.wrapRichTextChunksInFragment,
    defaultRichTextElements: config2.defaultRichTextElements
  };
}
function assignUniqueKeysToFormatXMLElementFnArgument(values) {
  if (!values) {
    return values;
  }
  return Object.keys(values).reduce(function(acc, k2) {
    var v2 = values[k2];
    acc[k2] = isFormatXMLElementFn(v2) ? assignUniqueKeysToParts(v2) : v2;
    return acc;
  }, {});
}
var formatMessage = function(config2, formatters, descriptor, rawValues) {
  var rest = [];
  for (var _i2 = 4; _i2 < arguments.length; _i2++) {
    rest[_i2 - 4] = arguments[_i2];
  }
  var values = assignUniqueKeysToFormatXMLElementFnArgument(rawValues);
  var chunks = formatMessage$1.apply(void 0, __spreadArray([
    config2,
    formatters,
    descriptor,
    values
  ], rest, false));
  if (Array.isArray(chunks)) {
    return A$1.toArray(chunks);
  }
  return chunks;
};
var createIntl = function(_a3, cache) {
  var rawDefaultRichTextElements = _a3.defaultRichTextElements, config2 = __rest(_a3, ["defaultRichTextElements"]);
  var defaultRichTextElements = assignUniqueKeysToFormatXMLElementFnArgument(rawDefaultRichTextElements);
  var coreIntl = createIntl$1(__assign(__assign(__assign({}, DEFAULT_INTL_CONFIG), config2), { defaultRichTextElements }), cache);
  return __assign(__assign({}, coreIntl), { formatMessage: formatMessage.bind(null, {
    locale: coreIntl.locale,
    timeZone: coreIntl.timeZone,
    fallbackOnEmptyString: coreIntl.fallbackOnEmptyString,
    formats: coreIntl.formats,
    defaultLocale: coreIntl.defaultLocale,
    defaultFormats: coreIntl.defaultFormats,
    messages: coreIntl.messages,
    onError: coreIntl.onError,
    defaultRichTextElements
  }, coreIntl.formatters) });
};
var IntlProvider = (
  /** @class */
  function(_super) {
    __extends(IntlProvider2, _super);
    function IntlProvider2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.cache = createIntlCache();
      _this.state = {
        cache: _this.cache,
        intl: createIntl(processIntlConfig(_this.props), _this.cache),
        prevConfig: processIntlConfig(_this.props)
      };
      return _this;
    }
    IntlProvider2.getDerivedStateFromProps = function(props, _a3) {
      var prevConfig = _a3.prevConfig, cache = _a3.cache;
      var config2 = processIntlConfig(props);
      if (!shallowEqual(prevConfig, config2)) {
        return {
          intl: createIntl(config2, cache),
          prevConfig: config2
        };
      }
      return null;
    };
    IntlProvider2.prototype.render = function() {
      invariantIntlContext(this.state.intl);
      return y$3(Provider, { value: this.state.intl }, this.props.children);
    };
    IntlProvider2.displayName = "IntlProvider";
    IntlProvider2.defaultProps = DEFAULT_INTL_CONFIG;
    return IntlProvider2;
  }(E)
);
function areEqual(prevProps, nextProps) {
  var values = prevProps.values, otherProps = __rest(prevProps, ["values"]);
  var nextValues = nextProps.values, nextOtherProps = __rest(nextProps, ["values"]);
  return shallowEqual(nextValues, values) && shallowEqual(otherProps, nextOtherProps);
}
function FormattedMessage(props) {
  var intl = useIntl();
  var formatMessage2 = intl.formatMessage, _a3 = intl.textComponent, Text = _a3 === void 0 ? g$3 : _a3;
  var id2 = props.id, description2 = props.description, defaultMessage = props.defaultMessage, values = props.values, children = props.children, _b2 = props.tagName, Component = _b2 === void 0 ? Text : _b2, ignoreTag = props.ignoreTag;
  var descriptor = { id: id2, description: description2, defaultMessage };
  var nodes = formatMessage2(descriptor, values, {
    ignoreTag
  });
  if (typeof children === "function") {
    return children(Array.isArray(nodes) ? nodes : [nodes]);
  }
  if (Component) {
    return y$3(Component, null, A$1.toArray(nodes));
  }
  return y$3(g$3, null, nodes);
}
FormattedMessage.displayName = "FormattedMessage";
var MemoizedFormattedMessage = w$1(FormattedMessage, areEqual);
MemoizedFormattedMessage.displayName = "MemoizedFormattedMessage";
createFormattedComponent("formatDate");
createFormattedComponent("formatTime");
createFormattedComponent("formatNumber");
createFormattedComponent("formatList");
createFormattedComponent("formatDisplayName");
createFormattedDateTimePartsComponent("formatDate");
createFormattedDateTimePartsComponent("formatTime");
var _flattenMessages = function flattenMessages(nestedMessages) {
  var prefix2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  return Object.entries(nestedMessages).reduce(function(messages, _ref3) {
    var _ref22 = _slicedToArray(_ref3, 2), key = _ref22[0], value = _ref22[1];
    var prefixedKey = prefix2 !== "" ? "".concat(prefix2, ".").concat(key) : key;
    if (typeof value === "string") {
      messages[prefixedKey] = value;
    } else {
      Object.assign(messages, _flattenMessages(value, prefixedKey));
    }
    return messages;
  }, {});
};
var POSITION_LEFT = "left";
var POSITION_RIGHT = "right";
var animationDuration = 225;
var backgroundOpacity = 0.8;
var contentStyle = function contentStyle2(customParentId) {
  return /* @__PURE__ */ css({
    position: customParentId !== void 0 ? "absolute" : "fixed",
    top: 0,
    zIndex: theme.zIndex.highest,
    width: "100%",
    height: "100%",
    display: "flex",
    alignItems: "center"
  }, "", "", "", "");
};
var DrawerStatus = /* @__PURE__ */ function(DrawerStatus2) {
  DrawerStatus2["CLOSED"] = "CLOSED";
  DrawerStatus2["WILL_OPEN"] = "WILL_OPEN";
  DrawerStatus2["OPENING"] = "OPENING";
  DrawerStatus2["OPENED"] = "OPENED";
  DrawerStatus2["CLOSING"] = "CLOSING";
  return DrawerStatus2;
}({});
var maskStyle$1 = function maskStyle2(status2) {
  return /* @__PURE__ */ css({
    position: "absolute",
    top: 0,
    left: 0,
    zIndex: theme.zIndex.high,
    width: "100%",
    height: "100%",
    background: theme.palette.grey100,
    opacity: [DrawerStatus.OPENING, DrawerStatus.OPENED].includes(status2) ? backgroundOpacity : 0,
    transition: "opacity linear ".concat(animationDuration, "ms"),
    "&:empty": {
      display: "block"
    }
  }, "", "", "", "");
};
var defaultDrawerStyle = function defaultDrawerStyle2(position2, status2) {
  return /* @__PURE__ */ css({
    left: position2 === POSITION_LEFT ? "0" : "unset",
    right: position2 === POSITION_RIGHT ? "0" : "unset",
    position: "absolute",
    zIndex: theme.zIndex.high,
    background: theme.palette.classic.white,
    borderRadius: theme.borderRadius.md,
    margin: spacings.xxl,
    width: "500px",
    height: "calc(100% - (".concat(spacings.xxl, ") * 2)"),
    padding: spacings.xxl,
    transition: "transform linear ".concat(animationDuration, "ms"),
    transform: "translateX(".concat([DrawerStatus.OPENING, DrawerStatus.OPENED].includes(status2) ? 0 : position2 === POSITION_LEFT ? -100 : 100, "%)"),
    display: "flex",
    flexDirection: "column"
  }, "", "", "", "");
};
var getParentElement = function getParentElement2(customParentId) {
  var parent = document.body;
  if (customParentId !== void 0) {
    var customParent = document.getElementById(customParentId);
    if (customParent !== null) {
      parent = customParent;
    }
  }
  return parent;
};
var Drawer = function Drawer2(_ref3) {
  var customParentId = _ref3.customParentId, onClose = _ref3.onClose, onClosed = _ref3.onClosed, onStatusChanged = _ref3.onStatusChanged, customDrawerStyle = _ref3.customDrawerStyle, customDrawerRootStyle = _ref3.customDrawerRootStyle, customMaskStyle = _ref3.customMaskStyle, _ref$display = _ref3.display, display = _ref$display === void 0 ? false : _ref$display, children = _ref3.children, _ref$position = _ref3.position, position2 = _ref$position === void 0 ? POSITION_RIGHT : _ref$position, id2 = _ref3.id;
  var contentNode = F$1(null);
  var _useState = p$1(display ? DrawerStatus.WILL_OPEN : DrawerStatus.CLOSED), _useState2 = _slicedToArray(_useState, 2), status2 = _useState2[0], setStatus = _useState2[1];
  _(function() {
    var timeout;
    if (display) {
      setStatus(DrawerStatus.WILL_OPEN);
      timeout = setTimeout(function() {
        return setStatus(DrawerStatus.OPENED);
      }, animationDuration);
    } else {
      setStatus(DrawerStatus.CLOSING);
      timeout = setTimeout(function() {
        return setStatus(DrawerStatus.CLOSED);
      }, animationDuration);
    }
    return function() {
      clearTimeout(timeout);
    };
  }, [display]);
  _(function() {
    var raf2;
    if (status2 === DrawerStatus.WILL_OPEN) raf2 = requestAnimationFrame(function() {
      return setStatus(DrawerStatus.OPENING);
    });
    if (status2 === DrawerStatus.CLOSED && onClosed !== void 0) onClosed();
    if (status2 === DrawerStatus.OPENING && contentNode.current !== null) contentNode.current.focus();
    if (onStatusChanged !== void 0) onStatusChanged(status2);
    return function() {
      if (raf2 !== void 0) cancelAnimationFrame(raf2);
    };
  }, [status2, onClosed, onStatusChanged]);
  var onKeyUp = x$2(function(event) {
    if (event.key === "Escape") onClose();
  }, [onClose]);
  var parent = getParentElement(customParentId);
  return /* @__PURE__ */ j(status2 !== DrawerStatus.CLOSED ? jsx$1("div", {
    css: [contentStyle(customParentId), customDrawerRootStyle, "", "", "", ""],
    ref: contentNode,
    role: "button",
    tabIndex: 0,
    onKeyUp
  }, jsx$1("div", {
    css: [maskStyle$1(status2), customMaskStyle, "", "", "", ""],
    onClick: onClose,
    role: "button",
    tabIndex: 0,
    onKeyUp
  }), jsx$1("div", {
    css: [defaultDrawerStyle(position2, status2), customDrawerStyle, "", "", "", ""],
    id: id2
  }, children)) : jsx$1(xn.Fragment, null), parent);
};
var timeoutRef = void 0;
var DEFAULT_DEBOUNCE_DELAY = 500;
var debounce = function debounce2(onDebounced) {
  var delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_DEBOUNCE_DELAY;
  if (timeoutRef !== void 0) {
    clearTimeout(timeoutRef);
  }
  timeoutRef = setTimeout(function() {
    onDebounced();
  }, delay);
};
var scrollToBottom = function scrollToBottom2(_ref3) {
  var containerRef = _ref3.containerRef, _ref$scrollBehavior = _ref3.scrollBehavior, scrollBehavior = _ref$scrollBehavior === void 0 ? "smooth" : _ref$scrollBehavior;
  setTimeout(function() {
    if (containerRef === null) {
      return;
    }
    containerRef.scrollIntoView({
      behavior: scrollBehavior
    });
  }, 0);
};
function listCacheClear$1() {
  this.__data__ = [];
  this.size = 0;
}
var _listCacheClear = listCacheClear$1;
function eq$3(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_1 = eq$3;
var eq$2 = eq_1;
function assocIndexOf$4(array, key) {
  var length2 = array.length;
  while (length2--) {
    if (eq$2(array[length2][0], key)) {
      return length2;
    }
  }
  return -1;
}
var _assocIndexOf = assocIndexOf$4;
var assocIndexOf$3 = _assocIndexOf;
var arrayProto = Array.prototype;
var splice$1 = arrayProto.splice;
function listCacheDelete$1(key) {
  var data = this.__data__, index2 = assocIndexOf$3(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice$1.call(data, index2, 1);
  }
  --this.size;
  return true;
}
var _listCacheDelete = listCacheDelete$1;
var assocIndexOf$2 = _assocIndexOf;
function listCacheGet$1(key) {
  var data = this.__data__, index2 = assocIndexOf$2(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
var _listCacheGet = listCacheGet$1;
var assocIndexOf$1 = _assocIndexOf;
function listCacheHas$1(key) {
  return assocIndexOf$1(this.__data__, key) > -1;
}
var _listCacheHas = listCacheHas$1;
var assocIndexOf = _assocIndexOf;
function listCacheSet$1(key, value) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
var _listCacheSet = listCacheSet$1;
var listCacheClear = _listCacheClear, listCacheDelete = _listCacheDelete, listCacheGet = _listCacheGet, listCacheHas = _listCacheHas, listCacheSet = _listCacheSet;
function ListCache$4(entries2) {
  var index2 = -1, length2 = entries2 == null ? 0 : entries2.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries2[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache$4.prototype.clear = listCacheClear;
ListCache$4.prototype["delete"] = listCacheDelete;
ListCache$4.prototype.get = listCacheGet;
ListCache$4.prototype.has = listCacheHas;
ListCache$4.prototype.set = listCacheSet;
var _ListCache = ListCache$4;
var ListCache$3 = _ListCache;
function stackClear$1() {
  this.__data__ = new ListCache$3();
  this.size = 0;
}
var _stackClear = stackClear$1;
function stackDelete$1(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
var _stackDelete = stackDelete$1;
function stackGet$1(key) {
  return this.__data__.get(key);
}
var _stackGet = stackGet$1;
function stackHas$1(key) {
  return this.__data__.has(key);
}
var _stackHas = stackHas$1;
var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$1;
var freeGlobal = _freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$b = freeGlobal || freeSelf || Function("return this")();
var _root = root$b;
var root$a = _root;
var Symbol$5 = root$a.Symbol;
var _Symbol = Symbol$5;
var Symbol$4 = _Symbol;
var objectProto$d = Object.prototype;
var hasOwnProperty$c = objectProto$d.hasOwnProperty;
var nativeObjectToString$1 = objectProto$d.toString;
var symToStringTag$1 = Symbol$4 ? Symbol$4.toStringTag : void 0;
function getRawTag$1(value) {
  var isOwn = hasOwnProperty$c.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e2) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var _getRawTag = getRawTag$1;
var objectProto$c = Object.prototype;
var nativeObjectToString = objectProto$c.toString;
function objectToString$1(value) {
  return nativeObjectToString.call(value);
}
var _objectToString = objectToString$1;
var Symbol$3 = _Symbol, getRawTag = _getRawTag, objectToString = _objectToString;
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$3 ? Symbol$3.toStringTag : void 0;
function baseGetTag$5(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
var _baseGetTag = baseGetTag$5;
function isObject$6(value) {
  var type2 = typeof value;
  return value != null && (type2 == "object" || type2 == "function");
}
var isObject_1 = isObject$6;
var baseGetTag$4 = _baseGetTag, isObject$5 = isObject_1;
var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$3(value) {
  if (!isObject$5(value)) {
    return false;
  }
  var tag = baseGetTag$4(value);
  return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_1 = isFunction$3;
var root$9 = _root;
var coreJsData$1 = root$9["__core-js_shared__"];
var _coreJsData = coreJsData$1;
var coreJsData = _coreJsData;
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked$1(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var _isMasked = isMasked$1;
var funcProto$1 = Function.prototype;
var funcToString$1 = funcProto$1.toString;
function toSource$2(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e2) {
    }
    try {
      return func + "";
    } catch (e2) {
    }
  }
  return "";
}
var _toSource = toSource$2;
var isFunction$2 = isFunction_1, isMasked = _isMasked, isObject$4 = isObject_1, toSource$1 = _toSource;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto = Function.prototype, objectProto$b = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$b = objectProto$b.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString.call(hasOwnProperty$b).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative$1(value) {
  if (!isObject$4(value) || isMasked(value)) {
    return false;
  }
  var pattern2 = isFunction$2(value) ? reIsNative : reIsHostCtor;
  return pattern2.test(toSource$1(value));
}
var _baseIsNative = baseIsNative$1;
function getValue$1(object, key) {
  return object == null ? void 0 : object[key];
}
var _getValue = getValue$1;
var baseIsNative = _baseIsNative, getValue = _getValue;
function getNative$7(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : void 0;
}
var _getNative = getNative$7;
var getNative$6 = _getNative, root$8 = _root;
var Map$4 = getNative$6(root$8, "Map");
var _Map = Map$4;
var getNative$5 = _getNative;
var nativeCreate$4 = getNative$5(Object, "create");
var _nativeCreate = nativeCreate$4;
var nativeCreate$3 = _nativeCreate;
function hashClear$1() {
  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
  this.size = 0;
}
var _hashClear = hashClear$1;
function hashDelete$1(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var _hashDelete = hashDelete$1;
var nativeCreate$2 = _nativeCreate;
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var objectProto$a = Object.prototype;
var hasOwnProperty$a = objectProto$a.hasOwnProperty;
function hashGet$1(key) {
  var data = this.__data__;
  if (nativeCreate$2) {
    var result = data[key];
    return result === HASH_UNDEFINED$2 ? void 0 : result;
  }
  return hasOwnProperty$a.call(data, key) ? data[key] : void 0;
}
var _hashGet = hashGet$1;
var nativeCreate$1 = _nativeCreate;
var objectProto$9 = Object.prototype;
var hasOwnProperty$9 = objectProto$9.hasOwnProperty;
function hashHas$1(key) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$9.call(data, key);
}
var _hashHas = hashHas$1;
var nativeCreate = _nativeCreate;
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet$1(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
  return this;
}
var _hashSet = hashSet$1;
var hashClear = _hashClear, hashDelete = _hashDelete, hashGet = _hashGet, hashHas = _hashHas, hashSet = _hashSet;
function Hash$1(entries2) {
  var index2 = -1, length2 = entries2 == null ? 0 : entries2.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries2[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash$1.prototype.clear = hashClear;
Hash$1.prototype["delete"] = hashDelete;
Hash$1.prototype.get = hashGet;
Hash$1.prototype.has = hashHas;
Hash$1.prototype.set = hashSet;
var _Hash = Hash$1;
var Hash = _Hash, ListCache$2 = _ListCache, Map$3 = _Map;
function mapCacheClear$1() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$3 || ListCache$2)(),
    "string": new Hash()
  };
}
var _mapCacheClear = mapCacheClear$1;
function isKeyable$1(value) {
  var type2 = typeof value;
  return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
}
var _isKeyable = isKeyable$1;
var isKeyable = _isKeyable;
function getMapData$4(map2, key) {
  var data = map2.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var _getMapData = getMapData$4;
var getMapData$3 = _getMapData;
function mapCacheDelete$1(key) {
  var result = getMapData$3(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var _mapCacheDelete = mapCacheDelete$1;
var getMapData$2 = _getMapData;
function mapCacheGet$1(key) {
  return getMapData$2(this, key).get(key);
}
var _mapCacheGet = mapCacheGet$1;
var getMapData$1 = _getMapData;
function mapCacheHas$1(key) {
  return getMapData$1(this, key).has(key);
}
var _mapCacheHas = mapCacheHas$1;
var getMapData = _getMapData;
function mapCacheSet$1(key, value) {
  var data = getMapData(this, key), size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
var _mapCacheSet = mapCacheSet$1;
var mapCacheClear = _mapCacheClear, mapCacheDelete = _mapCacheDelete, mapCacheGet = _mapCacheGet, mapCacheHas = _mapCacheHas, mapCacheSet = _mapCacheSet;
function MapCache$3(entries2) {
  var index2 = -1, length2 = entries2 == null ? 0 : entries2.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries2[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache$3.prototype.clear = mapCacheClear;
MapCache$3.prototype["delete"] = mapCacheDelete;
MapCache$3.prototype.get = mapCacheGet;
MapCache$3.prototype.has = mapCacheHas;
MapCache$3.prototype.set = mapCacheSet;
var _MapCache = MapCache$3;
var ListCache$1 = _ListCache, Map$2 = _Map, MapCache$2 = _MapCache;
var LARGE_ARRAY_SIZE = 200;
function stackSet$1(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache$1) {
    var pairs = data.__data__;
    if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache$2(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
var _stackSet = stackSet$1;
var ListCache = _ListCache, stackClear = _stackClear, stackDelete = _stackDelete, stackGet = _stackGet, stackHas = _stackHas, stackSet = _stackSet;
function Stack$2(entries2) {
  var data = this.__data__ = new ListCache(entries2);
  this.size = data.size;
}
Stack$2.prototype.clear = stackClear;
Stack$2.prototype["delete"] = stackDelete;
Stack$2.prototype.get = stackGet;
Stack$2.prototype.has = stackHas;
Stack$2.prototype.set = stackSet;
var _Stack = Stack$2;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd$1(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}
var _setCacheAdd = setCacheAdd$1;
function setCacheHas$1(value) {
  return this.__data__.has(value);
}
var _setCacheHas = setCacheHas$1;
var MapCache$1 = _MapCache, setCacheAdd = _setCacheAdd, setCacheHas = _setCacheHas;
function SetCache$1(values) {
  var index2 = -1, length2 = values == null ? 0 : values.length;
  this.__data__ = new MapCache$1();
  while (++index2 < length2) {
    this.add(values[index2]);
  }
}
SetCache$1.prototype.add = SetCache$1.prototype.push = setCacheAdd;
SetCache$1.prototype.has = setCacheHas;
var _SetCache = SetCache$1;
function arraySome$1(array, predicate) {
  var index2 = -1, length2 = array == null ? 0 : array.length;
  while (++index2 < length2) {
    if (predicate(array[index2], index2, array)) {
      return true;
    }
  }
  return false;
}
var _arraySome = arraySome$1;
function cacheHas$1(cache, key) {
  return cache.has(key);
}
var _cacheHas = cacheHas$1;
var SetCache = _SetCache, arraySome = _arraySome, cacheHas = _cacheHas;
var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
function equalArrays$2(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
  stack.set(array, other);
  stack.set(other, array);
  while (++index2 < arrLength) {
    var arrValue = array[index2], othValue = other[index2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome(other, function(othValue2, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array);
  stack["delete"](other);
  return result;
}
var _equalArrays = equalArrays$2;
var root$7 = _root;
var Uint8Array$2 = root$7.Uint8Array;
var _Uint8Array = Uint8Array$2;
function mapToArray$1(map2) {
  var index2 = -1, result = Array(map2.size);
  map2.forEach(function(value, key) {
    result[++index2] = [key, value];
  });
  return result;
}
var _mapToArray = mapToArray$1;
function setToArray$1(set) {
  var index2 = -1, result = Array(set.size);
  set.forEach(function(value) {
    result[++index2] = value;
  });
  return result;
}
var _setToArray = setToArray$1;
var Symbol$2 = _Symbol, Uint8Array$1 = _Uint8Array, eq$1 = eq_1, equalArrays$1 = _equalArrays, mapToArray = _mapToArray, setToArray = _setToArray;
var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
var boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]";
var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : void 0;
function equalByTag$1(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag$2:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag$1:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {
        return false;
      }
      return true;
    case boolTag$1:
    case dateTag$1:
    case numberTag$1:
      return eq$1(+object, +other);
    case errorTag$1:
      return object.name == other.name && object.message == other.message;
    case regexpTag$1:
    case stringTag$1:
      return object == other + "";
    case mapTag$2:
      var convert2 = mapToArray;
    case setTag$2:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
      convert2 || (convert2 = setToArray);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$2;
      stack.set(object, other);
      var result = equalArrays$1(convert2(object), convert2(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object);
      return result;
    case symbolTag$1:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}
var _equalByTag = equalByTag$1;
function arrayPush$3(array, values) {
  var index2 = -1, length2 = values.length, offset = array.length;
  while (++index2 < length2) {
    array[offset + index2] = values[index2];
  }
  return array;
}
var _arrayPush = arrayPush$3;
var isArray$a = Array.isArray;
var isArray_1 = isArray$a;
var arrayPush$2 = _arrayPush, isArray$9 = isArray_1;
function baseGetAllKeys$1(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray$9(object) ? result : arrayPush$2(result, symbolsFunc(object));
}
var _baseGetAllKeys = baseGetAllKeys$1;
function arrayFilter$1(array, predicate) {
  var index2 = -1, length2 = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index2 < length2) {
    var value = array[index2];
    if (predicate(value, index2, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
var _arrayFilter = arrayFilter$1;
function stubArray$2() {
  return [];
}
var stubArray_1 = stubArray$2;
var arrayFilter = _arrayFilter, stubArray$1 = stubArray_1;
var objectProto$8 = Object.prototype;
var propertyIsEnumerable$1 = objectProto$8.propertyIsEnumerable;
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
var getSymbols$1 = !nativeGetSymbols$1 ? stubArray$1 : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
    return propertyIsEnumerable$1.call(object, symbol);
  });
};
var _getSymbols = getSymbols$1;
function baseTimes$1(n2, iteratee) {
  var index2 = -1, result = Array(n2);
  while (++index2 < n2) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var _baseTimes = baseTimes$1;
function isObjectLike$5(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_1 = isObjectLike$5;
var baseGetTag$3 = _baseGetTag, isObjectLike$4 = isObjectLike_1;
var argsTag$2 = "[object Arguments]";
function baseIsArguments$1(value) {
  return isObjectLike$4(value) && baseGetTag$3(value) == argsTag$2;
}
var _baseIsArguments = baseIsArguments$1;
var baseIsArguments = _baseIsArguments, isObjectLike$3 = isObjectLike_1;
var objectProto$7 = Object.prototype;
var hasOwnProperty$8 = objectProto$7.hasOwnProperty;
var propertyIsEnumerable = objectProto$7.propertyIsEnumerable;
var isArguments$2 = baseIsArguments(/* @__PURE__ */ function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike$3(value) && hasOwnProperty$8.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
};
var isArguments_1 = isArguments$2;
var isBuffer$3 = { exports: {} };
function stubFalse() {
  return false;
}
var stubFalse_1 = stubFalse;
isBuffer$3.exports;
(function(module, exports) {
  var root2 = _root, stubFalse2 = stubFalse_1;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root2.Buffer : void 0;
  var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
  var isBuffer2 = nativeIsBuffer || stubFalse2;
  module.exports = isBuffer2;
})(isBuffer$3, isBuffer$3.exports);
var isBufferExports = isBuffer$3.exports;
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex$3(value, length2) {
  var type2 = typeof value;
  length2 = length2 == null ? MAX_SAFE_INTEGER$1 : length2;
  return !!length2 && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
}
var _isIndex = isIndex$3;
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength$3(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
var isLength_1 = isLength$3;
var baseGetTag$2 = _baseGetTag, isLength$2 = isLength_1, isObjectLike$2 = isObjectLike_1;
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag$1 = "[object Map]", numberTag = "[object Number]", objectTag$2 = "[object Object]", regexpTag = "[object RegExp]", setTag$1 = "[object Set]", stringTag = "[object String]", weakMapTag$1 = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag$1] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag$1] = typedArrayTags[numberTag] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag] = typedArrayTags[setTag$1] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag$1] = false;
function baseIsTypedArray$1(value) {
  return isObjectLike$2(value) && isLength$2(value.length) && !!typedArrayTags[baseGetTag$2(value)];
}
var _baseIsTypedArray = baseIsTypedArray$1;
function baseUnary$1(func) {
  return function(value) {
    return func(value);
  };
}
var _baseUnary = baseUnary$1;
var _nodeUtil = { exports: {} };
_nodeUtil.exports;
(function(module, exports) {
  var freeGlobal2 = _freeGlobal;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil2 = function() {
    try {
      var types2 = freeModule && freeModule.require && freeModule.require("util").types;
      if (types2) {
        return types2;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e2) {
    }
  }();
  module.exports = nodeUtil2;
})(_nodeUtil, _nodeUtil.exports);
var _nodeUtilExports = _nodeUtil.exports;
var baseIsTypedArray = _baseIsTypedArray, baseUnary = _baseUnary, nodeUtil = _nodeUtilExports;
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
var isTypedArray$3 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray_1 = isTypedArray$3;
var baseTimes = _baseTimes, isArguments$1 = isArguments_1, isArray$8 = isArray_1, isBuffer$2 = isBufferExports, isIndex$2 = _isIndex, isTypedArray$2 = isTypedArray_1;
var objectProto$6 = Object.prototype;
var hasOwnProperty$7 = objectProto$6.hasOwnProperty;
function arrayLikeKeys$2(value, inherited) {
  var isArr = isArray$8(value), isArg = !isArr && isArguments$1(value), isBuff = !isArr && !isArg && isBuffer$2(value), isType = !isArr && !isArg && !isBuff && isTypedArray$2(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$7.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex$2(key, length2)))) {
      result.push(key);
    }
  }
  return result;
}
var _arrayLikeKeys = arrayLikeKeys$2;
var objectProto$5 = Object.prototype;
function isPrototype$2(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$5;
  return value === proto;
}
var _isPrototype = isPrototype$2;
function overArg$2(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var _overArg = overArg$2;
var overArg$1 = _overArg;
var nativeKeys$1 = overArg$1(Object.keys, Object);
var _nativeKeys = nativeKeys$1;
var isPrototype$1 = _isPrototype, nativeKeys = _nativeKeys;
var objectProto$4 = Object.prototype;
var hasOwnProperty$6 = objectProto$4.hasOwnProperty;
function baseKeys$1(object) {
  if (!isPrototype$1(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$6.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
var _baseKeys = baseKeys$1;
var isFunction$1 = isFunction_1, isLength$1 = isLength_1;
function isArrayLike$2(value) {
  return value != null && isLength$1(value.length) && !isFunction$1(value);
}
var isArrayLike_1 = isArrayLike$2;
var arrayLikeKeys$1 = _arrayLikeKeys, baseKeys = _baseKeys, isArrayLike$1 = isArrayLike_1;
function keys$2(object) {
  return isArrayLike$1(object) ? arrayLikeKeys$1(object) : baseKeys(object);
}
var keys_1 = keys$2;
var _getAllKeys;
var hasRequired_getAllKeys;
function require_getAllKeys() {
  if (hasRequired_getAllKeys) return _getAllKeys;
  hasRequired_getAllKeys = 1;
  var baseGetAllKeys2 = _baseGetAllKeys, getSymbols2 = _getSymbols, keys2 = keys_1;
  function getAllKeys2(object) {
    return baseGetAllKeys2(object, keys2, getSymbols2);
  }
  _getAllKeys = getAllKeys2;
  return _getAllKeys;
}
var getAllKeys = require_getAllKeys();
var COMPARE_PARTIAL_FLAG$3 = 1;
var objectProto$3 = Object.prototype;
var hasOwnProperty$5 = objectProto$3.hasOwnProperty;
function equalObjects$1(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index2 = objLength;
  while (index2--) {
    var key = objProps[index2];
    if (!(isPartial ? key in other : hasOwnProperty$5.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;
  while (++index2 < objLength) {
    key = objProps[index2];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object);
  stack["delete"](other);
  return result;
}
var _equalObjects = equalObjects$1;
var getNative$4 = _getNative, root$6 = _root;
var DataView$1 = getNative$4(root$6, "DataView");
var _DataView = DataView$1;
var getNative$3 = _getNative, root$5 = _root;
var Promise$2 = getNative$3(root$5, "Promise");
var _Promise = Promise$2;
var getNative$2 = _getNative, root$4 = _root;
var Set$2 = getNative$2(root$4, "Set");
var _Set = Set$2;
var getNative$1 = _getNative, root$3 = _root;
var WeakMap$2 = getNative$1(root$3, "WeakMap");
var _WeakMap = WeakMap$2;
var DataView = _DataView, Map$1 = _Map, Promise$1 = _Promise, Set$1 = _Set, WeakMap$1 = _WeakMap, baseGetTag$1 = _baseGetTag, toSource = _toSource;
var mapTag = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag = "[object Set]", weakMapTag = "[object WeakMap]";
var dataViewTag = "[object DataView]";
var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1);
var getTag$1 = baseGetTag$1;
if (DataView && getTag$1(new DataView(new ArrayBuffer(1))) != dataViewTag || Map$1 && getTag$1(new Map$1()) != mapTag || Promise$1 && getTag$1(Promise$1.resolve()) != promiseTag || Set$1 && getTag$1(new Set$1()) != setTag || WeakMap$1 && getTag$1(new WeakMap$1()) != weakMapTag) {
  getTag$1 = function(value) {
    var result = baseGetTag$1(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag;
        case mapCtorString:
          return mapTag;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag;
        case weakMapCtorString:
          return weakMapTag;
      }
    }
    return result;
  };
}
var _getTag = getTag$1;
var Stack$1 = _Stack, equalArrays = _equalArrays, equalByTag = _equalByTag, equalObjects = _equalObjects, getTag = _getTag, isArray$7 = isArray_1, isBuffer$1 = isBufferExports, isTypedArray$1 = isTypedArray_1;
var COMPARE_PARTIAL_FLAG$2 = 1;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
var objectProto$2 = Object.prototype;
var hasOwnProperty$4 = objectProto$2.hasOwnProperty;
function baseIsEqualDeep$1(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray$7(object), othIsArr = isArray$7(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer$1(object)) {
    if (!isBuffer$1(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack$1());
    return objIsArr || isTypedArray$1(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
    var objIsWrapped = objIsObj && hasOwnProperty$4.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$4.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack$1());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack$1());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}
var _baseIsEqualDeep = baseIsEqualDeep$1;
var baseIsEqualDeep = _baseIsEqualDeep, isObjectLike$1 = isObjectLike_1;
function baseIsEqual$2(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike$1(value) && !isObjectLike$1(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual$2, stack);
}
var _baseIsEqual = baseIsEqual$2;
var TEXTAREA_STATES_STYLES = {
  "default": {
    border: "1px solid ".concat(theme.palette.grey300),
    shadow: theme.shadow.xs,
    background: theme.palette.classic.white,
    borderRadius: theme.borderRadius.md
  },
  hover: {
    border: "1px solid ".concat(theme.palette.grey400),
    shadow: theme.shadow.xs,
    background: theme.palette.classic.white,
    borderRadius: theme.borderRadius.md
  },
  focus: {
    border: "1px solid ".concat(theme.palette.purple600),
    shadow: theme.shadow.selected,
    background: theme.palette.classic.white,
    borderRadius: theme.borderRadius.md
  },
  disabled: {
    border: "1px solid ".concat(theme.palette.grey300),
    shadow: theme.shadow.xs,
    background: theme.palette.grey100,
    borderRadius: theme.borderRadius.md
  },
  error: {
    border: "1px solid ".concat(theme.palette.red600),
    shadow: theme.shadow.error,
    background: theme.palette.grey100,
    borderRadius: theme.borderRadius.md
  }
};
var defaultTextareaStyle = /* @__PURE__ */ css({
  resize: "none",
  color: theme.palette.classic.black,
  fontSize: theme.typography.body2.fontSize,
  fontWeight: theme.typography.body1.fontWeight,
  fontFamily: theme.typography.fontFamily,
  lineHeight: theme.typography.body2.lineHeight,
  padding: "".concat(spacings.sm, " ").concat(spacings.lg),
  outline: "unset",
  width: "100%",
  boxSizing: "border-box",
  height: "100%",
  border: TEXTAREA_STATES_STYLES["default"].border,
  borderRadius: TEXTAREA_STATES_STYLES["default"].borderRadius,
  boxShadow: TEXTAREA_STATES_STYLES["default"].shadow,
  "&::placeholder": {
    fontWeight: theme.typography.body2.fontWeight
  },
  "&:hover": {
    border: TEXTAREA_STATES_STYLES.hover.border,
    borderRadius: TEXTAREA_STATES_STYLES.hover.borderRadius,
    boxShadow: TEXTAREA_STATES_STYLES.hover.shadow
  },
  "&:focus": {
    border: TEXTAREA_STATES_STYLES.focus.border,
    borderRadius: TEXTAREA_STATES_STYLES.focus.borderRadius,
    boxShadow: TEXTAREA_STATES_STYLES.focus.shadow
  },
  "&:disabled": {
    border: TEXTAREA_STATES_STYLES.disabled.border,
    borderRadius: TEXTAREA_STATES_STYLES.disabled.borderRadius,
    boxShadow: TEXTAREA_STATES_STYLES.disabled.shadow
  }
}, "", "", "", "");
var textareaErrorStyle = /* @__PURE__ */ css({
  border: TEXTAREA_STATES_STYLES.error.border,
  borderRadius: TEXTAREA_STATES_STYLES.error.borderRadius,
  boxShadow: TEXTAREA_STATES_STYLES.error.shadow
}, "", "", "", "");
var _ref$5 = {
  name: "0",
  styles: ""
};
var Textarea = /* @__PURE__ */ N(function(_ref22, ref2) {
  var id2 = _ref22.id, name2 = _ref22.name, value = _ref22.value, placeholder = _ref22.placeholder, textAreaCustomCss = _ref22.textAreaCustomCss, customCss = _ref22.customCss, error2 = _ref22.error, onChange = _ref22.onChange, onFocus = _ref22.onFocus, _onKeyDown = _ref22.onKeyDown, disabled = _ref22.disabled, onBlur = _ref22.onBlur, enableDynamicHeight = _ref22.enableDynamicHeight, debounce$1 = _ref22.debounce, debounceDelay = _ref22.debounceDelay, label = _ref22.label;
  var _useState = p$1(value !== null && value !== void 0 ? value : ""), _useState2 = _slicedToArray(_useState, 2), currentValue = _useState2[0], setCurrentValue = _useState2[1];
  var textAreaRef = useForwardRef(ref2);
  var setDynamicHeight = x$2(function() {
    if (textAreaRef.current !== null && enableDynamicHeight === true) {
      textAreaRef.current.style.height = "0px";
      textAreaRef.current.style.height = "".concat(textAreaRef.current.scrollHeight, "px");
    }
  }, [enableDynamicHeight, textAreaRef]);
  var resetDynamicHeight = x$2(function() {
    if (textAreaRef.current !== null) {
      textAreaRef.current.style.height = "0px";
    }
  }, [textAreaRef]);
  var handleChange = function handleChange2(event) {
    var target = event.target;
    setCurrentValue(target.value);
    setDynamicHeight();
    if (debounce$1 === true) {
      debounce(function() {
        return onChange(event);
      }, debounceDelay);
      return;
    }
    onChange(event);
  };
  _(function() {
    var _ref3, _textAreaRef$current;
    setCurrentValue((_ref3 = value !== null && value !== void 0 ? value : (_textAreaRef$current = textAreaRef.current) === null || _textAreaRef$current === void 0 ? void 0 : _textAreaRef$current.value) !== null && _ref3 !== void 0 ? _ref3 : "");
    if ((value === null || value === void 0 ? void 0 : value.length) === 0) {
      resetDynamicHeight();
    } else {
      setDynamicHeight();
    }
  }, [resetDynamicHeight, setDynamicHeight, textAreaRef, value]);
  return jsx$1("div", {
    css: /* @__PURE__ */ css([{
      display: "flex",
      flexDirection: "column",
      width: "100%",
      gap: spacings.sm
    }, customCss], "", "", "", "")
  }, label !== void 0 && jsx$1(Typography, {
    variant: "sm-md"
  }, label), jsx$1("textarea", {
    disabled,
    onKeyDown: function onKeyDown(event) {
      return _onKeyDown === null || _onKeyDown === void 0 ? void 0 : _onKeyDown(event);
    },
    name: name2,
    value: currentValue,
    placeholder,
    css: [defaultTextareaStyle, error2 !== void 0 ? textareaErrorStyle : _ref$5, textAreaCustomCss, "", "", "", ""],
    ref: textAreaRef,
    id: id2,
    onChange: handleChange,
    onFocus,
    onBlur
  }), error2 !== void 0 && jsx$1(Typography, {
    variant: "sm-md",
    customCss: /* @__PURE__ */ css({
      color: theme.palette.red600,
      marginTop: spacings.sm,
      display: "block"
    }, "", "", "", "")
  }, error2));
});
var ClassicHeader = function ClassicHeader2(_ref3) {
  var name2 = _ref3.name, value = _ref3.value;
  return jsx$1("div", {
    css: /* @__PURE__ */ css({
      justifyContent: "space-between",
      gap: spacings.sm,
      display: "flex",
      alignItems: "center",
      width: "100%"
    }, "", "", "", "")
  }, jsx$1(Typography, {
    variant: "sm-md"
  }, name2), jsx$1("div", {
    css: /* @__PURE__ */ css({
      gap: spacings.sm,
      display: "flex",
      alignItems: "center"
    }, "", "", "", "")
  }, jsx$1(Typography, {
    variant: "sm-reg"
  }, value), jsx$1(SelectorIcon, null)));
};
var CompactHeader = function CompactHeader2(_ref3) {
  var value = _ref3.value;
  return jsx$1("div", {
    css: /* @__PURE__ */ css({
      gap: spacings.sm,
      display: "flex",
      alignItems: "center",
      width: "100%",
      justifyContent: "space-between"
    }, "", "", "", "")
  }, jsx$1(Typography, {
    variant: "sm-reg"
  }, value), jsx$1(CarretDownIcon, {
    color: theme.palette.grey200
  }));
};
var defaultSelectHeaderStyle = /* @__PURE__ */ css({
  display: "flex",
  justifyContent: "space-between",
  width: "100%",
  height: "100%",
  alignItems: "center",
  cursor: "pointer",
  paddingBottom: spacings.md,
  borderBottom: "1px solid ".concat(theme.palette.grey150)
}, "", "", "", "");
var defaultCompactSelectHeaderStyle = /* @__PURE__ */ css({
  display: "flex",
  justifyContent: "space-between",
  width: "100%",
  height: "100%",
  alignItems: "center",
  cursor: "pointer",
  padding: "".concat(spacings.xs, " ").concat(spacings.sm),
  borderRadius: theme.borderRadius.md,
  background: theme.palette.classic.white,
  border: "1px solid ".concat(theme.palette.grey200)
}, "", "", "", "");
var getCurrentValue = function getCurrentValue2(options, selectedValue) {
  return selectedValue !== void 0 ? options.find(function(opt) {
    return opt.value === selectedValue;
  }) : options[0];
};
var _ref$4 = {
  name: "6vuwgd",
  styles: "opacity:0;position:absolute;top:0;left:0;width:100%;height:100%"
};
var _ref2$1 = {
  name: "pw7jst",
  styles: "position:relative;width:100%"
};
var ClassicSelect = function ClassicSelect2(_ref3) {
  var _currentValue$label, _currentValue$label2;
  var _ref3$enableCompactMo = _ref3.enableCompactMode, enableCompactMode = _ref3$enableCompactMo === void 0 ? false : _ref3$enableCompactMo, customContainerStyle = _ref3.customContainerStyle, id2 = _ref3.id, options = _ref3.options, name2 = _ref3.name, onChange = _ref3.onChange, selectedValue = _ref3.selectedValue;
  var _useState = p$1(getCurrentValue(options, selectedValue)), _useState2 = _slicedToArray(_useState, 2), currentValue = _useState2[0], setCurrentValue = _useState2[1];
  var handleOnChange = function handleOnChange2(event) {
    event.stopPropagation();
    setCurrentValue(getCurrentValue(options, event.target.value));
    onChange === null || onChange === void 0 || onChange(event.target.value);
  };
  return jsx$1("div", {
    css: [_ref2$1, customContainerStyle, "", "", "", ""]
  }, jsx$1("div", {
    css: enableCompactMode ? defaultCompactSelectHeaderStyle : defaultSelectHeaderStyle
  }, enableCompactMode ? jsx$1(CompactHeader, {
    value: (_currentValue$label = currentValue === null || currentValue === void 0 ? void 0 : currentValue.label) !== null && _currentValue$label !== void 0 ? _currentValue$label : ""
  }) : jsx$1(ClassicHeader, {
    name: name2,
    value: (_currentValue$label2 = currentValue === null || currentValue === void 0 ? void 0 : currentValue.label) !== null && _currentValue$label2 !== void 0 ? _currentValue$label2 : ""
  })), jsx$1("select", {
    id: id2,
    name: name2,
    onChange: handleOnChange,
    css: _ref$4
  }, options.map(function(_ref4) {
    var label = _ref4.label, value = _ref4.value;
    return jsx$1("option", {
      key: "select-option-".concat(id2, "-").concat(value),
      value,
      selected: (currentValue === null || currentValue === void 0 ? void 0 : currentValue.value) === value
    }, label);
  })));
};
var _ref$3 = {
  name: "18o260q",
  styles: "cursor:pointer;&:empty{display:block;}"
};
var DivClickable = /* @__PURE__ */ N(function(_ref22, ref2) {
  var onClick = _ref22.onClick, children = _ref22.children, customCss = _ref22.customCss;
  var divClickableRef = useForwardRef(ref2);
  return jsx$1("div", {
    ref: divClickableRef,
    role: "button",
    tabIndex: 0,
    onClick,
    onKeyPress: function onKeyPress(event) {
      if (event.key === "Enter") {
        onClick(event);
      }
    },
    css: [_ref$3, customCss, "", "", "", ""]
  }, children);
});
var _templateObject$1;
var rotate$1 = keyframes(_templateObject$1 || (_templateObject$1 = _taggedTemplateLiteral(["\n  0% {\n    transform: rotate(0deg);\n  }\n\n  100% {\n    transform: rotate(360deg);\n  }\n"])));
var animatedLoaderStyle = /* @__PURE__ */ css({
  animation: "".concat(rotate$1, " 0.66s linear infinite")
}, "", "", "", "");
var _ref$2 = {
  name: "1ejd82u",
  styles: "height:100%;display:flex;justify-content:center;align-items:center;flex-direction:column"
};
var PageLoader = function PageLoader2(_ref22) {
  var customCss = _ref22.customCss;
  return jsx$1("div", {
    css: [_ref$2, customCss, "", "", "", ""]
  }, jsx$1("div", null, jsx$1(SpinnerIcon, {
    color: theme.palette.purple600,
    customCss: animatedLoaderStyle
  })));
};
var _ref$1 = {
  name: "1q6lzqz",
  styles: "width:36px;height:12px"
};
var _ref2 = {
  name: "ot4ncn",
  styles: "font-size:10px"
};
var PoweredByDialog = function PoweredByDialog2() {
  return jsx$1("a", {
    target: "_blank",
    href: "https://www.askdialog.com",
    css: [
      /* @__PURE__ */ css(_defineProperty$1({
        textDecoration: "unset",
        display: "flex",
        justifyContent: "center",
        gap: spacings.xs,
        alignItems: "center",
        cursor: "pointer",
        "&:hover": {
          transition: "all linear 0.1s",
          transform: "scale(1.04)"
        }
      }, "@media screen and (max-width: ".concat(TABLET_BP, ")"), {
        padding: 0
      }), "", "", "", ""),
      "",
      "",
      "",
      ""
    ],
    rel: "noreferrer"
  }, jsx$1(Typography, {
    variant: "xs-md",
    color: theme.palette.grey400,
    customCss: _ref2
  }, "Powered By"), jsx$1(Dialog, {
    customCss: _ref$1,
    color: theme.palette.grey400
  }));
};
var DEFAULT_BLUR_WIDTH = 100;
var commonButtonStyle = /* @__PURE__ */ css(_defineProperty$1({
  borderRadius: "100%",
  zIndex: theme.zIndex.highest
}, "@media screen and (max-width: ".concat(TABLET_BP, ")"), {
  display: "none"
}), "", "", "", "");
var blurStyle = function blurStyle2(displayButtons) {
  var blurWidth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_BLUR_WIDTH;
  return /* @__PURE__ */ css({
    "&::before": {
      display: displayButtons.left ? "block" : "none",
      left: 0,
      background: "linear-gradient(90deg, rgb(255 255 255 / 100%) 0%, rgb(255 255 255 / 0%) 100%) ;"
    },
    "&::after": {
      display: displayButtons.right ? "block" : "none",
      right: 0,
      background: "linear-gradient(90deg, rgb(255 255 255 / 0%) 0%, #FFF 100%)"
    },
    "&::before, &::after": _defineProperty$1({
      content: "' '",
      position: "absolute",
      zIndex: theme.zIndex.high,
      width: "".concat(blurWidth, "px"),
      height: "100%"
    }, "@media screen and (max-width: ".concat(TABLET_BP, ")"), {
      display: "none"
    })
  }, "", "", "", "");
};
var DEFAULT_SCROLL_PERCENTAGE = 25;
var BUTTON_WIDTH = 36;
var _ref = {
  name: "1dbubah",
  styles: "display:flex;align-items:center;position:relative"
};
var ScrollContainer = function ScrollContainer2(_ref22) {
  var _containerRef$current, _containerRef$current2, _containerRef$current3, _containerRef$current4;
  var scrollType = _ref22.scrollType, children = _ref22.children, _ref2$scrollPercentag = _ref22.scrollPercentage, scrollPercentage = _ref2$scrollPercentag === void 0 ? DEFAULT_SCROLL_PERCENTAGE : _ref2$scrollPercentag, customContainerStyle = _ref22.customContainerStyle, _ref2$marginSideButto = _ref22.marginSideButton, marginSideButton = _ref2$marginSideButto === void 0 ? 0 : _ref2$marginSideButto, blurWidth = _ref22.blurWidth;
  var containerRef = F$1(null);
  var _useState = p$1({
    left: false,
    right: false
  }), _useState2 = _slicedToArray(_useState, 2), displayButtons = _useState2[0], setDisplayButtons = _useState2[1];
  var handleScroll = x$2(function() {
    if (containerRef.current === null) return;
    var maxScroll = containerRef.current.scrollWidth - containerRef.current.clientWidth;
    var scrollLeft = Math.floor(containerRef.current.scrollLeft);
    setDisplayButtons({
      right: scrollLeft < maxScroll,
      left: scrollLeft > 0
    });
  }, []);
  var scrollByDirectionWithPercentage = function scrollByDirectionWithPercentage2(direction) {
    if (containerRef.current === null) return;
    var scrollAmountInPx = containerRef.current.scrollWidth * scrollPercentage / 100;
    var maxScrollPosition = Math.round(containerRef.current.scrollWidth - containerRef.current.clientWidth);
    var currentScrollLeft = containerRef.current.scrollLeft;
    var newScrollPosition = direction === "left" ? currentScrollLeft - scrollAmountInPx : currentScrollLeft + scrollAmountInPx;
    var newScrollLeft = newScrollPosition < 0 ? 0 : newScrollPosition > maxScrollPosition ? maxScrollPosition : newScrollPosition;
    containerRef.current.scroll({
      left: newScrollLeft
    });
  };
  var scrollByDirectionWithFullWidth = function scrollByDirectionWithFullWidth2(direction) {
    if (containerRef.current === null) return;
    containerRef.current.scroll({
      left: direction === "left" ? 0 : containerRef.current.scrollWidth
    });
  };
  _(function() {
    if (containerRef.current === null) return;
    var saveRef = containerRef.current;
    containerRef.current.addEventListener("scroll", handleScroll);
    return function() {
      saveRef.removeEventListener("scroll", handleScroll);
    };
  }, [handleScroll, containerRef]);
  _(function() {
    if (containerRef.current === null) return;
    var enableScroll2 = containerRef.current.scrollWidth > containerRef.current.clientWidth;
    setDisplayButtons({
      left: false,
      right: enableScroll2
    });
  }, [containerRef]);
  var handleScrolling = scrollType === "full" ? scrollByDirectionWithFullWidth : scrollByDirectionWithPercentage;
  var enableScroll = ((_containerRef$current = (_containerRef$current2 = containerRef.current) === null || _containerRef$current2 === void 0 ? void 0 : _containerRef$current2.scrollWidth) !== null && _containerRef$current !== void 0 ? _containerRef$current : 0) > ((_containerRef$current3 = (_containerRef$current4 = containerRef.current) === null || _containerRef$current4 === void 0 ? void 0 : _containerRef$current4.clientWidth) !== null && _containerRef$current3 !== void 0 ? _containerRef$current3 : 0);
  return jsx$1("div", {
    css: [_ref, blurStyle(displayButtons, blurWidth), "", "", "", ""]
  }, displayButtons.left && enableScroll && jsx$1(Button, {
    onClick: function onClick() {
      return handleScrolling("left");
    },
    iconLeft: jsx$1(CarretLeftIcon, null),
    variant: "secondary",
    customCss: [
      commonButtonStyle,
      /* @__PURE__ */ css({
        position: "absolute",
        left: "".concat(marginSideButton, "px")
      }, "", "", "", "")
    ]
  }), jsx$1("div", {
    ref: containerRef,
    css: [
      /* @__PURE__ */ css({
        position: "relative",
        display: "flex",
        gap: spacings.md,
        width: "100%",
        overflowX: "auto",
        justifyContent: "safe center",
        "&::-webkit-scrollbar": {
          display: "none"
        },
        msOverflowStyle: "none",
        scrollbarWidth: "none"
      }, "", "", "", ""),
      customContainerStyle,
      "",
      "",
      "",
      ""
    ]
  }, children), displayButtons.right && enableScroll && jsx$1(Button, {
    onClick: function onClick() {
      return handleScrolling("right");
    },
    iconLeft: jsx$1(CarretRightIcon, null),
    variant: "secondary",
    customCss: [
      commonButtonStyle,
      /* @__PURE__ */ css({
        width: "".concat(BUTTON_WIDTH, "px"),
        position: "absolute",
        right: "".concat(marginSideButton, "px")
      }, "", "", "", "")
    ]
  }));
};
var getThemeColor = function getThemeColor2(color2) {
  var hasChildColor = color2.split(".");
  if (hasChildColor.length > 1) {
    var mainKey = hasChildColor[0];
    var childKey = hasChildColor[1];
    return theme.palette[mainKey][childKey];
  }
  var value = theme.palette[color2];
  return typeof value === "string" ? value : "unset";
};
var FlexBox = /* @__PURE__ */ N(function(_ref3, ref2) {
  var id2 = _ref3.id, children = _ref3.children, gap = _ref3.gap, align = _ref3.align, justify = _ref3.justify, direction = _ref3.direction, wrap2 = _ref3.wrap, alignSelf = _ref3.alignSelf, justifySelf = _ref3.justifySelf, px = _ref3.px, py = _ref3.py, radius = _ref3.radius, bgColor = _ref3.bgColor, customCss = _ref3.customCss, overflow = _ref3.overflow;
  return jsx$1("div", {
    ref: ref2,
    id: id2,
    css: [
      /* @__PURE__ */ css({
        display: "flex",
        gap: gap ? spacings[gap] : 0,
        alignItems: align,
        justifyContent: justify,
        flexDirection: direction,
        flexWrap: wrap2,
        alignSelf,
        borderRadius: radius ? theme.borderRadius[radius] : "unset",
        justifySelf,
        backgroundColor: bgColor ? getThemeColor(bgColor) : "unset",
        paddingLeft: px ? spacings[px] : 0,
        paddingRight: px ? spacings[px] : 0,
        paddingTop: py ? spacings[py] : 0,
        paddingBottom: py ? spacings[py] : 0,
        overflow,
        "&::-webkit-scrollbar": {
          display: "none"
        },
        msOverflowStyle: "none",
        scrollbarWidth: "none"
      }, "", "", "", ""),
      customCss,
      "",
      "",
      "",
      ""
    ]
  }, children);
});
var _templateObject;
var rotate = keyframes(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n0% {\n  transform: rotate(0deg);\n}\n\n100% {\n  transform: rotate(360deg);\n}\n"])));
var infiniteRotationStyle = function infiniteRotationStyle2() {
  var speed = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0.66;
  return /* @__PURE__ */ css({
    animation: "".concat(rotate, " ").concat(speed, "s linear infinite")
  }, "", "", "", "");
};
var Subscribable = /* @__PURE__ */ function() {
  function Subscribable2() {
    this.listeners = [];
  }
  var _proto = Subscribable2.prototype;
  _proto.subscribe = function subscribe(listener) {
    var _this = this;
    var callback = listener || function() {
      return void 0;
    };
    this.listeners.push(callback);
    this.onSubscribe();
    return function() {
      _this.listeners = _this.listeners.filter(function(x2) {
        return x2 !== callback;
      });
      _this.onUnsubscribe();
    };
  };
  _proto.hasListeners = function hasListeners() {
    return this.listeners.length > 0;
  };
  _proto.onSubscribe = function onSubscribe() {
  };
  _proto.onUnsubscribe = function onUnsubscribe() {
  };
  return Subscribable2;
}();
var isServer = typeof window === "undefined";
function noop$2() {
  return void 0;
}
function functionalUpdate(updater, input) {
  return typeof updater === "function" ? updater(input) : updater;
}
function isValidTimeout(value) {
  return typeof value === "number" && value >= 0 && value !== Infinity;
}
function ensureQueryKeyArray(value) {
  return Array.isArray(value) ? value : [value];
}
function timeUntilStale(updatedAt, staleTime) {
  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);
}
function parseQueryArgs(arg1, arg2, arg3) {
  if (!isQueryKey(arg1)) {
    return arg1;
  }
  if (typeof arg2 === "function") {
    return _extends({}, arg3, {
      queryKey: arg1,
      queryFn: arg2
    });
  }
  return _extends({}, arg2, {
    queryKey: arg1
  });
}
function parseMutationArgs(arg1, arg2, arg3) {
  if (isQueryKey(arg1)) {
    if (typeof arg2 === "function") {
      return _extends({}, arg3, {
        mutationKey: arg1,
        mutationFn: arg2
      });
    }
    return _extends({}, arg2, {
      mutationKey: arg1
    });
  }
  if (typeof arg1 === "function") {
    return _extends({}, arg2, {
      mutationFn: arg1
    });
  }
  return _extends({}, arg1);
}
function parseFilterArgs(arg1, arg2, arg3) {
  return isQueryKey(arg1) ? [_extends({}, arg2, {
    queryKey: arg1
  }), arg3] : [arg1 || {}, arg2];
}
function mapQueryStatusFilter(active, inactive) {
  if (active === true && inactive === true || active == null && inactive == null) {
    return "all";
  } else if (active === false && inactive === false) {
    return "none";
  } else {
    var isActive = active != null ? active : !inactive;
    return isActive ? "active" : "inactive";
  }
}
function matchQuery(filters, query) {
  var active = filters.active, exact = filters.exact, fetching = filters.fetching, inactive = filters.inactive, predicate = filters.predicate, queryKey = filters.queryKey, stale = filters.stale;
  if (isQueryKey(queryKey)) {
    if (exact) {
      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {
        return false;
      }
    } else if (!partialMatchKey(query.queryKey, queryKey)) {
      return false;
    }
  }
  var queryStatusFilter = mapQueryStatusFilter(active, inactive);
  if (queryStatusFilter === "none") {
    return false;
  } else if (queryStatusFilter !== "all") {
    var isActive = query.isActive();
    if (queryStatusFilter === "active" && !isActive) {
      return false;
    }
    if (queryStatusFilter === "inactive" && isActive) {
      return false;
    }
  }
  if (typeof stale === "boolean" && query.isStale() !== stale) {
    return false;
  }
  if (typeof fetching === "boolean" && query.isFetching() !== fetching) {
    return false;
  }
  if (predicate && !predicate(query)) {
    return false;
  }
  return true;
}
function matchMutation(filters, mutation) {
  var exact = filters.exact, fetching = filters.fetching, predicate = filters.predicate, mutationKey = filters.mutationKey;
  if (isQueryKey(mutationKey)) {
    if (!mutation.options.mutationKey) {
      return false;
    }
    if (exact) {
      if (hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)) {
        return false;
      }
    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {
      return false;
    }
  }
  if (typeof fetching === "boolean" && mutation.state.status === "loading" !== fetching) {
    return false;
  }
  if (predicate && !predicate(mutation)) {
    return false;
  }
  return true;
}
function hashQueryKeyByOptions(queryKey, options) {
  var hashFn = (options == null ? void 0 : options.queryKeyHashFn) || hashQueryKey;
  return hashFn(queryKey);
}
function hashQueryKey(queryKey) {
  var asArray = ensureQueryKeyArray(queryKey);
  return stableValueHash(asArray);
}
function stableValueHash(value) {
  return JSON.stringify(value, function(_2, val) {
    return isPlainObject$3(val) ? Object.keys(val).sort().reduce(function(result, key) {
      result[key] = val[key];
      return result;
    }, {}) : val;
  });
}
function partialMatchKey(a2, b2) {
  return partialDeepEqual(ensureQueryKeyArray(a2), ensureQueryKeyArray(b2));
}
function partialDeepEqual(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  if (typeof a2 !== typeof b2) {
    return false;
  }
  if (a2 && b2 && typeof a2 === "object" && typeof b2 === "object") {
    return !Object.keys(b2).some(function(key) {
      return !partialDeepEqual(a2[key], b2[key]);
    });
  }
  return false;
}
function replaceEqualDeep(a2, b2) {
  if (a2 === b2) {
    return a2;
  }
  var array = Array.isArray(a2) && Array.isArray(b2);
  if (array || isPlainObject$3(a2) && isPlainObject$3(b2)) {
    var aSize = array ? a2.length : Object.keys(a2).length;
    var bItems = array ? b2 : Object.keys(b2);
    var bSize = bItems.length;
    var copy2 = array ? [] : {};
    var equalItems = 0;
    for (var i = 0; i < bSize; i++) {
      var key = array ? i : bItems[i];
      copy2[key] = replaceEqualDeep(a2[key], b2[key]);
      if (copy2[key] === a2[key]) {
        equalItems++;
      }
    }
    return aSize === bSize && equalItems === aSize ? a2 : copy2;
  }
  return b2;
}
function shallowEqualObjects(a2, b2) {
  if (a2 && !b2 || b2 && !a2) {
    return false;
  }
  for (var key in a2) {
    if (a2[key] !== b2[key]) {
      return false;
    }
  }
  return true;
}
function isPlainObject$3(o2) {
  if (!hasObjectPrototype(o2)) {
    return false;
  }
  var ctor = o2.constructor;
  if (typeof ctor === "undefined") {
    return true;
  }
  var prot = ctor.prototype;
  if (!hasObjectPrototype(prot)) {
    return false;
  }
  if (!prot.hasOwnProperty("isPrototypeOf")) {
    return false;
  }
  return true;
}
function hasObjectPrototype(o2) {
  return Object.prototype.toString.call(o2) === "[object Object]";
}
function isQueryKey(value) {
  return typeof value === "string" || Array.isArray(value);
}
function sleep(timeout) {
  return new Promise(function(resolve2) {
    setTimeout(resolve2, timeout);
  });
}
function scheduleMicrotask(callback) {
  Promise.resolve().then(callback).catch(function(error2) {
    return setTimeout(function() {
      throw error2;
    });
  });
}
function getAbortController() {
  if (typeof AbortController === "function") {
    return new AbortController();
  }
}
var FocusManager = /* @__PURE__ */ function(_Subscribable) {
  _inheritsLoose(FocusManager2, _Subscribable);
  function FocusManager2() {
    var _this;
    _this = _Subscribable.call(this) || this;
    _this.setup = function(onFocus) {
      var _window;
      if (!isServer && ((_window = window) == null ? void 0 : _window.addEventListener)) {
        var listener = function listener2() {
          return onFocus();
        };
        window.addEventListener("visibilitychange", listener, false);
        window.addEventListener("focus", listener, false);
        return function() {
          window.removeEventListener("visibilitychange", listener);
          window.removeEventListener("focus", listener);
        };
      }
    };
    return _this;
  }
  var _proto = FocusManager2.prototype;
  _proto.onSubscribe = function onSubscribe() {
    if (!this.cleanup) {
      this.setEventListener(this.setup);
    }
  };
  _proto.onUnsubscribe = function onUnsubscribe() {
    if (!this.hasListeners()) {
      var _this$cleanup;
      (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);
      this.cleanup = void 0;
    }
  };
  _proto.setEventListener = function setEventListener(setup) {
    var _this$cleanup2, _this2 = this;
    this.setup = setup;
    (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);
    this.cleanup = setup(function(focused) {
      if (typeof focused === "boolean") {
        _this2.setFocused(focused);
      } else {
        _this2.onFocus();
      }
    });
  };
  _proto.setFocused = function setFocused(focused) {
    this.focused = focused;
    if (focused) {
      this.onFocus();
    }
  };
  _proto.onFocus = function onFocus() {
    this.listeners.forEach(function(listener) {
      listener();
    });
  };
  _proto.isFocused = function isFocused() {
    if (typeof this.focused === "boolean") {
      return this.focused;
    }
    if (typeof document === "undefined") {
      return true;
    }
    return [void 0, "visible", "prerender"].includes(document.visibilityState);
  };
  return FocusManager2;
}(Subscribable);
var focusManager = new FocusManager();
var OnlineManager = /* @__PURE__ */ function(_Subscribable) {
  _inheritsLoose(OnlineManager2, _Subscribable);
  function OnlineManager2() {
    var _this;
    _this = _Subscribable.call(this) || this;
    _this.setup = function(onOnline) {
      var _window;
      if (!isServer && ((_window = window) == null ? void 0 : _window.addEventListener)) {
        var listener = function listener2() {
          return onOnline();
        };
        window.addEventListener("online", listener, false);
        window.addEventListener("offline", listener, false);
        return function() {
          window.removeEventListener("online", listener);
          window.removeEventListener("offline", listener);
        };
      }
    };
    return _this;
  }
  var _proto = OnlineManager2.prototype;
  _proto.onSubscribe = function onSubscribe() {
    if (!this.cleanup) {
      this.setEventListener(this.setup);
    }
  };
  _proto.onUnsubscribe = function onUnsubscribe() {
    if (!this.hasListeners()) {
      var _this$cleanup;
      (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);
      this.cleanup = void 0;
    }
  };
  _proto.setEventListener = function setEventListener(setup) {
    var _this$cleanup2, _this2 = this;
    this.setup = setup;
    (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);
    this.cleanup = setup(function(online) {
      if (typeof online === "boolean") {
        _this2.setOnline(online);
      } else {
        _this2.onOnline();
      }
    });
  };
  _proto.setOnline = function setOnline(online) {
    this.online = online;
    if (online) {
      this.onOnline();
    }
  };
  _proto.onOnline = function onOnline() {
    this.listeners.forEach(function(listener) {
      listener();
    });
  };
  _proto.isOnline = function isOnline() {
    if (typeof this.online === "boolean") {
      return this.online;
    }
    if (typeof navigator === "undefined" || typeof navigator.onLine === "undefined") {
      return true;
    }
    return navigator.onLine;
  };
  return OnlineManager2;
}(Subscribable);
var onlineManager = new OnlineManager();
function defaultRetryDelay(failureCount) {
  return Math.min(1e3 * Math.pow(2, failureCount), 3e4);
}
function isCancelable(value) {
  return typeof (value == null ? void 0 : value.cancel) === "function";
}
var CancelledError = function CancelledError2(options) {
  this.revert = options == null ? void 0 : options.revert;
  this.silent = options == null ? void 0 : options.silent;
};
function isCancelledError(value) {
  return value instanceof CancelledError;
}
var Retryer = function Retryer2(config2) {
  var _this = this;
  var cancelRetry = false;
  var cancelFn;
  var continueFn;
  var promiseResolve;
  var promiseReject;
  this.abort = config2.abort;
  this.cancel = function(cancelOptions) {
    return cancelFn == null ? void 0 : cancelFn(cancelOptions);
  };
  this.cancelRetry = function() {
    cancelRetry = true;
  };
  this.continueRetry = function() {
    cancelRetry = false;
  };
  this.continue = function() {
    return continueFn == null ? void 0 : continueFn();
  };
  this.failureCount = 0;
  this.isPaused = false;
  this.isResolved = false;
  this.isTransportCancelable = false;
  this.promise = new Promise(function(outerResolve, outerReject) {
    promiseResolve = outerResolve;
    promiseReject = outerReject;
  });
  var resolve2 = function resolve3(value) {
    if (!_this.isResolved) {
      _this.isResolved = true;
      config2.onSuccess == null ? void 0 : config2.onSuccess(value);
      continueFn == null ? void 0 : continueFn();
      promiseResolve(value);
    }
  };
  var reject = function reject2(value) {
    if (!_this.isResolved) {
      _this.isResolved = true;
      config2.onError == null ? void 0 : config2.onError(value);
      continueFn == null ? void 0 : continueFn();
      promiseReject(value);
    }
  };
  var pause = function pause2() {
    return new Promise(function(continueResolve) {
      continueFn = continueResolve;
      _this.isPaused = true;
      config2.onPause == null ? void 0 : config2.onPause();
    }).then(function() {
      continueFn = void 0;
      _this.isPaused = false;
      config2.onContinue == null ? void 0 : config2.onContinue();
    });
  };
  var run = function run2() {
    if (_this.isResolved) {
      return;
    }
    var promiseOrValue;
    try {
      promiseOrValue = config2.fn();
    } catch (error2) {
      promiseOrValue = Promise.reject(error2);
    }
    cancelFn = function cancelFn2(cancelOptions) {
      if (!_this.isResolved) {
        reject(new CancelledError(cancelOptions));
        _this.abort == null ? void 0 : _this.abort();
        if (isCancelable(promiseOrValue)) {
          try {
            promiseOrValue.cancel();
          } catch (_unused) {
          }
        }
      }
    };
    _this.isTransportCancelable = isCancelable(promiseOrValue);
    Promise.resolve(promiseOrValue).then(resolve2).catch(function(error2) {
      var _config$retry, _config$retryDelay;
      if (_this.isResolved) {
        return;
      }
      var retry = (_config$retry = config2.retry) != null ? _config$retry : 3;
      var retryDelay = (_config$retryDelay = config2.retryDelay) != null ? _config$retryDelay : defaultRetryDelay;
      var delay = typeof retryDelay === "function" ? retryDelay(_this.failureCount, error2) : retryDelay;
      var shouldRetry = retry === true || typeof retry === "number" && _this.failureCount < retry || typeof retry === "function" && retry(_this.failureCount, error2);
      if (cancelRetry || !shouldRetry) {
        reject(error2);
        return;
      }
      _this.failureCount++;
      config2.onFail == null ? void 0 : config2.onFail(_this.failureCount, error2);
      sleep(delay).then(function() {
        if (!focusManager.isFocused() || !onlineManager.isOnline()) {
          return pause();
        }
      }).then(function() {
        if (cancelRetry) {
          reject(error2);
        } else {
          run2();
        }
      });
    });
  };
  run();
};
var NotifyManager = /* @__PURE__ */ function() {
  function NotifyManager2() {
    this.queue = [];
    this.transactions = 0;
    this.notifyFn = function(callback) {
      callback();
    };
    this.batchNotifyFn = function(callback) {
      callback();
    };
  }
  var _proto = NotifyManager2.prototype;
  _proto.batch = function batch(callback) {
    var result;
    this.transactions++;
    try {
      result = callback();
    } finally {
      this.transactions--;
      if (!this.transactions) {
        this.flush();
      }
    }
    return result;
  };
  _proto.schedule = function schedule2(callback) {
    var _this = this;
    if (this.transactions) {
      this.queue.push(callback);
    } else {
      scheduleMicrotask(function() {
        _this.notifyFn(callback);
      });
    }
  };
  _proto.batchCalls = function batchCalls(callback) {
    var _this2 = this;
    return function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this2.schedule(function() {
        callback.apply(void 0, args);
      });
    };
  };
  _proto.flush = function flush2() {
    var _this3 = this;
    var queue = this.queue;
    this.queue = [];
    if (queue.length) {
      scheduleMicrotask(function() {
        _this3.batchNotifyFn(function() {
          queue.forEach(function(callback) {
            _this3.notifyFn(callback);
          });
        });
      });
    }
  };
  _proto.setNotifyFunction = function setNotifyFunction(fn2) {
    this.notifyFn = fn2;
  };
  _proto.setBatchNotifyFunction = function setBatchNotifyFunction(fn2) {
    this.batchNotifyFn = fn2;
  };
  return NotifyManager2;
}();
var notifyManager = new NotifyManager();
var logger$1 = console;
function getLogger() {
  return logger$1;
}
function setLogger(newLogger) {
  logger$1 = newLogger;
}
var Query = /* @__PURE__ */ function() {
  function Query2(config2) {
    this.abortSignalConsumed = false;
    this.hadObservers = false;
    this.defaultOptions = config2.defaultOptions;
    this.setOptions(config2.options);
    this.observers = [];
    this.cache = config2.cache;
    this.queryKey = config2.queryKey;
    this.queryHash = config2.queryHash;
    this.initialState = config2.state || this.getDefaultState(this.options);
    this.state = this.initialState;
    this.meta = config2.meta;
    this.scheduleGc();
  }
  var _proto = Query2.prototype;
  _proto.setOptions = function setOptions(options) {
    var _this$options$cacheTi;
    this.options = _extends({}, this.defaultOptions, options);
    this.meta = options == null ? void 0 : options.meta;
    this.cacheTime = Math.max(this.cacheTime || 0, (_this$options$cacheTi = this.options.cacheTime) != null ? _this$options$cacheTi : 5 * 60 * 1e3);
  };
  _proto.setDefaultOptions = function setDefaultOptions(options) {
    this.defaultOptions = options;
  };
  _proto.scheduleGc = function scheduleGc() {
    var _this = this;
    this.clearGcTimeout();
    if (isValidTimeout(this.cacheTime)) {
      this.gcTimeout = setTimeout(function() {
        _this.optionalRemove();
      }, this.cacheTime);
    }
  };
  _proto.clearGcTimeout = function clearGcTimeout() {
    clearTimeout(this.gcTimeout);
    this.gcTimeout = void 0;
  };
  _proto.optionalRemove = function optionalRemove() {
    if (!this.observers.length) {
      if (this.state.isFetching) {
        if (this.hadObservers) {
          this.scheduleGc();
        }
      } else {
        this.cache.remove(this);
      }
    }
  };
  _proto.setData = function setData(updater, options) {
    var _this$options$isDataE, _this$options;
    var prevData = this.state.data;
    var data = functionalUpdate(updater, prevData);
    if ((_this$options$isDataE = (_this$options = this.options).isDataEqual) == null ? void 0 : _this$options$isDataE.call(_this$options, prevData, data)) {
      data = prevData;
    } else if (this.options.structuralSharing !== false) {
      data = replaceEqualDeep(prevData, data);
    }
    this.dispatch({
      data,
      type: "success",
      dataUpdatedAt: options == null ? void 0 : options.updatedAt
    });
    return data;
  };
  _proto.setState = function setState(state, setStateOptions) {
    this.dispatch({
      type: "setState",
      state,
      setStateOptions
    });
  };
  _proto.cancel = function cancel(options) {
    var _this$retryer;
    var promise = this.promise;
    (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.cancel(options);
    return promise ? promise.then(noop$2).catch(noop$2) : Promise.resolve();
  };
  _proto.destroy = function destroy() {
    this.clearGcTimeout();
    this.cancel({
      silent: true
    });
  };
  _proto.reset = function reset() {
    this.destroy();
    this.setState(this.initialState);
  };
  _proto.isActive = function isActive() {
    return this.observers.some(function(observer) {
      return observer.options.enabled !== false;
    });
  };
  _proto.isFetching = function isFetching() {
    return this.state.isFetching;
  };
  _proto.isStale = function isStale2() {
    return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some(function(observer) {
      return observer.getCurrentResult().isStale;
    });
  };
  _proto.isStaleByTime = function isStaleByTime(staleTime) {
    if (staleTime === void 0) {
      staleTime = 0;
    }
    return this.state.isInvalidated || !this.state.dataUpdatedAt || !timeUntilStale(this.state.dataUpdatedAt, staleTime);
  };
  _proto.onFocus = function onFocus() {
    var _this$retryer2;
    var observer = this.observers.find(function(x2) {
      return x2.shouldFetchOnWindowFocus();
    });
    if (observer) {
      observer.refetch();
    }
    (_this$retryer2 = this.retryer) == null ? void 0 : _this$retryer2.continue();
  };
  _proto.onOnline = function onOnline() {
    var _this$retryer3;
    var observer = this.observers.find(function(x2) {
      return x2.shouldFetchOnReconnect();
    });
    if (observer) {
      observer.refetch();
    }
    (_this$retryer3 = this.retryer) == null ? void 0 : _this$retryer3.continue();
  };
  _proto.addObserver = function addObserver(observer) {
    if (this.observers.indexOf(observer) === -1) {
      this.observers.push(observer);
      this.hadObservers = true;
      this.clearGcTimeout();
      this.cache.notify({
        type: "observerAdded",
        query: this,
        observer
      });
    }
  };
  _proto.removeObserver = function removeObserver(observer) {
    if (this.observers.indexOf(observer) !== -1) {
      this.observers = this.observers.filter(function(x2) {
        return x2 !== observer;
      });
      if (!this.observers.length) {
        if (this.retryer) {
          if (this.retryer.isTransportCancelable || this.abortSignalConsumed) {
            this.retryer.cancel({
              revert: true
            });
          } else {
            this.retryer.cancelRetry();
          }
        }
        if (this.cacheTime) {
          this.scheduleGc();
        } else {
          this.cache.remove(this);
        }
      }
      this.cache.notify({
        type: "observerRemoved",
        query: this,
        observer
      });
    }
  };
  _proto.getObserversCount = function getObserversCount() {
    return this.observers.length;
  };
  _proto.invalidate = function invalidate() {
    if (!this.state.isInvalidated) {
      this.dispatch({
        type: "invalidate"
      });
    }
  };
  _proto.fetch = function fetch2(options, fetchOptions) {
    var _this2 = this, _this$options$behavio, _context$fetchOptions, _abortController$abor;
    if (this.state.isFetching) {
      if (this.state.dataUpdatedAt && (fetchOptions == null ? void 0 : fetchOptions.cancelRefetch)) {
        this.cancel({
          silent: true
        });
      } else if (this.promise) {
        var _this$retryer4;
        (_this$retryer4 = this.retryer) == null ? void 0 : _this$retryer4.continueRetry();
        return this.promise;
      }
    }
    if (options) {
      this.setOptions(options);
    }
    if (!this.options.queryFn) {
      var observer = this.observers.find(function(x2) {
        return x2.options.queryFn;
      });
      if (observer) {
        this.setOptions(observer.options);
      }
    }
    var queryKey = ensureQueryKeyArray(this.queryKey);
    var abortController = getAbortController();
    var queryFnContext = {
      queryKey,
      pageParam: void 0,
      meta: this.meta
    };
    Object.defineProperty(queryFnContext, "signal", {
      enumerable: true,
      get: function get2() {
        if (abortController) {
          _this2.abortSignalConsumed = true;
          return abortController.signal;
        }
        return void 0;
      }
    });
    var fetchFn = function fetchFn2() {
      if (!_this2.options.queryFn) {
        return Promise.reject("Missing queryFn");
      }
      _this2.abortSignalConsumed = false;
      return _this2.options.queryFn(queryFnContext);
    };
    var context = {
      fetchOptions,
      options: this.options,
      queryKey,
      state: this.state,
      fetchFn,
      meta: this.meta
    };
    if ((_this$options$behavio = this.options.behavior) == null ? void 0 : _this$options$behavio.onFetch) {
      var _this$options$behavio2;
      (_this$options$behavio2 = this.options.behavior) == null ? void 0 : _this$options$behavio2.onFetch(context);
    }
    this.revertState = this.state;
    if (!this.state.isFetching || this.state.fetchMeta !== ((_context$fetchOptions = context.fetchOptions) == null ? void 0 : _context$fetchOptions.meta)) {
      var _context$fetchOptions2;
      this.dispatch({
        type: "fetch",
        meta: (_context$fetchOptions2 = context.fetchOptions) == null ? void 0 : _context$fetchOptions2.meta
      });
    }
    this.retryer = new Retryer({
      fn: context.fetchFn,
      abort: abortController == null ? void 0 : (_abortController$abor = abortController.abort) == null ? void 0 : _abortController$abor.bind(abortController),
      onSuccess: function onSuccess(data) {
        _this2.setData(data);
        _this2.cache.config.onSuccess == null ? void 0 : _this2.cache.config.onSuccess(data, _this2);
        if (_this2.cacheTime === 0) {
          _this2.optionalRemove();
        }
      },
      onError: function onError(error2) {
        if (!(isCancelledError(error2) && error2.silent)) {
          _this2.dispatch({
            type: "error",
            error: error2
          });
        }
        if (!isCancelledError(error2)) {
          _this2.cache.config.onError == null ? void 0 : _this2.cache.config.onError(error2, _this2);
          getLogger().error(error2);
        }
        if (_this2.cacheTime === 0) {
          _this2.optionalRemove();
        }
      },
      onFail: function onFail() {
        _this2.dispatch({
          type: "failed"
        });
      },
      onPause: function onPause() {
        _this2.dispatch({
          type: "pause"
        });
      },
      onContinue: function onContinue() {
        _this2.dispatch({
          type: "continue"
        });
      },
      retry: context.options.retry,
      retryDelay: context.options.retryDelay
    });
    this.promise = this.retryer.promise;
    return this.promise;
  };
  _proto.dispatch = function dispatch(action) {
    var _this3 = this;
    this.state = this.reducer(this.state, action);
    notifyManager.batch(function() {
      _this3.observers.forEach(function(observer) {
        observer.onQueryUpdate(action);
      });
      _this3.cache.notify({
        query: _this3,
        type: "queryUpdated",
        action
      });
    });
  };
  _proto.getDefaultState = function getDefaultState2(options) {
    var data = typeof options.initialData === "function" ? options.initialData() : options.initialData;
    var hasInitialData = typeof options.initialData !== "undefined";
    var initialDataUpdatedAt = hasInitialData ? typeof options.initialDataUpdatedAt === "function" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;
    var hasData = typeof data !== "undefined";
    return {
      data,
      dataUpdateCount: 0,
      dataUpdatedAt: hasData ? initialDataUpdatedAt != null ? initialDataUpdatedAt : Date.now() : 0,
      error: null,
      errorUpdateCount: 0,
      errorUpdatedAt: 0,
      fetchFailureCount: 0,
      fetchMeta: null,
      isFetching: false,
      isInvalidated: false,
      isPaused: false,
      status: hasData ? "success" : "idle"
    };
  };
  _proto.reducer = function reducer2(state, action) {
    var _action$meta, _action$dataUpdatedAt;
    switch (action.type) {
      case "failed":
        return _extends({}, state, {
          fetchFailureCount: state.fetchFailureCount + 1
        });
      case "pause":
        return _extends({}, state, {
          isPaused: true
        });
      case "continue":
        return _extends({}, state, {
          isPaused: false
        });
      case "fetch":
        return _extends({}, state, {
          fetchFailureCount: 0,
          fetchMeta: (_action$meta = action.meta) != null ? _action$meta : null,
          isFetching: true,
          isPaused: false
        }, !state.dataUpdatedAt && {
          error: null,
          status: "loading"
        });
      case "success":
        return _extends({}, state, {
          data: action.data,
          dataUpdateCount: state.dataUpdateCount + 1,
          dataUpdatedAt: (_action$dataUpdatedAt = action.dataUpdatedAt) != null ? _action$dataUpdatedAt : Date.now(),
          error: null,
          fetchFailureCount: 0,
          isFetching: false,
          isInvalidated: false,
          isPaused: false,
          status: "success"
        });
      case "error":
        var error2 = action.error;
        if (isCancelledError(error2) && error2.revert && this.revertState) {
          return _extends({}, this.revertState);
        }
        return _extends({}, state, {
          error: error2,
          errorUpdateCount: state.errorUpdateCount + 1,
          errorUpdatedAt: Date.now(),
          fetchFailureCount: state.fetchFailureCount + 1,
          isFetching: false,
          isPaused: false,
          status: "error"
        });
      case "invalidate":
        return _extends({}, state, {
          isInvalidated: true
        });
      case "setState":
        return _extends({}, state, action.state);
      default:
        return state;
    }
  };
  return Query2;
}();
var QueryCache = /* @__PURE__ */ function(_Subscribable) {
  _inheritsLoose(QueryCache2, _Subscribable);
  function QueryCache2(config2) {
    var _this;
    _this = _Subscribable.call(this) || this;
    _this.config = config2 || {};
    _this.queries = [];
    _this.queriesMap = {};
    return _this;
  }
  var _proto = QueryCache2.prototype;
  _proto.build = function build(client, options, state) {
    var _options$queryHash;
    var queryKey = options.queryKey;
    var queryHash = (_options$queryHash = options.queryHash) != null ? _options$queryHash : hashQueryKeyByOptions(queryKey, options);
    var query = this.get(queryHash);
    if (!query) {
      query = new Query({
        cache: this,
        queryKey,
        queryHash,
        options: client.defaultQueryOptions(options),
        state,
        defaultOptions: client.getQueryDefaults(queryKey),
        meta: options.meta
      });
      this.add(query);
    }
    return query;
  };
  _proto.add = function add(query) {
    if (!this.queriesMap[query.queryHash]) {
      this.queriesMap[query.queryHash] = query;
      this.queries.push(query);
      this.notify({
        type: "queryAdded",
        query
      });
    }
  };
  _proto.remove = function remove(query) {
    var queryInMap = this.queriesMap[query.queryHash];
    if (queryInMap) {
      query.destroy();
      this.queries = this.queries.filter(function(x2) {
        return x2 !== query;
      });
      if (queryInMap === query) {
        delete this.queriesMap[query.queryHash];
      }
      this.notify({
        type: "queryRemoved",
        query
      });
    }
  };
  _proto.clear = function clear() {
    var _this2 = this;
    notifyManager.batch(function() {
      _this2.queries.forEach(function(query) {
        _this2.remove(query);
      });
    });
  };
  _proto.get = function get2(queryHash) {
    return this.queriesMap[queryHash];
  };
  _proto.getAll = function getAll() {
    return this.queries;
  };
  _proto.find = function find2(arg1, arg2) {
    var _parseFilterArgs = parseFilterArgs(arg1, arg2), filters = _parseFilterArgs[0];
    if (typeof filters.exact === "undefined") {
      filters.exact = true;
    }
    return this.queries.find(function(query) {
      return matchQuery(filters, query);
    });
  };
  _proto.findAll = function findAll(arg1, arg2) {
    var _parseFilterArgs2 = parseFilterArgs(arg1, arg2), filters = _parseFilterArgs2[0];
    return Object.keys(filters).length > 0 ? this.queries.filter(function(query) {
      return matchQuery(filters, query);
    }) : this.queries;
  };
  _proto.notify = function notify(event) {
    var _this3 = this;
    notifyManager.batch(function() {
      _this3.listeners.forEach(function(listener) {
        listener(event);
      });
    });
  };
  _proto.onFocus = function onFocus() {
    var _this4 = this;
    notifyManager.batch(function() {
      _this4.queries.forEach(function(query) {
        query.onFocus();
      });
    });
  };
  _proto.onOnline = function onOnline() {
    var _this5 = this;
    notifyManager.batch(function() {
      _this5.queries.forEach(function(query) {
        query.onOnline();
      });
    });
  };
  return QueryCache2;
}(Subscribable);
var Mutation = /* @__PURE__ */ function() {
  function Mutation2(config2) {
    this.options = _extends({}, config2.defaultOptions, config2.options);
    this.mutationId = config2.mutationId;
    this.mutationCache = config2.mutationCache;
    this.observers = [];
    this.state = config2.state || getDefaultState();
    this.meta = config2.meta;
  }
  var _proto = Mutation2.prototype;
  _proto.setState = function setState(state) {
    this.dispatch({
      type: "setState",
      state
    });
  };
  _proto.addObserver = function addObserver(observer) {
    if (this.observers.indexOf(observer) === -1) {
      this.observers.push(observer);
    }
  };
  _proto.removeObserver = function removeObserver(observer) {
    this.observers = this.observers.filter(function(x2) {
      return x2 !== observer;
    });
  };
  _proto.cancel = function cancel() {
    if (this.retryer) {
      this.retryer.cancel();
      return this.retryer.promise.then(noop$2).catch(noop$2);
    }
    return Promise.resolve();
  };
  _proto.continue = function _continue() {
    if (this.retryer) {
      this.retryer.continue();
      return this.retryer.promise;
    }
    return this.execute();
  };
  _proto.execute = function execute() {
    var _this = this;
    var data;
    var restored = this.state.status === "loading";
    var promise = Promise.resolve();
    if (!restored) {
      this.dispatch({
        type: "loading",
        variables: this.options.variables
      });
      promise = promise.then(function() {
        _this.mutationCache.config.onMutate == null ? void 0 : _this.mutationCache.config.onMutate(_this.state.variables, _this);
      }).then(function() {
        return _this.options.onMutate == null ? void 0 : _this.options.onMutate(_this.state.variables);
      }).then(function(context) {
        if (context !== _this.state.context) {
          _this.dispatch({
            type: "loading",
            context,
            variables: _this.state.variables
          });
        }
      });
    }
    return promise.then(function() {
      return _this.executeMutation();
    }).then(function(result) {
      data = result;
      _this.mutationCache.config.onSuccess == null ? void 0 : _this.mutationCache.config.onSuccess(data, _this.state.variables, _this.state.context, _this);
    }).then(function() {
      return _this.options.onSuccess == null ? void 0 : _this.options.onSuccess(data, _this.state.variables, _this.state.context);
    }).then(function() {
      return _this.options.onSettled == null ? void 0 : _this.options.onSettled(data, null, _this.state.variables, _this.state.context);
    }).then(function() {
      _this.dispatch({
        type: "success",
        data
      });
      return data;
    }).catch(function(error2) {
      _this.mutationCache.config.onError == null ? void 0 : _this.mutationCache.config.onError(error2, _this.state.variables, _this.state.context, _this);
      getLogger().error(error2);
      return Promise.resolve().then(function() {
        return _this.options.onError == null ? void 0 : _this.options.onError(error2, _this.state.variables, _this.state.context);
      }).then(function() {
        return _this.options.onSettled == null ? void 0 : _this.options.onSettled(void 0, error2, _this.state.variables, _this.state.context);
      }).then(function() {
        _this.dispatch({
          type: "error",
          error: error2
        });
        throw error2;
      });
    });
  };
  _proto.executeMutation = function executeMutation() {
    var _this2 = this, _this$options$retry;
    this.retryer = new Retryer({
      fn: function fn2() {
        if (!_this2.options.mutationFn) {
          return Promise.reject("No mutationFn found");
        }
        return _this2.options.mutationFn(_this2.state.variables);
      },
      onFail: function onFail() {
        _this2.dispatch({
          type: "failed"
        });
      },
      onPause: function onPause() {
        _this2.dispatch({
          type: "pause"
        });
      },
      onContinue: function onContinue() {
        _this2.dispatch({
          type: "continue"
        });
      },
      retry: (_this$options$retry = this.options.retry) != null ? _this$options$retry : 0,
      retryDelay: this.options.retryDelay
    });
    return this.retryer.promise;
  };
  _proto.dispatch = function dispatch(action) {
    var _this3 = this;
    this.state = reducer$1(this.state, action);
    notifyManager.batch(function() {
      _this3.observers.forEach(function(observer) {
        observer.onMutationUpdate(action);
      });
      _this3.mutationCache.notify(_this3);
    });
  };
  return Mutation2;
}();
function getDefaultState() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    isPaused: false,
    status: "idle",
    variables: void 0
  };
}
function reducer$1(state, action) {
  switch (action.type) {
    case "failed":
      return _extends({}, state, {
        failureCount: state.failureCount + 1
      });
    case "pause":
      return _extends({}, state, {
        isPaused: true
      });
    case "continue":
      return _extends({}, state, {
        isPaused: false
      });
    case "loading":
      return _extends({}, state, {
        context: action.context,
        data: void 0,
        error: null,
        isPaused: false,
        status: "loading",
        variables: action.variables
      });
    case "success":
      return _extends({}, state, {
        data: action.data,
        error: null,
        status: "success",
        isPaused: false
      });
    case "error":
      return _extends({}, state, {
        data: void 0,
        error: action.error,
        failureCount: state.failureCount + 1,
        isPaused: false,
        status: "error"
      });
    case "setState":
      return _extends({}, state, action.state);
    default:
      return state;
  }
}
var MutationCache = /* @__PURE__ */ function(_Subscribable) {
  _inheritsLoose(MutationCache2, _Subscribable);
  function MutationCache2(config2) {
    var _this;
    _this = _Subscribable.call(this) || this;
    _this.config = config2 || {};
    _this.mutations = [];
    _this.mutationId = 0;
    return _this;
  }
  var _proto = MutationCache2.prototype;
  _proto.build = function build(client, options, state) {
    var mutation = new Mutation({
      mutationCache: this,
      mutationId: ++this.mutationId,
      options: client.defaultMutationOptions(options),
      state,
      defaultOptions: options.mutationKey ? client.getMutationDefaults(options.mutationKey) : void 0,
      meta: options.meta
    });
    this.add(mutation);
    return mutation;
  };
  _proto.add = function add(mutation) {
    this.mutations.push(mutation);
    this.notify(mutation);
  };
  _proto.remove = function remove(mutation) {
    this.mutations = this.mutations.filter(function(x2) {
      return x2 !== mutation;
    });
    mutation.cancel();
    this.notify(mutation);
  };
  _proto.clear = function clear() {
    var _this2 = this;
    notifyManager.batch(function() {
      _this2.mutations.forEach(function(mutation) {
        _this2.remove(mutation);
      });
    });
  };
  _proto.getAll = function getAll() {
    return this.mutations;
  };
  _proto.find = function find2(filters) {
    if (typeof filters.exact === "undefined") {
      filters.exact = true;
    }
    return this.mutations.find(function(mutation) {
      return matchMutation(filters, mutation);
    });
  };
  _proto.findAll = function findAll(filters) {
    return this.mutations.filter(function(mutation) {
      return matchMutation(filters, mutation);
    });
  };
  _proto.notify = function notify(mutation) {
    var _this3 = this;
    notifyManager.batch(function() {
      _this3.listeners.forEach(function(listener) {
        listener(mutation);
      });
    });
  };
  _proto.onFocus = function onFocus() {
    this.resumePausedMutations();
  };
  _proto.onOnline = function onOnline() {
    this.resumePausedMutations();
  };
  _proto.resumePausedMutations = function resumePausedMutations() {
    var pausedMutations = this.mutations.filter(function(x2) {
      return x2.state.isPaused;
    });
    return notifyManager.batch(function() {
      return pausedMutations.reduce(function(promise, mutation) {
        return promise.then(function() {
          return mutation.continue().catch(noop$2);
        });
      }, Promise.resolve());
    });
  };
  return MutationCache2;
}(Subscribable);
function infiniteQueryBehavior() {
  return {
    onFetch: function onFetch(context) {
      context.fetchFn = function() {
        var _context$fetchOptions, _context$fetchOptions2, _context$fetchOptions3, _context$fetchOptions4, _context$state$data, _context$state$data2;
        var refetchPage = (_context$fetchOptions = context.fetchOptions) == null ? void 0 : (_context$fetchOptions2 = _context$fetchOptions.meta) == null ? void 0 : _context$fetchOptions2.refetchPage;
        var fetchMore = (_context$fetchOptions3 = context.fetchOptions) == null ? void 0 : (_context$fetchOptions4 = _context$fetchOptions3.meta) == null ? void 0 : _context$fetchOptions4.fetchMore;
        var pageParam = fetchMore == null ? void 0 : fetchMore.pageParam;
        var isFetchingNextPage = (fetchMore == null ? void 0 : fetchMore.direction) === "forward";
        var isFetchingPreviousPage = (fetchMore == null ? void 0 : fetchMore.direction) === "backward";
        var oldPages = ((_context$state$data = context.state.data) == null ? void 0 : _context$state$data.pages) || [];
        var oldPageParams = ((_context$state$data2 = context.state.data) == null ? void 0 : _context$state$data2.pageParams) || [];
        var abortController = getAbortController();
        var abortSignal = abortController == null ? void 0 : abortController.signal;
        var newPageParams = oldPageParams;
        var cancelled = false;
        var queryFn = context.options.queryFn || function() {
          return Promise.reject("Missing queryFn");
        };
        var buildNewPages = function buildNewPages2(pages, param2, page, previous2) {
          newPageParams = previous2 ? [param2].concat(newPageParams) : [].concat(newPageParams, [param2]);
          return previous2 ? [page].concat(pages) : [].concat(pages, [page]);
        };
        var fetchPage = function fetchPage2(pages, manual2, param2, previous2) {
          if (cancelled) {
            return Promise.reject("Cancelled");
          }
          if (typeof param2 === "undefined" && !manual2 && pages.length) {
            return Promise.resolve(pages);
          }
          var queryFnContext = {
            queryKey: context.queryKey,
            signal: abortSignal,
            pageParam: param2,
            meta: context.meta
          };
          var queryFnResult = queryFn(queryFnContext);
          var promise2 = Promise.resolve(queryFnResult).then(function(page) {
            return buildNewPages(pages, param2, page, previous2);
          });
          if (isCancelable(queryFnResult)) {
            var promiseAsAny = promise2;
            promiseAsAny.cancel = queryFnResult.cancel;
          }
          return promise2;
        };
        var promise;
        if (!oldPages.length) {
          promise = fetchPage([]);
        } else if (isFetchingNextPage) {
          var manual = typeof pageParam !== "undefined";
          var param = manual ? pageParam : getNextPageParam(context.options, oldPages);
          promise = fetchPage(oldPages, manual, param);
        } else if (isFetchingPreviousPage) {
          var _manual = typeof pageParam !== "undefined";
          var _param = _manual ? pageParam : getPreviousPageParam(context.options, oldPages);
          promise = fetchPage(oldPages, _manual, _param, true);
        } else {
          (function() {
            newPageParams = [];
            var manual2 = typeof context.options.getNextPageParam === "undefined";
            var shouldFetchFirstPage = refetchPage && oldPages[0] ? refetchPage(oldPages[0], 0, oldPages) : true;
            promise = shouldFetchFirstPage ? fetchPage([], manual2, oldPageParams[0]) : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0]));
            var _loop = function _loop2(i2) {
              promise = promise.then(function(pages) {
                var shouldFetchNextPage = refetchPage && oldPages[i2] ? refetchPage(oldPages[i2], i2, oldPages) : true;
                if (shouldFetchNextPage) {
                  var _param2 = manual2 ? oldPageParams[i2] : getNextPageParam(context.options, pages);
                  return fetchPage(pages, manual2, _param2);
                }
                return Promise.resolve(buildNewPages(pages, oldPageParams[i2], oldPages[i2]));
              });
            };
            for (var i = 1; i < oldPages.length; i++) {
              _loop(i);
            }
          })();
        }
        var finalPromise = promise.then(function(pages) {
          return {
            pages,
            pageParams: newPageParams
          };
        });
        var finalPromiseAsAny = finalPromise;
        finalPromiseAsAny.cancel = function() {
          cancelled = true;
          abortController == null ? void 0 : abortController.abort();
          if (isCancelable(promise)) {
            promise.cancel();
          }
        };
        return finalPromise;
      };
    }
  };
}
function getNextPageParam(options, pages) {
  return options.getNextPageParam == null ? void 0 : options.getNextPageParam(pages[pages.length - 1], pages);
}
function getPreviousPageParam(options, pages) {
  return options.getPreviousPageParam == null ? void 0 : options.getPreviousPageParam(pages[0], pages);
}
var QueryClient = /* @__PURE__ */ function() {
  function QueryClient2(config2) {
    if (config2 === void 0) {
      config2 = {};
    }
    this.queryCache = config2.queryCache || new QueryCache();
    this.mutationCache = config2.mutationCache || new MutationCache();
    this.defaultOptions = config2.defaultOptions || {};
    this.queryDefaults = [];
    this.mutationDefaults = [];
  }
  var _proto = QueryClient2.prototype;
  _proto.mount = function mount() {
    var _this = this;
    this.unsubscribeFocus = focusManager.subscribe(function() {
      if (focusManager.isFocused() && onlineManager.isOnline()) {
        _this.mutationCache.onFocus();
        _this.queryCache.onFocus();
      }
    });
    this.unsubscribeOnline = onlineManager.subscribe(function() {
      if (focusManager.isFocused() && onlineManager.isOnline()) {
        _this.mutationCache.onOnline();
        _this.queryCache.onOnline();
      }
    });
  };
  _proto.unmount = function unmount() {
    var _this$unsubscribeFocu, _this$unsubscribeOnli;
    (_this$unsubscribeFocu = this.unsubscribeFocus) == null ? void 0 : _this$unsubscribeFocu.call(this);
    (_this$unsubscribeOnli = this.unsubscribeOnline) == null ? void 0 : _this$unsubscribeOnli.call(this);
  };
  _proto.isFetching = function isFetching(arg1, arg2) {
    var _parseFilterArgs = parseFilterArgs(arg1, arg2), filters = _parseFilterArgs[0];
    filters.fetching = true;
    return this.queryCache.findAll(filters).length;
  };
  _proto.isMutating = function isMutating(filters) {
    return this.mutationCache.findAll(_extends({}, filters, {
      fetching: true
    })).length;
  };
  _proto.getQueryData = function getQueryData(queryKey, filters) {
    var _this$queryCache$find;
    return (_this$queryCache$find = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find.state.data;
  };
  _proto.getQueriesData = function getQueriesData(queryKeyOrFilters) {
    return this.getQueryCache().findAll(queryKeyOrFilters).map(function(_ref3) {
      var queryKey = _ref3.queryKey, state = _ref3.state;
      var data = state.data;
      return [queryKey, data];
    });
  };
  _proto.setQueryData = function setQueryData(queryKey, updater, options) {
    var parsedOptions = parseQueryArgs(queryKey);
    var defaultedOptions = this.defaultQueryOptions(parsedOptions);
    return this.queryCache.build(this, defaultedOptions).setData(updater, options);
  };
  _proto.setQueriesData = function setQueriesData(queryKeyOrFilters, updater, options) {
    var _this2 = this;
    return notifyManager.batch(function() {
      return _this2.getQueryCache().findAll(queryKeyOrFilters).map(function(_ref22) {
        var queryKey = _ref22.queryKey;
        return [queryKey, _this2.setQueryData(queryKey, updater, options)];
      });
    });
  };
  _proto.getQueryState = function getQueryState(queryKey, filters) {
    var _this$queryCache$find2;
    return (_this$queryCache$find2 = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find2.state;
  };
  _proto.removeQueries = function removeQueries(arg1, arg2) {
    var _parseFilterArgs2 = parseFilterArgs(arg1, arg2), filters = _parseFilterArgs2[0];
    var queryCache = this.queryCache;
    notifyManager.batch(function() {
      queryCache.findAll(filters).forEach(function(query) {
        queryCache.remove(query);
      });
    });
  };
  _proto.resetQueries = function resetQueries(arg1, arg2, arg3) {
    var _this3 = this;
    var _parseFilterArgs3 = parseFilterArgs(arg1, arg2, arg3), filters = _parseFilterArgs3[0], options = _parseFilterArgs3[1];
    var queryCache = this.queryCache;
    var refetchFilters = _extends({}, filters, {
      active: true
    });
    return notifyManager.batch(function() {
      queryCache.findAll(filters).forEach(function(query) {
        query.reset();
      });
      return _this3.refetchQueries(refetchFilters, options);
    });
  };
  _proto.cancelQueries = function cancelQueries(arg1, arg2, arg3) {
    var _this4 = this;
    var _parseFilterArgs4 = parseFilterArgs(arg1, arg2, arg3), filters = _parseFilterArgs4[0], _parseFilterArgs4$ = _parseFilterArgs4[1], cancelOptions = _parseFilterArgs4$ === void 0 ? {} : _parseFilterArgs4$;
    if (typeof cancelOptions.revert === "undefined") {
      cancelOptions.revert = true;
    }
    var promises = notifyManager.batch(function() {
      return _this4.queryCache.findAll(filters).map(function(query) {
        return query.cancel(cancelOptions);
      });
    });
    return Promise.all(promises).then(noop$2).catch(noop$2);
  };
  _proto.invalidateQueries = function invalidateQueries(arg1, arg2, arg3) {
    var _ref3, _filters$refetchActiv, _filters$refetchInact, _this5 = this;
    var _parseFilterArgs5 = parseFilterArgs(arg1, arg2, arg3), filters = _parseFilterArgs5[0], options = _parseFilterArgs5[1];
    var refetchFilters = _extends({}, filters, {
      // if filters.refetchActive is not provided and filters.active is explicitly false,
      // e.g. invalidateQueries({ active: false }), we don't want to refetch active queries
      active: (_ref3 = (_filters$refetchActiv = filters.refetchActive) != null ? _filters$refetchActiv : filters.active) != null ? _ref3 : true,
      inactive: (_filters$refetchInact = filters.refetchInactive) != null ? _filters$refetchInact : false
    });
    return notifyManager.batch(function() {
      _this5.queryCache.findAll(filters).forEach(function(query) {
        query.invalidate();
      });
      return _this5.refetchQueries(refetchFilters, options);
    });
  };
  _proto.refetchQueries = function refetchQueries(arg1, arg2, arg3) {
    var _this6 = this;
    var _parseFilterArgs6 = parseFilterArgs(arg1, arg2, arg3), filters = _parseFilterArgs6[0], options = _parseFilterArgs6[1];
    var promises = notifyManager.batch(function() {
      return _this6.queryCache.findAll(filters).map(function(query) {
        return query.fetch(void 0, _extends({}, options, {
          meta: {
            refetchPage: filters == null ? void 0 : filters.refetchPage
          }
        }));
      });
    });
    var promise = Promise.all(promises).then(noop$2);
    if (!(options == null ? void 0 : options.throwOnError)) {
      promise = promise.catch(noop$2);
    }
    return promise;
  };
  _proto.fetchQuery = function fetchQuery(arg1, arg2, arg3) {
    var parsedOptions = parseQueryArgs(arg1, arg2, arg3);
    var defaultedOptions = this.defaultQueryOptions(parsedOptions);
    if (typeof defaultedOptions.retry === "undefined") {
      defaultedOptions.retry = false;
    }
    var query = this.queryCache.build(this, defaultedOptions);
    return query.isStaleByTime(defaultedOptions.staleTime) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);
  };
  _proto.prefetchQuery = function prefetchQuery(arg1, arg2, arg3) {
    return this.fetchQuery(arg1, arg2, arg3).then(noop$2).catch(noop$2);
  };
  _proto.fetchInfiniteQuery = function fetchInfiniteQuery(arg1, arg2, arg3) {
    var parsedOptions = parseQueryArgs(arg1, arg2, arg3);
    parsedOptions.behavior = infiniteQueryBehavior();
    return this.fetchQuery(parsedOptions);
  };
  _proto.prefetchInfiniteQuery = function prefetchInfiniteQuery(arg1, arg2, arg3) {
    return this.fetchInfiniteQuery(arg1, arg2, arg3).then(noop$2).catch(noop$2);
  };
  _proto.cancelMutations = function cancelMutations() {
    var _this7 = this;
    var promises = notifyManager.batch(function() {
      return _this7.mutationCache.getAll().map(function(mutation) {
        return mutation.cancel();
      });
    });
    return Promise.all(promises).then(noop$2).catch(noop$2);
  };
  _proto.resumePausedMutations = function resumePausedMutations() {
    return this.getMutationCache().resumePausedMutations();
  };
  _proto.executeMutation = function executeMutation(options) {
    return this.mutationCache.build(this, options).execute();
  };
  _proto.getQueryCache = function getQueryCache() {
    return this.queryCache;
  };
  _proto.getMutationCache = function getMutationCache() {
    return this.mutationCache;
  };
  _proto.getDefaultOptions = function getDefaultOptions() {
    return this.defaultOptions;
  };
  _proto.setDefaultOptions = function setDefaultOptions(options) {
    this.defaultOptions = options;
  };
  _proto.setQueryDefaults = function setQueryDefaults(queryKey, options) {
    var result = this.queryDefaults.find(function(x2) {
      return hashQueryKey(queryKey) === hashQueryKey(x2.queryKey);
    });
    if (result) {
      result.defaultOptions = options;
    } else {
      this.queryDefaults.push({
        queryKey,
        defaultOptions: options
      });
    }
  };
  _proto.getQueryDefaults = function getQueryDefaults(queryKey) {
    var _this$queryDefaults$f;
    return queryKey ? (_this$queryDefaults$f = this.queryDefaults.find(function(x2) {
      return partialMatchKey(queryKey, x2.queryKey);
    })) == null ? void 0 : _this$queryDefaults$f.defaultOptions : void 0;
  };
  _proto.setMutationDefaults = function setMutationDefaults(mutationKey, options) {
    var result = this.mutationDefaults.find(function(x2) {
      return hashQueryKey(mutationKey) === hashQueryKey(x2.mutationKey);
    });
    if (result) {
      result.defaultOptions = options;
    } else {
      this.mutationDefaults.push({
        mutationKey,
        defaultOptions: options
      });
    }
  };
  _proto.getMutationDefaults = function getMutationDefaults(mutationKey) {
    var _this$mutationDefault;
    return mutationKey ? (_this$mutationDefault = this.mutationDefaults.find(function(x2) {
      return partialMatchKey(mutationKey, x2.mutationKey);
    })) == null ? void 0 : _this$mutationDefault.defaultOptions : void 0;
  };
  _proto.defaultQueryOptions = function defaultQueryOptions(options) {
    if (options == null ? void 0 : options._defaulted) {
      return options;
    }
    var defaultedOptions = _extends({}, this.defaultOptions.queries, this.getQueryDefaults(options == null ? void 0 : options.queryKey), options, {
      _defaulted: true
    });
    if (!defaultedOptions.queryHash && defaultedOptions.queryKey) {
      defaultedOptions.queryHash = hashQueryKeyByOptions(defaultedOptions.queryKey, defaultedOptions);
    }
    return defaultedOptions;
  };
  _proto.defaultQueryObserverOptions = function defaultQueryObserverOptions(options) {
    return this.defaultQueryOptions(options);
  };
  _proto.defaultMutationOptions = function defaultMutationOptions(options) {
    if (options == null ? void 0 : options._defaulted) {
      return options;
    }
    return _extends({}, this.defaultOptions.mutations, this.getMutationDefaults(options == null ? void 0 : options.mutationKey), options, {
      _defaulted: true
    });
  };
  _proto.clear = function clear() {
    this.queryCache.clear();
    this.mutationCache.clear();
  };
  return QueryClient2;
}();
var QueryObserver = /* @__PURE__ */ function(_Subscribable) {
  _inheritsLoose(QueryObserver2, _Subscribable);
  function QueryObserver2(client, options) {
    var _this;
    _this = _Subscribable.call(this) || this;
    _this.client = client;
    _this.options = options;
    _this.trackedProps = [];
    _this.selectError = null;
    _this.bindMethods();
    _this.setOptions(options);
    return _this;
  }
  var _proto = QueryObserver2.prototype;
  _proto.bindMethods = function bindMethods() {
    this.remove = this.remove.bind(this);
    this.refetch = this.refetch.bind(this);
  };
  _proto.onSubscribe = function onSubscribe() {
    if (this.listeners.length === 1) {
      this.currentQuery.addObserver(this);
      if (shouldFetchOnMount(this.currentQuery, this.options)) {
        this.executeFetch();
      }
      this.updateTimers();
    }
  };
  _proto.onUnsubscribe = function onUnsubscribe() {
    if (!this.listeners.length) {
      this.destroy();
    }
  };
  _proto.shouldFetchOnReconnect = function shouldFetchOnReconnect() {
    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnReconnect);
  };
  _proto.shouldFetchOnWindowFocus = function shouldFetchOnWindowFocus() {
    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnWindowFocus);
  };
  _proto.destroy = function destroy() {
    this.listeners = [];
    this.clearTimers();
    this.currentQuery.removeObserver(this);
  };
  _proto.setOptions = function setOptions(options, notifyOptions) {
    var prevOptions = this.options;
    var prevQuery = this.currentQuery;
    this.options = this.client.defaultQueryObserverOptions(options);
    if (typeof this.options.enabled !== "undefined" && typeof this.options.enabled !== "boolean") {
      throw new Error("Expected enabled to be a boolean");
    }
    if (!this.options.queryKey) {
      this.options.queryKey = prevOptions.queryKey;
    }
    this.updateQuery();
    var mounted = this.hasListeners();
    if (mounted && shouldFetchOptionally(this.currentQuery, prevQuery, this.options, prevOptions)) {
      this.executeFetch();
    }
    this.updateResult(notifyOptions);
    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime)) {
      this.updateStaleTimeout();
    }
    var nextRefetchInterval = this.computeRefetchInterval();
    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || nextRefetchInterval !== this.currentRefetchInterval)) {
      this.updateRefetchInterval(nextRefetchInterval);
    }
  };
  _proto.getOptimisticResult = function getOptimisticResult(options) {
    var defaultedOptions = this.client.defaultQueryObserverOptions(options);
    var query = this.client.getQueryCache().build(this.client, defaultedOptions);
    return this.createResult(query, defaultedOptions);
  };
  _proto.getCurrentResult = function getCurrentResult() {
    return this.currentResult;
  };
  _proto.trackResult = function trackResult(result, defaultedOptions) {
    var _this2 = this;
    var trackedResult = {};
    var trackProp = function trackProp2(key) {
      if (!_this2.trackedProps.includes(key)) {
        _this2.trackedProps.push(key);
      }
    };
    Object.keys(result).forEach(function(key) {
      Object.defineProperty(trackedResult, key, {
        configurable: false,
        enumerable: true,
        get: function get2() {
          trackProp(key);
          return result[key];
        }
      });
    });
    if (defaultedOptions.useErrorBoundary || defaultedOptions.suspense) {
      trackProp("error");
    }
    return trackedResult;
  };
  _proto.getNextResult = function getNextResult(options) {
    var _this3 = this;
    return new Promise(function(resolve2, reject) {
      var unsubscribe = _this3.subscribe(function(result) {
        if (!result.isFetching) {
          unsubscribe();
          if (result.isError && (options == null ? void 0 : options.throwOnError)) {
            reject(result.error);
          } else {
            resolve2(result);
          }
        }
      });
    });
  };
  _proto.getCurrentQuery = function getCurrentQuery() {
    return this.currentQuery;
  };
  _proto.remove = function remove() {
    this.client.getQueryCache().remove(this.currentQuery);
  };
  _proto.refetch = function refetch(options) {
    return this.fetch(_extends({}, options, {
      meta: {
        refetchPage: options == null ? void 0 : options.refetchPage
      }
    }));
  };
  _proto.fetchOptimistic = function fetchOptimistic(options) {
    var _this4 = this;
    var defaultedOptions = this.client.defaultQueryObserverOptions(options);
    var query = this.client.getQueryCache().build(this.client, defaultedOptions);
    return query.fetch().then(function() {
      return _this4.createResult(query, defaultedOptions);
    });
  };
  _proto.fetch = function fetch2(fetchOptions) {
    var _this5 = this;
    return this.executeFetch(fetchOptions).then(function() {
      _this5.updateResult();
      return _this5.currentResult;
    });
  };
  _proto.executeFetch = function executeFetch(fetchOptions) {
    this.updateQuery();
    var promise = this.currentQuery.fetch(this.options, fetchOptions);
    if (!(fetchOptions == null ? void 0 : fetchOptions.throwOnError)) {
      promise = promise.catch(noop$2);
    }
    return promise;
  };
  _proto.updateStaleTimeout = function updateStaleTimeout() {
    var _this6 = this;
    this.clearStaleTimeout();
    if (isServer || this.currentResult.isStale || !isValidTimeout(this.options.staleTime)) {
      return;
    }
    var time = timeUntilStale(this.currentResult.dataUpdatedAt, this.options.staleTime);
    var timeout = time + 1;
    this.staleTimeoutId = setTimeout(function() {
      if (!_this6.currentResult.isStale) {
        _this6.updateResult();
      }
    }, timeout);
  };
  _proto.computeRefetchInterval = function computeRefetchInterval() {
    var _this$options$refetch;
    return typeof this.options.refetchInterval === "function" ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : (_this$options$refetch = this.options.refetchInterval) != null ? _this$options$refetch : false;
  };
  _proto.updateRefetchInterval = function updateRefetchInterval(nextInterval) {
    var _this7 = this;
    this.clearRefetchInterval();
    this.currentRefetchInterval = nextInterval;
    if (isServer || this.options.enabled === false || !isValidTimeout(this.currentRefetchInterval) || this.currentRefetchInterval === 0) {
      return;
    }
    this.refetchIntervalId = setInterval(function() {
      if (_this7.options.refetchIntervalInBackground || focusManager.isFocused()) {
        _this7.executeFetch();
      }
    }, this.currentRefetchInterval);
  };
  _proto.updateTimers = function updateTimers() {
    this.updateStaleTimeout();
    this.updateRefetchInterval(this.computeRefetchInterval());
  };
  _proto.clearTimers = function clearTimers() {
    this.clearStaleTimeout();
    this.clearRefetchInterval();
  };
  _proto.clearStaleTimeout = function clearStaleTimeout() {
    clearTimeout(this.staleTimeoutId);
    this.staleTimeoutId = void 0;
  };
  _proto.clearRefetchInterval = function clearRefetchInterval() {
    clearInterval(this.refetchIntervalId);
    this.refetchIntervalId = void 0;
  };
  _proto.createResult = function createResult(query, options) {
    var prevQuery = this.currentQuery;
    var prevOptions = this.options;
    var prevResult = this.currentResult;
    var prevResultState = this.currentResultState;
    var prevResultOptions = this.currentResultOptions;
    var queryChange = query !== prevQuery;
    var queryInitialState = queryChange ? query.state : this.currentQueryInitialState;
    var prevQueryResult = queryChange ? this.currentResult : this.previousQueryResult;
    var state = query.state;
    var dataUpdatedAt = state.dataUpdatedAt, error2 = state.error, errorUpdatedAt = state.errorUpdatedAt, isFetching = state.isFetching, status2 = state.status;
    var isPreviousData = false;
    var isPlaceholderData = false;
    var data;
    if (options.optimisticResults) {
      var mounted = this.hasListeners();
      var fetchOnMount = !mounted && shouldFetchOnMount(query, options);
      var fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);
      if (fetchOnMount || fetchOptionally) {
        isFetching = true;
        if (!dataUpdatedAt) {
          status2 = "loading";
        }
      }
    }
    if (options.keepPreviousData && !state.dataUpdateCount && (prevQueryResult == null ? void 0 : prevQueryResult.isSuccess) && status2 !== "error") {
      data = prevQueryResult.data;
      dataUpdatedAt = prevQueryResult.dataUpdatedAt;
      status2 = prevQueryResult.status;
      isPreviousData = true;
    } else if (options.select && typeof state.data !== "undefined") {
      if (prevResult && state.data === (prevResultState == null ? void 0 : prevResultState.data) && options.select === this.selectFn) {
        data = this.selectResult;
      } else {
        try {
          this.selectFn = options.select;
          data = options.select(state.data);
          if (options.structuralSharing !== false) {
            data = replaceEqualDeep(prevResult == null ? void 0 : prevResult.data, data);
          }
          this.selectResult = data;
          this.selectError = null;
        } catch (selectError) {
          getLogger().error(selectError);
          this.selectError = selectError;
        }
      }
    } else {
      data = state.data;
    }
    if (typeof options.placeholderData !== "undefined" && typeof data === "undefined" && (status2 === "loading" || status2 === "idle")) {
      var placeholderData;
      if ((prevResult == null ? void 0 : prevResult.isPlaceholderData) && options.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {
        placeholderData = prevResult.data;
      } else {
        placeholderData = typeof options.placeholderData === "function" ? options.placeholderData() : options.placeholderData;
        if (options.select && typeof placeholderData !== "undefined") {
          try {
            placeholderData = options.select(placeholderData);
            if (options.structuralSharing !== false) {
              placeholderData = replaceEqualDeep(prevResult == null ? void 0 : prevResult.data, placeholderData);
            }
            this.selectError = null;
          } catch (selectError) {
            getLogger().error(selectError);
            this.selectError = selectError;
          }
        }
      }
      if (typeof placeholderData !== "undefined") {
        status2 = "success";
        data = placeholderData;
        isPlaceholderData = true;
      }
    }
    if (this.selectError) {
      error2 = this.selectError;
      data = this.selectResult;
      errorUpdatedAt = Date.now();
      status2 = "error";
    }
    var result = {
      status: status2,
      isLoading: status2 === "loading",
      isSuccess: status2 === "success",
      isError: status2 === "error",
      isIdle: status2 === "idle",
      data,
      dataUpdatedAt,
      error: error2,
      errorUpdatedAt,
      failureCount: state.fetchFailureCount,
      errorUpdateCount: state.errorUpdateCount,
      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,
      isFetchedAfterMount: state.dataUpdateCount > queryInitialState.dataUpdateCount || state.errorUpdateCount > queryInitialState.errorUpdateCount,
      isFetching,
      isRefetching: isFetching && status2 !== "loading",
      isLoadingError: status2 === "error" && state.dataUpdatedAt === 0,
      isPlaceholderData,
      isPreviousData,
      isRefetchError: status2 === "error" && state.dataUpdatedAt !== 0,
      isStale: isStale(query, options),
      refetch: this.refetch,
      remove: this.remove
    };
    return result;
  };
  _proto.shouldNotifyListeners = function shouldNotifyListeners(result, prevResult) {
    if (!prevResult) {
      return true;
    }
    var _this$options = this.options, notifyOnChangeProps = _this$options.notifyOnChangeProps, notifyOnChangePropsExclusions = _this$options.notifyOnChangePropsExclusions;
    if (!notifyOnChangeProps && !notifyOnChangePropsExclusions) {
      return true;
    }
    if (notifyOnChangeProps === "tracked" && !this.trackedProps.length) {
      return true;
    }
    var includedProps = notifyOnChangeProps === "tracked" ? this.trackedProps : notifyOnChangeProps;
    return Object.keys(result).some(function(key) {
      var typedKey = key;
      var changed = result[typedKey] !== prevResult[typedKey];
      var isIncluded = includedProps == null ? void 0 : includedProps.some(function(x2) {
        return x2 === key;
      });
      var isExcluded = notifyOnChangePropsExclusions == null ? void 0 : notifyOnChangePropsExclusions.some(function(x2) {
        return x2 === key;
      });
      return changed && !isExcluded && (!includedProps || isIncluded);
    });
  };
  _proto.updateResult = function updateResult(notifyOptions) {
    var prevResult = this.currentResult;
    this.currentResult = this.createResult(this.currentQuery, this.options);
    this.currentResultState = this.currentQuery.state;
    this.currentResultOptions = this.options;
    if (shallowEqualObjects(this.currentResult, prevResult)) {
      return;
    }
    var defaultNotifyOptions = {
      cache: true
    };
    if ((notifyOptions == null ? void 0 : notifyOptions.listeners) !== false && this.shouldNotifyListeners(this.currentResult, prevResult)) {
      defaultNotifyOptions.listeners = true;
    }
    this.notify(_extends({}, defaultNotifyOptions, notifyOptions));
  };
  _proto.updateQuery = function updateQuery() {
    var query = this.client.getQueryCache().build(this.client, this.options);
    if (query === this.currentQuery) {
      return;
    }
    var prevQuery = this.currentQuery;
    this.currentQuery = query;
    this.currentQueryInitialState = query.state;
    this.previousQueryResult = this.currentResult;
    if (this.hasListeners()) {
      prevQuery == null ? void 0 : prevQuery.removeObserver(this);
      query.addObserver(this);
    }
  };
  _proto.onQueryUpdate = function onQueryUpdate(action) {
    var notifyOptions = {};
    if (action.type === "success") {
      notifyOptions.onSuccess = true;
    } else if (action.type === "error" && !isCancelledError(action.error)) {
      notifyOptions.onError = true;
    }
    this.updateResult(notifyOptions);
    if (this.hasListeners()) {
      this.updateTimers();
    }
  };
  _proto.notify = function notify(notifyOptions) {
    var _this8 = this;
    notifyManager.batch(function() {
      if (notifyOptions.onSuccess) {
        _this8.options.onSuccess == null ? void 0 : _this8.options.onSuccess(_this8.currentResult.data);
        _this8.options.onSettled == null ? void 0 : _this8.options.onSettled(_this8.currentResult.data, null);
      } else if (notifyOptions.onError) {
        _this8.options.onError == null ? void 0 : _this8.options.onError(_this8.currentResult.error);
        _this8.options.onSettled == null ? void 0 : _this8.options.onSettled(void 0, _this8.currentResult.error);
      }
      if (notifyOptions.listeners) {
        _this8.listeners.forEach(function(listener) {
          listener(_this8.currentResult);
        });
      }
      if (notifyOptions.cache) {
        _this8.client.getQueryCache().notify({
          query: _this8.currentQuery,
          type: "observerResultsUpdated"
        });
      }
    });
  };
  return QueryObserver2;
}(Subscribable);
function shouldLoadOnMount(query, options) {
  return options.enabled !== false && !query.state.dataUpdatedAt && !(query.state.status === "error" && options.retryOnMount === false);
}
function shouldFetchOnMount(query, options) {
  return shouldLoadOnMount(query, options) || query.state.dataUpdatedAt > 0 && shouldFetchOn(query, options, options.refetchOnMount);
}
function shouldFetchOn(query, options, field) {
  if (options.enabled !== false) {
    var value = typeof field === "function" ? field(query) : field;
    return value === "always" || value !== false && isStale(query, options);
  }
  return false;
}
function shouldFetchOptionally(query, prevQuery, options, prevOptions) {
  return options.enabled !== false && (query !== prevQuery || prevOptions.enabled === false) && (!options.suspense || query.state.status !== "error") && isStale(query, options);
}
function isStale(query, options) {
  return query.isStaleByTime(options.staleTime);
}
var MutationObserver$1 = /* @__PURE__ */ function(_Subscribable) {
  _inheritsLoose(MutationObserver2, _Subscribable);
  function MutationObserver2(client, options) {
    var _this;
    _this = _Subscribable.call(this) || this;
    _this.client = client;
    _this.setOptions(options);
    _this.bindMethods();
    _this.updateResult();
    return _this;
  }
  var _proto = MutationObserver2.prototype;
  _proto.bindMethods = function bindMethods() {
    this.mutate = this.mutate.bind(this);
    this.reset = this.reset.bind(this);
  };
  _proto.setOptions = function setOptions(options) {
    this.options = this.client.defaultMutationOptions(options);
  };
  _proto.onUnsubscribe = function onUnsubscribe() {
    if (!this.listeners.length) {
      var _this$currentMutation;
      (_this$currentMutation = this.currentMutation) == null ? void 0 : _this$currentMutation.removeObserver(this);
    }
  };
  _proto.onMutationUpdate = function onMutationUpdate(action) {
    this.updateResult();
    var notifyOptions = {
      listeners: true
    };
    if (action.type === "success") {
      notifyOptions.onSuccess = true;
    } else if (action.type === "error") {
      notifyOptions.onError = true;
    }
    this.notify(notifyOptions);
  };
  _proto.getCurrentResult = function getCurrentResult() {
    return this.currentResult;
  };
  _proto.reset = function reset() {
    this.currentMutation = void 0;
    this.updateResult();
    this.notify({
      listeners: true
    });
  };
  _proto.mutate = function mutate(variables, options) {
    this.mutateOptions = options;
    if (this.currentMutation) {
      this.currentMutation.removeObserver(this);
    }
    this.currentMutation = this.client.getMutationCache().build(this.client, _extends({}, this.options, {
      variables: typeof variables !== "undefined" ? variables : this.options.variables
    }));
    this.currentMutation.addObserver(this);
    return this.currentMutation.execute();
  };
  _proto.updateResult = function updateResult() {
    var state = this.currentMutation ? this.currentMutation.state : getDefaultState();
    var result = _extends({}, state, {
      isLoading: state.status === "loading",
      isSuccess: state.status === "success",
      isError: state.status === "error",
      isIdle: state.status === "idle",
      mutate: this.mutate,
      reset: this.reset
    });
    this.currentResult = result;
  };
  _proto.notify = function notify(options) {
    var _this2 = this;
    notifyManager.batch(function() {
      if (_this2.mutateOptions) {
        if (options.onSuccess) {
          _this2.mutateOptions.onSuccess == null ? void 0 : _this2.mutateOptions.onSuccess(_this2.currentResult.data, _this2.currentResult.variables, _this2.currentResult.context);
          _this2.mutateOptions.onSettled == null ? void 0 : _this2.mutateOptions.onSettled(_this2.currentResult.data, null, _this2.currentResult.variables, _this2.currentResult.context);
        } else if (options.onError) {
          _this2.mutateOptions.onError == null ? void 0 : _this2.mutateOptions.onError(_this2.currentResult.error, _this2.currentResult.variables, _this2.currentResult.context);
          _this2.mutateOptions.onSettled == null ? void 0 : _this2.mutateOptions.onSettled(void 0, _this2.currentResult.error, _this2.currentResult.variables, _this2.currentResult.context);
        }
      }
      if (options.listeners) {
        _this2.listeners.forEach(function(listener) {
          listener(_this2.currentResult);
        });
      }
    });
  };
  return MutationObserver2;
}(Subscribable);
var unstable_batchedUpdates = xn.unstable_batchedUpdates;
notifyManager.setBatchNotifyFunction(unstable_batchedUpdates);
var logger = console;
setLogger(logger);
var defaultContext = /* @__PURE__ */ xn.createContext(void 0);
var QueryClientSharingContext = /* @__PURE__ */ xn.createContext(false);
function getQueryClientContext(contextSharing) {
  if (contextSharing && typeof window !== "undefined") {
    if (!window.ReactQueryClientContext) {
      window.ReactQueryClientContext = defaultContext;
    }
    return window.ReactQueryClientContext;
  }
  return defaultContext;
}
var useQueryClient = function useQueryClient2() {
  var queryClient = xn.useContext(getQueryClientContext(xn.useContext(QueryClientSharingContext)));
  if (!queryClient) {
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  }
  return queryClient;
};
var QueryClientProvider = function QueryClientProvider2(_ref3) {
  var client = _ref3.client, _ref$contextSharing = _ref3.contextSharing, contextSharing = _ref$contextSharing === void 0 ? false : _ref$contextSharing, children = _ref3.children;
  xn.useEffect(function() {
    client.mount();
    return function() {
      client.unmount();
    };
  }, [client]);
  var Context2 = getQueryClientContext(contextSharing);
  return /* @__PURE__ */ xn.createElement(QueryClientSharingContext.Provider, {
    value: contextSharing
  }, /* @__PURE__ */ xn.createElement(Context2.Provider, {
    value: client
  }, children));
};
function createValue() {
  var _isReset = false;
  return {
    clearReset: function clearReset() {
      _isReset = false;
    },
    reset: function reset() {
      _isReset = true;
    },
    isReset: function isReset() {
      return _isReset;
    }
  };
}
var QueryErrorResetBoundaryContext = /* @__PURE__ */ xn.createContext(createValue());
var useQueryErrorResetBoundary = function useQueryErrorResetBoundary2() {
  return xn.useContext(QueryErrorResetBoundaryContext);
};
function shouldThrowError(suspense, _useErrorBoundary, params) {
  if (typeof _useErrorBoundary === "function") {
    return _useErrorBoundary.apply(void 0, params);
  }
  if (typeof _useErrorBoundary === "boolean") return _useErrorBoundary;
  return !!suspense;
}
function useMutation(arg1, arg2, arg3) {
  var mountedRef = xn.useRef(false);
  var _React$useState = xn.useState(0), forceUpdate = _React$useState[1];
  var options = parseMutationArgs(arg1, arg2, arg3);
  var queryClient = useQueryClient();
  var obsRef = xn.useRef();
  if (!obsRef.current) {
    obsRef.current = new MutationObserver$1(queryClient, options);
  } else {
    obsRef.current.setOptions(options);
  }
  var currentResult = obsRef.current.getCurrentResult();
  xn.useEffect(function() {
    mountedRef.current = true;
    var unsubscribe = obsRef.current.subscribe(notifyManager.batchCalls(function() {
      if (mountedRef.current) {
        forceUpdate(function(x2) {
          return x2 + 1;
        });
      }
    }));
    return function() {
      mountedRef.current = false;
      unsubscribe();
    };
  }, []);
  var mutate = xn.useCallback(function(variables, mutateOptions) {
    obsRef.current.mutate(variables, mutateOptions).catch(noop$2);
  }, []);
  if (currentResult.error && shouldThrowError(void 0, obsRef.current.options.useErrorBoundary, [currentResult.error])) {
    throw currentResult.error;
  }
  return _extends({}, currentResult, {
    mutate,
    mutateAsync: currentResult.mutate
  });
}
function useBaseQuery(options, Observer) {
  var mountedRef = xn.useRef(false);
  var _React$useState = xn.useState(0), forceUpdate = _React$useState[1];
  var queryClient = useQueryClient();
  var errorResetBoundary = useQueryErrorResetBoundary();
  var defaultedOptions = queryClient.defaultQueryObserverOptions(options);
  defaultedOptions.optimisticResults = true;
  if (defaultedOptions.onError) {
    defaultedOptions.onError = notifyManager.batchCalls(defaultedOptions.onError);
  }
  if (defaultedOptions.onSuccess) {
    defaultedOptions.onSuccess = notifyManager.batchCalls(defaultedOptions.onSuccess);
  }
  if (defaultedOptions.onSettled) {
    defaultedOptions.onSettled = notifyManager.batchCalls(defaultedOptions.onSettled);
  }
  if (defaultedOptions.suspense) {
    if (typeof defaultedOptions.staleTime !== "number") {
      defaultedOptions.staleTime = 1e3;
    }
    if (defaultedOptions.cacheTime === 0) {
      defaultedOptions.cacheTime = 1;
    }
  }
  if (defaultedOptions.suspense || defaultedOptions.useErrorBoundary) {
    if (!errorResetBoundary.isReset()) {
      defaultedOptions.retryOnMount = false;
    }
  }
  var _React$useState2 = xn.useState(function() {
    return new Observer(queryClient, defaultedOptions);
  }), observer = _React$useState2[0];
  var result = observer.getOptimisticResult(defaultedOptions);
  xn.useEffect(function() {
    mountedRef.current = true;
    errorResetBoundary.clearReset();
    var unsubscribe = observer.subscribe(notifyManager.batchCalls(function() {
      if (mountedRef.current) {
        forceUpdate(function(x2) {
          return x2 + 1;
        });
      }
    }));
    observer.updateResult();
    return function() {
      mountedRef.current = false;
      unsubscribe();
    };
  }, [errorResetBoundary, observer]);
  xn.useEffect(function() {
    observer.setOptions(defaultedOptions, {
      listeners: false
    });
  }, [defaultedOptions, observer]);
  if (defaultedOptions.suspense && result.isLoading) {
    throw observer.fetchOptimistic(defaultedOptions).then(function(_ref3) {
      var data = _ref3.data;
      defaultedOptions.onSuccess == null ? void 0 : defaultedOptions.onSuccess(data);
      defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(data, null);
    }).catch(function(error2) {
      errorResetBoundary.clearReset();
      defaultedOptions.onError == null ? void 0 : defaultedOptions.onError(error2);
      defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(void 0, error2);
    });
  }
  if (result.isError && !errorResetBoundary.isReset() && !result.isFetching && shouldThrowError(defaultedOptions.suspense, defaultedOptions.useErrorBoundary, [result.error, observer.getCurrentQuery()])) {
    throw result.error;
  }
  if (defaultedOptions.notifyOnChangeProps === "tracked") {
    result = observer.trackResult(result, defaultedOptions);
  }
  return result;
}
function useQuery(arg1, arg2, arg3) {
  var parsedOptions = parseQueryArgs(arg1, arg2, arg3);
  return useBaseQuery(parsedOptions, QueryObserver);
}
var TRACKING_EVENTS = {
  PAGE_CAMPAIGN_REPORTS: "page_campaign_reports",
  UPDATED_ORGANIZATION: "updated_organization",
  CREATED_APP: "created_app",
  SIGNED_UP: "signed_up",
  SIGNED_IN: "signed_in",
  UPDATED_USER_PROFILE: "updated_user_profile",
  OPENED_USER_PROFILE: "opened_user_profile",
  CREATED_CAMPAIGN: "created_campaign",
  PUBLISHED_CAMPAIGN: "published_campaign",
  INVITED_MEMBER: "invited_member",
  UPDATED_CAMPAIGN_STATUS: "updated_campaign_status",
  UPDATED_CAMPAIGN: "updated_campaign",
  CREATED_SEGMENT: "created_segment",
  LAUNCHED_EXPORT: "launched_export",
  IMPORT_WALLETS_FROM_CSV: "import_wallets_from_csv",
  CREATE_SHOPIFY_ORGANIZATION: "create_shopify_organization",
  START_ASSISTANT_CONVERSATION: "user_started_conversation",
  ADD_TO_CART: "user_added_to_cart_from_assistant",
  ADDED_TO_CART: "user_added_to_cart",
  USER_SEND_MESSAGE: "user_sent_message",
  USER_ASKED_QUESTION: "user_asked_question",
  USER_SENT_CUSTOM_MESSAGE: "user_sent_custom_message",
  USER_RECORDED_MESSAGE: "user_recorded_message",
  USER_CLICKED_SUGGESTION: "user_clicked_product_suggestion",
  USER_OPENED_RECOMMENDATION: "user_opened_recommendation",
  USER_SENT_MODAL_MESSAGE: "user_sent_modal_message",
  SHOPIFY_APP_UNINSTALLED: "shopify_app_uninstalled",
  NEW_SESSION: "new_session",
  CONVERSATION_LIMIT_REACHED: "conversation_limit_reached",
  ONBOARDING_GET_STARTED: "onboarding_get_started",
  ONBOARDING_METAFIELDS: "onboarding_metafields",
  ONBOARDING_BUSINESS: "onboarding_business",
  ONBOARDING_BUSINESS_SKILLS: "onboarding_business_skills",
  ONBOARDING_UPLOAD_DOCUMENTS: "onboarding_upload_documents",
  ONBOARDING_COMPLETED: "onboarding_completed",
  USAGE_STEP: "usage_step",
  USER_SUBMITTED_CHECKOUT: "user_submitted_checkout",
  APP_SUBSCRIPTION_UPDATED: "app_subscription_updated"
};
var buffer = {};
var base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code$5 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i = 0, len = code$5.length; i < len; ++i) {
  lookup[i] = code$5[i];
  revLookup[code$5.charCodeAt(i)] = i;
}
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1) validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;
  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 255;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start2, end) {
  var tmp;
  var output = [];
  for (var i = start2; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(
      lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
    );
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(
      lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
    );
  }
  return parts.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(buffer2, offset, isLE, mLen, nBytes) {
  var e2, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d2 = isLE ? -1 : 1;
  var s2 = buffer2[offset + i];
  i += d2;
  e2 = s2 & (1 << -nBits) - 1;
  s2 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e2 = e2 * 256 + buffer2[offset + i], i += d2, nBits -= 8) {
  }
  m2 = e2 & (1 << -nBits) - 1;
  e2 >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m2 = m2 * 256 + buffer2[offset + i], i += d2, nBits -= 8) {
  }
  if (e2 === 0) {
    e2 = 1 - eBias;
  } else if (e2 === eMax) {
    return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e2 = e2 - eBias;
  }
  return (s2 ? -1 : 1) * m2 * Math.pow(2, e2 - mLen);
};
ieee754.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
  var e2, m2, c6;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt2 = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d2 = isLE ? 1 : -1;
  var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m2 = isNaN(value) ? 1 : 0;
    e2 = eMax;
  } else {
    e2 = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c6 = Math.pow(2, -e2)) < 1) {
      e2--;
      c6 *= 2;
    }
    if (e2 + eBias >= 1) {
      value += rt2 / c6;
    } else {
      value += rt2 * Math.pow(2, 1 - eBias);
    }
    if (value * c6 >= 2) {
      e2++;
      c6 /= 2;
    }
    if (e2 + eBias >= eMax) {
      m2 = 0;
      e2 = eMax;
    } else if (e2 + eBias >= 1) {
      m2 = (value * c6 - 1) * Math.pow(2, mLen);
      e2 = e2 + eBias;
    } else {
      m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e2 = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset + i] = m2 & 255, i += d2, m2 /= 256, mLen -= 8) {
  }
  e2 = e2 << mLen | m2;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset + i] = e2 & 255, i += d2, e2 /= 256, eLen -= 8) {
  }
  buffer2[offset + i - d2] |= s2 * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(exports) {
  var base64 = base64Js;
  var ieee754$1 = ieee754;
  var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports.Buffer = Buffer2;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;
  var K_MAX_LENGTH = 2147483647;
  exports.kMaxLength = K_MAX_LENGTH;
  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
  }
  function typedArraySupport() {
    try {
      var arr = new Uint8Array(1);
      var proto = { foo: function() {
        return 42;
      } };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e2) {
      return false;
    }
  }
  Object.defineProperty(Buffer2.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this)) return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer2.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this)) return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length2) {
    if (length2 > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length2 + '" is invalid for option "size"');
    }
    var buf = new Uint8Array(length2);
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function Buffer2(arg, encodingOrOffset, length2) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      }
      return allocUnsafe(arg);
    }
    return from2(arg, encodingOrOffset, length2);
  }
  Buffer2.poolSize = 8192;
  function from2(value, encodingOrOffset, length2) {
    if (typeof value === "string") {
      return fromString(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length2);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length2);
    }
    if (typeof value === "number") {
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    }
    var valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer2.from(valueOf, encodingOrOffset, length2);
    }
    var b2 = fromObject(value);
    if (b2) return b2;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer2.from(
        value[Symbol.toPrimitive]("string"),
        encodingOrOffset,
        length2
      );
    }
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
    );
  }
  Buffer2.from = function(value, encodingOrOffset, length2) {
    return from2(value, encodingOrOffset, length2);
  };
  Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer2, Uint8Array);
  function assertSize(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
  }
  function alloc2(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(size);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    }
    return createBuffer(size);
  }
  Buffer2.alloc = function(size, fill, encoding) {
    return alloc2(size, fill, encoding);
  };
  function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
  }
  Buffer2.allocUnsafe = function(size) {
    return allocUnsafe(size);
  };
  Buffer2.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
  };
  function fromString(string2, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    var length2 = byteLength2(string2, encoding) | 0;
    var buf = createBuffer(length2);
    var actual = buf.write(string2, encoding);
    if (actual !== length2) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    var length2 = array.length < 0 ? 0 : checked(array.length) | 0;
    var buf = createBuffer(length2);
    for (var i = 0; i < length2; i += 1) {
      buf[i] = array[i] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      var copy2 = new Uint8Array(arrayView);
      return fromArrayBuffer(copy2.buffer, copy2.byteOffset, copy2.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length2) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length2 || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    var buf;
    if (byteOffset === void 0 && length2 === void 0) {
      buf = new Uint8Array(array);
    } else if (length2 === void 0) {
      buf = new Uint8Array(array, byteOffset);
    } else {
      buf = new Uint8Array(array, byteOffset, length2);
    }
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer2.isBuffer(obj)) {
      var len = checked(obj.length) | 0;
      var buf = createBuffer(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length2) {
    if (length2 >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length2 | 0;
  }
  function SlowBuffer(length2) {
    if (+length2 != length2) {
      length2 = 0;
    }
    return Buffer2.alloc(+length2);
  }
  Buffer2.isBuffer = function isBuffer2(b2) {
    return b2 != null && b2._isBuffer === true && b2 !== Buffer2.prototype;
  };
  Buffer2.compare = function compare(a2, b2) {
    if (isInstance(a2, Uint8Array)) a2 = Buffer2.from(a2, a2.offset, a2.byteLength);
    if (isInstance(b2, Uint8Array)) b2 = Buffer2.from(b2, b2.offset, b2.byteLength);
    if (!Buffer2.isBuffer(a2) || !Buffer2.isBuffer(b2)) {
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    }
    if (a2 === b2) return 0;
    var x2 = a2.length;
    var y2 = b2.length;
    for (var i = 0, len = Math.min(x2, y2); i < len; ++i) {
      if (a2[i] !== b2[i]) {
        x2 = a2[i];
        y2 = b2[i];
        break;
      }
    }
    if (x2 < y2) return -1;
    if (y2 < x2) return 1;
    return 0;
  };
  Buffer2.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function concat(list2, length2) {
    if (!Array.isArray(list2)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list2.length === 0) {
      return Buffer2.alloc(0);
    }
    var i;
    if (length2 === void 0) {
      length2 = 0;
      for (i = 0; i < list2.length; ++i) {
        length2 += list2[i].length;
      }
    }
    var buffer2 = Buffer2.allocUnsafe(length2);
    var pos = 0;
    for (i = 0; i < list2.length; ++i) {
      var buf = list2[i];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer2.length) {
          Buffer2.from(buf).copy(buffer2, pos);
        } else {
          Uint8Array.prototype.set.call(
            buffer2,
            buf,
            pos
          );
        }
      } else if (!Buffer2.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength2(string2, encoding) {
    if (Buffer2.isBuffer(string2)) {
      return string2.length;
    }
    if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {
      return string2.byteLength;
    }
    if (typeof string2 !== "string") {
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string2
      );
    }
    var len = string2.length;
    var mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
          return utf8ToBytes(string2).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string2).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string2).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.byteLength = byteLength2;
  function slowToString(encoding, start2, end) {
    var loweredCase = false;
    if (start2 === void 0 || start2 < 0) {
      start2 = 0;
    }
    if (start2 > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start2 >>>= 0;
    if (end <= start2) {
      return "";
    }
    if (!encoding) encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start2, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start2, end);
        case "ascii":
          return asciiSlice(this, start2, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start2, end);
        case "base64":
          return base64Slice(this, start2, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start2, end);
        default:
          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.prototype._isBuffer = true;
  function swap(b2, n2, m2) {
    var i = b2[n2];
    b2[n2] = b2[m2];
    b2[m2] = i;
  }
  Buffer2.prototype.swap16 = function swap16() {
    var len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (var i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }
    return this;
  };
  Buffer2.prototype.swap32 = function swap32() {
    var len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (var i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }
    return this;
  };
  Buffer2.prototype.swap64 = function swap64() {
    var len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (var i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }
    return this;
  };
  Buffer2.prototype.toString = function toString3() {
    var length2 = this.length;
    if (length2 === 0) return "";
    if (arguments.length === 0) return utf8Slice(this, 0, length2);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
  Buffer2.prototype.equals = function equals(b2) {
    if (!Buffer2.isBuffer(b2)) throw new TypeError("Argument must be a Buffer");
    if (this === b2) return true;
    return Buffer2.compare(this, b2) === 0;
  };
  Buffer2.prototype.inspect = function inspect() {
    var str = "";
    var max = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
  }
  Buffer2.prototype.compare = function compare(target, start2, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer2.from(target, target.offset, target.byteLength);
    }
    if (!Buffer2.isBuffer(target)) {
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
      );
    }
    if (start2 === void 0) {
      start2 = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start2 < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start2 >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start2 >= end) {
      return 1;
    }
    start2 >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    var x2 = thisEnd - thisStart;
    var y2 = end - start2;
    var len = Math.min(x2, y2);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start2, end);
    for (var i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x2 = thisCopy[i];
        y2 = targetCopy[i];
        break;
      }
    }
    if (x2 < y2) return -1;
    if (y2 < x2) return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0) return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0) byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir) return -1;
      else byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;
      else return -1;
    }
    if (typeof val === "string") {
      val = Buffer2.from(val, encoding);
    }
    if (Buffer2.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read(buf, i2) {
      if (indexSize === 1) {
        return buf[i2];
      } else {
        return buf.readUInt16BE(i2 * indexSize);
      }
    }
    var i;
    if (dir) {
      var foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) foundIndex = i;
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1) i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        var found = true;
        for (var j2 = 0; j2 < valLength; j2++) {
          if (read(arr, i + j2) !== read(val, j2)) {
            found = false;
            break;
          }
        }
        if (found) return i;
      }
    }
    return -1;
  }
  Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string2, offset, length2) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length2) {
      length2 = remaining;
    } else {
      length2 = Number(length2);
      if (length2 > remaining) {
        length2 = remaining;
      }
    }
    var strLen = string2.length;
    if (length2 > strLen / 2) {
      length2 = strLen / 2;
    }
    for (var i = 0; i < length2; ++i) {
      var parsed = parseInt(string2.substr(i * 2, 2), 16);
      if (numberIsNaN(parsed)) return i;
      buf[offset + i] = parsed;
    }
    return i;
  }
  function utf8Write(buf, string2, offset, length2) {
    return blitBuffer(utf8ToBytes(string2, buf.length - offset), buf, offset, length2);
  }
  function asciiWrite(buf, string2, offset, length2) {
    return blitBuffer(asciiToBytes(string2), buf, offset, length2);
  }
  function base64Write(buf, string2, offset, length2) {
    return blitBuffer(base64ToBytes(string2), buf, offset, length2);
  }
  function ucs2Write(buf, string2, offset, length2) {
    return blitBuffer(utf16leToBytes(string2, buf.length - offset), buf, offset, length2);
  }
  Buffer2.prototype.write = function write(string2, offset, length2, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length2 = this.length;
      offset = 0;
    } else if (length2 === void 0 && typeof offset === "string") {
      encoding = offset;
      length2 = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length2)) {
        length2 = length2 >>> 0;
        if (encoding === void 0) encoding = "utf8";
      } else {
        encoding = length2;
        length2 = void 0;
      }
    } else {
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    }
    var remaining = this.length - offset;
    if (length2 === void 0 || length2 > remaining) length2 = remaining;
    if (string2.length > 0 && (length2 < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding) encoding = "utf8";
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string2, offset, length2);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string2, offset, length2);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string2, offset, length2);
        case "base64":
          return base64Write(this, string2, offset, length2);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string2, offset, length2);
        default:
          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer2.prototype.toJSON = function toJSON2() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start2, end) {
    if (start2 === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start2, end));
    }
  }
  function utf8Slice(buf, start2, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start2;
    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  var MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    var res = "";
    var i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res;
  }
  function asciiSlice(buf, start2, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for (var i = start2; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start2, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for (var i = start2; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  function hexSlice(buf, start2, end) {
    var len = buf.length;
    if (!start2 || start2 < 0) start2 = 0;
    if (!end || end < 0 || end > len) end = len;
    var out = "";
    for (var i = start2; i < end; ++i) {
      out += hexSliceLookupTable[buf[i]];
    }
    return out;
  }
  function utf16leSlice(buf, start2, end) {
    var bytes = buf.slice(start2, end);
    var res = "";
    for (var i = 0; i < bytes.length - 1; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
  }
  Buffer2.prototype.slice = function slice2(start2, end) {
    var len = this.length;
    start2 = ~~start2;
    end = end === void 0 ? len : ~~end;
    if (start2 < 0) {
      start2 += len;
      if (start2 < 0) start2 = 0;
    } else if (start2 > len) {
      start2 = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start2) end = start2;
    var newBuf = this.subarray(start2, end);
    Object.setPrototypeOf(newBuf, Buffer2.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length2) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
    if (offset + ext > length2) throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength3, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val += this[offset + i] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength3, this.length);
    }
    var val = this[offset + --byteLength3];
    var mul = 1;
    while (byteLength3 > 0 && (mul *= 256)) {
      val += this[offset + --byteLength3] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength3, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val += this[offset + i] * mul;
    }
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength3, this.length);
    var i = byteLength3;
    var mul = 1;
    var val = this[offset + --i];
    while (i > 0 && (mul *= 256)) {
      val += this[offset + --i] * mul;
    }
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128)) return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer2.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
  }
  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    var mul = 1;
    var i = 0;
    this[offset] = value & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      this[offset + i] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    var i = byteLength3 - 1;
    var mul = 1;
    this[offset + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      this[offset + i] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    var i = byteLength3 - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
    if (value < 0) value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0) value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
    if (offset < 0) throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer2.prototype.copy = function copy2(target, targetStart, start2, end) {
    if (!Buffer2.isBuffer(target)) throw new TypeError("argument should be a Buffer");
    if (!start2) start2 = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start2) end = start2;
    if (end === start2) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start2 < 0 || start2 >= this.length) throw new RangeError("Index out of range");
    if (end < 0) throw new RangeError("sourceEnd out of bounds");
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start2) {
      end = target.length - targetStart + start2;
    }
    var len = end - start2;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start2, end);
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start2, end),
        targetStart
      );
    }
    return len;
  };
  Buffer2.prototype.fill = function fill(val, start2, end, encoding) {
    if (typeof val === "string") {
      if (typeof start2 === "string") {
        encoding = start2;
        start2 = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        var code2 = val.charCodeAt(0);
        if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
          val = code2;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start2 < 0 || this.length < start2 || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start2) {
      return this;
    }
    start2 = start2 >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val) val = 0;
    var i;
    if (typeof val === "number") {
      for (i = start2; i < end; ++i) {
        this[i] = val;
      }
    } else {
      var bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
      var len = bytes.length;
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i = 0; i < end - start2; ++i) {
        this[i + start2] = bytes[i % len];
      }
    }
    return this;
  };
  var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2) return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes(string2, units) {
    units = units || Infinity;
    var codePoint;
    var length2 = string2.length;
    var leadSurrogate = null;
    var bytes = [];
    for (var i = 0; i < length2; ++i) {
      codePoint = string2.charCodeAt(i);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            continue;
          } else if (i + 1 === length2) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1) bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0) break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0) break;
        bytes.push(
          codePoint >> 6 | 192,
          codePoint & 63 | 128
        );
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0) break;
        bytes.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0) break;
        bytes.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      byteArray.push(str.charCodeAt(i) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    var c6, hi2, lo2;
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0) break;
      c6 = str.charCodeAt(i);
      hi2 = c6 >> 8;
      lo2 = c6 % 256;
      byteArray.push(lo2);
      byteArray.push(hi2);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length2) {
    for (var i = 0; i < length2; ++i) {
      if (i + offset >= dst.length || i >= src.length) break;
      dst[i + offset] = src[i];
    }
    return i;
  }
  function isInstance(obj, type2) {
    return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  var hexSliceLookupTable = function() {
    var alphabet = "0123456789abcdef";
    var table2 = new Array(256);
    for (var i = 0; i < 16; ++i) {
      var i16 = i * 16;
      for (var j2 = 0; j2 < 16; ++j2) {
        table2[i16 + j2] = alphabet[i] + alphabet[j2];
      }
    }
    return table2;
  }();
})(buffer);
var process$1 = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var browser$1 = { exports: {} };
  var process2 = browser$1.exports = {};
  var cachedSetTimeout;
  var cachedClearTimeout;
  function defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
  }
  function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
  }
  (function() {
    try {
      if (typeof setTimeout === "function") {
        cachedSetTimeout = setTimeout;
      } else {
        cachedSetTimeout = defaultSetTimout;
      }
    } catch (e2) {
      cachedSetTimeout = defaultSetTimout;
    }
    try {
      if (typeof clearTimeout === "function") {
        cachedClearTimeout = clearTimeout;
      } else {
        cachedClearTimeout = defaultClearTimeout;
      }
    } catch (e2) {
      cachedClearTimeout = defaultClearTimeout;
    }
  })();
  function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
      return setTimeout(fun, 0);
    }
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
      cachedSetTimeout = setTimeout;
      return setTimeout(fun, 0);
    }
    try {
      return cachedSetTimeout(fun, 0);
    } catch (e2) {
      try {
        return cachedSetTimeout.call(null, fun, 0);
      } catch (e22) {
        return cachedSetTimeout.call(this, fun, 0);
      }
    }
  }
  function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
      return clearTimeout(marker);
    }
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
      cachedClearTimeout = clearTimeout;
      return clearTimeout(marker);
    }
    try {
      return cachedClearTimeout(marker);
    } catch (e2) {
      try {
        return cachedClearTimeout.call(null, marker);
      } catch (e22) {
        return cachedClearTimeout.call(this, marker);
      }
    }
  }
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;
  function cleanUpNextTick() {
    if (!draining || !currentQueue) {
      return;
    }
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length) {
      drainQueue();
    }
  }
  function drainQueue() {
    if (draining) {
      return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
  }
  process2.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
      runTimeout(drainQueue);
    }
  };
  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  Item.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  process2.title = "browser";
  process2.browser = true;
  process2.env = {};
  process2.argv = [];
  process2.version = "";
  process2.versions = {};
  function noop$12() {
  }
  process2.on = noop$12;
  process2.addListener = noop$12;
  process2.once = noop$12;
  process2.off = noop$12;
  process2.removeListener = noop$12;
  process2.removeAllListeners = noop$12;
  process2.emit = noop$12;
  process2.prependListener = noop$12;
  process2.prependOnceListener = noop$12;
  process2.listeners = function(name2) {
    return [];
  };
  process2.binding = function(name2) {
    throw new Error("process.binding is not supported");
  };
  process2.cwd = function() {
    return "/";
  };
  process2.chdir = function(dir) {
    throw new Error("process.chdir is not supported");
  };
  process2.umask = function() {
    return 0;
  };
  function noop2() {
  }
  var browser2 = (
    /** @type {boolean} */
    browser$1.exports.browser
  );
  var emitWarning = noop2;
  var binding = (
    /** @type {Function} */
    browser$1.exports.binding
  );
  var exit2 = noop2;
  var pid = 1;
  var features = {};
  var kill = noop2;
  var dlopen = noop2;
  var uptime = noop2;
  var memoryUsage = noop2;
  var uvCounters = noop2;
  var platform2 = "browser";
  var arch = "browser";
  var execPath = "browser";
  var execArgv = (
    /** @type {string[]} */
    []
  );
  var api = {
    nextTick: browser$1.exports.nextTick,
    title: browser$1.exports.title,
    browser: browser2,
    env: browser$1.exports.env,
    argv: browser$1.exports.argv,
    version: browser$1.exports.version,
    versions: browser$1.exports.versions,
    on: browser$1.exports.on,
    addListener: browser$1.exports.addListener,
    once: browser$1.exports.once,
    off: browser$1.exports.off,
    removeListener: browser$1.exports.removeListener,
    removeAllListeners: browser$1.exports.removeAllListeners,
    emit: browser$1.exports.emit,
    emitWarning,
    prependListener: browser$1.exports.prependListener,
    prependOnceListener: browser$1.exports.prependOnceListener,
    listeners: browser$1.exports.listeners,
    binding,
    cwd: browser$1.exports.cwd,
    chdir: browser$1.exports.chdir,
    umask: browser$1.exports.umask,
    exit: exit2,
    pid,
    features,
    kill,
    dlopen,
    uptime,
    memoryUsage,
    uvCounters,
    platform: platform2,
    arch,
    execPath,
    execArgv
  };
  exports.addListener = browser$1.exports.addListener;
  exports.arch = arch;
  exports.argv = browser$1.exports.argv;
  exports.binding = binding;
  exports.browser = browser2;
  exports.chdir = browser$1.exports.chdir;
  exports.cwd = browser$1.exports.cwd;
  exports["default"] = api;
  exports.dlopen = dlopen;
  exports.emit = browser$1.exports.emit;
  exports.emitWarning = emitWarning;
  exports.env = browser$1.exports.env;
  exports.execArgv = execArgv;
  exports.execPath = execPath;
  exports.exit = exit2;
  exports.features = features;
  exports.kill = kill;
  exports.listeners = browser$1.exports.listeners;
  exports.memoryUsage = memoryUsage;
  exports.nextTick = browser$1.exports.nextTick;
  exports.off = browser$1.exports.off;
  exports.on = browser$1.exports.on;
  exports.once = browser$1.exports.once;
  exports.pid = pid;
  exports.platform = platform2;
  exports.prependListener = browser$1.exports.prependListener;
  exports.prependOnceListener = browser$1.exports.prependOnceListener;
  exports.removeAllListeners = browser$1.exports.removeAllListeners;
  exports.removeListener = browser$1.exports.removeListener;
  exports.title = browser$1.exports.title;
  exports.umask = browser$1.exports.umask;
  exports.uptime = uptime;
  exports.uvCounters = uvCounters;
  exports.version = browser$1.exports.version;
  exports.versions = browser$1.exports.versions;
  exports = module.exports = api;
})(process$1, process$1.exports);
var processExports = process$1.exports;
const process = /* @__PURE__ */ getDefaultExportFromCjs(processExports);
var _globalThis = function(Object2) {
  function get2() {
    var _global3 = this || self;
    delete Object2.prototype.__magic__;
    return _global3;
  }
  if (typeof globalThis === "object") {
    return globalThis;
  }
  if (this) {
    return get2();
  } else {
    Object2.defineProperty(Object2.prototype, "__magic__", {
      configurable: true,
      get: get2
    });
    var _global2 = __magic__;
    return _global2;
  }
}(Object);
var _global$1 = _globalThis;
function isUndefined$1(value) {
  return value === void 0;
}
var isUndefined_1 = isUndefined$1;
const isUndefined3 = /* @__PURE__ */ getDefaultExportFromCjs(isUndefined_1);
var Stack = _Stack, baseIsEqual$1 = _baseIsEqual;
var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function baseIsMatch$1(object, source, matchData, customizer) {
  var index2 = matchData.length, length2 = index2, noCustomizer = !customizer;
  if (object == null) {
    return !length2;
  }
  object = Object(object);
  while (index2--) {
    var data = matchData[index2];
    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }
  while (++index2 < length2) {
    data = matchData[index2];
    var key = data[0], objValue = object[key], srcValue = data[1];
    if (noCustomizer && data[2]) {
      if (objValue === void 0 && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === void 0 ? baseIsEqual$1(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}
var _baseIsMatch = baseIsMatch$1;
var isObject$3 = isObject_1;
function isStrictComparable$2(value) {
  return value === value && !isObject$3(value);
}
var _isStrictComparable = isStrictComparable$2;
var isStrictComparable$1 = _isStrictComparable, keys$1 = keys_1;
function getMatchData$1(object) {
  var result = keys$1(object), length2 = result.length;
  while (length2--) {
    var key = result[length2], value = object[key];
    result[length2] = [key, value, isStrictComparable$1(value)];
  }
  return result;
}
var _getMatchData = getMatchData$1;
function matchesStrictComparable$2(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
  };
}
var _matchesStrictComparable = matchesStrictComparable$2;
var baseIsMatch = _baseIsMatch, getMatchData = _getMatchData, matchesStrictComparable$1 = _matchesStrictComparable;
function baseMatches$1(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable$1(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}
var _baseMatches = baseMatches$1;
var baseGetTag = _baseGetTag, isObjectLike = isObjectLike_1;
var symbolTag = "[object Symbol]";
function isSymbol$3(value) {
  return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
}
var isSymbol_1 = isSymbol$3;
var isArray$6 = isArray_1, isSymbol$2 = isSymbol_1;
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey$3(value, object) {
  if (isArray$6(value)) {
    return false;
  }
  var type2 = typeof value;
  if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol$2(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var _isKey = isKey$3;
var MapCache = _MapCache;
var FUNC_ERROR_TEXT$1 = "Expected a function";
function memoize$1(func, resolver2) {
  if (typeof func != "function" || resolver2 != null && typeof resolver2 != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  var memoized = function() {
    var args = arguments, key = resolver2 ? resolver2.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize$1.Cache || MapCache)();
  return memoized;
}
memoize$1.Cache = MapCache;
var memoize_1 = memoize$1;
var memoize = memoize_1;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped$1(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}
var _memoizeCapped = memoizeCapped$1;
var memoizeCapped = _memoizeCapped;
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath$1 = memoizeCapped(function(string2) {
  var result = [];
  if (string2.charCodeAt(0) === 46) {
    result.push("");
  }
  string2.replace(rePropName, function(match2, number2, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match2);
  });
  return result;
});
var _stringToPath = stringToPath$1;
function arrayMap$2(array, iteratee) {
  var index2 = -1, length2 = array == null ? 0 : array.length, result = Array(length2);
  while (++index2 < length2) {
    result[index2] = iteratee(array[index2], index2, array);
  }
  return result;
}
var _arrayMap = arrayMap$2;
var Symbol$1 = _Symbol, arrayMap$1 = _arrayMap, isArray$5 = isArray_1, isSymbol$1 = isSymbol_1;
var INFINITY$1 = 1 / 0;
var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString$1(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray$5(value)) {
    return arrayMap$1(value, baseToString$1) + "";
  }
  if (isSymbol$1(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
}
var _baseToString = baseToString$1;
var baseToString = _baseToString;
function toString$4(value) {
  return value == null ? "" : baseToString(value);
}
var toString_1 = toString$4;
var isArray$4 = isArray_1, isKey$2 = _isKey, stringToPath = _stringToPath, toString$3 = toString_1;
function castPath$4(value, object) {
  if (isArray$4(value)) {
    return value;
  }
  return isKey$2(value, object) ? [value] : stringToPath(toString$3(value));
}
var _castPath = castPath$4;
var isSymbol = isSymbol_1;
var INFINITY = 1 / 0;
function toKey$5(value) {
  if (typeof value == "string" || isSymbol(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
var _toKey = toKey$5;
var castPath$3 = _castPath, toKey$4 = _toKey;
function baseGet$3(object, path2) {
  path2 = castPath$3(path2, object);
  var index2 = 0, length2 = path2.length;
  while (object != null && index2 < length2) {
    object = object[toKey$4(path2[index2++])];
  }
  return index2 && index2 == length2 ? object : void 0;
}
var _baseGet = baseGet$3;
var baseGet$2 = _baseGet;
function get$1(object, path2, defaultValue) {
  var result = object == null ? void 0 : baseGet$2(object, path2);
  return result === void 0 ? defaultValue : result;
}
var get_1 = get$1;
function baseHasIn$1(object, key) {
  return object != null && key in Object(object);
}
var _baseHasIn = baseHasIn$1;
var castPath$2 = _castPath, isArguments = isArguments_1, isArray$3 = isArray_1, isIndex$1 = _isIndex, isLength = isLength_1, toKey$3 = _toKey;
function hasPath$1(object, path2, hasFunc) {
  path2 = castPath$2(path2, object);
  var index2 = -1, length2 = path2.length, result = false;
  while (++index2 < length2) {
    var key = toKey$3(path2[index2]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index2 != length2) {
    return result;
  }
  length2 = object == null ? 0 : object.length;
  return !!length2 && isLength(length2) && isIndex$1(key, length2) && (isArray$3(object) || isArguments(object));
}
var _hasPath = hasPath$1;
var baseHasIn = _baseHasIn, hasPath = _hasPath;
function hasIn$1(object, path2) {
  return object != null && hasPath(object, path2, baseHasIn);
}
var hasIn_1 = hasIn$1;
var baseIsEqual = _baseIsEqual, get = get_1, hasIn = hasIn_1, isKey$1 = _isKey, isStrictComparable = _isStrictComparable, matchesStrictComparable = _matchesStrictComparable, toKey$2 = _toKey;
var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
function baseMatchesProperty$1(path2, srcValue) {
  if (isKey$1(path2) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey$2(path2), srcValue);
  }
  return function(object) {
    var objValue = get(object, path2);
    return objValue === void 0 && objValue === srcValue ? hasIn(object, path2) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}
var _baseMatchesProperty = baseMatchesProperty$1;
function identity$1(value) {
  return value;
}
var identity_1 = identity$1;
function baseProperty$1(key) {
  return function(object) {
    return object == null ? void 0 : object[key];
  };
}
var _baseProperty = baseProperty$1;
var baseGet$1 = _baseGet;
function basePropertyDeep$1(path2) {
  return function(object) {
    return baseGet$1(object, path2);
  };
}
var _basePropertyDeep = basePropertyDeep$1;
var baseProperty = _baseProperty, basePropertyDeep = _basePropertyDeep, isKey = _isKey, toKey$1 = _toKey;
function property$1(path2) {
  return isKey(path2) ? baseProperty(toKey$1(path2)) : basePropertyDeep(path2);
}
var property_1 = property$1;
var baseMatches = _baseMatches, baseMatchesProperty = _baseMatchesProperty, identity = identity_1, isArray$2 = isArray_1, property = property_1;
function baseIteratee$2(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == "object") {
    return isArray$2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }
  return property(value);
}
var _baseIteratee = baseIteratee$2;
var FUNC_ERROR_TEXT = "Expected a function";
function negate$1(predicate) {
  if (typeof predicate != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  return function() {
    var args = arguments;
    switch (args.length) {
      case 0:
        return !predicate.call(this);
      case 1:
        return !predicate.call(this, args[0]);
      case 2:
        return !predicate.call(this, args[0], args[1]);
      case 3:
        return !predicate.call(this, args[0], args[1], args[2]);
    }
    return !predicate.apply(this, args);
  };
}
var negate_1 = negate$1;
var getNative = _getNative;
var defineProperty$2 = function() {
  try {
    var func = getNative(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e2) {
  }
}();
var _defineProperty = defineProperty$2;
var defineProperty$1 = _defineProperty;
function baseAssignValue$1(object, key, value) {
  if (key == "__proto__" && defineProperty$1) {
    defineProperty$1(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
var _baseAssignValue = baseAssignValue$1;
var baseAssignValue = _baseAssignValue, eq = eq_1;
var objectProto$1 = Object.prototype;
var hasOwnProperty$3 = objectProto$1.hasOwnProperty;
function assignValue$1(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$3.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}
var _assignValue = assignValue$1;
var assignValue = _assignValue, castPath$1 = _castPath, isIndex = _isIndex, isObject$2 = isObject_1, toKey = _toKey;
function baseSet$1(object, path2, value, customizer) {
  if (!isObject$2(object)) {
    return object;
  }
  path2 = castPath$1(path2, object);
  var index2 = -1, length2 = path2.length, lastIndex = length2 - 1, nested = object;
  while (nested != null && ++index2 < length2) {
    var key = toKey(path2[index2]), newValue = value;
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return object;
    }
    if (index2 != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject$2(objValue) ? objValue : isIndex(path2[index2 + 1]) ? [] : {};
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}
var _baseSet = baseSet$1;
var baseGet = _baseGet, baseSet = _baseSet, castPath = _castPath;
function basePickBy$1(object, paths, predicate) {
  var index2 = -1, length2 = paths.length, result = {};
  while (++index2 < length2) {
    var path2 = paths[index2], value = baseGet(object, path2);
    if (predicate(value, path2)) {
      baseSet(result, castPath(path2, object), value);
    }
  }
  return result;
}
var _basePickBy = basePickBy$1;
var overArg = _overArg;
var getPrototype$1 = overArg(Object.getPrototypeOf, Object);
var _getPrototype = getPrototype$1;
var arrayPush$1 = _arrayPush, getPrototype = _getPrototype, getSymbols = _getSymbols, stubArray = stubArray_1;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbolsIn$1 = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush$1(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};
var _getSymbolsIn = getSymbolsIn$1;
function nativeKeysIn$1(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
var _nativeKeysIn = nativeKeysIn$1;
var isObject$1 = isObject_1, isPrototype = _isPrototype, nativeKeysIn = _nativeKeysIn;
var objectProto = Object.prototype;
var hasOwnProperty$2 = objectProto.hasOwnProperty;
function baseKeysIn$1(object) {
  if (!isObject$1(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object), result = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$2.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
var _baseKeysIn = baseKeysIn$1;
var arrayLikeKeys = _arrayLikeKeys, baseKeysIn = _baseKeysIn, isArrayLike = isArrayLike_1;
function keysIn$1(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}
var keysIn_1 = keysIn$1;
var baseGetAllKeys = _baseGetAllKeys, getSymbolsIn = _getSymbolsIn, keysIn = keysIn_1;
function getAllKeysIn$1(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}
var _getAllKeysIn = getAllKeysIn$1;
var arrayMap = _arrayMap, baseIteratee$1 = _baseIteratee, basePickBy = _basePickBy, getAllKeysIn = _getAllKeysIn;
function pickBy$1(object, predicate) {
  if (object == null) {
    return {};
  }
  var props = arrayMap(getAllKeysIn(object), function(prop) {
    return [prop];
  });
  predicate = baseIteratee$1(predicate);
  return basePickBy(object, props, function(value, path2) {
    return predicate(value, path2[0]);
  });
}
var pickBy_1 = pickBy$1;
var baseIteratee = _baseIteratee, negate = negate_1, pickBy = pickBy_1;
function omitBy(object, predicate) {
  return pickBy(object, negate(baseIteratee(predicate)));
}
var omitBy_1 = omitBy;
const omitBy3 = /* @__PURE__ */ getDefaultExportFromCjs(omitBy_1);
var ajv = { exports: {} };
var core$2 = {};
var validate = {};
var boolSchema = {};
var errors = {};
var codegen = {};
var code$4 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
  class _CodeOrName {
  }
  exports._CodeOrName = _CodeOrName;
  exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
  class Name extends _CodeOrName {
    constructor(s2) {
      super();
      if (!exports.IDENTIFIER.test(s2))
        throw new Error("CodeGen: name must be a valid identifier");
      this.str = s2;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      return false;
    }
    get names() {
      return { [this.str]: 1 };
    }
  }
  exports.Name = Name;
  class _Code extends _CodeOrName {
    constructor(code2) {
      super();
      this._items = typeof code2 === "string" ? [code2] : code2;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      if (this._items.length > 1)
        return false;
      const item = this._items[0];
      return item === "" || item === '""';
    }
    get str() {
      var _a3;
      return (_a3 = this._str) !== null && _a3 !== void 0 ? _a3 : this._str = this._items.reduce((s2, c6) => `${s2}${c6}`, "");
    }
    get names() {
      var _a3;
      return (_a3 = this._names) !== null && _a3 !== void 0 ? _a3 : this._names = this._items.reduce((names2, c6) => {
        if (c6 instanceof Name)
          names2[c6.str] = (names2[c6.str] || 0) + 1;
        return names2;
      }, {});
    }
  }
  exports._Code = _Code;
  exports.nil = new _Code("");
  function _2(strs, ...args) {
    const code2 = [strs[0]];
    let i = 0;
    while (i < args.length) {
      addCodeArg(code2, args[i]);
      code2.push(strs[++i]);
    }
    return new _Code(code2);
  }
  exports._ = _2;
  const plus = new _Code("+");
  function str(strs, ...args) {
    const expr = [safeStringify(strs[0])];
    let i = 0;
    while (i < args.length) {
      expr.push(plus);
      addCodeArg(expr, args[i]);
      expr.push(plus, safeStringify(strs[++i]));
    }
    optimize(expr);
    return new _Code(expr);
  }
  exports.str = str;
  function addCodeArg(code2, arg) {
    if (arg instanceof _Code)
      code2.push(...arg._items);
    else if (arg instanceof Name)
      code2.push(arg);
    else
      code2.push(interpolate2(arg));
  }
  exports.addCodeArg = addCodeArg;
  function optimize(expr) {
    let i = 1;
    while (i < expr.length - 1) {
      if (expr[i] === plus) {
        const res = mergeExprItems(expr[i - 1], expr[i + 1]);
        if (res !== void 0) {
          expr.splice(i - 1, 3, res);
          continue;
        }
        expr[i++] = "+";
      }
      i++;
    }
  }
  function mergeExprItems(a2, b2) {
    if (b2 === '""')
      return a2;
    if (a2 === '""')
      return b2;
    if (typeof a2 == "string") {
      if (b2 instanceof Name || a2[a2.length - 1] !== '"')
        return;
      if (typeof b2 != "string")
        return `${a2.slice(0, -1)}${b2}"`;
      if (b2[0] === '"')
        return a2.slice(0, -1) + b2.slice(1);
      return;
    }
    if (typeof b2 == "string" && b2[0] === '"' && !(a2 instanceof Name))
      return `"${a2}${b2.slice(1)}`;
    return;
  }
  function strConcat(c12, c22) {
    return c22.emptyStr() ? c12 : c12.emptyStr() ? c22 : str`${c12}${c22}`;
  }
  exports.strConcat = strConcat;
  function interpolate2(x2) {
    return typeof x2 == "number" || typeof x2 == "boolean" || x2 === null ? x2 : safeStringify(Array.isArray(x2) ? x2.join(",") : x2);
  }
  function stringify2(x2) {
    return new _Code(safeStringify(x2));
  }
  exports.stringify = stringify2;
  function safeStringify(x2) {
    return JSON.stringify(x2).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  }
  exports.safeStringify = safeStringify;
  function getProperty3(key) {
    return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _2`[${key}]`;
  }
  exports.getProperty = getProperty3;
  function getEsmExportName(key) {
    if (typeof key == "string" && exports.IDENTIFIER.test(key)) {
      return new _Code(`${key}`);
    }
    throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
  }
  exports.getEsmExportName = getEsmExportName;
  function regexpCode(rx) {
    return new _Code(rx.toString());
  }
  exports.regexpCode = regexpCode;
})(code$4);
var scope = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
  const code_12 = code$4;
  class ValueError extends Error {
    constructor(name2) {
      super(`CodeGen: "code" for ${name2} not defined`);
      this.value = name2.value;
    }
  }
  var UsedValueState;
  (function(UsedValueState2) {
    UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
    UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
  })(UsedValueState || (exports.UsedValueState = UsedValueState = {}));
  exports.varKinds = {
    const: new code_12.Name("const"),
    let: new code_12.Name("let"),
    var: new code_12.Name("var")
  };
  class Scope {
    constructor({ prefixes: prefixes2, parent } = {}) {
      this._names = {};
      this._prefixes = prefixes2;
      this._parent = parent;
    }
    toName(nameOrPrefix) {
      return nameOrPrefix instanceof code_12.Name ? nameOrPrefix : this.name(nameOrPrefix);
    }
    name(prefix2) {
      return new code_12.Name(this._newName(prefix2));
    }
    _newName(prefix2) {
      const ng = this._names[prefix2] || this._nameGroup(prefix2);
      return `${prefix2}${ng.index++}`;
    }
    _nameGroup(prefix2) {
      var _a3, _b2;
      if (((_b2 = (_a3 = this._parent) === null || _a3 === void 0 ? void 0 : _a3._prefixes) === null || _b2 === void 0 ? void 0 : _b2.has(prefix2)) || this._prefixes && !this._prefixes.has(prefix2)) {
        throw new Error(`CodeGen: prefix "${prefix2}" is not allowed in this scope`);
      }
      return this._names[prefix2] = { prefix: prefix2, index: 0 };
    }
  }
  exports.Scope = Scope;
  class ValueScopeName extends code_12.Name {
    constructor(prefix2, nameStr) {
      super(nameStr);
      this.prefix = prefix2;
    }
    setValue(value, { property: property2, itemIndex }) {
      this.value = value;
      this.scopePath = (0, code_12._)`.${new code_12.Name(property2)}[${itemIndex}]`;
    }
  }
  exports.ValueScopeName = ValueScopeName;
  const line2 = (0, code_12._)`\n`;
  class ValueScope extends Scope {
    constructor(opts) {
      super(opts);
      this._values = {};
      this._scope = opts.scope;
      this.opts = { ...opts, _n: opts.lines ? line2 : code_12.nil };
    }
    get() {
      return this._scope;
    }
    name(prefix2) {
      return new ValueScopeName(prefix2, this._newName(prefix2));
    }
    value(nameOrPrefix, value) {
      var _a3;
      if (value.ref === void 0)
        throw new Error("CodeGen: ref must be passed in value");
      const name2 = this.toName(nameOrPrefix);
      const { prefix: prefix2 } = name2;
      const valueKey = (_a3 = value.key) !== null && _a3 !== void 0 ? _a3 : value.ref;
      let vs2 = this._values[prefix2];
      if (vs2) {
        const _name = vs2.get(valueKey);
        if (_name)
          return _name;
      } else {
        vs2 = this._values[prefix2] = /* @__PURE__ */ new Map();
      }
      vs2.set(valueKey, name2);
      const s2 = this._scope[prefix2] || (this._scope[prefix2] = []);
      const itemIndex = s2.length;
      s2[itemIndex] = value.ref;
      name2.setValue(value, { property: prefix2, itemIndex });
      return name2;
    }
    getValue(prefix2, keyOrRef) {
      const vs2 = this._values[prefix2];
      if (!vs2)
        return;
      return vs2.get(keyOrRef);
    }
    scopeRefs(scopeName, values = this._values) {
      return this._reduceValues(values, (name2) => {
        if (name2.scopePath === void 0)
          throw new Error(`CodeGen: name "${name2}" has no value`);
        return (0, code_12._)`${scopeName}${name2.scopePath}`;
      });
    }
    scopeCode(values = this._values, usedValues, getCode) {
      return this._reduceValues(values, (name2) => {
        if (name2.value === void 0)
          throw new Error(`CodeGen: name "${name2}" has no value`);
        return name2.value.code;
      }, usedValues, getCode);
    }
    _reduceValues(values, valueCode, usedValues = {}, getCode) {
      let code2 = code_12.nil;
      for (const prefix2 in values) {
        const vs2 = values[prefix2];
        if (!vs2)
          continue;
        const nameSet = usedValues[prefix2] = usedValues[prefix2] || /* @__PURE__ */ new Map();
        vs2.forEach((name2) => {
          if (nameSet.has(name2))
            return;
          nameSet.set(name2, UsedValueState.Started);
          let c6 = valueCode(name2);
          if (c6) {
            const def2 = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
            code2 = (0, code_12._)`${code2}${def2} ${name2} = ${c6};${this.opts._n}`;
          } else if (c6 = getCode === null || getCode === void 0 ? void 0 : getCode(name2)) {
            code2 = (0, code_12._)`${code2}${c6}${this.opts._n}`;
          } else {
            throw new ValueError(name2);
          }
          nameSet.set(name2, UsedValueState.Completed);
        });
      }
      return code2;
    }
  }
  exports.ValueScope = ValueScope;
})(scope);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
  const code_12 = code$4;
  const scope_1 = scope;
  var code_2 = code$4;
  Object.defineProperty(exports, "_", { enumerable: true, get: function() {
    return code_2._;
  } });
  Object.defineProperty(exports, "str", { enumerable: true, get: function() {
    return code_2.str;
  } });
  Object.defineProperty(exports, "strConcat", { enumerable: true, get: function() {
    return code_2.strConcat;
  } });
  Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
    return code_2.nil;
  } });
  Object.defineProperty(exports, "getProperty", { enumerable: true, get: function() {
    return code_2.getProperty;
  } });
  Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
    return code_2.stringify;
  } });
  Object.defineProperty(exports, "regexpCode", { enumerable: true, get: function() {
    return code_2.regexpCode;
  } });
  Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
    return code_2.Name;
  } });
  var scope_2 = scope;
  Object.defineProperty(exports, "Scope", { enumerable: true, get: function() {
    return scope_2.Scope;
  } });
  Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function() {
    return scope_2.ValueScope;
  } });
  Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function() {
    return scope_2.ValueScopeName;
  } });
  Object.defineProperty(exports, "varKinds", { enumerable: true, get: function() {
    return scope_2.varKinds;
  } });
  exports.operators = {
    GT: new code_12._Code(">"),
    GTE: new code_12._Code(">="),
    LT: new code_12._Code("<"),
    LTE: new code_12._Code("<="),
    EQ: new code_12._Code("==="),
    NEQ: new code_12._Code("!=="),
    NOT: new code_12._Code("!"),
    OR: new code_12._Code("||"),
    AND: new code_12._Code("&&"),
    ADD: new code_12._Code("+")
  };
  class Node {
    optimizeNodes() {
      return this;
    }
    optimizeNames(_names, _constants) {
      return this;
    }
  }
  class Def extends Node {
    constructor(varKind, name2, rhs) {
      super();
      this.varKind = varKind;
      this.name = name2;
      this.rhs = rhs;
    }
    render({ es5, _n: _n2 }) {
      const varKind = es5 ? scope_1.varKinds.var : this.varKind;
      const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
      return `${varKind} ${this.name}${rhs};` + _n2;
    }
    optimizeNames(names2, constants) {
      if (!names2[this.name.str])
        return;
      if (this.rhs)
        this.rhs = optimizeExpr(this.rhs, names2, constants);
      return this;
    }
    get names() {
      return this.rhs instanceof code_12._CodeOrName ? this.rhs.names : {};
    }
  }
  class Assign extends Node {
    constructor(lhs, rhs, sideEffects) {
      super();
      this.lhs = lhs;
      this.rhs = rhs;
      this.sideEffects = sideEffects;
    }
    render({ _n: _n2 }) {
      return `${this.lhs} = ${this.rhs};` + _n2;
    }
    optimizeNames(names2, constants) {
      if (this.lhs instanceof code_12.Name && !names2[this.lhs.str] && !this.sideEffects)
        return;
      this.rhs = optimizeExpr(this.rhs, names2, constants);
      return this;
    }
    get names() {
      const names2 = this.lhs instanceof code_12.Name ? {} : { ...this.lhs.names };
      return addExprNames(names2, this.rhs);
    }
  }
  class AssignOp extends Assign {
    constructor(lhs, op, rhs, sideEffects) {
      super(lhs, rhs, sideEffects);
      this.op = op;
    }
    render({ _n: _n2 }) {
      return `${this.lhs} ${this.op}= ${this.rhs};` + _n2;
    }
  }
  class Label extends Node {
    constructor(label) {
      super();
      this.label = label;
      this.names = {};
    }
    render({ _n: _n2 }) {
      return `${this.label}:` + _n2;
    }
  }
  class Break extends Node {
    constructor(label) {
      super();
      this.label = label;
      this.names = {};
    }
    render({ _n: _n2 }) {
      const label = this.label ? ` ${this.label}` : "";
      return `break${label};` + _n2;
    }
  }
  class Throw extends Node {
    constructor(error2) {
      super();
      this.error = error2;
    }
    render({ _n: _n2 }) {
      return `throw ${this.error};` + _n2;
    }
    get names() {
      return this.error.names;
    }
  }
  class AnyCode extends Node {
    constructor(code2) {
      super();
      this.code = code2;
    }
    render({ _n: _n2 }) {
      return `${this.code};` + _n2;
    }
    optimizeNodes() {
      return `${this.code}` ? this : void 0;
    }
    optimizeNames(names2, constants) {
      this.code = optimizeExpr(this.code, names2, constants);
      return this;
    }
    get names() {
      return this.code instanceof code_12._CodeOrName ? this.code.names : {};
    }
  }
  class ParentNode extends Node {
    constructor(nodes = []) {
      super();
      this.nodes = nodes;
    }
    render(opts) {
      return this.nodes.reduce((code2, n2) => code2 + n2.render(opts), "");
    }
    optimizeNodes() {
      const { nodes } = this;
      let i = nodes.length;
      while (i--) {
        const n2 = nodes[i].optimizeNodes();
        if (Array.isArray(n2))
          nodes.splice(i, 1, ...n2);
        else if (n2)
          nodes[i] = n2;
        else
          nodes.splice(i, 1);
      }
      return nodes.length > 0 ? this : void 0;
    }
    optimizeNames(names2, constants) {
      const { nodes } = this;
      let i = nodes.length;
      while (i--) {
        const n2 = nodes[i];
        if (n2.optimizeNames(names2, constants))
          continue;
        subtractNames(names2, n2.names);
        nodes.splice(i, 1);
      }
      return nodes.length > 0 ? this : void 0;
    }
    get names() {
      return this.nodes.reduce((names2, n2) => addNames(names2, n2.names), {});
    }
  }
  class BlockNode extends ParentNode {
    render(opts) {
      return "{" + opts._n + super.render(opts) + "}" + opts._n;
    }
  }
  class Root extends ParentNode {
  }
  class Else extends BlockNode {
  }
  Else.kind = "else";
  class If extends BlockNode {
    constructor(condition, nodes) {
      super(nodes);
      this.condition = condition;
    }
    render(opts) {
      let code2 = `if(${this.condition})` + super.render(opts);
      if (this.else)
        code2 += "else " + this.else.render(opts);
      return code2;
    }
    optimizeNodes() {
      super.optimizeNodes();
      const cond = this.condition;
      if (cond === true)
        return this.nodes;
      let e2 = this.else;
      if (e2) {
        const ns2 = e2.optimizeNodes();
        e2 = this.else = Array.isArray(ns2) ? new Else(ns2) : ns2;
      }
      if (e2) {
        if (cond === false)
          return e2 instanceof If ? e2 : e2.nodes;
        if (this.nodes.length)
          return this;
        return new If(not2(cond), e2 instanceof If ? [e2] : e2.nodes);
      }
      if (cond === false || !this.nodes.length)
        return void 0;
      return this;
    }
    optimizeNames(names2, constants) {
      var _a3;
      this.else = (_a3 = this.else) === null || _a3 === void 0 ? void 0 : _a3.optimizeNames(names2, constants);
      if (!(super.optimizeNames(names2, constants) || this.else))
        return;
      this.condition = optimizeExpr(this.condition, names2, constants);
      return this;
    }
    get names() {
      const names2 = super.names;
      addExprNames(names2, this.condition);
      if (this.else)
        addNames(names2, this.else.names);
      return names2;
    }
  }
  If.kind = "if";
  class For extends BlockNode {
  }
  For.kind = "for";
  class ForLoop extends For {
    constructor(iteration) {
      super();
      this.iteration = iteration;
    }
    render(opts) {
      return `for(${this.iteration})` + super.render(opts);
    }
    optimizeNames(names2, constants) {
      if (!super.optimizeNames(names2, constants))
        return;
      this.iteration = optimizeExpr(this.iteration, names2, constants);
      return this;
    }
    get names() {
      return addNames(super.names, this.iteration.names);
    }
  }
  class ForRange extends For {
    constructor(varKind, name2, from2, to2) {
      super();
      this.varKind = varKind;
      this.name = name2;
      this.from = from2;
      this.to = to2;
    }
    render(opts) {
      const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
      const { name: name2, from: from2, to: to2 } = this;
      return `for(${varKind} ${name2}=${from2}; ${name2}<${to2}; ${name2}++)` + super.render(opts);
    }
    get names() {
      const names2 = addExprNames(super.names, this.from);
      return addExprNames(names2, this.to);
    }
  }
  class ForIter extends For {
    constructor(loop2, varKind, name2, iterable) {
      super();
      this.loop = loop2;
      this.varKind = varKind;
      this.name = name2;
      this.iterable = iterable;
    }
    render(opts) {
      return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
    }
    optimizeNames(names2, constants) {
      if (!super.optimizeNames(names2, constants))
        return;
      this.iterable = optimizeExpr(this.iterable, names2, constants);
      return this;
    }
    get names() {
      return addNames(super.names, this.iterable.names);
    }
  }
  class Func extends BlockNode {
    constructor(name2, args, async) {
      super();
      this.name = name2;
      this.args = args;
      this.async = async;
    }
    render(opts) {
      const _async = this.async ? "async " : "";
      return `${_async}function ${this.name}(${this.args})` + super.render(opts);
    }
  }
  Func.kind = "func";
  class Return extends ParentNode {
    render(opts) {
      return "return " + super.render(opts);
    }
  }
  Return.kind = "return";
  class Try extends BlockNode {
    render(opts) {
      let code2 = "try" + super.render(opts);
      if (this.catch)
        code2 += this.catch.render(opts);
      if (this.finally)
        code2 += this.finally.render(opts);
      return code2;
    }
    optimizeNodes() {
      var _a3, _b2;
      super.optimizeNodes();
      (_a3 = this.catch) === null || _a3 === void 0 ? void 0 : _a3.optimizeNodes();
      (_b2 = this.finally) === null || _b2 === void 0 ? void 0 : _b2.optimizeNodes();
      return this;
    }
    optimizeNames(names2, constants) {
      var _a3, _b2;
      super.optimizeNames(names2, constants);
      (_a3 = this.catch) === null || _a3 === void 0 ? void 0 : _a3.optimizeNames(names2, constants);
      (_b2 = this.finally) === null || _b2 === void 0 ? void 0 : _b2.optimizeNames(names2, constants);
      return this;
    }
    get names() {
      const names2 = super.names;
      if (this.catch)
        addNames(names2, this.catch.names);
      if (this.finally)
        addNames(names2, this.finally.names);
      return names2;
    }
  }
  class Catch extends BlockNode {
    constructor(error2) {
      super();
      this.error = error2;
    }
    render(opts) {
      return `catch(${this.error})` + super.render(opts);
    }
  }
  Catch.kind = "catch";
  class Finally extends BlockNode {
    render(opts) {
      return "finally" + super.render(opts);
    }
  }
  Finally.kind = "finally";
  class CodeGen {
    constructor(extScope, opts = {}) {
      this._values = {};
      this._blockStarts = [];
      this._constants = {};
      this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
      this._extScope = extScope;
      this._scope = new scope_1.Scope({ parent: extScope });
      this._nodes = [new Root()];
    }
    toString() {
      return this._root.render(this.opts);
    }
    // returns unique name in the internal scope
    name(prefix2) {
      return this._scope.name(prefix2);
    }
    // reserves unique name in the external scope
    scopeName(prefix2) {
      return this._extScope.name(prefix2);
    }
    // reserves unique name in the external scope and assigns value to it
    scopeValue(prefixOrName, value) {
      const name2 = this._extScope.value(prefixOrName, value);
      const vs2 = this._values[name2.prefix] || (this._values[name2.prefix] = /* @__PURE__ */ new Set());
      vs2.add(name2);
      return name2;
    }
    getScopeValue(prefix2, keyOrRef) {
      return this._extScope.getValue(prefix2, keyOrRef);
    }
    // return code that assigns values in the external scope to the names that are used internally
    // (same names that were returned by gen.scopeName or gen.scopeValue)
    scopeRefs(scopeName) {
      return this._extScope.scopeRefs(scopeName, this._values);
    }
    scopeCode() {
      return this._extScope.scopeCode(this._values);
    }
    _def(varKind, nameOrPrefix, rhs, constant) {
      const name2 = this._scope.toName(nameOrPrefix);
      if (rhs !== void 0 && constant)
        this._constants[name2.str] = rhs;
      this._leafNode(new Def(varKind, name2, rhs));
      return name2;
    }
    // `const` declaration (`var` in es5 mode)
    const(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
    }
    // `let` declaration with optional assignment (`var` in es5 mode)
    let(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
    }
    // `var` declaration with optional assignment
    var(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
    }
    // assignment code
    assign(lhs, rhs, sideEffects) {
      return this._leafNode(new Assign(lhs, rhs, sideEffects));
    }
    // `+=` code
    add(lhs, rhs) {
      return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
    }
    // appends passed SafeExpr to code or executes Block
    code(c6) {
      if (typeof c6 == "function")
        c6();
      else if (c6 !== code_12.nil)
        this._leafNode(new AnyCode(c6));
      return this;
    }
    // returns code for object literal for the passed argument list of key-value pairs
    object(...keyValues) {
      const code2 = ["{"];
      for (const [key, value] of keyValues) {
        if (code2.length > 1)
          code2.push(",");
        code2.push(key);
        if (key !== value || this.opts.es5) {
          code2.push(":");
          (0, code_12.addCodeArg)(code2, value);
        }
      }
      code2.push("}");
      return new code_12._Code(code2);
    }
    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
    if(condition, thenBody, elseBody) {
      this._blockNode(new If(condition));
      if (thenBody && elseBody) {
        this.code(thenBody).else().code(elseBody).endIf();
      } else if (thenBody) {
        this.code(thenBody).endIf();
      } else if (elseBody) {
        throw new Error('CodeGen: "else" body without "then" body');
      }
      return this;
    }
    // `else if` clause - invalid without `if` or after `else` clauses
    elseIf(condition) {
      return this._elseNode(new If(condition));
    }
    // `else` clause - only valid after `if` or `else if` clauses
    else() {
      return this._elseNode(new Else());
    }
    // end `if` statement (needed if gen.if was used only with condition)
    endIf() {
      return this._endBlockNode(If, Else);
    }
    _for(node2, forBody) {
      this._blockNode(node2);
      if (forBody)
        this.code(forBody).endFor();
      return this;
    }
    // a generic `for` clause (or statement if `forBody` is passed)
    for(iteration, forBody) {
      return this._for(new ForLoop(iteration), forBody);
    }
    // `for` statement for a range of values
    forRange(nameOrPrefix, from2, to2, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
      const name2 = this._scope.toName(nameOrPrefix);
      return this._for(new ForRange(varKind, name2, from2, to2), () => forBody(name2));
    }
    // `for-of` statement (in es5 mode replace with a normal for loop)
    forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
      const name2 = this._scope.toName(nameOrPrefix);
      if (this.opts.es5) {
        const arr = iterable instanceof code_12.Name ? iterable : this.var("_arr", iterable);
        return this.forRange("_i", 0, (0, code_12._)`${arr}.length`, (i) => {
          this.var(name2, (0, code_12._)`${arr}[${i}]`);
          forBody(name2);
        });
      }
      return this._for(new ForIter("of", varKind, name2, iterable), () => forBody(name2));
    }
    // `for-in` statement.
    // With option `ownProperties` replaced with a `for-of` loop for object keys
    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
      if (this.opts.ownProperties) {
        return this.forOf(nameOrPrefix, (0, code_12._)`Object.keys(${obj})`, forBody);
      }
      const name2 = this._scope.toName(nameOrPrefix);
      return this._for(new ForIter("in", varKind, name2, obj), () => forBody(name2));
    }
    // end `for` loop
    endFor() {
      return this._endBlockNode(For);
    }
    // `label` statement
    label(label) {
      return this._leafNode(new Label(label));
    }
    // `break` statement
    break(label) {
      return this._leafNode(new Break(label));
    }
    // `return` statement
    return(value) {
      const node2 = new Return();
      this._blockNode(node2);
      this.code(value);
      if (node2.nodes.length !== 1)
        throw new Error('CodeGen: "return" should have one node');
      return this._endBlockNode(Return);
    }
    // `try` statement
    try(tryBody, catchCode, finallyCode) {
      if (!catchCode && !finallyCode)
        throw new Error('CodeGen: "try" without "catch" and "finally"');
      const node2 = new Try();
      this._blockNode(node2);
      this.code(tryBody);
      if (catchCode) {
        const error2 = this.name("e");
        this._currNode = node2.catch = new Catch(error2);
        catchCode(error2);
      }
      if (finallyCode) {
        this._currNode = node2.finally = new Finally();
        this.code(finallyCode);
      }
      return this._endBlockNode(Catch, Finally);
    }
    // `throw` statement
    throw(error2) {
      return this._leafNode(new Throw(error2));
    }
    // start self-balancing block
    block(body, nodeCount) {
      this._blockStarts.push(this._nodes.length);
      if (body)
        this.code(body).endBlock(nodeCount);
      return this;
    }
    // end the current self-balancing block
    endBlock(nodeCount) {
      const len = this._blockStarts.pop();
      if (len === void 0)
        throw new Error("CodeGen: not in self-balancing block");
      const toClose = this._nodes.length - len;
      if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
        throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
      }
      this._nodes.length = len;
      return this;
    }
    // `function` heading (or definition if funcBody is passed)
    func(name2, args = code_12.nil, async, funcBody) {
      this._blockNode(new Func(name2, args, async));
      if (funcBody)
        this.code(funcBody).endFunc();
      return this;
    }
    // end function definition
    endFunc() {
      return this._endBlockNode(Func);
    }
    optimize(n2 = 1) {
      while (n2-- > 0) {
        this._root.optimizeNodes();
        this._root.optimizeNames(this._root.names, this._constants);
      }
    }
    _leafNode(node2) {
      this._currNode.nodes.push(node2);
      return this;
    }
    _blockNode(node2) {
      this._currNode.nodes.push(node2);
      this._nodes.push(node2);
    }
    _endBlockNode(N1, N2) {
      const n2 = this._currNode;
      if (n2 instanceof N1 || N2 && n2 instanceof N2) {
        this._nodes.pop();
        return this;
      }
      throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
    }
    _elseNode(node2) {
      const n2 = this._currNode;
      if (!(n2 instanceof If)) {
        throw new Error('CodeGen: "else" without "if"');
      }
      this._currNode = n2.else = node2;
      return this;
    }
    get _root() {
      return this._nodes[0];
    }
    get _currNode() {
      const ns2 = this._nodes;
      return ns2[ns2.length - 1];
    }
    set _currNode(node2) {
      const ns2 = this._nodes;
      ns2[ns2.length - 1] = node2;
    }
  }
  exports.CodeGen = CodeGen;
  function addNames(names2, from2) {
    for (const n2 in from2)
      names2[n2] = (names2[n2] || 0) + (from2[n2] || 0);
    return names2;
  }
  function addExprNames(names2, from2) {
    return from2 instanceof code_12._CodeOrName ? addNames(names2, from2.names) : names2;
  }
  function optimizeExpr(expr, names2, constants) {
    if (expr instanceof code_12.Name)
      return replaceName(expr);
    if (!canOptimize(expr))
      return expr;
    return new code_12._Code(expr._items.reduce((items2, c6) => {
      if (c6 instanceof code_12.Name)
        c6 = replaceName(c6);
      if (c6 instanceof code_12._Code)
        items2.push(...c6._items);
      else
        items2.push(c6);
      return items2;
    }, []));
    function replaceName(n2) {
      const c6 = constants[n2.str];
      if (c6 === void 0 || names2[n2.str] !== 1)
        return n2;
      delete names2[n2.str];
      return c6;
    }
    function canOptimize(e2) {
      return e2 instanceof code_12._Code && e2._items.some((c6) => c6 instanceof code_12.Name && names2[c6.str] === 1 && constants[c6.str] !== void 0);
    }
  }
  function subtractNames(names2, from2) {
    for (const n2 in from2)
      names2[n2] = (names2[n2] || 0) - (from2[n2] || 0);
  }
  function not2(x2) {
    return typeof x2 == "boolean" || typeof x2 == "number" || x2 === null ? !x2 : (0, code_12._)`!${par(x2)}`;
  }
  exports.not = not2;
  const andCode = mappend(exports.operators.AND);
  function and(...args) {
    return args.reduce(andCode);
  }
  exports.and = and;
  const orCode = mappend(exports.operators.OR);
  function or2(...args) {
    return args.reduce(orCode);
  }
  exports.or = or2;
  function mappend(op) {
    return (x2, y2) => x2 === code_12.nil ? y2 : y2 === code_12.nil ? x2 : (0, code_12._)`${par(x2)} ${op} ${par(y2)}`;
  }
  function par(x2) {
    return x2 instanceof code_12.Name ? x2 : (0, code_12._)`(${x2})`;
  }
})(codegen);
var util = {};
Object.defineProperty(util, "__esModule", { value: true });
util.checkStrictMode = util.getErrorPath = util.Type = util.useFunc = util.setEvaluated = util.evaluatedPropsToName = util.mergeEvaluated = util.eachItem = util.unescapeJsonPointer = util.escapeJsonPointer = util.escapeFragment = util.unescapeFragment = util.schemaRefOrVal = util.schemaHasRulesButRef = util.schemaHasRules = util.checkUnknownRules = util.alwaysValidSchema = util.toHash = void 0;
const codegen_1$v = codegen;
const code_1$a = code$4;
function toHash(arr) {
  const hash2 = {};
  for (const item of arr)
    hash2[item] = true;
  return hash2;
}
util.toHash = toHash;
function alwaysValidSchema(it2, schema) {
  if (typeof schema == "boolean")
    return schema;
  if (Object.keys(schema).length === 0)
    return true;
  checkUnknownRules(it2, schema);
  return !schemaHasRules(schema, it2.self.RULES.all);
}
util.alwaysValidSchema = alwaysValidSchema;
function checkUnknownRules(it2, schema = it2.schema) {
  const { opts, self: self2 } = it2;
  if (!opts.strictSchema)
    return;
  if (typeof schema === "boolean")
    return;
  const rules2 = self2.RULES.keywords;
  for (const key in schema) {
    if (!rules2[key])
      checkStrictMode(it2, `unknown keyword: "${key}"`);
  }
}
util.checkUnknownRules = checkUnknownRules;
function schemaHasRules(schema, rules2) {
  if (typeof schema == "boolean")
    return !schema;
  for (const key in schema)
    if (rules2[key])
      return true;
  return false;
}
util.schemaHasRules = schemaHasRules;
function schemaHasRulesButRef(schema, RULES) {
  if (typeof schema == "boolean")
    return !schema;
  for (const key in schema)
    if (key !== "$ref" && RULES.all[key])
      return true;
  return false;
}
util.schemaHasRulesButRef = schemaHasRulesButRef;
function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword2, $data) {
  if (!$data) {
    if (typeof schema == "number" || typeof schema == "boolean")
      return schema;
    if (typeof schema == "string")
      return (0, codegen_1$v._)`${schema}`;
  }
  return (0, codegen_1$v._)`${topSchemaRef}${schemaPath}${(0, codegen_1$v.getProperty)(keyword2)}`;
}
util.schemaRefOrVal = schemaRefOrVal;
function unescapeFragment(str) {
  return unescapeJsonPointer(decodeURIComponent(str));
}
util.unescapeFragment = unescapeFragment;
function escapeFragment(str) {
  return encodeURIComponent(escapeJsonPointer(str));
}
util.escapeFragment = escapeFragment;
function escapeJsonPointer(str) {
  if (typeof str == "number")
    return `${str}`;
  return str.replace(/~/g, "~0").replace(/\//g, "~1");
}
util.escapeJsonPointer = escapeJsonPointer;
function unescapeJsonPointer(str) {
  return str.replace(/~1/g, "/").replace(/~0/g, "~");
}
util.unescapeJsonPointer = unescapeJsonPointer;
function eachItem(xs2, f2) {
  if (Array.isArray(xs2)) {
    for (const x2 of xs2)
      f2(x2);
  } else {
    f2(xs2);
  }
}
util.eachItem = eachItem;
function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
  return (gen, from2, to2, toName) => {
    const res = to2 === void 0 ? from2 : to2 instanceof codegen_1$v.Name ? (from2 instanceof codegen_1$v.Name ? mergeNames(gen, from2, to2) : mergeToName(gen, from2, to2), to2) : from2 instanceof codegen_1$v.Name ? (mergeToName(gen, to2, from2), from2) : mergeValues(from2, to2);
    return toName === codegen_1$v.Name && !(res instanceof codegen_1$v.Name) ? resultToName(gen, res) : res;
  };
}
util.mergeEvaluated = {
  props: makeMergeEvaluated({
    mergeNames: (gen, from2, to2) => gen.if((0, codegen_1$v._)`${to2} !== true && ${from2} !== undefined`, () => {
      gen.if((0, codegen_1$v._)`${from2} === true`, () => gen.assign(to2, true), () => gen.assign(to2, (0, codegen_1$v._)`${to2} || {}`).code((0, codegen_1$v._)`Object.assign(${to2}, ${from2})`));
    }),
    mergeToName: (gen, from2, to2) => gen.if((0, codegen_1$v._)`${to2} !== true`, () => {
      if (from2 === true) {
        gen.assign(to2, true);
      } else {
        gen.assign(to2, (0, codegen_1$v._)`${to2} || {}`);
        setEvaluated(gen, to2, from2);
      }
    }),
    mergeValues: (from2, to2) => from2 === true ? true : { ...from2, ...to2 },
    resultToName: evaluatedPropsToName
  }),
  items: makeMergeEvaluated({
    mergeNames: (gen, from2, to2) => gen.if((0, codegen_1$v._)`${to2} !== true && ${from2} !== undefined`, () => gen.assign(to2, (0, codegen_1$v._)`${from2} === true ? true : ${to2} > ${from2} ? ${to2} : ${from2}`)),
    mergeToName: (gen, from2, to2) => gen.if((0, codegen_1$v._)`${to2} !== true`, () => gen.assign(to2, from2 === true ? true : (0, codegen_1$v._)`${to2} > ${from2} ? ${to2} : ${from2}`)),
    mergeValues: (from2, to2) => from2 === true ? true : Math.max(from2, to2),
    resultToName: (gen, items2) => gen.var("items", items2)
  })
};
function evaluatedPropsToName(gen, ps2) {
  if (ps2 === true)
    return gen.var("props", true);
  const props = gen.var("props", (0, codegen_1$v._)`{}`);
  if (ps2 !== void 0)
    setEvaluated(gen, props, ps2);
  return props;
}
util.evaluatedPropsToName = evaluatedPropsToName;
function setEvaluated(gen, props, ps2) {
  Object.keys(ps2).forEach((p2) => gen.assign((0, codegen_1$v._)`${props}${(0, codegen_1$v.getProperty)(p2)}`, true));
}
util.setEvaluated = setEvaluated;
const snippets = {};
function useFunc(gen, f2) {
  return gen.scopeValue("func", {
    ref: f2,
    code: snippets[f2.code] || (snippets[f2.code] = new code_1$a._Code(f2.code))
  });
}
util.useFunc = useFunc;
var Type;
(function(Type2) {
  Type2[Type2["Num"] = 0] = "Num";
  Type2[Type2["Str"] = 1] = "Str";
})(Type || (util.Type = Type = {}));
function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
  if (dataProp instanceof codegen_1$v.Name) {
    const isNumber2 = dataPropType === Type.Num;
    return jsPropertySyntax ? isNumber2 ? (0, codegen_1$v._)`"[" + ${dataProp} + "]"` : (0, codegen_1$v._)`"['" + ${dataProp} + "']"` : isNumber2 ? (0, codegen_1$v._)`"/" + ${dataProp}` : (0, codegen_1$v._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
  }
  return jsPropertySyntax ? (0, codegen_1$v.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
}
util.getErrorPath = getErrorPath;
function checkStrictMode(it2, msg, mode = it2.opts.strictSchema) {
  if (!mode)
    return;
  msg = `strict mode: ${msg}`;
  if (mode === true)
    throw new Error(msg);
  it2.self.logger.warn(msg);
}
util.checkStrictMode = checkStrictMode;
var names$1 = {};
Object.defineProperty(names$1, "__esModule", { value: true });
const codegen_1$u = codegen;
const names = {
  // validation function arguments
  data: new codegen_1$u.Name("data"),
  // data passed to validation function
  // args passed from referencing schema
  valCxt: new codegen_1$u.Name("valCxt"),
  // validation/data context - should not be used directly, it is destructured to the names below
  instancePath: new codegen_1$u.Name("instancePath"),
  parentData: new codegen_1$u.Name("parentData"),
  parentDataProperty: new codegen_1$u.Name("parentDataProperty"),
  rootData: new codegen_1$u.Name("rootData"),
  // root data - same as the data passed to the first/top validation function
  dynamicAnchors: new codegen_1$u.Name("dynamicAnchors"),
  // used to support recursiveRef and dynamicRef
  // function scoped variables
  vErrors: new codegen_1$u.Name("vErrors"),
  // null or array of validation errors
  errors: new codegen_1$u.Name("errors"),
  // counter of validation errors
  this: new codegen_1$u.Name("this"),
  // "globals"
  self: new codegen_1$u.Name("self"),
  scope: new codegen_1$u.Name("scope"),
  // JTD serialize/parse name for JSON string and position
  json: new codegen_1$u.Name("json"),
  jsonPos: new codegen_1$u.Name("jsonPos"),
  jsonLen: new codegen_1$u.Name("jsonLen"),
  jsonPart: new codegen_1$u.Name("jsonPart")
};
names$1.default = names;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
  const codegen_12 = codegen;
  const util_12 = util;
  const names_12 = names$1;
  exports.keywordError = {
    message: ({ keyword: keyword2 }) => (0, codegen_12.str)`must pass "${keyword2}" keyword validation`
  };
  exports.keyword$DataError = {
    message: ({ keyword: keyword2, schemaType }) => schemaType ? (0, codegen_12.str)`"${keyword2}" keyword must be ${schemaType} ($data)` : (0, codegen_12.str)`"${keyword2}" keyword is invalid ($data)`
  };
  function reportError(cxt, error2 = exports.keywordError, errorPaths, overrideAllErrors) {
    const { it: it2 } = cxt;
    const { gen, compositeRule, allErrors } = it2;
    const errObj = errorObjectCode(cxt, error2, errorPaths);
    if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
      addError(gen, errObj);
    } else {
      returnErrors(it2, (0, codegen_12._)`[${errObj}]`);
    }
  }
  exports.reportError = reportError;
  function reportExtraError(cxt, error2 = exports.keywordError, errorPaths) {
    const { it: it2 } = cxt;
    const { gen, compositeRule, allErrors } = it2;
    const errObj = errorObjectCode(cxt, error2, errorPaths);
    addError(gen, errObj);
    if (!(compositeRule || allErrors)) {
      returnErrors(it2, names_12.default.vErrors);
    }
  }
  exports.reportExtraError = reportExtraError;
  function resetErrorsCount(gen, errsCount) {
    gen.assign(names_12.default.errors, errsCount);
    gen.if((0, codegen_12._)`${names_12.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_12._)`${names_12.default.vErrors}.length`, errsCount), () => gen.assign(names_12.default.vErrors, null)));
  }
  exports.resetErrorsCount = resetErrorsCount;
  function extendErrors({ gen, keyword: keyword2, schemaValue, data, errsCount, it: it2 }) {
    if (errsCount === void 0)
      throw new Error("ajv implementation error");
    const err = gen.name("err");
    gen.forRange("i", errsCount, names_12.default.errors, (i) => {
      gen.const(err, (0, codegen_12._)`${names_12.default.vErrors}[${i}]`);
      gen.if((0, codegen_12._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_12._)`${err}.instancePath`, (0, codegen_12.strConcat)(names_12.default.instancePath, it2.errorPath)));
      gen.assign((0, codegen_12._)`${err}.schemaPath`, (0, codegen_12.str)`${it2.errSchemaPath}/${keyword2}`);
      if (it2.opts.verbose) {
        gen.assign((0, codegen_12._)`${err}.schema`, schemaValue);
        gen.assign((0, codegen_12._)`${err}.data`, data);
      }
    });
  }
  exports.extendErrors = extendErrors;
  function addError(gen, errObj) {
    const err = gen.const("err", errObj);
    gen.if((0, codegen_12._)`${names_12.default.vErrors} === null`, () => gen.assign(names_12.default.vErrors, (0, codegen_12._)`[${err}]`), (0, codegen_12._)`${names_12.default.vErrors}.push(${err})`);
    gen.code((0, codegen_12._)`${names_12.default.errors}++`);
  }
  function returnErrors(it2, errs) {
    const { gen, validateName, schemaEnv } = it2;
    if (schemaEnv.$async) {
      gen.throw((0, codegen_12._)`new ${it2.ValidationError}(${errs})`);
    } else {
      gen.assign((0, codegen_12._)`${validateName}.errors`, errs);
      gen.return(false);
    }
  }
  const E2 = {
    keyword: new codegen_12.Name("keyword"),
    schemaPath: new codegen_12.Name("schemaPath"),
    // also used in JTD errors
    params: new codegen_12.Name("params"),
    propertyName: new codegen_12.Name("propertyName"),
    message: new codegen_12.Name("message"),
    schema: new codegen_12.Name("schema"),
    parentSchema: new codegen_12.Name("parentSchema")
  };
  function errorObjectCode(cxt, error2, errorPaths) {
    const { createErrors } = cxt.it;
    if (createErrors === false)
      return (0, codegen_12._)`{}`;
    return errorObject(cxt, error2, errorPaths);
  }
  function errorObject(cxt, error2, errorPaths = {}) {
    const { gen, it: it2 } = cxt;
    const keyValues = [
      errorInstancePath(it2, errorPaths),
      errorSchemaPath(cxt, errorPaths)
    ];
    extraErrorProps(cxt, error2, keyValues);
    return gen.object(...keyValues);
  }
  function errorInstancePath({ errorPath }, { instancePath }) {
    const instPath = instancePath ? (0, codegen_12.str)`${errorPath}${(0, util_12.getErrorPath)(instancePath, util_12.Type.Str)}` : errorPath;
    return [names_12.default.instancePath, (0, codegen_12.strConcat)(names_12.default.instancePath, instPath)];
  }
  function errorSchemaPath({ keyword: keyword2, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
    let schPath = parentSchema ? errSchemaPath : (0, codegen_12.str)`${errSchemaPath}/${keyword2}`;
    if (schemaPath) {
      schPath = (0, codegen_12.str)`${schPath}${(0, util_12.getErrorPath)(schemaPath, util_12.Type.Str)}`;
    }
    return [E2.schemaPath, schPath];
  }
  function extraErrorProps(cxt, { params, message }, keyValues) {
    const { keyword: keyword2, data, schemaValue, it: it2 } = cxt;
    const { opts, propertyName, topSchemaRef, schemaPath } = it2;
    keyValues.push([E2.keyword, keyword2], [E2.params, typeof params == "function" ? params(cxt) : params || (0, codegen_12._)`{}`]);
    if (opts.messages) {
      keyValues.push([E2.message, typeof message == "function" ? message(cxt) : message]);
    }
    if (opts.verbose) {
      keyValues.push([E2.schema, schemaValue], [E2.parentSchema, (0, codegen_12._)`${topSchemaRef}${schemaPath}`], [names_12.default.data, data]);
    }
    if (propertyName)
      keyValues.push([E2.propertyName, propertyName]);
  }
})(errors);
Object.defineProperty(boolSchema, "__esModule", { value: true });
boolSchema.boolOrEmptySchema = boolSchema.topBoolOrEmptySchema = void 0;
const errors_1$3 = errors;
const codegen_1$t = codegen;
const names_1$6 = names$1;
const boolError = {
  message: "boolean schema is false"
};
function topBoolOrEmptySchema(it2) {
  const { gen, schema, validateName } = it2;
  if (schema === false) {
    falseSchemaError(it2, false);
  } else if (typeof schema == "object" && schema.$async === true) {
    gen.return(names_1$6.default.data);
  } else {
    gen.assign((0, codegen_1$t._)`${validateName}.errors`, null);
    gen.return(true);
  }
}
boolSchema.topBoolOrEmptySchema = topBoolOrEmptySchema;
function boolOrEmptySchema(it2, valid2) {
  const { gen, schema } = it2;
  if (schema === false) {
    gen.var(valid2, false);
    falseSchemaError(it2);
  } else {
    gen.var(valid2, true);
  }
}
boolSchema.boolOrEmptySchema = boolOrEmptySchema;
function falseSchemaError(it2, overrideAllErrors) {
  const { gen, data } = it2;
  const cxt = {
    gen,
    keyword: "false schema",
    data,
    schema: false,
    schemaCode: false,
    schemaValue: false,
    params: {},
    it: it2
  };
  (0, errors_1$3.reportError)(cxt, boolError, void 0, overrideAllErrors);
}
var dataType = {};
var rules = {};
Object.defineProperty(rules, "__esModule", { value: true });
rules.getRules = rules.isJSONType = void 0;
const _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
const jsonTypes = new Set(_jsonTypes);
function isJSONType(x2) {
  return typeof x2 == "string" && jsonTypes.has(x2);
}
rules.isJSONType = isJSONType;
function getRules2() {
  const groups = {
    number: { type: "number", rules: [] },
    string: { type: "string", rules: [] },
    array: { type: "array", rules: [] },
    object: { type: "object", rules: [] }
  };
  return {
    types: { ...groups, integer: true, boolean: true, null: true },
    rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
    post: { rules: [] },
    all: {},
    keywords: {}
  };
}
rules.getRules = getRules2;
var applicability = {};
Object.defineProperty(applicability, "__esModule", { value: true });
applicability.shouldUseRule = applicability.shouldUseGroup = applicability.schemaHasRulesForType = void 0;
function schemaHasRulesForType({ schema, self: self2 }, type2) {
  const group = self2.RULES.types[type2];
  return group && group !== true && shouldUseGroup(schema, group);
}
applicability.schemaHasRulesForType = schemaHasRulesForType;
function shouldUseGroup(schema, group) {
  return group.rules.some((rule) => shouldUseRule(schema, rule));
}
applicability.shouldUseGroup = shouldUseGroup;
function shouldUseRule(schema, rule) {
  var _a3;
  return schema[rule.keyword] !== void 0 || ((_a3 = rule.definition.implements) === null || _a3 === void 0 ? void 0 : _a3.some((kwd) => schema[kwd] !== void 0));
}
applicability.shouldUseRule = shouldUseRule;
Object.defineProperty(dataType, "__esModule", { value: true });
dataType.reportTypeError = dataType.checkDataTypes = dataType.checkDataType = dataType.coerceAndCheckDataType = dataType.getJSONTypes = dataType.getSchemaTypes = dataType.DataType = void 0;
const rules_1 = rules;
const applicability_1$1 = applicability;
const errors_1$2 = errors;
const codegen_1$s = codegen;
const util_1$q = util;
var DataType;
(function(DataType2) {
  DataType2[DataType2["Correct"] = 0] = "Correct";
  DataType2[DataType2["Wrong"] = 1] = "Wrong";
})(DataType || (dataType.DataType = DataType = {}));
function getSchemaTypes(schema) {
  const types2 = getJSONTypes(schema.type);
  const hasNull = types2.includes("null");
  if (hasNull) {
    if (schema.nullable === false)
      throw new Error("type: null contradicts nullable: false");
  } else {
    if (!types2.length && schema.nullable !== void 0) {
      throw new Error('"nullable" cannot be used without "type"');
    }
    if (schema.nullable === true)
      types2.push("null");
  }
  return types2;
}
dataType.getSchemaTypes = getSchemaTypes;
function getJSONTypes(ts2) {
  const types2 = Array.isArray(ts2) ? ts2 : ts2 ? [ts2] : [];
  if (types2.every(rules_1.isJSONType))
    return types2;
  throw new Error("type must be JSONType or JSONType[]: " + types2.join(","));
}
dataType.getJSONTypes = getJSONTypes;
function coerceAndCheckDataType(it2, types2) {
  const { gen, data, opts } = it2;
  const coerceTo = coerceToTypes(types2, opts.coerceTypes);
  const checkTypes = types2.length > 0 && !(coerceTo.length === 0 && types2.length === 1 && (0, applicability_1$1.schemaHasRulesForType)(it2, types2[0]));
  if (checkTypes) {
    const wrongType = checkDataTypes(types2, data, opts.strictNumbers, DataType.Wrong);
    gen.if(wrongType, () => {
      if (coerceTo.length)
        coerceData(it2, types2, coerceTo);
      else
        reportTypeError(it2);
    });
  }
  return checkTypes;
}
dataType.coerceAndCheckDataType = coerceAndCheckDataType;
const COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
function coerceToTypes(types2, coerceTypes) {
  return coerceTypes ? types2.filter((t2) => COERCIBLE.has(t2) || coerceTypes === "array" && t2 === "array") : [];
}
function coerceData(it2, types2, coerceTo) {
  const { gen, data, opts } = it2;
  const dataType2 = gen.let("dataType", (0, codegen_1$s._)`typeof ${data}`);
  const coerced = gen.let("coerced", (0, codegen_1$s._)`undefined`);
  if (opts.coerceTypes === "array") {
    gen.if((0, codegen_1$s._)`${dataType2} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1$s._)`${data}[0]`).assign(dataType2, (0, codegen_1$s._)`typeof ${data}`).if(checkDataTypes(types2, data, opts.strictNumbers), () => gen.assign(coerced, data)));
  }
  gen.if((0, codegen_1$s._)`${coerced} !== undefined`);
  for (const t2 of coerceTo) {
    if (COERCIBLE.has(t2) || t2 === "array" && opts.coerceTypes === "array") {
      coerceSpecificType(t2);
    }
  }
  gen.else();
  reportTypeError(it2);
  gen.endIf();
  gen.if((0, codegen_1$s._)`${coerced} !== undefined`, () => {
    gen.assign(data, coerced);
    assignParentData(it2, coerced);
  });
  function coerceSpecificType(t2) {
    switch (t2) {
      case "string":
        gen.elseIf((0, codegen_1$s._)`${dataType2} == "number" || ${dataType2} == "boolean"`).assign(coerced, (0, codegen_1$s._)`"" + ${data}`).elseIf((0, codegen_1$s._)`${data} === null`).assign(coerced, (0, codegen_1$s._)`""`);
        return;
      case "number":
        gen.elseIf((0, codegen_1$s._)`${dataType2} == "boolean" || ${data} === null
              || (${dataType2} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1$s._)`+${data}`);
        return;
      case "integer":
        gen.elseIf((0, codegen_1$s._)`${dataType2} === "boolean" || ${data} === null
              || (${dataType2} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1$s._)`+${data}`);
        return;
      case "boolean":
        gen.elseIf((0, codegen_1$s._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1$s._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
        return;
      case "null":
        gen.elseIf((0, codegen_1$s._)`${data} === "" || ${data} === 0 || ${data} === false`);
        gen.assign(coerced, null);
        return;
      case "array":
        gen.elseIf((0, codegen_1$s._)`${dataType2} === "string" || ${dataType2} === "number"
              || ${dataType2} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1$s._)`[${data}]`);
    }
  }
}
function assignParentData({ gen, parentData, parentDataProperty }, expr) {
  gen.if((0, codegen_1$s._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1$s._)`${parentData}[${parentDataProperty}]`, expr));
}
function checkDataType(dataType2, data, strictNums, correct = DataType.Correct) {
  const EQ = correct === DataType.Correct ? codegen_1$s.operators.EQ : codegen_1$s.operators.NEQ;
  let cond;
  switch (dataType2) {
    case "null":
      return (0, codegen_1$s._)`${data} ${EQ} null`;
    case "array":
      cond = (0, codegen_1$s._)`Array.isArray(${data})`;
      break;
    case "object":
      cond = (0, codegen_1$s._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
      break;
    case "integer":
      cond = numCond((0, codegen_1$s._)`!(${data} % 1) && !isNaN(${data})`);
      break;
    case "number":
      cond = numCond();
      break;
    default:
      return (0, codegen_1$s._)`typeof ${data} ${EQ} ${dataType2}`;
  }
  return correct === DataType.Correct ? cond : (0, codegen_1$s.not)(cond);
  function numCond(_cond = codegen_1$s.nil) {
    return (0, codegen_1$s.and)((0, codegen_1$s._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1$s._)`isFinite(${data})` : codegen_1$s.nil);
  }
}
dataType.checkDataType = checkDataType;
function checkDataTypes(dataTypes, data, strictNums, correct) {
  if (dataTypes.length === 1) {
    return checkDataType(dataTypes[0], data, strictNums, correct);
  }
  let cond;
  const types2 = (0, util_1$q.toHash)(dataTypes);
  if (types2.array && types2.object) {
    const notObj = (0, codegen_1$s._)`typeof ${data} != "object"`;
    cond = types2.null ? notObj : (0, codegen_1$s._)`!${data} || ${notObj}`;
    delete types2.null;
    delete types2.array;
    delete types2.object;
  } else {
    cond = codegen_1$s.nil;
  }
  if (types2.number)
    delete types2.integer;
  for (const t2 in types2)
    cond = (0, codegen_1$s.and)(cond, checkDataType(t2, data, strictNums, correct));
  return cond;
}
dataType.checkDataTypes = checkDataTypes;
const typeError = {
  message: ({ schema }) => `must be ${schema}`,
  params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1$s._)`{type: ${schema}}` : (0, codegen_1$s._)`{type: ${schemaValue}}`
};
function reportTypeError(it2) {
  const cxt = getTypeErrorContext(it2);
  (0, errors_1$2.reportError)(cxt, typeError);
}
dataType.reportTypeError = reportTypeError;
function getTypeErrorContext(it2) {
  const { gen, data, schema } = it2;
  const schemaCode = (0, util_1$q.schemaRefOrVal)(it2, schema, "type");
  return {
    gen,
    keyword: "type",
    data,
    schema: schema.type,
    schemaCode,
    schemaValue: schemaCode,
    parentSchema: schema,
    params: {},
    it: it2
  };
}
var defaults$2 = {};
Object.defineProperty(defaults$2, "__esModule", { value: true });
defaults$2.assignDefaults = void 0;
const codegen_1$r = codegen;
const util_1$p = util;
function assignDefaults(it2, ty) {
  const { properties: properties2, items: items2 } = it2.schema;
  if (ty === "object" && properties2) {
    for (const key in properties2) {
      assignDefault(it2, key, properties2[key].default);
    }
  } else if (ty === "array" && Array.isArray(items2)) {
    items2.forEach((sch, i) => assignDefault(it2, i, sch.default));
  }
}
defaults$2.assignDefaults = assignDefaults;
function assignDefault(it2, prop, defaultValue) {
  const { gen, compositeRule, data, opts } = it2;
  if (defaultValue === void 0)
    return;
  const childData = (0, codegen_1$r._)`${data}${(0, codegen_1$r.getProperty)(prop)}`;
  if (compositeRule) {
    (0, util_1$p.checkStrictMode)(it2, `default is ignored for: ${childData}`);
    return;
  }
  let condition = (0, codegen_1$r._)`${childData} === undefined`;
  if (opts.useDefaults === "empty") {
    condition = (0, codegen_1$r._)`${condition} || ${childData} === null || ${childData} === ""`;
  }
  gen.if(condition, (0, codegen_1$r._)`${childData} = ${(0, codegen_1$r.stringify)(defaultValue)}`);
}
var keyword = {};
var code$3 = {};
Object.defineProperty(code$3, "__esModule", { value: true });
code$3.validateUnion = code$3.validateArray = code$3.usePattern = code$3.callValidateCode = code$3.schemaProperties = code$3.allSchemaProperties = code$3.noPropertyInData = code$3.propertyInData = code$3.isOwnProperty = code$3.hasPropFunc = code$3.reportMissingProp = code$3.checkMissingProp = code$3.checkReportMissingProp = void 0;
const codegen_1$q = codegen;
const util_1$o = util;
const names_1$5 = names$1;
const util_2$1 = util;
function checkReportMissingProp(cxt, prop) {
  const { gen, data, it: it2 } = cxt;
  gen.if(noPropertyInData(gen, data, prop, it2.opts.ownProperties), () => {
    cxt.setParams({ missingProperty: (0, codegen_1$q._)`${prop}` }, true);
    cxt.error();
  });
}
code$3.checkReportMissingProp = checkReportMissingProp;
function checkMissingProp({ gen, data, it: { opts } }, properties2, missing) {
  return (0, codegen_1$q.or)(...properties2.map((prop) => (0, codegen_1$q.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1$q._)`${missing} = ${prop}`)));
}
code$3.checkMissingProp = checkMissingProp;
function reportMissingProp(cxt, missing) {
  cxt.setParams({ missingProperty: missing }, true);
  cxt.error();
}
code$3.reportMissingProp = reportMissingProp;
function hasPropFunc(gen) {
  return gen.scopeValue("func", {
    // eslint-disable-next-line @typescript-eslint/unbound-method
    ref: Object.prototype.hasOwnProperty,
    code: (0, codegen_1$q._)`Object.prototype.hasOwnProperty`
  });
}
code$3.hasPropFunc = hasPropFunc;
function isOwnProperty(gen, data, property2) {
  return (0, codegen_1$q._)`${hasPropFunc(gen)}.call(${data}, ${property2})`;
}
code$3.isOwnProperty = isOwnProperty;
function propertyInData(gen, data, property2, ownProperties) {
  const cond = (0, codegen_1$q._)`${data}${(0, codegen_1$q.getProperty)(property2)} !== undefined`;
  return ownProperties ? (0, codegen_1$q._)`${cond} && ${isOwnProperty(gen, data, property2)}` : cond;
}
code$3.propertyInData = propertyInData;
function noPropertyInData(gen, data, property2, ownProperties) {
  const cond = (0, codegen_1$q._)`${data}${(0, codegen_1$q.getProperty)(property2)} === undefined`;
  return ownProperties ? (0, codegen_1$q.or)(cond, (0, codegen_1$q.not)(isOwnProperty(gen, data, property2))) : cond;
}
code$3.noPropertyInData = noPropertyInData;
function allSchemaProperties(schemaMap) {
  return schemaMap ? Object.keys(schemaMap).filter((p2) => p2 !== "__proto__") : [];
}
code$3.allSchemaProperties = allSchemaProperties;
function schemaProperties(it2, schemaMap) {
  return allSchemaProperties(schemaMap).filter((p2) => !(0, util_1$o.alwaysValidSchema)(it2, schemaMap[p2]));
}
code$3.schemaProperties = schemaProperties;
function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it: it2 }, func, context, passSchema) {
  const dataAndSchema = passSchema ? (0, codegen_1$q._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
  const valCxt = [
    [names_1$5.default.instancePath, (0, codegen_1$q.strConcat)(names_1$5.default.instancePath, errorPath)],
    [names_1$5.default.parentData, it2.parentData],
    [names_1$5.default.parentDataProperty, it2.parentDataProperty],
    [names_1$5.default.rootData, names_1$5.default.rootData]
  ];
  if (it2.opts.dynamicRef)
    valCxt.push([names_1$5.default.dynamicAnchors, names_1$5.default.dynamicAnchors]);
  const args = (0, codegen_1$q._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
  return context !== codegen_1$q.nil ? (0, codegen_1$q._)`${func}.call(${context}, ${args})` : (0, codegen_1$q._)`${func}(${args})`;
}
code$3.callValidateCode = callValidateCode;
const newRegExp = (0, codegen_1$q._)`new RegExp`;
function usePattern({ gen, it: { opts } }, pattern2) {
  const u2 = opts.unicodeRegExp ? "u" : "";
  const { regExp } = opts.code;
  const rx = regExp(pattern2, u2);
  return gen.scopeValue("pattern", {
    key: rx.toString(),
    ref: rx,
    code: (0, codegen_1$q._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2$1.useFunc)(gen, regExp)}(${pattern2}, ${u2})`
  });
}
code$3.usePattern = usePattern;
function validateArray(cxt) {
  const { gen, data, keyword: keyword2, it: it2 } = cxt;
  const valid2 = gen.name("valid");
  if (it2.allErrors) {
    const validArr = gen.let("valid", true);
    validateItems(() => gen.assign(validArr, false));
    return validArr;
  }
  gen.var(valid2, true);
  validateItems(() => gen.break());
  return valid2;
  function validateItems(notValid) {
    const len = gen.const("len", (0, codegen_1$q._)`${data}.length`);
    gen.forRange("i", 0, len, (i) => {
      cxt.subschema({
        keyword: keyword2,
        dataProp: i,
        dataPropType: util_1$o.Type.Num
      }, valid2);
      gen.if((0, codegen_1$q.not)(valid2), notValid);
    });
  }
}
code$3.validateArray = validateArray;
function validateUnion(cxt) {
  const { gen, schema, keyword: keyword2, it: it2 } = cxt;
  if (!Array.isArray(schema))
    throw new Error("ajv implementation error");
  const alwaysValid = schema.some((sch) => (0, util_1$o.alwaysValidSchema)(it2, sch));
  if (alwaysValid && !it2.opts.unevaluated)
    return;
  const valid2 = gen.let("valid", false);
  const schValid = gen.name("_valid");
  gen.block(() => schema.forEach((_sch, i) => {
    const schCxt = cxt.subschema({
      keyword: keyword2,
      schemaProp: i,
      compositeRule: true
    }, schValid);
    gen.assign(valid2, (0, codegen_1$q._)`${valid2} || ${schValid}`);
    const merged = cxt.mergeValidEvaluated(schCxt, schValid);
    if (!merged)
      gen.if((0, codegen_1$q.not)(valid2));
  }));
  cxt.result(valid2, () => cxt.reset(), () => cxt.error(true));
}
code$3.validateUnion = validateUnion;
Object.defineProperty(keyword, "__esModule", { value: true });
keyword.validateKeywordUsage = keyword.validSchemaType = keyword.funcKeywordCode = keyword.macroKeywordCode = void 0;
const codegen_1$p = codegen;
const names_1$4 = names$1;
const code_1$9 = code$3;
const errors_1$1 = errors;
function macroKeywordCode(cxt, def2) {
  const { gen, keyword: keyword2, schema, parentSchema, it: it2 } = cxt;
  const macroSchema = def2.macro.call(it2.self, schema, parentSchema, it2);
  const schemaRef = useKeyword(gen, keyword2, macroSchema);
  if (it2.opts.validateSchema !== false)
    it2.self.validateSchema(macroSchema, true);
  const valid2 = gen.name("valid");
  cxt.subschema({
    schema: macroSchema,
    schemaPath: codegen_1$p.nil,
    errSchemaPath: `${it2.errSchemaPath}/${keyword2}`,
    topSchemaRef: schemaRef,
    compositeRule: true
  }, valid2);
  cxt.pass(valid2, () => cxt.error(true));
}
keyword.macroKeywordCode = macroKeywordCode;
function funcKeywordCode(cxt, def2) {
  var _a3;
  const { gen, keyword: keyword2, schema, parentSchema, $data, it: it2 } = cxt;
  checkAsyncKeyword(it2, def2);
  const validate2 = !$data && def2.compile ? def2.compile.call(it2.self, schema, parentSchema, it2) : def2.validate;
  const validateRef = useKeyword(gen, keyword2, validate2);
  const valid2 = gen.let("valid");
  cxt.block$data(valid2, validateKeyword);
  cxt.ok((_a3 = def2.valid) !== null && _a3 !== void 0 ? _a3 : valid2);
  function validateKeyword() {
    if (def2.errors === false) {
      assignValid();
      if (def2.modifying)
        modifyData(cxt);
      reportErrs(() => cxt.error());
    } else {
      const ruleErrs = def2.async ? validateAsync() : validateSync();
      if (def2.modifying)
        modifyData(cxt);
      reportErrs(() => addErrs(cxt, ruleErrs));
    }
  }
  function validateAsync() {
    const ruleErrs = gen.let("ruleErrs", null);
    gen.try(() => assignValid((0, codegen_1$p._)`await `), (e2) => gen.assign(valid2, false).if((0, codegen_1$p._)`${e2} instanceof ${it2.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1$p._)`${e2}.errors`), () => gen.throw(e2)));
    return ruleErrs;
  }
  function validateSync() {
    const validateErrs = (0, codegen_1$p._)`${validateRef}.errors`;
    gen.assign(validateErrs, null);
    assignValid(codegen_1$p.nil);
    return validateErrs;
  }
  function assignValid(_await = def2.async ? (0, codegen_1$p._)`await ` : codegen_1$p.nil) {
    const passCxt = it2.opts.passContext ? names_1$4.default.this : names_1$4.default.self;
    const passSchema = !("compile" in def2 && !$data || def2.schema === false);
    gen.assign(valid2, (0, codegen_1$p._)`${_await}${(0, code_1$9.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def2.modifying);
  }
  function reportErrs(errors2) {
    var _a4;
    gen.if((0, codegen_1$p.not)((_a4 = def2.valid) !== null && _a4 !== void 0 ? _a4 : valid2), errors2);
  }
}
keyword.funcKeywordCode = funcKeywordCode;
function modifyData(cxt) {
  const { gen, data, it: it2 } = cxt;
  gen.if(it2.parentData, () => gen.assign(data, (0, codegen_1$p._)`${it2.parentData}[${it2.parentDataProperty}]`));
}
function addErrs(cxt, errs) {
  const { gen } = cxt;
  gen.if((0, codegen_1$p._)`Array.isArray(${errs})`, () => {
    gen.assign(names_1$4.default.vErrors, (0, codegen_1$p._)`${names_1$4.default.vErrors} === null ? ${errs} : ${names_1$4.default.vErrors}.concat(${errs})`).assign(names_1$4.default.errors, (0, codegen_1$p._)`${names_1$4.default.vErrors}.length`);
    (0, errors_1$1.extendErrors)(cxt);
  }, () => cxt.error());
}
function checkAsyncKeyword({ schemaEnv }, def2) {
  if (def2.async && !schemaEnv.$async)
    throw new Error("async keyword in sync schema");
}
function useKeyword(gen, keyword2, result) {
  if (result === void 0)
    throw new Error(`keyword "${keyword2}" failed to compile`);
  return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1$p.stringify)(result) });
}
function validSchemaType(schema, schemaType, allowUndefined = false) {
  return !schemaType.length || schemaType.some((st2) => st2 === "array" ? Array.isArray(schema) : st2 === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st2 || allowUndefined && typeof schema == "undefined");
}
keyword.validSchemaType = validSchemaType;
function validateKeywordUsage({ schema, opts, self: self2, errSchemaPath }, def2, keyword2) {
  if (Array.isArray(def2.keyword) ? !def2.keyword.includes(keyword2) : def2.keyword !== keyword2) {
    throw new Error("ajv implementation error");
  }
  const deps = def2.dependencies;
  if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
    throw new Error(`parent schema must have dependencies of ${keyword2}: ${deps.join(",")}`);
  }
  if (def2.validateSchema) {
    const valid2 = def2.validateSchema(schema[keyword2]);
    if (!valid2) {
      const msg = `keyword "${keyword2}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def2.validateSchema.errors);
      if (opts.validateSchema === "log")
        self2.logger.error(msg);
      else
        throw new Error(msg);
    }
  }
}
keyword.validateKeywordUsage = validateKeywordUsage;
var subschema = {};
Object.defineProperty(subschema, "__esModule", { value: true });
subschema.extendSubschemaMode = subschema.extendSubschemaData = subschema.getSubschema = void 0;
const codegen_1$o = codegen;
const util_1$n = util;
function getSubschema(it2, { keyword: keyword2, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
  if (keyword2 !== void 0 && schema !== void 0) {
    throw new Error('both "keyword" and "schema" passed, only one allowed');
  }
  if (keyword2 !== void 0) {
    const sch = it2.schema[keyword2];
    return schemaProp === void 0 ? {
      schema: sch,
      schemaPath: (0, codegen_1$o._)`${it2.schemaPath}${(0, codegen_1$o.getProperty)(keyword2)}`,
      errSchemaPath: `${it2.errSchemaPath}/${keyword2}`
    } : {
      schema: sch[schemaProp],
      schemaPath: (0, codegen_1$o._)`${it2.schemaPath}${(0, codegen_1$o.getProperty)(keyword2)}${(0, codegen_1$o.getProperty)(schemaProp)}`,
      errSchemaPath: `${it2.errSchemaPath}/${keyword2}/${(0, util_1$n.escapeFragment)(schemaProp)}`
    };
  }
  if (schema !== void 0) {
    if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
      throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
    }
    return {
      schema,
      schemaPath,
      topSchemaRef,
      errSchemaPath
    };
  }
  throw new Error('either "keyword" or "schema" must be passed');
}
subschema.getSubschema = getSubschema;
function extendSubschemaData(subschema2, it2, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
  if (data !== void 0 && dataProp !== void 0) {
    throw new Error('both "data" and "dataProp" passed, only one allowed');
  }
  const { gen } = it2;
  if (dataProp !== void 0) {
    const { errorPath, dataPathArr, opts } = it2;
    const nextData = gen.let("data", (0, codegen_1$o._)`${it2.data}${(0, codegen_1$o.getProperty)(dataProp)}`, true);
    dataContextProps(nextData);
    subschema2.errorPath = (0, codegen_1$o.str)`${errorPath}${(0, util_1$n.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
    subschema2.parentDataProperty = (0, codegen_1$o._)`${dataProp}`;
    subschema2.dataPathArr = [...dataPathArr, subschema2.parentDataProperty];
  }
  if (data !== void 0) {
    const nextData = data instanceof codegen_1$o.Name ? data : gen.let("data", data, true);
    dataContextProps(nextData);
    if (propertyName !== void 0)
      subschema2.propertyName = propertyName;
  }
  if (dataTypes)
    subschema2.dataTypes = dataTypes;
  function dataContextProps(_nextData) {
    subschema2.data = _nextData;
    subschema2.dataLevel = it2.dataLevel + 1;
    subschema2.dataTypes = [];
    it2.definedProperties = /* @__PURE__ */ new Set();
    subschema2.parentData = it2.data;
    subschema2.dataNames = [...it2.dataNames, _nextData];
  }
}
subschema.extendSubschemaData = extendSubschemaData;
function extendSubschemaMode(subschema2, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
  if (compositeRule !== void 0)
    subschema2.compositeRule = compositeRule;
  if (createErrors !== void 0)
    subschema2.createErrors = createErrors;
  if (allErrors !== void 0)
    subschema2.allErrors = allErrors;
  subschema2.jtdDiscriminator = jtdDiscriminator;
  subschema2.jtdMetadata = jtdMetadata;
}
subschema.extendSubschemaMode = extendSubschemaMode;
var resolve$2 = {};
var fastDeepEqual = function equal(a2, b2) {
  if (a2 === b2) return true;
  if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
    if (a2.constructor !== b2.constructor) return false;
    var length2, i, keys2;
    if (Array.isArray(a2)) {
      length2 = a2.length;
      if (length2 != b2.length) return false;
      for (i = length2; i-- !== 0; )
        if (!equal(a2[i], b2[i])) return false;
      return true;
    }
    if (a2.constructor === RegExp) return a2.source === b2.source && a2.flags === b2.flags;
    if (a2.valueOf !== Object.prototype.valueOf) return a2.valueOf() === b2.valueOf();
    if (a2.toString !== Object.prototype.toString) return a2.toString() === b2.toString();
    keys2 = Object.keys(a2);
    length2 = keys2.length;
    if (length2 !== Object.keys(b2).length) return false;
    for (i = length2; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b2, keys2[i])) return false;
    for (i = length2; i-- !== 0; ) {
      var key = keys2[i];
      if (!equal(a2[key], b2[key])) return false;
    }
    return true;
  }
  return a2 !== a2 && b2 !== b2;
};
var jsonSchemaTraverse = { exports: {} };
var traverse$1 = jsonSchemaTraverse.exports = function(schema, opts, cb) {
  if (typeof opts == "function") {
    cb = opts;
    opts = {};
  }
  cb = opts.cb || cb;
  var pre = typeof cb == "function" ? cb : cb.pre || function() {
  };
  var post = cb.post || function() {
  };
  _traverse(opts, pre, post, schema, "", schema);
};
traverse$1.keywords = {
  additionalItems: true,
  items: true,
  contains: true,
  additionalProperties: true,
  propertyNames: true,
  not: true,
  if: true,
  then: true,
  else: true
};
traverse$1.arrayKeywords = {
  items: true,
  allOf: true,
  anyOf: true,
  oneOf: true
};
traverse$1.propsKeywords = {
  $defs: true,
  definitions: true,
  properties: true,
  patternProperties: true,
  dependencies: true
};
traverse$1.skipKeywords = {
  default: true,
  enum: true,
  const: true,
  required: true,
  maximum: true,
  minimum: true,
  exclusiveMaximum: true,
  exclusiveMinimum: true,
  multipleOf: true,
  maxLength: true,
  minLength: true,
  pattern: true,
  format: true,
  maxItems: true,
  minItems: true,
  uniqueItems: true,
  maxProperties: true,
  minProperties: true
};
function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
  if (schema && typeof schema == "object" && !Array.isArray(schema)) {
    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    for (var key in schema) {
      var sch = schema[key];
      if (Array.isArray(sch)) {
        if (key in traverse$1.arrayKeywords) {
          for (var i = 0; i < sch.length; i++)
            _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
        }
      } else if (key in traverse$1.propsKeywords) {
        if (sch && typeof sch == "object") {
          for (var prop in sch)
            _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
        }
      } else if (key in traverse$1.keywords || opts.allKeys && !(key in traverse$1.skipKeywords)) {
        _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
      }
    }
    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
  }
}
function escapeJsonPtr(str) {
  return str.replace(/~/g, "~0").replace(/\//g, "~1");
}
var jsonSchemaTraverseExports = jsonSchemaTraverse.exports;
Object.defineProperty(resolve$2, "__esModule", { value: true });
resolve$2.getSchemaRefs = resolve$2.resolveUrl = resolve$2.normalizeId = resolve$2._getFullPath = resolve$2.getFullPath = resolve$2.inlineRef = void 0;
const util_1$m = util;
const equal$3 = fastDeepEqual;
const traverse = jsonSchemaTraverseExports;
const SIMPLE_INLINED = /* @__PURE__ */ new Set([
  "type",
  "format",
  "pattern",
  "maxLength",
  "minLength",
  "maxProperties",
  "minProperties",
  "maxItems",
  "minItems",
  "maximum",
  "minimum",
  "uniqueItems",
  "multipleOf",
  "required",
  "enum",
  "const"
]);
function inlineRef(schema, limit = true) {
  if (typeof schema == "boolean")
    return true;
  if (limit === true)
    return !hasRef(schema);
  if (!limit)
    return false;
  return countKeys(schema) <= limit;
}
resolve$2.inlineRef = inlineRef;
const REF_KEYWORDS = /* @__PURE__ */ new Set([
  "$ref",
  "$recursiveRef",
  "$recursiveAnchor",
  "$dynamicRef",
  "$dynamicAnchor"
]);
function hasRef(schema) {
  for (const key in schema) {
    if (REF_KEYWORDS.has(key))
      return true;
    const sch = schema[key];
    if (Array.isArray(sch) && sch.some(hasRef))
      return true;
    if (typeof sch == "object" && hasRef(sch))
      return true;
  }
  return false;
}
function countKeys(schema) {
  let count = 0;
  for (const key in schema) {
    if (key === "$ref")
      return Infinity;
    count++;
    if (SIMPLE_INLINED.has(key))
      continue;
    if (typeof schema[key] == "object") {
      (0, util_1$m.eachItem)(schema[key], (sch) => count += countKeys(sch));
    }
    if (count === Infinity)
      return Infinity;
  }
  return count;
}
function getFullPath(resolver2, id2 = "", normalize2) {
  if (normalize2 !== false)
    id2 = normalizeId(id2);
  const p2 = resolver2.parse(id2);
  return _getFullPath(resolver2, p2);
}
resolve$2.getFullPath = getFullPath;
function _getFullPath(resolver2, p2) {
  const serialized = resolver2.serialize(p2);
  return serialized.split("#")[0] + "#";
}
resolve$2._getFullPath = _getFullPath;
const TRAILING_SLASH_HASH = /#\/?$/;
function normalizeId(id2) {
  return id2 ? id2.replace(TRAILING_SLASH_HASH, "") : "";
}
resolve$2.normalizeId = normalizeId;
function resolveUrl(resolver2, baseId, id2) {
  id2 = normalizeId(id2);
  return resolver2.resolve(baseId, id2);
}
resolve$2.resolveUrl = resolveUrl;
const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
function getSchemaRefs(schema, baseId) {
  if (typeof schema == "boolean")
    return {};
  const { schemaId, uriResolver } = this.opts;
  const schId = normalizeId(schema[schemaId] || baseId);
  const baseIds = { "": schId };
  const pathPrefix = getFullPath(uriResolver, schId, false);
  const localRefs = {};
  const schemaRefs = /* @__PURE__ */ new Set();
  traverse(schema, { allKeys: true }, (sch, jsonPtr, _2, parentJsonPtr) => {
    if (parentJsonPtr === void 0)
      return;
    const fullPath = pathPrefix + jsonPtr;
    let innerBaseId = baseIds[parentJsonPtr];
    if (typeof sch[schemaId] == "string")
      innerBaseId = addRef.call(this, sch[schemaId]);
    addAnchor.call(this, sch.$anchor);
    addAnchor.call(this, sch.$dynamicAnchor);
    baseIds[jsonPtr] = innerBaseId;
    function addRef(ref2) {
      const _resolve = this.opts.uriResolver.resolve;
      ref2 = normalizeId(innerBaseId ? _resolve(innerBaseId, ref2) : ref2);
      if (schemaRefs.has(ref2))
        throw ambiguos(ref2);
      schemaRefs.add(ref2);
      let schOrRef = this.refs[ref2];
      if (typeof schOrRef == "string")
        schOrRef = this.refs[schOrRef];
      if (typeof schOrRef == "object") {
        checkAmbiguosRef(sch, schOrRef.schema, ref2);
      } else if (ref2 !== normalizeId(fullPath)) {
        if (ref2[0] === "#") {
          checkAmbiguosRef(sch, localRefs[ref2], ref2);
          localRefs[ref2] = sch;
        } else {
          this.refs[ref2] = fullPath;
        }
      }
      return ref2;
    }
    function addAnchor(anchor) {
      if (typeof anchor == "string") {
        if (!ANCHOR.test(anchor))
          throw new Error(`invalid anchor "${anchor}"`);
        addRef.call(this, `#${anchor}`);
      }
    }
  });
  return localRefs;
  function checkAmbiguosRef(sch1, sch2, ref2) {
    if (sch2 !== void 0 && !equal$3(sch1, sch2))
      throw ambiguos(ref2);
  }
  function ambiguos(ref2) {
    return new Error(`reference "${ref2}" resolves to more than one schema`);
  }
}
resolve$2.getSchemaRefs = getSchemaRefs;
Object.defineProperty(validate, "__esModule", { value: true });
validate.getData = validate.KeywordCxt = validate.validateFunctionCode = void 0;
const boolSchema_1 = boolSchema;
const dataType_1$1 = dataType;
const applicability_1 = applicability;
const dataType_2 = dataType;
const defaults_1 = defaults$2;
const keyword_1 = keyword;
const subschema_1 = subschema;
const codegen_1$n = codegen;
const names_1$3 = names$1;
const resolve_1$2 = resolve$2;
const util_1$l = util;
const errors_1 = errors;
function validateFunctionCode(it2) {
  if (isSchemaObj(it2)) {
    checkKeywords(it2);
    if (schemaCxtHasRules(it2)) {
      topSchemaObjCode(it2);
      return;
    }
  }
  validateFunction(it2, () => (0, boolSchema_1.topBoolOrEmptySchema)(it2));
}
validate.validateFunctionCode = validateFunctionCode;
function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
  if (opts.code.es5) {
    gen.func(validateName, (0, codegen_1$n._)`${names_1$3.default.data}, ${names_1$3.default.valCxt}`, schemaEnv.$async, () => {
      gen.code((0, codegen_1$n._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
      destructureValCxtES5(gen, opts);
      gen.code(body);
    });
  } else {
    gen.func(validateName, (0, codegen_1$n._)`${names_1$3.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
  }
}
function destructureValCxt(opts) {
  return (0, codegen_1$n._)`{${names_1$3.default.instancePath}="", ${names_1$3.default.parentData}, ${names_1$3.default.parentDataProperty}, ${names_1$3.default.rootData}=${names_1$3.default.data}${opts.dynamicRef ? (0, codegen_1$n._)`, ${names_1$3.default.dynamicAnchors}={}` : codegen_1$n.nil}}={}`;
}
function destructureValCxtES5(gen, opts) {
  gen.if(names_1$3.default.valCxt, () => {
    gen.var(names_1$3.default.instancePath, (0, codegen_1$n._)`${names_1$3.default.valCxt}.${names_1$3.default.instancePath}`);
    gen.var(names_1$3.default.parentData, (0, codegen_1$n._)`${names_1$3.default.valCxt}.${names_1$3.default.parentData}`);
    gen.var(names_1$3.default.parentDataProperty, (0, codegen_1$n._)`${names_1$3.default.valCxt}.${names_1$3.default.parentDataProperty}`);
    gen.var(names_1$3.default.rootData, (0, codegen_1$n._)`${names_1$3.default.valCxt}.${names_1$3.default.rootData}`);
    if (opts.dynamicRef)
      gen.var(names_1$3.default.dynamicAnchors, (0, codegen_1$n._)`${names_1$3.default.valCxt}.${names_1$3.default.dynamicAnchors}`);
  }, () => {
    gen.var(names_1$3.default.instancePath, (0, codegen_1$n._)`""`);
    gen.var(names_1$3.default.parentData, (0, codegen_1$n._)`undefined`);
    gen.var(names_1$3.default.parentDataProperty, (0, codegen_1$n._)`undefined`);
    gen.var(names_1$3.default.rootData, names_1$3.default.data);
    if (opts.dynamicRef)
      gen.var(names_1$3.default.dynamicAnchors, (0, codegen_1$n._)`{}`);
  });
}
function topSchemaObjCode(it2) {
  const { schema, opts, gen } = it2;
  validateFunction(it2, () => {
    if (opts.$comment && schema.$comment)
      commentKeyword(it2);
    checkNoDefault(it2);
    gen.let(names_1$3.default.vErrors, null);
    gen.let(names_1$3.default.errors, 0);
    if (opts.unevaluated)
      resetEvaluated(it2);
    typeAndKeywords(it2);
    returnResults(it2);
  });
  return;
}
function resetEvaluated(it2) {
  const { gen, validateName } = it2;
  it2.evaluated = gen.const("evaluated", (0, codegen_1$n._)`${validateName}.evaluated`);
  gen.if((0, codegen_1$n._)`${it2.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1$n._)`${it2.evaluated}.props`, (0, codegen_1$n._)`undefined`));
  gen.if((0, codegen_1$n._)`${it2.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1$n._)`${it2.evaluated}.items`, (0, codegen_1$n._)`undefined`));
}
function funcSourceUrl(schema, opts) {
  const schId = typeof schema == "object" && schema[opts.schemaId];
  return schId && (opts.code.source || opts.code.process) ? (0, codegen_1$n._)`/*# sourceURL=${schId} */` : codegen_1$n.nil;
}
function subschemaCode(it2, valid2) {
  if (isSchemaObj(it2)) {
    checkKeywords(it2);
    if (schemaCxtHasRules(it2)) {
      subSchemaObjCode(it2, valid2);
      return;
    }
  }
  (0, boolSchema_1.boolOrEmptySchema)(it2, valid2);
}
function schemaCxtHasRules({ schema, self: self2 }) {
  if (typeof schema == "boolean")
    return !schema;
  for (const key in schema)
    if (self2.RULES.all[key])
      return true;
  return false;
}
function isSchemaObj(it2) {
  return typeof it2.schema != "boolean";
}
function subSchemaObjCode(it2, valid2) {
  const { schema, gen, opts } = it2;
  if (opts.$comment && schema.$comment)
    commentKeyword(it2);
  updateContext(it2);
  checkAsyncSchema(it2);
  const errsCount = gen.const("_errs", names_1$3.default.errors);
  typeAndKeywords(it2, errsCount);
  gen.var(valid2, (0, codegen_1$n._)`${errsCount} === ${names_1$3.default.errors}`);
}
function checkKeywords(it2) {
  (0, util_1$l.checkUnknownRules)(it2);
  checkRefsAndKeywords(it2);
}
function typeAndKeywords(it2, errsCount) {
  if (it2.opts.jtd)
    return schemaKeywords(it2, [], false, errsCount);
  const types2 = (0, dataType_1$1.getSchemaTypes)(it2.schema);
  const checkedTypes = (0, dataType_1$1.coerceAndCheckDataType)(it2, types2);
  schemaKeywords(it2, types2, !checkedTypes, errsCount);
}
function checkRefsAndKeywords(it2) {
  const { schema, errSchemaPath, opts, self: self2 } = it2;
  if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1$l.schemaHasRulesButRef)(schema, self2.RULES)) {
    self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
  }
}
function checkNoDefault(it2) {
  const { schema, opts } = it2;
  if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
    (0, util_1$l.checkStrictMode)(it2, "default is ignored in the schema root");
  }
}
function updateContext(it2) {
  const schId = it2.schema[it2.opts.schemaId];
  if (schId)
    it2.baseId = (0, resolve_1$2.resolveUrl)(it2.opts.uriResolver, it2.baseId, schId);
}
function checkAsyncSchema(it2) {
  if (it2.schema.$async && !it2.schemaEnv.$async)
    throw new Error("async schema in sync schema");
}
function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
  const msg = schema.$comment;
  if (opts.$comment === true) {
    gen.code((0, codegen_1$n._)`${names_1$3.default.self}.logger.log(${msg})`);
  } else if (typeof opts.$comment == "function") {
    const schemaPath = (0, codegen_1$n.str)`${errSchemaPath}/$comment`;
    const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
    gen.code((0, codegen_1$n._)`${names_1$3.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
  }
}
function returnResults(it2) {
  const { gen, schemaEnv, validateName, ValidationError: ValidationError2, opts } = it2;
  if (schemaEnv.$async) {
    gen.if((0, codegen_1$n._)`${names_1$3.default.errors} === 0`, () => gen.return(names_1$3.default.data), () => gen.throw((0, codegen_1$n._)`new ${ValidationError2}(${names_1$3.default.vErrors})`));
  } else {
    gen.assign((0, codegen_1$n._)`${validateName}.errors`, names_1$3.default.vErrors);
    if (opts.unevaluated)
      assignEvaluated(it2);
    gen.return((0, codegen_1$n._)`${names_1$3.default.errors} === 0`);
  }
}
function assignEvaluated({ gen, evaluated, props, items: items2 }) {
  if (props instanceof codegen_1$n.Name)
    gen.assign((0, codegen_1$n._)`${evaluated}.props`, props);
  if (items2 instanceof codegen_1$n.Name)
    gen.assign((0, codegen_1$n._)`${evaluated}.items`, items2);
}
function schemaKeywords(it2, types2, typeErrors, errsCount) {
  const { gen, schema, data, allErrors, opts, self: self2 } = it2;
  const { RULES } = self2;
  if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1$l.schemaHasRulesButRef)(schema, RULES))) {
    gen.block(() => keywordCode(it2, "$ref", RULES.all.$ref.definition));
    return;
  }
  if (!opts.jtd)
    checkStrictTypes(it2, types2);
  gen.block(() => {
    for (const group of RULES.rules)
      groupKeywords(group);
    groupKeywords(RULES.post);
  });
  function groupKeywords(group) {
    if (!(0, applicability_1.shouldUseGroup)(schema, group))
      return;
    if (group.type) {
      gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
      iterateKeywords(it2, group);
      if (types2.length === 1 && types2[0] === group.type && typeErrors) {
        gen.else();
        (0, dataType_2.reportTypeError)(it2);
      }
      gen.endIf();
    } else {
      iterateKeywords(it2, group);
    }
    if (!allErrors)
      gen.if((0, codegen_1$n._)`${names_1$3.default.errors} === ${errsCount || 0}`);
  }
}
function iterateKeywords(it2, group) {
  const { gen, schema, opts: { useDefaults } } = it2;
  if (useDefaults)
    (0, defaults_1.assignDefaults)(it2, group.type);
  gen.block(() => {
    for (const rule of group.rules) {
      if ((0, applicability_1.shouldUseRule)(schema, rule)) {
        keywordCode(it2, rule.keyword, rule.definition, group.type);
      }
    }
  });
}
function checkStrictTypes(it2, types2) {
  if (it2.schemaEnv.meta || !it2.opts.strictTypes)
    return;
  checkContextTypes(it2, types2);
  if (!it2.opts.allowUnionTypes)
    checkMultipleTypes(it2, types2);
  checkKeywordTypes(it2, it2.dataTypes);
}
function checkContextTypes(it2, types2) {
  if (!types2.length)
    return;
  if (!it2.dataTypes.length) {
    it2.dataTypes = types2;
    return;
  }
  types2.forEach((t2) => {
    if (!includesType(it2.dataTypes, t2)) {
      strictTypesError(it2, `type "${t2}" not allowed by context "${it2.dataTypes.join(",")}"`);
    }
  });
  narrowSchemaTypes(it2, types2);
}
function checkMultipleTypes(it2, ts2) {
  if (ts2.length > 1 && !(ts2.length === 2 && ts2.includes("null"))) {
    strictTypesError(it2, "use allowUnionTypes to allow union type keyword");
  }
}
function checkKeywordTypes(it2, ts2) {
  const rules2 = it2.self.RULES.all;
  for (const keyword2 in rules2) {
    const rule = rules2[keyword2];
    if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it2.schema, rule)) {
      const { type: type2 } = rule.definition;
      if (type2.length && !type2.some((t2) => hasApplicableType(ts2, t2))) {
        strictTypesError(it2, `missing type "${type2.join(",")}" for keyword "${keyword2}"`);
      }
    }
  }
}
function hasApplicableType(schTs, kwdT) {
  return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
}
function includesType(ts2, t2) {
  return ts2.includes(t2) || t2 === "integer" && ts2.includes("number");
}
function narrowSchemaTypes(it2, withTypes) {
  const ts2 = [];
  for (const t2 of it2.dataTypes) {
    if (includesType(withTypes, t2))
      ts2.push(t2);
    else if (withTypes.includes("integer") && t2 === "number")
      ts2.push("integer");
  }
  it2.dataTypes = ts2;
}
function strictTypesError(it2, msg) {
  const schemaPath = it2.schemaEnv.baseId + it2.errSchemaPath;
  msg += ` at "${schemaPath}" (strictTypes)`;
  (0, util_1$l.checkStrictMode)(it2, msg, it2.opts.strictTypes);
}
class KeywordCxt {
  constructor(it2, def2, keyword2) {
    (0, keyword_1.validateKeywordUsage)(it2, def2, keyword2);
    this.gen = it2.gen;
    this.allErrors = it2.allErrors;
    this.keyword = keyword2;
    this.data = it2.data;
    this.schema = it2.schema[keyword2];
    this.$data = def2.$data && it2.opts.$data && this.schema && this.schema.$data;
    this.schemaValue = (0, util_1$l.schemaRefOrVal)(it2, this.schema, keyword2, this.$data);
    this.schemaType = def2.schemaType;
    this.parentSchema = it2.schema;
    this.params = {};
    this.it = it2;
    this.def = def2;
    if (this.$data) {
      this.schemaCode = it2.gen.const("vSchema", getData(this.$data, it2));
    } else {
      this.schemaCode = this.schemaValue;
      if (!(0, keyword_1.validSchemaType)(this.schema, def2.schemaType, def2.allowUndefined)) {
        throw new Error(`${keyword2} value must be ${JSON.stringify(def2.schemaType)}`);
      }
    }
    if ("code" in def2 ? def2.trackErrors : def2.errors !== false) {
      this.errsCount = it2.gen.const("_errs", names_1$3.default.errors);
    }
  }
  result(condition, successAction, failAction) {
    this.failResult((0, codegen_1$n.not)(condition), successAction, failAction);
  }
  failResult(condition, successAction, failAction) {
    this.gen.if(condition);
    if (failAction)
      failAction();
    else
      this.error();
    if (successAction) {
      this.gen.else();
      successAction();
      if (this.allErrors)
        this.gen.endIf();
    } else {
      if (this.allErrors)
        this.gen.endIf();
      else
        this.gen.else();
    }
  }
  pass(condition, failAction) {
    this.failResult((0, codegen_1$n.not)(condition), void 0, failAction);
  }
  fail(condition) {
    if (condition === void 0) {
      this.error();
      if (!this.allErrors)
        this.gen.if(false);
      return;
    }
    this.gen.if(condition);
    this.error();
    if (this.allErrors)
      this.gen.endIf();
    else
      this.gen.else();
  }
  fail$data(condition) {
    if (!this.$data)
      return this.fail(condition);
    const { schemaCode } = this;
    this.fail((0, codegen_1$n._)`${schemaCode} !== undefined && (${(0, codegen_1$n.or)(this.invalid$data(), condition)})`);
  }
  error(append3, errorParams, errorPaths) {
    if (errorParams) {
      this.setParams(errorParams);
      this._error(append3, errorPaths);
      this.setParams({});
      return;
    }
    this._error(append3, errorPaths);
  }
  _error(append3, errorPaths) {
    (append3 ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
  }
  $dataError() {
    (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
  }
  reset() {
    if (this.errsCount === void 0)
      throw new Error('add "trackErrors" to keyword definition');
    (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
  }
  ok(cond) {
    if (!this.allErrors)
      this.gen.if(cond);
  }
  setParams(obj, assign2) {
    if (assign2)
      Object.assign(this.params, obj);
    else
      this.params = obj;
  }
  block$data(valid2, codeBlock, $dataValid = codegen_1$n.nil) {
    this.gen.block(() => {
      this.check$data(valid2, $dataValid);
      codeBlock();
    });
  }
  check$data(valid2 = codegen_1$n.nil, $dataValid = codegen_1$n.nil) {
    if (!this.$data)
      return;
    const { gen, schemaCode, schemaType, def: def2 } = this;
    gen.if((0, codegen_1$n.or)((0, codegen_1$n._)`${schemaCode} === undefined`, $dataValid));
    if (valid2 !== codegen_1$n.nil)
      gen.assign(valid2, true);
    if (schemaType.length || def2.validateSchema) {
      gen.elseIf(this.invalid$data());
      this.$dataError();
      if (valid2 !== codegen_1$n.nil)
        gen.assign(valid2, false);
    }
    gen.else();
  }
  invalid$data() {
    const { gen, schemaCode, schemaType, def: def2, it: it2 } = this;
    return (0, codegen_1$n.or)(wrong$DataType(), invalid$DataSchema());
    function wrong$DataType() {
      if (schemaType.length) {
        if (!(schemaCode instanceof codegen_1$n.Name))
          throw new Error("ajv implementation error");
        const st2 = Array.isArray(schemaType) ? schemaType : [schemaType];
        return (0, codegen_1$n._)`${(0, dataType_2.checkDataTypes)(st2, schemaCode, it2.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
      }
      return codegen_1$n.nil;
    }
    function invalid$DataSchema() {
      if (def2.validateSchema) {
        const validateSchemaRef = gen.scopeValue("validate$data", { ref: def2.validateSchema });
        return (0, codegen_1$n._)`!${validateSchemaRef}(${schemaCode})`;
      }
      return codegen_1$n.nil;
    }
  }
  subschema(appl, valid2) {
    const subschema2 = (0, subschema_1.getSubschema)(this.it, appl);
    (0, subschema_1.extendSubschemaData)(subschema2, this.it, appl);
    (0, subschema_1.extendSubschemaMode)(subschema2, appl);
    const nextContext = { ...this.it, ...subschema2, items: void 0, props: void 0 };
    subschemaCode(nextContext, valid2);
    return nextContext;
  }
  mergeEvaluated(schemaCxt, toName) {
    const { it: it2, gen } = this;
    if (!it2.opts.unevaluated)
      return;
    if (it2.props !== true && schemaCxt.props !== void 0) {
      it2.props = util_1$l.mergeEvaluated.props(gen, schemaCxt.props, it2.props, toName);
    }
    if (it2.items !== true && schemaCxt.items !== void 0) {
      it2.items = util_1$l.mergeEvaluated.items(gen, schemaCxt.items, it2.items, toName);
    }
  }
  mergeValidEvaluated(schemaCxt, valid2) {
    const { it: it2, gen } = this;
    if (it2.opts.unevaluated && (it2.props !== true || it2.items !== true)) {
      gen.if(valid2, () => this.mergeEvaluated(schemaCxt, codegen_1$n.Name));
      return true;
    }
  }
}
validate.KeywordCxt = KeywordCxt;
function keywordCode(it2, keyword2, def2, ruleType) {
  const cxt = new KeywordCxt(it2, def2, keyword2);
  if ("code" in def2) {
    def2.code(cxt, ruleType);
  } else if (cxt.$data && def2.validate) {
    (0, keyword_1.funcKeywordCode)(cxt, def2);
  } else if ("macro" in def2) {
    (0, keyword_1.macroKeywordCode)(cxt, def2);
  } else if (def2.compile || def2.validate) {
    (0, keyword_1.funcKeywordCode)(cxt, def2);
  }
}
const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function getData($data, { dataLevel, dataNames, dataPathArr }) {
  let jsonPointer;
  let data;
  if ($data === "")
    return names_1$3.default.rootData;
  if ($data[0] === "/") {
    if (!JSON_POINTER.test($data))
      throw new Error(`Invalid JSON-pointer: ${$data}`);
    jsonPointer = $data;
    data = names_1$3.default.rootData;
  } else {
    const matches = RELATIVE_JSON_POINTER.exec($data);
    if (!matches)
      throw new Error(`Invalid JSON-pointer: ${$data}`);
    const up = +matches[1];
    jsonPointer = matches[2];
    if (jsonPointer === "#") {
      if (up >= dataLevel)
        throw new Error(errorMsg("property/index", up));
      return dataPathArr[dataLevel - up];
    }
    if (up > dataLevel)
      throw new Error(errorMsg("data", up));
    data = dataNames[dataLevel - up];
    if (!jsonPointer)
      return data;
  }
  let expr = data;
  const segments = jsonPointer.split("/");
  for (const segment of segments) {
    if (segment) {
      data = (0, codegen_1$n._)`${data}${(0, codegen_1$n.getProperty)((0, util_1$l.unescapeJsonPointer)(segment))}`;
      expr = (0, codegen_1$n._)`${expr} && ${data}`;
    }
  }
  return expr;
  function errorMsg(pointerType, up) {
    return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
  }
}
validate.getData = getData;
var validation_error = {};
Object.defineProperty(validation_error, "__esModule", { value: true });
class ValidationError extends Error {
  constructor(errors2) {
    super("validation failed");
    this.errors = errors2;
    this.ajv = this.validation = true;
  }
}
validation_error.default = ValidationError;
var ref_error = {};
Object.defineProperty(ref_error, "__esModule", { value: true });
const resolve_1$1 = resolve$2;
class MissingRefError extends Error {
  constructor(resolver2, baseId, ref2, msg) {
    super(msg || `can't resolve reference ${ref2} from id ${baseId}`);
    this.missingRef = (0, resolve_1$1.resolveUrl)(resolver2, baseId, ref2);
    this.missingSchema = (0, resolve_1$1.normalizeId)((0, resolve_1$1.getFullPath)(resolver2, this.missingRef));
  }
}
ref_error.default = MissingRefError;
var compile = {};
Object.defineProperty(compile, "__esModule", { value: true });
compile.resolveSchema = compile.getCompilingSchema = compile.resolveRef = compile.compileSchema = compile.SchemaEnv = void 0;
const codegen_1$m = codegen;
const validation_error_1 = validation_error;
const names_1$2 = names$1;
const resolve_1 = resolve$2;
const util_1$k = util;
const validate_1$1 = validate;
class SchemaEnv {
  constructor(env2) {
    var _a3;
    this.refs = {};
    this.dynamicAnchors = {};
    let schema;
    if (typeof env2.schema == "object")
      schema = env2.schema;
    this.schema = env2.schema;
    this.schemaId = env2.schemaId;
    this.root = env2.root || this;
    this.baseId = (_a3 = env2.baseId) !== null && _a3 !== void 0 ? _a3 : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env2.schemaId || "$id"]);
    this.schemaPath = env2.schemaPath;
    this.localRefs = env2.localRefs;
    this.meta = env2.meta;
    this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
    this.refs = {};
  }
}
compile.SchemaEnv = SchemaEnv;
function compileSchema(sch) {
  const _sch = getCompilingSchema.call(this, sch);
  if (_sch)
    return _sch;
  const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
  const { es5, lines } = this.opts.code;
  const { ownProperties } = this.opts;
  const gen = new codegen_1$m.CodeGen(this.scope, { es5, lines, ownProperties });
  let _ValidationError;
  if (sch.$async) {
    _ValidationError = gen.scopeValue("Error", {
      ref: validation_error_1.default,
      code: (0, codegen_1$m._)`require("ajv/dist/runtime/validation_error").default`
    });
  }
  const validateName = gen.scopeName("validate");
  sch.validateName = validateName;
  const schemaCxt = {
    gen,
    allErrors: this.opts.allErrors,
    data: names_1$2.default.data,
    parentData: names_1$2.default.parentData,
    parentDataProperty: names_1$2.default.parentDataProperty,
    dataNames: [names_1$2.default.data],
    dataPathArr: [codegen_1$m.nil],
    // TODO can its length be used as dataLevel if nil is removed?
    dataLevel: 0,
    dataTypes: [],
    definedProperties: /* @__PURE__ */ new Set(),
    topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1$m.stringify)(sch.schema) } : { ref: sch.schema }),
    validateName,
    ValidationError: _ValidationError,
    schema: sch.schema,
    schemaEnv: sch,
    rootId,
    baseId: sch.baseId || rootId,
    schemaPath: codegen_1$m.nil,
    errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
    errorPath: (0, codegen_1$m._)`""`,
    opts: this.opts,
    self: this
  };
  let sourceCode;
  try {
    this._compilations.add(sch);
    (0, validate_1$1.validateFunctionCode)(schemaCxt);
    gen.optimize(this.opts.code.optimize);
    const validateCode = gen.toString();
    sourceCode = `${gen.scopeRefs(names_1$2.default.scope)}return ${validateCode}`;
    if (this.opts.code.process)
      sourceCode = this.opts.code.process(sourceCode, sch);
    const makeValidate = new Function(`${names_1$2.default.self}`, `${names_1$2.default.scope}`, sourceCode);
    const validate2 = makeValidate(this, this.scope.get());
    this.scope.value(validateName, { ref: validate2 });
    validate2.errors = null;
    validate2.schema = sch.schema;
    validate2.schemaEnv = sch;
    if (sch.$async)
      validate2.$async = true;
    if (this.opts.code.source === true) {
      validate2.source = { validateName, validateCode, scopeValues: gen._values };
    }
    if (this.opts.unevaluated) {
      const { props, items: items2 } = schemaCxt;
      validate2.evaluated = {
        props: props instanceof codegen_1$m.Name ? void 0 : props,
        items: items2 instanceof codegen_1$m.Name ? void 0 : items2,
        dynamicProps: props instanceof codegen_1$m.Name,
        dynamicItems: items2 instanceof codegen_1$m.Name
      };
      if (validate2.source)
        validate2.source.evaluated = (0, codegen_1$m.stringify)(validate2.evaluated);
    }
    sch.validate = validate2;
    return sch;
  } catch (e2) {
    delete sch.validate;
    delete sch.validateName;
    if (sourceCode)
      this.logger.error("Error compiling schema, function code:", sourceCode);
    throw e2;
  } finally {
    this._compilations.delete(sch);
  }
}
compile.compileSchema = compileSchema;
function resolveRef(root2, baseId, ref2) {
  var _a3;
  ref2 = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref2);
  const schOrFunc = root2.refs[ref2];
  if (schOrFunc)
    return schOrFunc;
  let _sch = resolve$1.call(this, root2, ref2);
  if (_sch === void 0) {
    const schema = (_a3 = root2.localRefs) === null || _a3 === void 0 ? void 0 : _a3[ref2];
    const { schemaId } = this.opts;
    if (schema)
      _sch = new SchemaEnv({ schema, schemaId, root: root2, baseId });
  }
  if (_sch === void 0)
    return;
  return root2.refs[ref2] = inlineOrCompile.call(this, _sch);
}
compile.resolveRef = resolveRef;
function inlineOrCompile(sch) {
  if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
    return sch.schema;
  return sch.validate ? sch : compileSchema.call(this, sch);
}
function getCompilingSchema(schEnv) {
  for (const sch of this._compilations) {
    if (sameSchemaEnv(sch, schEnv))
      return sch;
  }
}
compile.getCompilingSchema = getCompilingSchema;
function sameSchemaEnv(s1, s2) {
  return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
}
function resolve$1(root2, ref2) {
  let sch;
  while (typeof (sch = this.refs[ref2]) == "string")
    ref2 = sch;
  return sch || this.schemas[ref2] || resolveSchema.call(this, root2, ref2);
}
function resolveSchema(root2, ref2) {
  const p2 = this.opts.uriResolver.parse(ref2);
  const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p2);
  let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root2.baseId, void 0);
  if (Object.keys(root2.schema).length > 0 && refPath === baseId) {
    return getJsonPointer.call(this, p2, root2);
  }
  const id2 = (0, resolve_1.normalizeId)(refPath);
  const schOrRef = this.refs[id2] || this.schemas[id2];
  if (typeof schOrRef == "string") {
    const sch = resolveSchema.call(this, root2, schOrRef);
    if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
      return;
    return getJsonPointer.call(this, p2, sch);
  }
  if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
    return;
  if (!schOrRef.validate)
    compileSchema.call(this, schOrRef);
  if (id2 === (0, resolve_1.normalizeId)(ref2)) {
    const { schema } = schOrRef;
    const { schemaId } = this.opts;
    const schId = schema[schemaId];
    if (schId)
      baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
    return new SchemaEnv({ schema, schemaId, root: root2, baseId });
  }
  return getJsonPointer.call(this, p2, schOrRef);
}
compile.resolveSchema = resolveSchema;
const PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
  "properties",
  "patternProperties",
  "enum",
  "dependencies",
  "definitions"
]);
function getJsonPointer(parsedRef, { baseId, schema, root: root2 }) {
  var _a3;
  if (((_a3 = parsedRef.fragment) === null || _a3 === void 0 ? void 0 : _a3[0]) !== "/")
    return;
  for (const part of parsedRef.fragment.slice(1).split("/")) {
    if (typeof schema === "boolean")
      return;
    const partSchema = schema[(0, util_1$k.unescapeFragment)(part)];
    if (partSchema === void 0)
      return;
    schema = partSchema;
    const schId = typeof schema === "object" && schema[this.opts.schemaId];
    if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
      baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
    }
  }
  let env2;
  if (typeof schema != "boolean" && schema.$ref && !(0, util_1$k.schemaHasRulesButRef)(schema, this.RULES)) {
    const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
    env2 = resolveSchema.call(this, root2, $ref);
  }
  const { schemaId } = this.opts;
  env2 = env2 || new SchemaEnv({ schema, schemaId, root: root2, baseId });
  if (env2.schema !== env2.root.schema)
    return env2;
  return void 0;
}
const $id$1 = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
const description = "Meta-schema for $data reference (JSON AnySchema extension proposal)";
const type$1 = "object";
const required$1 = [
  "$data"
];
const properties$2 = {
  $data: {
    type: "string",
    anyOf: [
      {
        format: "relative-json-pointer"
      },
      {
        format: "json-pointer"
      }
    ]
  }
};
const additionalProperties$1 = false;
const require$$9 = {
  $id: $id$1,
  description,
  type: type$1,
  required: required$1,
  properties: properties$2,
  additionalProperties: additionalProperties$1
};
var uri$1 = {};
var fastUri$1 = { exports: {} };
const HEX$1 = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  a: 10,
  A: 10,
  b: 11,
  B: 11,
  c: 12,
  C: 12,
  d: 13,
  D: 13,
  e: 14,
  E: 14,
  f: 15,
  F: 15
};
var scopedChars = {
  HEX: HEX$1
};
const { HEX } = scopedChars;
function normalizeIPv4$1(host2) {
  if (findToken(host2, ".") < 3) {
    return { host: host2, isIPV4: false };
  }
  const matches = host2.match(/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/u) || [];
  const [address] = matches;
  if (address) {
    return { host: stripLeadingZeros(address, "."), isIPV4: true };
  } else {
    return { host: host2, isIPV4: false };
  }
}
function stringArrayToHexStripped(input, keepZero = false) {
  let acc = "";
  let strip = true;
  for (const c6 of input) {
    if (HEX[c6] === void 0) return void 0;
    if (c6 !== "0" && strip === true) strip = false;
    if (!strip) acc += c6;
  }
  if (keepZero && acc.length === 0) acc = "0";
  return acc;
}
function getIPV6(input) {
  let tokenCount = 0;
  const output = { error: false, address: "", zone: "" };
  const address = [];
  const buffer2 = [];
  let isZone = false;
  let endipv6Encountered = false;
  let endIpv6 = false;
  function consume() {
    if (buffer2.length) {
      if (isZone === false) {
        const hex = stringArrayToHexStripped(buffer2);
        if (hex !== void 0) {
          address.push(hex);
        } else {
          output.error = true;
          return false;
        }
      }
      buffer2.length = 0;
    }
    return true;
  }
  for (let i = 0; i < input.length; i++) {
    const cursor2 = input[i];
    if (cursor2 === "[" || cursor2 === "]") {
      continue;
    }
    if (cursor2 === ":") {
      if (endipv6Encountered === true) {
        endIpv6 = true;
      }
      if (!consume()) {
        break;
      }
      tokenCount++;
      address.push(":");
      if (tokenCount > 7) {
        output.error = true;
        break;
      }
      if (i - 1 >= 0 && input[i - 1] === ":") {
        endipv6Encountered = true;
      }
      continue;
    } else if (cursor2 === "%") {
      if (!consume()) {
        break;
      }
      isZone = true;
    } else {
      buffer2.push(cursor2);
      continue;
    }
  }
  if (buffer2.length) {
    if (isZone) {
      output.zone = buffer2.join("");
    } else if (endIpv6) {
      address.push(buffer2.join(""));
    } else {
      address.push(stringArrayToHexStripped(buffer2));
    }
  }
  output.address = address.join("");
  return output;
}
function normalizeIPv6$1(host2, opts = {}) {
  if (findToken(host2, ":") < 2) {
    return { host: host2, isIPV6: false };
  }
  const ipv6 = getIPV6(host2);
  if (!ipv6.error) {
    let newHost = ipv6.address;
    let escapedHost = ipv6.address;
    if (ipv6.zone) {
      newHost += "%" + ipv6.zone;
      escapedHost += "%25" + ipv6.zone;
    }
    return { host: newHost, escapedHost, isIPV6: true };
  } else {
    return { host: host2, isIPV6: false };
  }
}
function stripLeadingZeros(str, token2) {
  let out = "";
  let skip = true;
  const l2 = str.length;
  for (let i = 0; i < l2; i++) {
    const c6 = str[i];
    if (c6 === "0" && skip) {
      if (i + 1 <= l2 && str[i + 1] === token2 || i + 1 === l2) {
        out += c6;
        skip = false;
      }
    } else {
      if (c6 === token2) {
        skip = true;
      } else {
        skip = false;
      }
      out += c6;
    }
  }
  return out;
}
function findToken(str, token2) {
  let ind = 0;
  for (let i = 0; i < str.length; i++) {
    if (str[i] === token2) ind++;
  }
  return ind;
}
const RDS1 = /^\.\.?\//u;
const RDS2 = /^\/\.(?:\/|$)/u;
const RDS3 = /^\/\.\.(?:\/|$)/u;
const RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/u;
function removeDotSegments$1(input) {
  const output = [];
  while (input.length) {
    if (input.match(RDS1)) {
      input = input.replace(RDS1, "");
    } else if (input.match(RDS2)) {
      input = input.replace(RDS2, "/");
    } else if (input.match(RDS3)) {
      input = input.replace(RDS3, "/");
      output.pop();
    } else if (input === "." || input === "..") {
      input = "";
    } else {
      const im = input.match(RDS5);
      if (im) {
        const s2 = im[0];
        input = input.slice(s2.length);
        output.push(s2);
      } else {
        throw new Error("Unexpected dot segment condition");
      }
    }
  }
  return output.join("");
}
function normalizeComponentEncoding$1(components, esc) {
  const func = esc !== true ? escape : unescape;
  if (components.scheme !== void 0) {
    components.scheme = func(components.scheme);
  }
  if (components.userinfo !== void 0) {
    components.userinfo = func(components.userinfo);
  }
  if (components.host !== void 0) {
    components.host = func(components.host);
  }
  if (components.path !== void 0) {
    components.path = func(components.path);
  }
  if (components.query !== void 0) {
    components.query = func(components.query);
  }
  if (components.fragment !== void 0) {
    components.fragment = func(components.fragment);
  }
  return components;
}
function recomposeAuthority$1(components, options) {
  const uriTokens = [];
  if (components.userinfo !== void 0) {
    uriTokens.push(components.userinfo);
    uriTokens.push("@");
  }
  if (components.host !== void 0) {
    let host2 = unescape(components.host);
    const ipV4res = normalizeIPv4$1(host2);
    if (ipV4res.isIPV4) {
      host2 = ipV4res.host;
    } else {
      const ipV6res = normalizeIPv6$1(ipV4res.host, { isIPV4: false });
      if (ipV6res.isIPV6 === true) {
        host2 = `[${ipV6res.escapedHost}]`;
      } else {
        host2 = components.host;
      }
    }
    uriTokens.push(host2);
  }
  if (typeof components.port === "number" || typeof components.port === "string") {
    uriTokens.push(":");
    uriTokens.push(String(components.port));
  }
  return uriTokens.length ? uriTokens.join("") : void 0;
}
var utils$2 = {
  recomposeAuthority: recomposeAuthority$1,
  normalizeComponentEncoding: normalizeComponentEncoding$1,
  removeDotSegments: removeDotSegments$1,
  normalizeIPv4: normalizeIPv4$1,
  normalizeIPv6: normalizeIPv6$1,
  stringArrayToHexStripped
};
const UUID_REG = /^[\da-f]{8}\b-[\da-f]{4}\b-[\da-f]{4}\b-[\da-f]{4}\b-[\da-f]{12}$/iu;
const URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
function isSecure(wsComponents) {
  return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
}
function httpParse(components) {
  if (!components.host) {
    components.error = components.error || "HTTP URIs must have a host.";
  }
  return components;
}
function httpSerialize(components) {
  const secure = String(components.scheme).toLowerCase() === "https";
  if (components.port === (secure ? 443 : 80) || components.port === "") {
    components.port = void 0;
  }
  if (!components.path) {
    components.path = "/";
  }
  return components;
}
function wsParse(wsComponents) {
  wsComponents.secure = isSecure(wsComponents);
  wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
  wsComponents.path = void 0;
  wsComponents.query = void 0;
  return wsComponents;
}
function wsSerialize(wsComponents) {
  if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
    wsComponents.port = void 0;
  }
  if (typeof wsComponents.secure === "boolean") {
    wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
    wsComponents.secure = void 0;
  }
  if (wsComponents.resourceName) {
    const [path2, query] = wsComponents.resourceName.split("?");
    wsComponents.path = path2 && path2 !== "/" ? path2 : void 0;
    wsComponents.query = query;
    wsComponents.resourceName = void 0;
  }
  wsComponents.fragment = void 0;
  return wsComponents;
}
function urnParse(urnComponents, options) {
  if (!urnComponents.path) {
    urnComponents.error = "URN can not be parsed";
    return urnComponents;
  }
  const matches = urnComponents.path.match(URN_REG);
  if (matches) {
    const scheme = options.scheme || urnComponents.scheme || "urn";
    urnComponents.nid = matches[1].toLowerCase();
    urnComponents.nss = matches[2];
    const urnScheme = `${scheme}:${options.nid || urnComponents.nid}`;
    const schemeHandler = SCHEMES$1[urnScheme];
    urnComponents.path = void 0;
    if (schemeHandler) {
      urnComponents = schemeHandler.parse(urnComponents, options);
    }
  } else {
    urnComponents.error = urnComponents.error || "URN can not be parsed.";
  }
  return urnComponents;
}
function urnSerialize(urnComponents, options) {
  const scheme = options.scheme || urnComponents.scheme || "urn";
  const nid = urnComponents.nid.toLowerCase();
  const urnScheme = `${scheme}:${options.nid || nid}`;
  const schemeHandler = SCHEMES$1[urnScheme];
  if (schemeHandler) {
    urnComponents = schemeHandler.serialize(urnComponents, options);
  }
  const uriComponents = urnComponents;
  const nss = urnComponents.nss;
  uriComponents.path = `${nid || options.nid}:${nss}`;
  options.skipEscape = true;
  return uriComponents;
}
function urnuuidParse(urnComponents, options) {
  const uuidComponents = urnComponents;
  uuidComponents.uuid = uuidComponents.nss;
  uuidComponents.nss = void 0;
  if (!options.tolerant && (!uuidComponents.uuid || !UUID_REG.test(uuidComponents.uuid))) {
    uuidComponents.error = uuidComponents.error || "UUID is not valid.";
  }
  return uuidComponents;
}
function urnuuidSerialize(uuidComponents) {
  const urnComponents = uuidComponents;
  urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
  return urnComponents;
}
const http = {
  scheme: "http",
  domainHost: true,
  parse: httpParse,
  serialize: httpSerialize
};
const https = {
  scheme: "https",
  domainHost: http.domainHost,
  parse: httpParse,
  serialize: httpSerialize
};
const ws2 = {
  scheme: "ws",
  domainHost: true,
  parse: wsParse,
  serialize: wsSerialize
};
const wss = {
  scheme: "wss",
  domainHost: ws2.domainHost,
  parse: ws2.parse,
  serialize: ws2.serialize
};
const urn = {
  scheme: "urn",
  parse: urnParse,
  serialize: urnSerialize,
  skipNormalize: true
};
const urnuuid = {
  scheme: "urn:uuid",
  parse: urnuuidParse,
  serialize: urnuuidSerialize,
  skipNormalize: true
};
const SCHEMES$1 = {
  http,
  https,
  ws: ws2,
  wss,
  urn,
  "urn:uuid": urnuuid
};
var schemes = SCHEMES$1;
const { normalizeIPv6, normalizeIPv4, removeDotSegments, recomposeAuthority, normalizeComponentEncoding } = utils$2;
const SCHEMES = schemes;
function normalize$2(uri2, options) {
  if (typeof uri2 === "string") {
    uri2 = serialize$2(parse$1(uri2, options), options);
  } else if (typeof uri2 === "object") {
    uri2 = parse$1(serialize$2(uri2, options), options);
  }
  return uri2;
}
function resolve(baseURI, relativeURI, options) {
  const schemelessOptions = Object.assign({ scheme: "null" }, options);
  const resolved = resolveComponents(parse$1(baseURI, schemelessOptions), parse$1(relativeURI, schemelessOptions), schemelessOptions, true);
  return serialize$2(resolved, { ...schemelessOptions, skipEscape: true });
}
function resolveComponents(base, relative, options, skipNormalization) {
  const target = {};
  if (!skipNormalization) {
    base = parse$1(serialize$2(base, options), options);
    relative = parse$1(serialize$2(relative, options), options);
  }
  options = options || {};
  if (!options.tolerant && relative.scheme) {
    target.scheme = relative.scheme;
    target.userinfo = relative.userinfo;
    target.host = relative.host;
    target.port = relative.port;
    target.path = removeDotSegments(relative.path || "");
    target.query = relative.query;
  } else {
    if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
      target.userinfo = relative.userinfo;
      target.host = relative.host;
      target.port = relative.port;
      target.path = removeDotSegments(relative.path || "");
      target.query = relative.query;
    } else {
      if (!relative.path) {
        target.path = base.path;
        if (relative.query !== void 0) {
          target.query = relative.query;
        } else {
          target.query = base.query;
        }
      } else {
        if (relative.path.charAt(0) === "/") {
          target.path = removeDotSegments(relative.path);
        } else {
          if ((base.userinfo !== void 0 || base.host !== void 0 || base.port !== void 0) && !base.path) {
            target.path = "/" + relative.path;
          } else if (!base.path) {
            target.path = relative.path;
          } else {
            target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
          }
          target.path = removeDotSegments(target.path);
        }
        target.query = relative.query;
      }
      target.userinfo = base.userinfo;
      target.host = base.host;
      target.port = base.port;
    }
    target.scheme = base.scheme;
  }
  target.fragment = relative.fragment;
  return target;
}
function equal$2(uriA, uriB, options) {
  if (typeof uriA === "string") {
    uriA = unescape(uriA);
    uriA = serialize$2(normalizeComponentEncoding(parse$1(uriA, options), true), { ...options, skipEscape: true });
  } else if (typeof uriA === "object") {
    uriA = serialize$2(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true });
  }
  if (typeof uriB === "string") {
    uriB = unescape(uriB);
    uriB = serialize$2(normalizeComponentEncoding(parse$1(uriB, options), true), { ...options, skipEscape: true });
  } else if (typeof uriB === "object") {
    uriB = serialize$2(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true });
  }
  return uriA.toLowerCase() === uriB.toLowerCase();
}
function serialize$2(cmpts, opts) {
  const components = {
    host: cmpts.host,
    scheme: cmpts.scheme,
    userinfo: cmpts.userinfo,
    port: cmpts.port,
    path: cmpts.path,
    query: cmpts.query,
    nid: cmpts.nid,
    nss: cmpts.nss,
    uuid: cmpts.uuid,
    fragment: cmpts.fragment,
    reference: cmpts.reference,
    resourceName: cmpts.resourceName,
    secure: cmpts.secure,
    error: ""
  };
  const options = Object.assign({}, opts);
  const uriTokens = [];
  const schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
  if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
  if (components.path !== void 0) {
    if (!options.skipEscape) {
      components.path = escape(components.path);
      if (components.scheme !== void 0) {
        components.path = components.path.split("%3A").join(":");
      }
    } else {
      components.path = unescape(components.path);
    }
  }
  if (options.reference !== "suffix" && components.scheme) {
    uriTokens.push(components.scheme, ":");
  }
  const authority = recomposeAuthority(components, options);
  if (authority !== void 0) {
    if (options.reference !== "suffix") {
      uriTokens.push("//");
    }
    uriTokens.push(authority);
    if (components.path && components.path.charAt(0) !== "/") {
      uriTokens.push("/");
    }
  }
  if (components.path !== void 0) {
    let s2 = components.path;
    if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
      s2 = removeDotSegments(s2);
    }
    if (authority === void 0) {
      s2 = s2.replace(/^\/\//u, "/%2F");
    }
    uriTokens.push(s2);
  }
  if (components.query !== void 0) {
    uriTokens.push("?", components.query);
  }
  if (components.fragment !== void 0) {
    uriTokens.push("#", components.fragment);
  }
  return uriTokens.join("");
}
const hexLookUp = Array.from({ length: 127 }, (v2, k2) => /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(k2)));
function nonSimpleDomain(value) {
  let code2 = 0;
  for (let i = 0, len = value.length; i < len; ++i) {
    code2 = value.charCodeAt(i);
    if (code2 > 126 || hexLookUp[code2]) {
      return true;
    }
  }
  return false;
}
const URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
function parse$1(uri2, opts) {
  const options = Object.assign({}, opts);
  const parsed = {
    scheme: void 0,
    userinfo: void 0,
    host: "",
    port: void 0,
    path: "",
    query: void 0,
    fragment: void 0
  };
  const gotEncoding = uri2.indexOf("%") !== -1;
  let isIP = false;
  if (options.reference === "suffix") uri2 = (options.scheme ? options.scheme + ":" : "") + "//" + uri2;
  const matches = uri2.match(URI_PARSE);
  if (matches) {
    parsed.scheme = matches[1];
    parsed.userinfo = matches[3];
    parsed.host = matches[4];
    parsed.port = parseInt(matches[5], 10);
    parsed.path = matches[6] || "";
    parsed.query = matches[7];
    parsed.fragment = matches[8];
    if (isNaN(parsed.port)) {
      parsed.port = matches[5];
    }
    if (parsed.host) {
      const ipv4result = normalizeIPv4(parsed.host);
      if (ipv4result.isIPV4 === false) {
        const ipv6result = normalizeIPv6(ipv4result.host, { isIPV4: false });
        parsed.host = ipv6result.host.toLowerCase();
        isIP = ipv6result.isIPV6;
      } else {
        parsed.host = ipv4result.host;
        isIP = true;
      }
    }
    if (parsed.scheme === void 0 && parsed.userinfo === void 0 && parsed.host === void 0 && parsed.port === void 0 && !parsed.path && parsed.query === void 0) {
      parsed.reference = "same-document";
    } else if (parsed.scheme === void 0) {
      parsed.reference = "relative";
    } else if (parsed.fragment === void 0) {
      parsed.reference = "absolute";
    } else {
      parsed.reference = "uri";
    }
    if (options.reference && options.reference !== "suffix" && options.reference !== parsed.reference) {
      parsed.error = parsed.error || "URI is not a " + options.reference + " reference.";
    }
    const schemeHandler = SCHEMES[(options.scheme || parsed.scheme || "").toLowerCase()];
    if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
      if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === false && nonSimpleDomain(parsed.host)) {
        try {
          parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
        } catch (e2) {
          parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e2;
        }
      }
    }
    if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
      if (gotEncoding && parsed.scheme !== void 0) {
        parsed.scheme = unescape(parsed.scheme);
      }
      if (gotEncoding && parsed.host !== void 0) {
        parsed.host = unescape(parsed.host);
      }
      if (parsed.path !== void 0 && parsed.path.length) {
        parsed.path = escape(unescape(parsed.path));
      }
      if (parsed.fragment !== void 0 && parsed.fragment.length) {
        parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
      }
    }
    if (schemeHandler && schemeHandler.parse) {
      schemeHandler.parse(parsed, options);
    }
  } else {
    parsed.error = parsed.error || "URI can not be parsed.";
  }
  return parsed;
}
const fastUri = {
  SCHEMES,
  normalize: normalize$2,
  resolve,
  resolveComponents,
  equal: equal$2,
  serialize: serialize$2,
  parse: parse$1
};
fastUri$1.exports = fastUri;
fastUri$1.exports.default = fastUri;
fastUri$1.exports.fastUri = fastUri;
var fastUriExports = fastUri$1.exports;
Object.defineProperty(uri$1, "__esModule", { value: true });
const uri = fastUriExports;
uri.code = 'require("ajv/dist/runtime/uri").default';
uri$1.default = uri;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
  var validate_12 = validate;
  Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
    return validate_12.KeywordCxt;
  } });
  var codegen_12 = codegen;
  Object.defineProperty(exports, "_", { enumerable: true, get: function() {
    return codegen_12._;
  } });
  Object.defineProperty(exports, "str", { enumerable: true, get: function() {
    return codegen_12.str;
  } });
  Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
    return codegen_12.stringify;
  } });
  Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
    return codegen_12.nil;
  } });
  Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
    return codegen_12.Name;
  } });
  Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
    return codegen_12.CodeGen;
  } });
  const validation_error_12 = validation_error;
  const ref_error_12 = ref_error;
  const rules_12 = rules;
  const compile_12 = compile;
  const codegen_2 = codegen;
  const resolve_12 = resolve$2;
  const dataType_12 = dataType;
  const util_12 = util;
  const $dataRefSchema = require$$9;
  const uri_1 = uri$1;
  const defaultRegExp = (str, flags) => new RegExp(str, flags);
  defaultRegExp.code = "new RegExp";
  const META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
  const EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
    "validate",
    "serialize",
    "parse",
    "wrapper",
    "root",
    "schema",
    "keyword",
    "pattern",
    "formats",
    "validate$data",
    "func",
    "obj",
    "Error"
  ]);
  const removedOptions = {
    errorDataPath: "",
    format: "`validateFormats: false` can be used instead.",
    nullable: '"nullable" keyword is supported by default.',
    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
    sourceCode: "Use option `code: {source: true}`",
    strictDefaults: "It is default now, see option `strict`.",
    strictKeywords: "It is default now, see option `strict`.",
    uniqueItems: '"uniqueItems" keyword is always validated.',
    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
    cache: "Map is used as cache, schema object as key.",
    serialize: "Map is used as cache, schema object as key.",
    ajvErrors: "It is default now."
  };
  const deprecatedOptions = {
    ignoreKeywordsWithRef: "",
    jsPropertySyntax: "",
    unicode: '"minLength"/"maxLength" account for unicode characters by default.'
  };
  const MAX_EXPRESSION = 200;
  function requiredOptions(o2) {
    var _a3, _b2, _c2, _d2, _e2, _f, _g, _h, _j, _k, _l, _m, _o2, _p, _q, _r2, _s2, _t2, _u, _v, _w, _x, _y, _z, _0;
    const s2 = o2.strict;
    const _optz = (_a3 = o2.code) === null || _a3 === void 0 ? void 0 : _a3.optimize;
    const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
    const regExp = (_c2 = (_b2 = o2.code) === null || _b2 === void 0 ? void 0 : _b2.regExp) !== null && _c2 !== void 0 ? _c2 : defaultRegExp;
    const uriResolver = (_d2 = o2.uriResolver) !== null && _d2 !== void 0 ? _d2 : uri_1.default;
    return {
      strictSchema: (_f = (_e2 = o2.strictSchema) !== null && _e2 !== void 0 ? _e2 : s2) !== null && _f !== void 0 ? _f : true,
      strictNumbers: (_h = (_g = o2.strictNumbers) !== null && _g !== void 0 ? _g : s2) !== null && _h !== void 0 ? _h : true,
      strictTypes: (_k = (_j = o2.strictTypes) !== null && _j !== void 0 ? _j : s2) !== null && _k !== void 0 ? _k : "log",
      strictTuples: (_m = (_l = o2.strictTuples) !== null && _l !== void 0 ? _l : s2) !== null && _m !== void 0 ? _m : "log",
      strictRequired: (_p = (_o2 = o2.strictRequired) !== null && _o2 !== void 0 ? _o2 : s2) !== null && _p !== void 0 ? _p : false,
      code: o2.code ? { ...o2.code, optimize, regExp } : { optimize, regExp },
      loopRequired: (_q = o2.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
      loopEnum: (_r2 = o2.loopEnum) !== null && _r2 !== void 0 ? _r2 : MAX_EXPRESSION,
      meta: (_s2 = o2.meta) !== null && _s2 !== void 0 ? _s2 : true,
      messages: (_t2 = o2.messages) !== null && _t2 !== void 0 ? _t2 : true,
      inlineRefs: (_u = o2.inlineRefs) !== null && _u !== void 0 ? _u : true,
      schemaId: (_v = o2.schemaId) !== null && _v !== void 0 ? _v : "$id",
      addUsedSchema: (_w = o2.addUsedSchema) !== null && _w !== void 0 ? _w : true,
      validateSchema: (_x = o2.validateSchema) !== null && _x !== void 0 ? _x : true,
      validateFormats: (_y = o2.validateFormats) !== null && _y !== void 0 ? _y : true,
      unicodeRegExp: (_z = o2.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
      int32range: (_0 = o2.int32range) !== null && _0 !== void 0 ? _0 : true,
      uriResolver
    };
  }
  class Ajv {
    constructor(opts = {}) {
      this.schemas = {};
      this.refs = {};
      this.formats = {};
      this._compilations = /* @__PURE__ */ new Set();
      this._loading = {};
      this._cache = /* @__PURE__ */ new Map();
      opts = this.opts = { ...opts, ...requiredOptions(opts) };
      const { es5, lines } = this.opts.code;
      this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
      this.logger = getLogger2(opts.logger);
      const formatOpt = opts.validateFormats;
      opts.validateFormats = false;
      this.RULES = (0, rules_12.getRules)();
      checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
      checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
      this._metaOpts = getMetaSchemaOptions.call(this);
      if (opts.formats)
        addInitialFormats.call(this);
      this._addVocabularies();
      this._addDefaultMetaSchema();
      if (opts.keywords)
        addInitialKeywords.call(this, opts.keywords);
      if (typeof opts.meta == "object")
        this.addMetaSchema(opts.meta);
      addInitialSchemas.call(this);
      opts.validateFormats = formatOpt;
    }
    _addVocabularies() {
      this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
      const { $data, meta, schemaId } = this.opts;
      let _dataRefSchema = $dataRefSchema;
      if (schemaId === "id") {
        _dataRefSchema = { ...$dataRefSchema };
        _dataRefSchema.id = _dataRefSchema.$id;
        delete _dataRefSchema.$id;
      }
      if (meta && $data)
        this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
    }
    defaultMeta() {
      const { meta, schemaId } = this.opts;
      return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
    }
    validate(schemaKeyRef, data) {
      let v2;
      if (typeof schemaKeyRef == "string") {
        v2 = this.getSchema(schemaKeyRef);
        if (!v2)
          throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
      } else {
        v2 = this.compile(schemaKeyRef);
      }
      const valid2 = v2(data);
      if (!("$async" in v2))
        this.errors = v2.errors;
      return valid2;
    }
    compile(schema, _meta) {
      const sch = this._addSchema(schema, _meta);
      return sch.validate || this._compileSchemaEnv(sch);
    }
    compileAsync(schema, meta) {
      if (typeof this.opts.loadSchema != "function") {
        throw new Error("options.loadSchema should be a function");
      }
      const { loadSchema } = this.opts;
      return runCompileAsync.call(this, schema, meta);
      async function runCompileAsync(_schema, _meta) {
        await loadMetaSchema.call(this, _schema.$schema);
        const sch = this._addSchema(_schema, _meta);
        return sch.validate || _compileAsync.call(this, sch);
      }
      async function loadMetaSchema($ref) {
        if ($ref && !this.getSchema($ref)) {
          await runCompileAsync.call(this, { $ref }, true);
        }
      }
      async function _compileAsync(sch) {
        try {
          return this._compileSchemaEnv(sch);
        } catch (e2) {
          if (!(e2 instanceof ref_error_12.default))
            throw e2;
          checkLoaded.call(this, e2);
          await loadMissingSchema.call(this, e2.missingSchema);
          return _compileAsync.call(this, sch);
        }
      }
      function checkLoaded({ missingSchema: ref2, missingRef }) {
        if (this.refs[ref2]) {
          throw new Error(`AnySchema ${ref2} is loaded but ${missingRef} cannot be resolved`);
        }
      }
      async function loadMissingSchema(ref2) {
        const _schema = await _loadSchema.call(this, ref2);
        if (!this.refs[ref2])
          await loadMetaSchema.call(this, _schema.$schema);
        if (!this.refs[ref2])
          this.addSchema(_schema, ref2, meta);
      }
      async function _loadSchema(ref2) {
        const p2 = this._loading[ref2];
        if (p2)
          return p2;
        try {
          return await (this._loading[ref2] = loadSchema(ref2));
        } finally {
          delete this._loading[ref2];
        }
      }
    }
    // Adds schema to the instance
    addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
      if (Array.isArray(schema)) {
        for (const sch of schema)
          this.addSchema(sch, void 0, _meta, _validateSchema);
        return this;
      }
      let id2;
      if (typeof schema === "object") {
        const { schemaId } = this.opts;
        id2 = schema[schemaId];
        if (id2 !== void 0 && typeof id2 != "string") {
          throw new Error(`schema ${schemaId} must be string`);
        }
      }
      key = (0, resolve_12.normalizeId)(key || id2);
      this._checkUnique(key);
      this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
      return this;
    }
    // Add schema that will be used to validate other schemas
    // options in META_IGNORE_OPTIONS are alway set to false
    addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
      this.addSchema(schema, key, true, _validateSchema);
      return this;
    }
    //  Validate schema against its meta-schema
    validateSchema(schema, throwOrLogError) {
      if (typeof schema == "boolean")
        return true;
      let $schema2;
      $schema2 = schema.$schema;
      if ($schema2 !== void 0 && typeof $schema2 != "string") {
        throw new Error("$schema must be a string");
      }
      $schema2 = $schema2 || this.opts.defaultMeta || this.defaultMeta();
      if (!$schema2) {
        this.logger.warn("meta-schema not available");
        this.errors = null;
        return true;
      }
      const valid2 = this.validate($schema2, schema);
      if (!valid2 && throwOrLogError) {
        const message = "schema is invalid: " + this.errorsText();
        if (this.opts.validateSchema === "log")
          this.logger.error(message);
        else
          throw new Error(message);
      }
      return valid2;
    }
    // Get compiled schema by `key` or `ref`.
    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
    getSchema(keyRef) {
      let sch;
      while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
        keyRef = sch;
      if (sch === void 0) {
        const { schemaId } = this.opts;
        const root2 = new compile_12.SchemaEnv({ schema: {}, schemaId });
        sch = compile_12.resolveSchema.call(this, root2, keyRef);
        if (!sch)
          return;
        this.refs[keyRef] = sch;
      }
      return sch.validate || this._compileSchemaEnv(sch);
    }
    // Remove cached schema(s).
    // If no parameter is passed all schemas but meta-schemas are removed.
    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
    removeSchema(schemaKeyRef) {
      if (schemaKeyRef instanceof RegExp) {
        this._removeAllSchemas(this.schemas, schemaKeyRef);
        this._removeAllSchemas(this.refs, schemaKeyRef);
        return this;
      }
      switch (typeof schemaKeyRef) {
        case "undefined":
          this._removeAllSchemas(this.schemas);
          this._removeAllSchemas(this.refs);
          this._cache.clear();
          return this;
        case "string": {
          const sch = getSchEnv.call(this, schemaKeyRef);
          if (typeof sch == "object")
            this._cache.delete(sch.schema);
          delete this.schemas[schemaKeyRef];
          delete this.refs[schemaKeyRef];
          return this;
        }
        case "object": {
          const cacheKey2 = schemaKeyRef;
          this._cache.delete(cacheKey2);
          let id2 = schemaKeyRef[this.opts.schemaId];
          if (id2) {
            id2 = (0, resolve_12.normalizeId)(id2);
            delete this.schemas[id2];
            delete this.refs[id2];
          }
          return this;
        }
        default:
          throw new Error("ajv.removeSchema: invalid parameter");
      }
    }
    // add "vocabulary" - a collection of keywords
    addVocabulary(definitions2) {
      for (const def2 of definitions2)
        this.addKeyword(def2);
      return this;
    }
    addKeyword(kwdOrDef, def2) {
      let keyword2;
      if (typeof kwdOrDef == "string") {
        keyword2 = kwdOrDef;
        if (typeof def2 == "object") {
          this.logger.warn("these parameters are deprecated, see docs for addKeyword");
          def2.keyword = keyword2;
        }
      } else if (typeof kwdOrDef == "object" && def2 === void 0) {
        def2 = kwdOrDef;
        keyword2 = def2.keyword;
        if (Array.isArray(keyword2) && !keyword2.length) {
          throw new Error("addKeywords: keyword must be string or non-empty array");
        }
      } else {
        throw new Error("invalid addKeywords parameters");
      }
      checkKeyword.call(this, keyword2, def2);
      if (!def2) {
        (0, util_12.eachItem)(keyword2, (kwd) => addRule.call(this, kwd));
        return this;
      }
      keywordMetaschema.call(this, def2);
      const definition2 = {
        ...def2,
        type: (0, dataType_12.getJSONTypes)(def2.type),
        schemaType: (0, dataType_12.getJSONTypes)(def2.schemaType)
      };
      (0, util_12.eachItem)(keyword2, definition2.type.length === 0 ? (k2) => addRule.call(this, k2, definition2) : (k2) => definition2.type.forEach((t2) => addRule.call(this, k2, definition2, t2)));
      return this;
    }
    getKeyword(keyword2) {
      const rule = this.RULES.all[keyword2];
      return typeof rule == "object" ? rule.definition : !!rule;
    }
    // Remove keyword
    removeKeyword(keyword2) {
      const { RULES } = this;
      delete RULES.keywords[keyword2];
      delete RULES.all[keyword2];
      for (const group of RULES.rules) {
        const i = group.rules.findIndex((rule) => rule.keyword === keyword2);
        if (i >= 0)
          group.rules.splice(i, 1);
      }
      return this;
    }
    // Add format
    addFormat(name2, format2) {
      if (typeof format2 == "string")
        format2 = new RegExp(format2);
      this.formats[name2] = format2;
      return this;
    }
    errorsText(errors2 = this.errors, { separator = ", ", dataVar = "data" } = {}) {
      if (!errors2 || errors2.length === 0)
        return "No errors";
      return errors2.map((e2) => `${dataVar}${e2.instancePath} ${e2.message}`).reduce((text2, msg) => text2 + separator + msg);
    }
    $dataMetaSchema(metaSchema, keywordsJsonPointers) {
      const rules2 = this.RULES.all;
      metaSchema = JSON.parse(JSON.stringify(metaSchema));
      for (const jsonPointer of keywordsJsonPointers) {
        const segments = jsonPointer.split("/").slice(1);
        let keywords = metaSchema;
        for (const seg of segments)
          keywords = keywords[seg];
        for (const key in rules2) {
          const rule = rules2[key];
          if (typeof rule != "object")
            continue;
          const { $data } = rule.definition;
          const schema = keywords[key];
          if ($data && schema)
            keywords[key] = schemaOrData(schema);
        }
      }
      return metaSchema;
    }
    _removeAllSchemas(schemas, regex) {
      for (const keyRef in schemas) {
        const sch = schemas[keyRef];
        if (!regex || regex.test(keyRef)) {
          if (typeof sch == "string") {
            delete schemas[keyRef];
          } else if (sch && !sch.meta) {
            this._cache.delete(sch.schema);
            delete schemas[keyRef];
          }
        }
      }
    }
    _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
      let id2;
      const { schemaId } = this.opts;
      if (typeof schema == "object") {
        id2 = schema[schemaId];
      } else {
        if (this.opts.jtd)
          throw new Error("schema must be object");
        else if (typeof schema != "boolean")
          throw new Error("schema must be object or boolean");
      }
      let sch = this._cache.get(schema);
      if (sch !== void 0)
        return sch;
      baseId = (0, resolve_12.normalizeId)(id2 || baseId);
      const localRefs = resolve_12.getSchemaRefs.call(this, schema, baseId);
      sch = new compile_12.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
      this._cache.set(sch.schema, sch);
      if (addSchema && !baseId.startsWith("#")) {
        if (baseId)
          this._checkUnique(baseId);
        this.refs[baseId] = sch;
      }
      if (validateSchema)
        this.validateSchema(schema, true);
      return sch;
    }
    _checkUnique(id2) {
      if (this.schemas[id2] || this.refs[id2]) {
        throw new Error(`schema with key or id "${id2}" already exists`);
      }
    }
    _compileSchemaEnv(sch) {
      if (sch.meta)
        this._compileMetaSchema(sch);
      else
        compile_12.compileSchema.call(this, sch);
      if (!sch.validate)
        throw new Error("ajv implementation error");
      return sch.validate;
    }
    _compileMetaSchema(sch) {
      const currentOpts = this.opts;
      this.opts = this._metaOpts;
      try {
        compile_12.compileSchema.call(this, sch);
      } finally {
        this.opts = currentOpts;
      }
    }
  }
  Ajv.ValidationError = validation_error_12.default;
  Ajv.MissingRefError = ref_error_12.default;
  exports.default = Ajv;
  function checkOptions(checkOpts, options, msg, log = "error") {
    for (const key in checkOpts) {
      const opt = key;
      if (opt in options)
        this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
    }
  }
  function getSchEnv(keyRef) {
    keyRef = (0, resolve_12.normalizeId)(keyRef);
    return this.schemas[keyRef] || this.refs[keyRef];
  }
  function addInitialSchemas() {
    const optsSchemas = this.opts.schemas;
    if (!optsSchemas)
      return;
    if (Array.isArray(optsSchemas))
      this.addSchema(optsSchemas);
    else
      for (const key in optsSchemas)
        this.addSchema(optsSchemas[key], key);
  }
  function addInitialFormats() {
    for (const name2 in this.opts.formats) {
      const format2 = this.opts.formats[name2];
      if (format2)
        this.addFormat(name2, format2);
    }
  }
  function addInitialKeywords(defs) {
    if (Array.isArray(defs)) {
      this.addVocabulary(defs);
      return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (const keyword2 in defs) {
      const def2 = defs[keyword2];
      if (!def2.keyword)
        def2.keyword = keyword2;
      this.addKeyword(def2);
    }
  }
  function getMetaSchemaOptions() {
    const metaOpts = { ...this.opts };
    for (const opt of META_IGNORE_OPTIONS)
      delete metaOpts[opt];
    return metaOpts;
  }
  const noLogs = { log() {
  }, warn() {
  }, error() {
  } };
  function getLogger2(logger2) {
    if (logger2 === false)
      return noLogs;
    if (logger2 === void 0)
      return console;
    if (logger2.log && logger2.warn && logger2.error)
      return logger2;
    throw new Error("logger must implement log, warn and error methods");
  }
  const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
  function checkKeyword(keyword2, def2) {
    const { RULES } = this;
    (0, util_12.eachItem)(keyword2, (kwd) => {
      if (RULES.keywords[kwd])
        throw new Error(`Keyword ${kwd} is already defined`);
      if (!KEYWORD_NAME.test(kwd))
        throw new Error(`Keyword ${kwd} has invalid name`);
    });
    if (!def2)
      return;
    if (def2.$data && !("code" in def2 || "validate" in def2)) {
      throw new Error('$data keyword must have "code" or "validate" function');
    }
  }
  function addRule(keyword2, definition2, dataType2) {
    var _a3;
    const post = definition2 === null || definition2 === void 0 ? void 0 : definition2.post;
    if (dataType2 && post)
      throw new Error('keyword with "post" flag cannot have "type"');
    const { RULES } = this;
    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t2 }) => t2 === dataType2);
    if (!ruleGroup) {
      ruleGroup = { type: dataType2, rules: [] };
      RULES.rules.push(ruleGroup);
    }
    RULES.keywords[keyword2] = true;
    if (!definition2)
      return;
    const rule = {
      keyword: keyword2,
      definition: {
        ...definition2,
        type: (0, dataType_12.getJSONTypes)(definition2.type),
        schemaType: (0, dataType_12.getJSONTypes)(definition2.schemaType)
      }
    };
    if (definition2.before)
      addBeforeRule.call(this, ruleGroup, rule, definition2.before);
    else
      ruleGroup.rules.push(rule);
    RULES.all[keyword2] = rule;
    (_a3 = definition2.implements) === null || _a3 === void 0 ? void 0 : _a3.forEach((kwd) => this.addKeyword(kwd));
  }
  function addBeforeRule(ruleGroup, rule, before) {
    const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
    if (i >= 0) {
      ruleGroup.rules.splice(i, 0, rule);
    } else {
      ruleGroup.rules.push(rule);
      this.logger.warn(`rule ${before} is not defined`);
    }
  }
  function keywordMetaschema(def2) {
    let { metaSchema } = def2;
    if (metaSchema === void 0)
      return;
    if (def2.$data && this.opts.$data)
      metaSchema = schemaOrData(metaSchema);
    def2.validateSchema = this.compile(metaSchema, true);
  }
  const $dataRef = {
    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
  };
  function schemaOrData(schema) {
    return { anyOf: [schema, $dataRef] };
  }
})(core$2);
var draft7 = {};
var core$1 = {};
var id = {};
Object.defineProperty(id, "__esModule", { value: true });
const def$s = {
  keyword: "id",
  code() {
    throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
  }
};
id.default = def$s;
var ref = {};
Object.defineProperty(ref, "__esModule", { value: true });
ref.callRef = ref.getValidate = void 0;
const ref_error_1$1 = ref_error;
const code_1$8 = code$3;
const codegen_1$l = codegen;
const names_1$1 = names$1;
const compile_1$1 = compile;
const util_1$j = util;
const def$r = {
  keyword: "$ref",
  schemaType: "string",
  code(cxt) {
    const { gen, schema: $ref, it: it2 } = cxt;
    const { baseId, schemaEnv: env2, validateName, opts, self: self2 } = it2;
    const { root: root2 } = env2;
    if (($ref === "#" || $ref === "#/") && baseId === root2.baseId)
      return callRootRef();
    const schOrEnv = compile_1$1.resolveRef.call(self2, root2, baseId, $ref);
    if (schOrEnv === void 0)
      throw new ref_error_1$1.default(it2.opts.uriResolver, baseId, $ref);
    if (schOrEnv instanceof compile_1$1.SchemaEnv)
      return callValidate(schOrEnv);
    return inlineRefSchema(schOrEnv);
    function callRootRef() {
      if (env2 === root2)
        return callRef(cxt, validateName, env2, env2.$async);
      const rootName = gen.scopeValue("root", { ref: root2 });
      return callRef(cxt, (0, codegen_1$l._)`${rootName}.validate`, root2, root2.$async);
    }
    function callValidate(sch) {
      const v2 = getValidate(cxt, sch);
      callRef(cxt, v2, sch, sch.$async);
    }
    function inlineRefSchema(sch) {
      const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1$l.stringify)(sch) } : { ref: sch });
      const valid2 = gen.name("valid");
      const schCxt = cxt.subschema({
        schema: sch,
        dataTypes: [],
        schemaPath: codegen_1$l.nil,
        topSchemaRef: schName,
        errSchemaPath: $ref
      }, valid2);
      cxt.mergeEvaluated(schCxt);
      cxt.ok(valid2);
    }
  }
};
function getValidate(cxt, sch) {
  const { gen } = cxt;
  return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1$l._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
}
ref.getValidate = getValidate;
function callRef(cxt, v2, sch, $async) {
  const { gen, it: it2 } = cxt;
  const { allErrors, schemaEnv: env2, opts } = it2;
  const passCxt = opts.passContext ? names_1$1.default.this : codegen_1$l.nil;
  if ($async)
    callAsyncRef();
  else
    callSyncRef();
  function callAsyncRef() {
    if (!env2.$async)
      throw new Error("async schema referenced by sync schema");
    const valid2 = gen.let("valid");
    gen.try(() => {
      gen.code((0, codegen_1$l._)`await ${(0, code_1$8.callValidateCode)(cxt, v2, passCxt)}`);
      addEvaluatedFrom(v2);
      if (!allErrors)
        gen.assign(valid2, true);
    }, (e2) => {
      gen.if((0, codegen_1$l._)`!(${e2} instanceof ${it2.ValidationError})`, () => gen.throw(e2));
      addErrorsFrom(e2);
      if (!allErrors)
        gen.assign(valid2, false);
    });
    cxt.ok(valid2);
  }
  function callSyncRef() {
    cxt.result((0, code_1$8.callValidateCode)(cxt, v2, passCxt), () => addEvaluatedFrom(v2), () => addErrorsFrom(v2));
  }
  function addErrorsFrom(source) {
    const errs = (0, codegen_1$l._)`${source}.errors`;
    gen.assign(names_1$1.default.vErrors, (0, codegen_1$l._)`${names_1$1.default.vErrors} === null ? ${errs} : ${names_1$1.default.vErrors}.concat(${errs})`);
    gen.assign(names_1$1.default.errors, (0, codegen_1$l._)`${names_1$1.default.vErrors}.length`);
  }
  function addEvaluatedFrom(source) {
    var _a3;
    if (!it2.opts.unevaluated)
      return;
    const schEvaluated = (_a3 = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a3 === void 0 ? void 0 : _a3.evaluated;
    if (it2.props !== true) {
      if (schEvaluated && !schEvaluated.dynamicProps) {
        if (schEvaluated.props !== void 0) {
          it2.props = util_1$j.mergeEvaluated.props(gen, schEvaluated.props, it2.props);
        }
      } else {
        const props = gen.var("props", (0, codegen_1$l._)`${source}.evaluated.props`);
        it2.props = util_1$j.mergeEvaluated.props(gen, props, it2.props, codegen_1$l.Name);
      }
    }
    if (it2.items !== true) {
      if (schEvaluated && !schEvaluated.dynamicItems) {
        if (schEvaluated.items !== void 0) {
          it2.items = util_1$j.mergeEvaluated.items(gen, schEvaluated.items, it2.items);
        }
      } else {
        const items2 = gen.var("items", (0, codegen_1$l._)`${source}.evaluated.items`);
        it2.items = util_1$j.mergeEvaluated.items(gen, items2, it2.items, codegen_1$l.Name);
      }
    }
  }
}
ref.callRef = callRef;
ref.default = def$r;
Object.defineProperty(core$1, "__esModule", { value: true });
const id_1 = id;
const ref_1 = ref;
const core = [
  "$schema",
  "$id",
  "$defs",
  "$vocabulary",
  { keyword: "$comment" },
  "definitions",
  id_1.default,
  ref_1.default
];
core$1.default = core;
var validation$1 = {};
var limitNumber = {};
Object.defineProperty(limitNumber, "__esModule", { value: true });
const codegen_1$k = codegen;
const ops = codegen_1$k.operators;
const KWDs = {
  maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
  minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
  exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
  exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
};
const error$i = {
  message: ({ keyword: keyword2, schemaCode }) => (0, codegen_1$k.str)`must be ${KWDs[keyword2].okStr} ${schemaCode}`,
  params: ({ keyword: keyword2, schemaCode }) => (0, codegen_1$k._)`{comparison: ${KWDs[keyword2].okStr}, limit: ${schemaCode}}`
};
const def$q = {
  keyword: Object.keys(KWDs),
  type: "number",
  schemaType: "number",
  $data: true,
  error: error$i,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode } = cxt;
    cxt.fail$data((0, codegen_1$k._)`${data} ${KWDs[keyword2].fail} ${schemaCode} || isNaN(${data})`);
  }
};
limitNumber.default = def$q;
var multipleOf = {};
Object.defineProperty(multipleOf, "__esModule", { value: true });
const codegen_1$j = codegen;
const error$h = {
  message: ({ schemaCode }) => (0, codegen_1$j.str)`must be multiple of ${schemaCode}`,
  params: ({ schemaCode }) => (0, codegen_1$j._)`{multipleOf: ${schemaCode}}`
};
const def$p = {
  keyword: "multipleOf",
  type: "number",
  schemaType: "number",
  $data: true,
  error: error$h,
  code(cxt) {
    const { gen, data, schemaCode, it: it2 } = cxt;
    const prec = it2.opts.multipleOfPrecision;
    const res = gen.let("res");
    const invalid = prec ? (0, codegen_1$j._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1$j._)`${res} !== parseInt(${res})`;
    cxt.fail$data((0, codegen_1$j._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
  }
};
multipleOf.default = def$p;
var limitLength = {};
var ucs2length$1 = {};
Object.defineProperty(ucs2length$1, "__esModule", { value: true });
function ucs2length(str) {
  const len = str.length;
  let length2 = 0;
  let pos = 0;
  let value;
  while (pos < len) {
    length2++;
    value = str.charCodeAt(pos++);
    if (value >= 55296 && value <= 56319 && pos < len) {
      value = str.charCodeAt(pos);
      if ((value & 64512) === 56320)
        pos++;
    }
  }
  return length2;
}
ucs2length$1.default = ucs2length;
ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
Object.defineProperty(limitLength, "__esModule", { value: true });
const codegen_1$i = codegen;
const util_1$i = util;
const ucs2length_1 = ucs2length$1;
const error$g = {
  message({ keyword: keyword2, schemaCode }) {
    const comp = keyword2 === "maxLength" ? "more" : "fewer";
    return (0, codegen_1$i.str)`must NOT have ${comp} than ${schemaCode} characters`;
  },
  params: ({ schemaCode }) => (0, codegen_1$i._)`{limit: ${schemaCode}}`
};
const def$o = {
  keyword: ["maxLength", "minLength"],
  type: "string",
  schemaType: "number",
  $data: true,
  error: error$g,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode, it: it2 } = cxt;
    const op = keyword2 === "maxLength" ? codegen_1$i.operators.GT : codegen_1$i.operators.LT;
    const len = it2.opts.unicode === false ? (0, codegen_1$i._)`${data}.length` : (0, codegen_1$i._)`${(0, util_1$i.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
    cxt.fail$data((0, codegen_1$i._)`${len} ${op} ${schemaCode}`);
  }
};
limitLength.default = def$o;
var pattern = {};
Object.defineProperty(pattern, "__esModule", { value: true });
const code_1$7 = code$3;
const codegen_1$h = codegen;
const error$f = {
  message: ({ schemaCode }) => (0, codegen_1$h.str)`must match pattern "${schemaCode}"`,
  params: ({ schemaCode }) => (0, codegen_1$h._)`{pattern: ${schemaCode}}`
};
const def$n = {
  keyword: "pattern",
  type: "string",
  schemaType: "string",
  $data: true,
  error: error$f,
  code(cxt) {
    const { data, $data, schema, schemaCode, it: it2 } = cxt;
    const u2 = it2.opts.unicodeRegExp ? "u" : "";
    const regExp = $data ? (0, codegen_1$h._)`(new RegExp(${schemaCode}, ${u2}))` : (0, code_1$7.usePattern)(cxt, schema);
    cxt.fail$data((0, codegen_1$h._)`!${regExp}.test(${data})`);
  }
};
pattern.default = def$n;
var limitProperties = {};
Object.defineProperty(limitProperties, "__esModule", { value: true });
const codegen_1$g = codegen;
const error$e = {
  message({ keyword: keyword2, schemaCode }) {
    const comp = keyword2 === "maxProperties" ? "more" : "fewer";
    return (0, codegen_1$g.str)`must NOT have ${comp} than ${schemaCode} properties`;
  },
  params: ({ schemaCode }) => (0, codegen_1$g._)`{limit: ${schemaCode}}`
};
const def$m = {
  keyword: ["maxProperties", "minProperties"],
  type: "object",
  schemaType: "number",
  $data: true,
  error: error$e,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode } = cxt;
    const op = keyword2 === "maxProperties" ? codegen_1$g.operators.GT : codegen_1$g.operators.LT;
    cxt.fail$data((0, codegen_1$g._)`Object.keys(${data}).length ${op} ${schemaCode}`);
  }
};
limitProperties.default = def$m;
var required = {};
Object.defineProperty(required, "__esModule", { value: true });
const code_1$6 = code$3;
const codegen_1$f = codegen;
const util_1$h = util;
const error$d = {
  message: ({ params: { missingProperty } }) => (0, codegen_1$f.str)`must have required property '${missingProperty}'`,
  params: ({ params: { missingProperty } }) => (0, codegen_1$f._)`{missingProperty: ${missingProperty}}`
};
const def$l = {
  keyword: "required",
  type: "object",
  schemaType: "array",
  $data: true,
  error: error$d,
  code(cxt) {
    const { gen, schema, schemaCode, data, $data, it: it2 } = cxt;
    const { opts } = it2;
    if (!$data && schema.length === 0)
      return;
    const useLoop = schema.length >= opts.loopRequired;
    if (it2.allErrors)
      allErrorsMode();
    else
      exitOnErrorMode();
    if (opts.strictRequired) {
      const props = cxt.parentSchema.properties;
      const { definedProperties } = cxt.it;
      for (const requiredKey of schema) {
        if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
          const schemaPath = it2.schemaEnv.baseId + it2.errSchemaPath;
          const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
          (0, util_1$h.checkStrictMode)(it2, msg, it2.opts.strictRequired);
        }
      }
    }
    function allErrorsMode() {
      if (useLoop || $data) {
        cxt.block$data(codegen_1$f.nil, loopAllRequired);
      } else {
        for (const prop of schema) {
          (0, code_1$6.checkReportMissingProp)(cxt, prop);
        }
      }
    }
    function exitOnErrorMode() {
      const missing = gen.let("missing");
      if (useLoop || $data) {
        const valid2 = gen.let("valid", true);
        cxt.block$data(valid2, () => loopUntilMissing(missing, valid2));
        cxt.ok(valid2);
      } else {
        gen.if((0, code_1$6.checkMissingProp)(cxt, schema, missing));
        (0, code_1$6.reportMissingProp)(cxt, missing);
        gen.else();
      }
    }
    function loopAllRequired() {
      gen.forOf("prop", schemaCode, (prop) => {
        cxt.setParams({ missingProperty: prop });
        gen.if((0, code_1$6.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
      });
    }
    function loopUntilMissing(missing, valid2) {
      cxt.setParams({ missingProperty: missing });
      gen.forOf(missing, schemaCode, () => {
        gen.assign(valid2, (0, code_1$6.propertyInData)(gen, data, missing, opts.ownProperties));
        gen.if((0, codegen_1$f.not)(valid2), () => {
          cxt.error();
          gen.break();
        });
      }, codegen_1$f.nil);
    }
  }
};
required.default = def$l;
var limitItems = {};
Object.defineProperty(limitItems, "__esModule", { value: true });
const codegen_1$e = codegen;
const error$c = {
  message({ keyword: keyword2, schemaCode }) {
    const comp = keyword2 === "maxItems" ? "more" : "fewer";
    return (0, codegen_1$e.str)`must NOT have ${comp} than ${schemaCode} items`;
  },
  params: ({ schemaCode }) => (0, codegen_1$e._)`{limit: ${schemaCode}}`
};
const def$k = {
  keyword: ["maxItems", "minItems"],
  type: "array",
  schemaType: "number",
  $data: true,
  error: error$c,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode } = cxt;
    const op = keyword2 === "maxItems" ? codegen_1$e.operators.GT : codegen_1$e.operators.LT;
    cxt.fail$data((0, codegen_1$e._)`${data}.length ${op} ${schemaCode}`);
  }
};
limitItems.default = def$k;
var uniqueItems = {};
var equal$1 = {};
Object.defineProperty(equal$1, "__esModule", { value: true });
const equal2 = fastDeepEqual;
equal2.code = 'require("ajv/dist/runtime/equal").default';
equal$1.default = equal2;
Object.defineProperty(uniqueItems, "__esModule", { value: true });
const dataType_1 = dataType;
const codegen_1$d = codegen;
const util_1$g = util;
const equal_1$2 = equal$1;
const error$b = {
  message: ({ params: { i, j: j2 } }) => (0, codegen_1$d.str)`must NOT have duplicate items (items ## ${j2} and ${i} are identical)`,
  params: ({ params: { i, j: j2 } }) => (0, codegen_1$d._)`{i: ${i}, j: ${j2}}`
};
const def$j = {
  keyword: "uniqueItems",
  type: "array",
  schemaType: "boolean",
  $data: true,
  error: error$b,
  code(cxt) {
    const { gen, data, $data, schema, parentSchema, schemaCode, it: it2 } = cxt;
    if (!$data && !schema)
      return;
    const valid2 = gen.let("valid");
    const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
    cxt.block$data(valid2, validateUniqueItems, (0, codegen_1$d._)`${schemaCode} === false`);
    cxt.ok(valid2);
    function validateUniqueItems() {
      const i = gen.let("i", (0, codegen_1$d._)`${data}.length`);
      const j2 = gen.let("j");
      cxt.setParams({ i, j: j2 });
      gen.assign(valid2, true);
      gen.if((0, codegen_1$d._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j2));
    }
    function canOptimize() {
      return itemTypes.length > 0 && !itemTypes.some((t2) => t2 === "object" || t2 === "array");
    }
    function loopN(i, j2) {
      const item = gen.name("item");
      const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it2.opts.strictNumbers, dataType_1.DataType.Wrong);
      const indices = gen.const("indices", (0, codegen_1$d._)`{}`);
      gen.for((0, codegen_1$d._)`;${i}--;`, () => {
        gen.let(item, (0, codegen_1$d._)`${data}[${i}]`);
        gen.if(wrongType, (0, codegen_1$d._)`continue`);
        if (itemTypes.length > 1)
          gen.if((0, codegen_1$d._)`typeof ${item} == "string"`, (0, codegen_1$d._)`${item} += "_"`);
        gen.if((0, codegen_1$d._)`typeof ${indices}[${item}] == "number"`, () => {
          gen.assign(j2, (0, codegen_1$d._)`${indices}[${item}]`);
          cxt.error();
          gen.assign(valid2, false).break();
        }).code((0, codegen_1$d._)`${indices}[${item}] = ${i}`);
      });
    }
    function loopN2(i, j2) {
      const eql = (0, util_1$g.useFunc)(gen, equal_1$2.default);
      const outer = gen.name("outer");
      gen.label(outer).for((0, codegen_1$d._)`;${i}--;`, () => gen.for((0, codegen_1$d._)`${j2} = ${i}; ${j2}--;`, () => gen.if((0, codegen_1$d._)`${eql}(${data}[${i}], ${data}[${j2}])`, () => {
        cxt.error();
        gen.assign(valid2, false).break(outer);
      })));
    }
  }
};
uniqueItems.default = def$j;
var _const = {};
Object.defineProperty(_const, "__esModule", { value: true });
const codegen_1$c = codegen;
const util_1$f = util;
const equal_1$1 = equal$1;
const error$a = {
  message: "must be equal to constant",
  params: ({ schemaCode }) => (0, codegen_1$c._)`{allowedValue: ${schemaCode}}`
};
const def$i = {
  keyword: "const",
  $data: true,
  error: error$a,
  code(cxt) {
    const { gen, data, $data, schemaCode, schema } = cxt;
    if ($data || schema && typeof schema == "object") {
      cxt.fail$data((0, codegen_1$c._)`!${(0, util_1$f.useFunc)(gen, equal_1$1.default)}(${data}, ${schemaCode})`);
    } else {
      cxt.fail((0, codegen_1$c._)`${schema} !== ${data}`);
    }
  }
};
_const.default = def$i;
var _enum = {};
Object.defineProperty(_enum, "__esModule", { value: true });
const codegen_1$b = codegen;
const util_1$e = util;
const equal_1 = equal$1;
const error$9 = {
  message: "must be equal to one of the allowed values",
  params: ({ schemaCode }) => (0, codegen_1$b._)`{allowedValues: ${schemaCode}}`
};
const def$h = {
  keyword: "enum",
  schemaType: "array",
  $data: true,
  error: error$9,
  code(cxt) {
    const { gen, data, $data, schema, schemaCode, it: it2 } = cxt;
    if (!$data && schema.length === 0)
      throw new Error("enum must have non-empty array");
    const useLoop = schema.length >= it2.opts.loopEnum;
    let eql;
    const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1$e.useFunc)(gen, equal_1.default);
    let valid2;
    if (useLoop || $data) {
      valid2 = gen.let("valid");
      cxt.block$data(valid2, loopEnum);
    } else {
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const vSchema = gen.const("vSchema", schemaCode);
      valid2 = (0, codegen_1$b.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
    }
    cxt.pass(valid2);
    function loopEnum() {
      gen.assign(valid2, false);
      gen.forOf("v", schemaCode, (v2) => gen.if((0, codegen_1$b._)`${getEql()}(${data}, ${v2})`, () => gen.assign(valid2, true).break()));
    }
    function equalCode(vSchema, i) {
      const sch = schema[i];
      return typeof sch === "object" && sch !== null ? (0, codegen_1$b._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1$b._)`${data} === ${sch}`;
    }
  }
};
_enum.default = def$h;
Object.defineProperty(validation$1, "__esModule", { value: true });
const limitNumber_1 = limitNumber;
const multipleOf_1 = multipleOf;
const limitLength_1 = limitLength;
const pattern_1 = pattern;
const limitProperties_1 = limitProperties;
const required_1 = required;
const limitItems_1 = limitItems;
const uniqueItems_1 = uniqueItems;
const const_1 = _const;
const enum_1 = _enum;
const validation = [
  // number
  limitNumber_1.default,
  multipleOf_1.default,
  // string
  limitLength_1.default,
  pattern_1.default,
  // object
  limitProperties_1.default,
  required_1.default,
  // array
  limitItems_1.default,
  uniqueItems_1.default,
  // any
  { keyword: "type", schemaType: ["string", "array"] },
  { keyword: "nullable", schemaType: "boolean" },
  const_1.default,
  enum_1.default
];
validation$1.default = validation;
var applicator = {};
var additionalItems = {};
Object.defineProperty(additionalItems, "__esModule", { value: true });
additionalItems.validateAdditionalItems = void 0;
const codegen_1$a = codegen;
const util_1$d = util;
const error$8 = {
  message: ({ params: { len } }) => (0, codegen_1$a.str)`must NOT have more than ${len} items`,
  params: ({ params: { len } }) => (0, codegen_1$a._)`{limit: ${len}}`
};
const def$g = {
  keyword: "additionalItems",
  type: "array",
  schemaType: ["boolean", "object"],
  before: "uniqueItems",
  error: error$8,
  code(cxt) {
    const { parentSchema, it: it2 } = cxt;
    const { items: items2 } = parentSchema;
    if (!Array.isArray(items2)) {
      (0, util_1$d.checkStrictMode)(it2, '"additionalItems" is ignored when "items" is not an array of schemas');
      return;
    }
    validateAdditionalItems(cxt, items2);
  }
};
function validateAdditionalItems(cxt, items2) {
  const { gen, schema, data, keyword: keyword2, it: it2 } = cxt;
  it2.items = true;
  const len = gen.const("len", (0, codegen_1$a._)`${data}.length`);
  if (schema === false) {
    cxt.setParams({ len: items2.length });
    cxt.pass((0, codegen_1$a._)`${len} <= ${items2.length}`);
  } else if (typeof schema == "object" && !(0, util_1$d.alwaysValidSchema)(it2, schema)) {
    const valid2 = gen.var("valid", (0, codegen_1$a._)`${len} <= ${items2.length}`);
    gen.if((0, codegen_1$a.not)(valid2), () => validateItems(valid2));
    cxt.ok(valid2);
  }
  function validateItems(valid2) {
    gen.forRange("i", items2.length, len, (i) => {
      cxt.subschema({ keyword: keyword2, dataProp: i, dataPropType: util_1$d.Type.Num }, valid2);
      if (!it2.allErrors)
        gen.if((0, codegen_1$a.not)(valid2), () => gen.break());
    });
  }
}
additionalItems.validateAdditionalItems = validateAdditionalItems;
additionalItems.default = def$g;
var prefixItems = {};
var items = {};
Object.defineProperty(items, "__esModule", { value: true });
items.validateTuple = void 0;
const codegen_1$9 = codegen;
const util_1$c = util;
const code_1$5 = code$3;
const def$f = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "array", "boolean"],
  before: "uniqueItems",
  code(cxt) {
    const { schema, it: it2 } = cxt;
    if (Array.isArray(schema))
      return validateTuple(cxt, "additionalItems", schema);
    it2.items = true;
    if ((0, util_1$c.alwaysValidSchema)(it2, schema))
      return;
    cxt.ok((0, code_1$5.validateArray)(cxt));
  }
};
function validateTuple(cxt, extraItems, schArr = cxt.schema) {
  const { gen, parentSchema, data, keyword: keyword2, it: it2 } = cxt;
  checkStrictTuple(parentSchema);
  if (it2.opts.unevaluated && schArr.length && it2.items !== true) {
    it2.items = util_1$c.mergeEvaluated.items(gen, schArr.length, it2.items);
  }
  const valid2 = gen.name("valid");
  const len = gen.const("len", (0, codegen_1$9._)`${data}.length`);
  schArr.forEach((sch, i) => {
    if ((0, util_1$c.alwaysValidSchema)(it2, sch))
      return;
    gen.if((0, codegen_1$9._)`${len} > ${i}`, () => cxt.subschema({
      keyword: keyword2,
      schemaProp: i,
      dataProp: i
    }, valid2));
    cxt.ok(valid2);
  });
  function checkStrictTuple(sch) {
    const { opts, errSchemaPath } = it2;
    const l2 = schArr.length;
    const fullTuple = l2 === sch.minItems && (l2 === sch.maxItems || sch[extraItems] === false);
    if (opts.strictTuples && !fullTuple) {
      const msg = `"${keyword2}" is ${l2}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
      (0, util_1$c.checkStrictMode)(it2, msg, opts.strictTuples);
    }
  }
}
items.validateTuple = validateTuple;
items.default = def$f;
Object.defineProperty(prefixItems, "__esModule", { value: true });
const items_1$1 = items;
const def$e = {
  keyword: "prefixItems",
  type: "array",
  schemaType: ["array"],
  before: "uniqueItems",
  code: (cxt) => (0, items_1$1.validateTuple)(cxt, "items")
};
prefixItems.default = def$e;
var items2020 = {};
Object.defineProperty(items2020, "__esModule", { value: true });
const codegen_1$8 = codegen;
const util_1$b = util;
const code_1$4 = code$3;
const additionalItems_1$1 = additionalItems;
const error$7 = {
  message: ({ params: { len } }) => (0, codegen_1$8.str)`must NOT have more than ${len} items`,
  params: ({ params: { len } }) => (0, codegen_1$8._)`{limit: ${len}}`
};
const def$d = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  error: error$7,
  code(cxt) {
    const { schema, parentSchema, it: it2 } = cxt;
    const { prefixItems: prefixItems2 } = parentSchema;
    it2.items = true;
    if ((0, util_1$b.alwaysValidSchema)(it2, schema))
      return;
    if (prefixItems2)
      (0, additionalItems_1$1.validateAdditionalItems)(cxt, prefixItems2);
    else
      cxt.ok((0, code_1$4.validateArray)(cxt));
  }
};
items2020.default = def$d;
var contains = {};
Object.defineProperty(contains, "__esModule", { value: true });
const codegen_1$7 = codegen;
const util_1$a = util;
const error$6 = {
  message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1$7.str)`must contain at least ${min} valid item(s)` : (0, codegen_1$7.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
  params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1$7._)`{minContains: ${min}}` : (0, codegen_1$7._)`{minContains: ${min}, maxContains: ${max}}`
};
const def$c = {
  keyword: "contains",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  trackErrors: true,
  error: error$6,
  code(cxt) {
    const { gen, schema, parentSchema, data, it: it2 } = cxt;
    let min;
    let max;
    const { minContains, maxContains } = parentSchema;
    if (it2.opts.next) {
      min = minContains === void 0 ? 1 : minContains;
      max = maxContains;
    } else {
      min = 1;
    }
    const len = gen.const("len", (0, codegen_1$7._)`${data}.length`);
    cxt.setParams({ min, max });
    if (max === void 0 && min === 0) {
      (0, util_1$a.checkStrictMode)(it2, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
      return;
    }
    if (max !== void 0 && min > max) {
      (0, util_1$a.checkStrictMode)(it2, `"minContains" > "maxContains" is always invalid`);
      cxt.fail();
      return;
    }
    if ((0, util_1$a.alwaysValidSchema)(it2, schema)) {
      let cond = (0, codegen_1$7._)`${len} >= ${min}`;
      if (max !== void 0)
        cond = (0, codegen_1$7._)`${cond} && ${len} <= ${max}`;
      cxt.pass(cond);
      return;
    }
    it2.items = true;
    const valid2 = gen.name("valid");
    if (max === void 0 && min === 1) {
      validateItems(valid2, () => gen.if(valid2, () => gen.break()));
    } else if (min === 0) {
      gen.let(valid2, true);
      if (max !== void 0)
        gen.if((0, codegen_1$7._)`${data}.length > 0`, validateItemsWithCount);
    } else {
      gen.let(valid2, false);
      validateItemsWithCount();
    }
    cxt.result(valid2, () => cxt.reset());
    function validateItemsWithCount() {
      const schValid = gen.name("_valid");
      const count = gen.let("count", 0);
      validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
    }
    function validateItems(_valid, block) {
      gen.forRange("i", 0, len, (i) => {
        cxt.subschema({
          keyword: "contains",
          dataProp: i,
          dataPropType: util_1$a.Type.Num,
          compositeRule: true
        }, _valid);
        block();
      });
    }
    function checkLimits(count) {
      gen.code((0, codegen_1$7._)`${count}++`);
      if (max === void 0) {
        gen.if((0, codegen_1$7._)`${count} >= ${min}`, () => gen.assign(valid2, true).break());
      } else {
        gen.if((0, codegen_1$7._)`${count} > ${max}`, () => gen.assign(valid2, false).break());
        if (min === 1)
          gen.assign(valid2, true);
        else
          gen.if((0, codegen_1$7._)`${count} >= ${min}`, () => gen.assign(valid2, true));
      }
    }
  }
};
contains.default = def$c;
var dependencies = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
  const codegen_12 = codegen;
  const util_12 = util;
  const code_12 = code$3;
  exports.error = {
    message: ({ params: { property: property2, depsCount, deps } }) => {
      const property_ies = depsCount === 1 ? "property" : "properties";
      return (0, codegen_12.str)`must have ${property_ies} ${deps} when property ${property2} is present`;
    },
    params: ({ params: { property: property2, depsCount, deps, missingProperty } }) => (0, codegen_12._)`{property: ${property2},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
    // TODO change to reference
  };
  const def2 = {
    keyword: "dependencies",
    type: "object",
    schemaType: "object",
    error: exports.error,
    code(cxt) {
      const [propDeps, schDeps] = splitDependencies(cxt);
      validatePropertyDeps(cxt, propDeps);
      validateSchemaDeps(cxt, schDeps);
    }
  };
  function splitDependencies({ schema }) {
    const propertyDeps = {};
    const schemaDeps = {};
    for (const key in schema) {
      if (key === "__proto__")
        continue;
      const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
      deps[key] = schema[key];
    }
    return [propertyDeps, schemaDeps];
  }
  function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
    const { gen, data, it: it2 } = cxt;
    if (Object.keys(propertyDeps).length === 0)
      return;
    const missing = gen.let("missing");
    for (const prop in propertyDeps) {
      const deps = propertyDeps[prop];
      if (deps.length === 0)
        continue;
      const hasProperty = (0, code_12.propertyInData)(gen, data, prop, it2.opts.ownProperties);
      cxt.setParams({
        property: prop,
        depsCount: deps.length,
        deps: deps.join(", ")
      });
      if (it2.allErrors) {
        gen.if(hasProperty, () => {
          for (const depProp of deps) {
            (0, code_12.checkReportMissingProp)(cxt, depProp);
          }
        });
      } else {
        gen.if((0, codegen_12._)`${hasProperty} && (${(0, code_12.checkMissingProp)(cxt, deps, missing)})`);
        (0, code_12.reportMissingProp)(cxt, missing);
        gen.else();
      }
    }
  }
  exports.validatePropertyDeps = validatePropertyDeps;
  function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
    const { gen, data, keyword: keyword2, it: it2 } = cxt;
    const valid2 = gen.name("valid");
    for (const prop in schemaDeps) {
      if ((0, util_12.alwaysValidSchema)(it2, schemaDeps[prop]))
        continue;
      gen.if(
        (0, code_12.propertyInData)(gen, data, prop, it2.opts.ownProperties),
        () => {
          const schCxt = cxt.subschema({ keyword: keyword2, schemaProp: prop }, valid2);
          cxt.mergeValidEvaluated(schCxt, valid2);
        },
        () => gen.var(valid2, true)
        // TODO var
      );
      cxt.ok(valid2);
    }
  }
  exports.validateSchemaDeps = validateSchemaDeps;
  exports.default = def2;
})(dependencies);
var propertyNames = {};
Object.defineProperty(propertyNames, "__esModule", { value: true });
const codegen_1$6 = codegen;
const util_1$9 = util;
const error$5 = {
  message: "property name must be valid",
  params: ({ params }) => (0, codegen_1$6._)`{propertyName: ${params.propertyName}}`
};
const def$b = {
  keyword: "propertyNames",
  type: "object",
  schemaType: ["object", "boolean"],
  error: error$5,
  code(cxt) {
    const { gen, schema, data, it: it2 } = cxt;
    if ((0, util_1$9.alwaysValidSchema)(it2, schema))
      return;
    const valid2 = gen.name("valid");
    gen.forIn("key", data, (key) => {
      cxt.setParams({ propertyName: key });
      cxt.subschema({
        keyword: "propertyNames",
        data: key,
        dataTypes: ["string"],
        propertyName: key,
        compositeRule: true
      }, valid2);
      gen.if((0, codegen_1$6.not)(valid2), () => {
        cxt.error(true);
        if (!it2.allErrors)
          gen.break();
      });
    });
    cxt.ok(valid2);
  }
};
propertyNames.default = def$b;
var additionalProperties = {};
Object.defineProperty(additionalProperties, "__esModule", { value: true });
const code_1$3 = code$3;
const codegen_1$5 = codegen;
const names_1 = names$1;
const util_1$8 = util;
const error$4 = {
  message: "must NOT have additional properties",
  params: ({ params }) => (0, codegen_1$5._)`{additionalProperty: ${params.additionalProperty}}`
};
const def$a = {
  keyword: "additionalProperties",
  type: ["object"],
  schemaType: ["boolean", "object"],
  allowUndefined: true,
  trackErrors: true,
  error: error$4,
  code(cxt) {
    const { gen, schema, parentSchema, data, errsCount, it: it2 } = cxt;
    if (!errsCount)
      throw new Error("ajv implementation error");
    const { allErrors, opts } = it2;
    it2.props = true;
    if (opts.removeAdditional !== "all" && (0, util_1$8.alwaysValidSchema)(it2, schema))
      return;
    const props = (0, code_1$3.allSchemaProperties)(parentSchema.properties);
    const patProps = (0, code_1$3.allSchemaProperties)(parentSchema.patternProperties);
    checkAdditionalProperties();
    cxt.ok((0, codegen_1$5._)`${errsCount} === ${names_1.default.errors}`);
    function checkAdditionalProperties() {
      gen.forIn("key", data, (key) => {
        if (!props.length && !patProps.length)
          additionalPropertyCode(key);
        else
          gen.if(isAdditional(key), () => additionalPropertyCode(key));
      });
    }
    function isAdditional(key) {
      let definedProp;
      if (props.length > 8) {
        const propsSchema = (0, util_1$8.schemaRefOrVal)(it2, parentSchema.properties, "properties");
        definedProp = (0, code_1$3.isOwnProperty)(gen, propsSchema, key);
      } else if (props.length) {
        definedProp = (0, codegen_1$5.or)(...props.map((p2) => (0, codegen_1$5._)`${key} === ${p2}`));
      } else {
        definedProp = codegen_1$5.nil;
      }
      if (patProps.length) {
        definedProp = (0, codegen_1$5.or)(definedProp, ...patProps.map((p2) => (0, codegen_1$5._)`${(0, code_1$3.usePattern)(cxt, p2)}.test(${key})`));
      }
      return (0, codegen_1$5.not)(definedProp);
    }
    function deleteAdditional(key) {
      gen.code((0, codegen_1$5._)`delete ${data}[${key}]`);
    }
    function additionalPropertyCode(key) {
      if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
        deleteAdditional(key);
        return;
      }
      if (schema === false) {
        cxt.setParams({ additionalProperty: key });
        cxt.error();
        if (!allErrors)
          gen.break();
        return;
      }
      if (typeof schema == "object" && !(0, util_1$8.alwaysValidSchema)(it2, schema)) {
        const valid2 = gen.name("valid");
        if (opts.removeAdditional === "failing") {
          applyAdditionalSchema(key, valid2, false);
          gen.if((0, codegen_1$5.not)(valid2), () => {
            cxt.reset();
            deleteAdditional(key);
          });
        } else {
          applyAdditionalSchema(key, valid2);
          if (!allErrors)
            gen.if((0, codegen_1$5.not)(valid2), () => gen.break());
        }
      }
    }
    function applyAdditionalSchema(key, valid2, errors2) {
      const subschema2 = {
        keyword: "additionalProperties",
        dataProp: key,
        dataPropType: util_1$8.Type.Str
      };
      if (errors2 === false) {
        Object.assign(subschema2, {
          compositeRule: true,
          createErrors: false,
          allErrors: false
        });
      }
      cxt.subschema(subschema2, valid2);
    }
  }
};
additionalProperties.default = def$a;
var properties$1 = {};
Object.defineProperty(properties$1, "__esModule", { value: true });
const validate_1 = validate;
const code_1$2 = code$3;
const util_1$7 = util;
const additionalProperties_1$1 = additionalProperties;
const def$9 = {
  keyword: "properties",
  type: "object",
  schemaType: "object",
  code(cxt) {
    const { gen, schema, parentSchema, data, it: it2 } = cxt;
    if (it2.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
      additionalProperties_1$1.default.code(new validate_1.KeywordCxt(it2, additionalProperties_1$1.default, "additionalProperties"));
    }
    const allProps = (0, code_1$2.allSchemaProperties)(schema);
    for (const prop of allProps) {
      it2.definedProperties.add(prop);
    }
    if (it2.opts.unevaluated && allProps.length && it2.props !== true) {
      it2.props = util_1$7.mergeEvaluated.props(gen, (0, util_1$7.toHash)(allProps), it2.props);
    }
    const properties2 = allProps.filter((p2) => !(0, util_1$7.alwaysValidSchema)(it2, schema[p2]));
    if (properties2.length === 0)
      return;
    const valid2 = gen.name("valid");
    for (const prop of properties2) {
      if (hasDefault(prop)) {
        applyPropertySchema(prop);
      } else {
        gen.if((0, code_1$2.propertyInData)(gen, data, prop, it2.opts.ownProperties));
        applyPropertySchema(prop);
        if (!it2.allErrors)
          gen.else().var(valid2, true);
        gen.endIf();
      }
      cxt.it.definedProperties.add(prop);
      cxt.ok(valid2);
    }
    function hasDefault(prop) {
      return it2.opts.useDefaults && !it2.compositeRule && schema[prop].default !== void 0;
    }
    function applyPropertySchema(prop) {
      cxt.subschema({
        keyword: "properties",
        schemaProp: prop,
        dataProp: prop
      }, valid2);
    }
  }
};
properties$1.default = def$9;
var patternProperties = {};
Object.defineProperty(patternProperties, "__esModule", { value: true });
const code_1$1 = code$3;
const codegen_1$4 = codegen;
const util_1$6 = util;
const util_2 = util;
const def$8 = {
  keyword: "patternProperties",
  type: "object",
  schemaType: "object",
  code(cxt) {
    const { gen, schema, data, parentSchema, it: it2 } = cxt;
    const { opts } = it2;
    const patterns = (0, code_1$1.allSchemaProperties)(schema);
    const alwaysValidPatterns = patterns.filter((p2) => (0, util_1$6.alwaysValidSchema)(it2, schema[p2]));
    if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it2.opts.unevaluated || it2.props === true)) {
      return;
    }
    const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
    const valid2 = gen.name("valid");
    if (it2.props !== true && !(it2.props instanceof codegen_1$4.Name)) {
      it2.props = (0, util_2.evaluatedPropsToName)(gen, it2.props);
    }
    const { props } = it2;
    validatePatternProperties();
    function validatePatternProperties() {
      for (const pat of patterns) {
        if (checkProperties)
          checkMatchingProperties(pat);
        if (it2.allErrors) {
          validateProperties(pat);
        } else {
          gen.var(valid2, true);
          validateProperties(pat);
          gen.if(valid2);
        }
      }
    }
    function checkMatchingProperties(pat) {
      for (const prop in checkProperties) {
        if (new RegExp(pat).test(prop)) {
          (0, util_1$6.checkStrictMode)(it2, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
        }
      }
    }
    function validateProperties(pat) {
      gen.forIn("key", data, (key) => {
        gen.if((0, codegen_1$4._)`${(0, code_1$1.usePattern)(cxt, pat)}.test(${key})`, () => {
          const alwaysValid = alwaysValidPatterns.includes(pat);
          if (!alwaysValid) {
            cxt.subschema({
              keyword: "patternProperties",
              schemaProp: pat,
              dataProp: key,
              dataPropType: util_2.Type.Str
            }, valid2);
          }
          if (it2.opts.unevaluated && props !== true) {
            gen.assign((0, codegen_1$4._)`${props}[${key}]`, true);
          } else if (!alwaysValid && !it2.allErrors) {
            gen.if((0, codegen_1$4.not)(valid2), () => gen.break());
          }
        });
      });
    }
  }
};
patternProperties.default = def$8;
var not = {};
Object.defineProperty(not, "__esModule", { value: true });
const util_1$5 = util;
const def$7 = {
  keyword: "not",
  schemaType: ["object", "boolean"],
  trackErrors: true,
  code(cxt) {
    const { gen, schema, it: it2 } = cxt;
    if ((0, util_1$5.alwaysValidSchema)(it2, schema)) {
      cxt.fail();
      return;
    }
    const valid2 = gen.name("valid");
    cxt.subschema({
      keyword: "not",
      compositeRule: true,
      createErrors: false,
      allErrors: false
    }, valid2);
    cxt.failResult(valid2, () => cxt.reset(), () => cxt.error());
  },
  error: { message: "must NOT be valid" }
};
not.default = def$7;
var anyOf = {};
Object.defineProperty(anyOf, "__esModule", { value: true });
const code_1 = code$3;
const def$6 = {
  keyword: "anyOf",
  schemaType: "array",
  trackErrors: true,
  code: code_1.validateUnion,
  error: { message: "must match a schema in anyOf" }
};
anyOf.default = def$6;
var oneOf = {};
Object.defineProperty(oneOf, "__esModule", { value: true });
const codegen_1$3 = codegen;
const util_1$4 = util;
const error$3 = {
  message: "must match exactly one schema in oneOf",
  params: ({ params }) => (0, codegen_1$3._)`{passingSchemas: ${params.passing}}`
};
const def$5 = {
  keyword: "oneOf",
  schemaType: "array",
  trackErrors: true,
  error: error$3,
  code(cxt) {
    const { gen, schema, parentSchema, it: it2 } = cxt;
    if (!Array.isArray(schema))
      throw new Error("ajv implementation error");
    if (it2.opts.discriminator && parentSchema.discriminator)
      return;
    const schArr = schema;
    const valid2 = gen.let("valid", false);
    const passing = gen.let("passing", null);
    const schValid = gen.name("_valid");
    cxt.setParams({ passing });
    gen.block(validateOneOf);
    cxt.result(valid2, () => cxt.reset(), () => cxt.error(true));
    function validateOneOf() {
      schArr.forEach((sch, i) => {
        let schCxt;
        if ((0, util_1$4.alwaysValidSchema)(it2, sch)) {
          gen.var(schValid, true);
        } else {
          schCxt = cxt.subschema({
            keyword: "oneOf",
            schemaProp: i,
            compositeRule: true
          }, schValid);
        }
        if (i > 0) {
          gen.if((0, codegen_1$3._)`${schValid} && ${valid2}`).assign(valid2, false).assign(passing, (0, codegen_1$3._)`[${passing}, ${i}]`).else();
        }
        gen.if(schValid, () => {
          gen.assign(valid2, true);
          gen.assign(passing, i);
          if (schCxt)
            cxt.mergeEvaluated(schCxt, codegen_1$3.Name);
        });
      });
    }
  }
};
oneOf.default = def$5;
var allOf = {};
Object.defineProperty(allOf, "__esModule", { value: true });
const util_1$3 = util;
const def$4 = {
  keyword: "allOf",
  schemaType: "array",
  code(cxt) {
    const { gen, schema, it: it2 } = cxt;
    if (!Array.isArray(schema))
      throw new Error("ajv implementation error");
    const valid2 = gen.name("valid");
    schema.forEach((sch, i) => {
      if ((0, util_1$3.alwaysValidSchema)(it2, sch))
        return;
      const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid2);
      cxt.ok(valid2);
      cxt.mergeEvaluated(schCxt);
    });
  }
};
allOf.default = def$4;
var _if = {};
Object.defineProperty(_if, "__esModule", { value: true });
const codegen_1$2 = codegen;
const util_1$2 = util;
const error$2 = {
  message: ({ params }) => (0, codegen_1$2.str)`must match "${params.ifClause}" schema`,
  params: ({ params }) => (0, codegen_1$2._)`{failingKeyword: ${params.ifClause}}`
};
const def$3 = {
  keyword: "if",
  schemaType: ["object", "boolean"],
  trackErrors: true,
  error: error$2,
  code(cxt) {
    const { gen, parentSchema, it: it2 } = cxt;
    if (parentSchema.then === void 0 && parentSchema.else === void 0) {
      (0, util_1$2.checkStrictMode)(it2, '"if" without "then" and "else" is ignored');
    }
    const hasThen = hasSchema(it2, "then");
    const hasElse = hasSchema(it2, "else");
    if (!hasThen && !hasElse)
      return;
    const valid2 = gen.let("valid", true);
    const schValid = gen.name("_valid");
    validateIf();
    cxt.reset();
    if (hasThen && hasElse) {
      const ifClause = gen.let("ifClause");
      cxt.setParams({ ifClause });
      gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
    } else if (hasThen) {
      gen.if(schValid, validateClause("then"));
    } else {
      gen.if((0, codegen_1$2.not)(schValid), validateClause("else"));
    }
    cxt.pass(valid2, () => cxt.error(true));
    function validateIf() {
      const schCxt = cxt.subschema({
        keyword: "if",
        compositeRule: true,
        createErrors: false,
        allErrors: false
      }, schValid);
      cxt.mergeEvaluated(schCxt);
    }
    function validateClause(keyword2, ifClause) {
      return () => {
        const schCxt = cxt.subschema({ keyword: keyword2 }, schValid);
        gen.assign(valid2, schValid);
        cxt.mergeValidEvaluated(schCxt, valid2);
        if (ifClause)
          gen.assign(ifClause, (0, codegen_1$2._)`${keyword2}`);
        else
          cxt.setParams({ ifClause: keyword2 });
      };
    }
  }
};
function hasSchema(it2, keyword2) {
  const schema = it2.schema[keyword2];
  return schema !== void 0 && !(0, util_1$2.alwaysValidSchema)(it2, schema);
}
_if.default = def$3;
var thenElse = {};
Object.defineProperty(thenElse, "__esModule", { value: true });
const util_1$1 = util;
const def$2 = {
  keyword: ["then", "else"],
  schemaType: ["object", "boolean"],
  code({ keyword: keyword2, parentSchema, it: it2 }) {
    if (parentSchema.if === void 0)
      (0, util_1$1.checkStrictMode)(it2, `"${keyword2}" without "if" is ignored`);
  }
};
thenElse.default = def$2;
Object.defineProperty(applicator, "__esModule", { value: true });
const additionalItems_1 = additionalItems;
const prefixItems_1 = prefixItems;
const items_1 = items;
const items2020_1 = items2020;
const contains_1 = contains;
const dependencies_1 = dependencies;
const propertyNames_1 = propertyNames;
const additionalProperties_1 = additionalProperties;
const properties_1 = properties$1;
const patternProperties_1 = patternProperties;
const not_1 = not;
const anyOf_1 = anyOf;
const oneOf_1 = oneOf;
const allOf_1 = allOf;
const if_1 = _if;
const thenElse_1 = thenElse;
function getApplicator(draft2020 = false) {
  const applicator2 = [
    // any
    not_1.default,
    anyOf_1.default,
    oneOf_1.default,
    allOf_1.default,
    if_1.default,
    thenElse_1.default,
    // object
    propertyNames_1.default,
    additionalProperties_1.default,
    dependencies_1.default,
    properties_1.default,
    patternProperties_1.default
  ];
  if (draft2020)
    applicator2.push(prefixItems_1.default, items2020_1.default);
  else
    applicator2.push(additionalItems_1.default, items_1.default);
  applicator2.push(contains_1.default);
  return applicator2;
}
applicator.default = getApplicator;
var format$2 = {};
var format$1 = {};
Object.defineProperty(format$1, "__esModule", { value: true });
const codegen_1$1 = codegen;
const error$1 = {
  message: ({ schemaCode }) => (0, codegen_1$1.str)`must match format "${schemaCode}"`,
  params: ({ schemaCode }) => (0, codegen_1$1._)`{format: ${schemaCode}}`
};
const def$1 = {
  keyword: "format",
  type: ["number", "string"],
  schemaType: "string",
  $data: true,
  error: error$1,
  code(cxt, ruleType) {
    const { gen, data, $data, schema, schemaCode, it: it2 } = cxt;
    const { opts, errSchemaPath, schemaEnv, self: self2 } = it2;
    if (!opts.validateFormats)
      return;
    if ($data)
      validate$DataFormat();
    else
      validateFormat();
    function validate$DataFormat() {
      const fmts = gen.scopeValue("formats", {
        ref: self2.formats,
        code: opts.code.formats
      });
      const fDef = gen.const("fDef", (0, codegen_1$1._)`${fmts}[${schemaCode}]`);
      const fType = gen.let("fType");
      const format2 = gen.let("format");
      gen.if((0, codegen_1$1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1$1._)`${fDef}.type || "string"`).assign(format2, (0, codegen_1$1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1$1._)`"string"`).assign(format2, fDef));
      cxt.fail$data((0, codegen_1$1.or)(unknownFmt(), invalidFmt()));
      function unknownFmt() {
        if (opts.strictSchema === false)
          return codegen_1$1.nil;
        return (0, codegen_1$1._)`${schemaCode} && !${format2}`;
      }
      function invalidFmt() {
        const callFormat = schemaEnv.$async ? (0, codegen_1$1._)`(${fDef}.async ? await ${format2}(${data}) : ${format2}(${data}))` : (0, codegen_1$1._)`${format2}(${data})`;
        const validData = (0, codegen_1$1._)`(typeof ${format2} == "function" ? ${callFormat} : ${format2}.test(${data}))`;
        return (0, codegen_1$1._)`${format2} && ${format2} !== true && ${fType} === ${ruleType} && !${validData}`;
      }
    }
    function validateFormat() {
      const formatDef = self2.formats[schema];
      if (!formatDef) {
        unknownFormat();
        return;
      }
      if (formatDef === true)
        return;
      const [fmtType, format2, fmtRef] = getFormat(formatDef);
      if (fmtType === ruleType)
        cxt.pass(validCondition());
      function unknownFormat() {
        if (opts.strictSchema === false) {
          self2.logger.warn(unknownMsg());
          return;
        }
        throw new Error(unknownMsg());
        function unknownMsg() {
          return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
        }
      }
      function getFormat(fmtDef) {
        const code2 = fmtDef instanceof RegExp ? (0, codegen_1$1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1$1._)`${opts.code.formats}${(0, codegen_1$1.getProperty)(schema)}` : void 0;
        const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code: code2 });
        if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
          return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1$1._)`${fmt}.validate`];
        }
        return ["string", fmtDef, fmt];
      }
      function validCondition() {
        if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
          if (!schemaEnv.$async)
            throw new Error("async format in sync schema");
          return (0, codegen_1$1._)`await ${fmtRef}(${data})`;
        }
        return typeof format2 == "function" ? (0, codegen_1$1._)`${fmtRef}(${data})` : (0, codegen_1$1._)`${fmtRef}.test(${data})`;
      }
    }
  }
};
format$1.default = def$1;
Object.defineProperty(format$2, "__esModule", { value: true });
const format_1$1 = format$1;
const format = [format_1$1.default];
format$2.default = format;
var metadata = {};
Object.defineProperty(metadata, "__esModule", { value: true });
metadata.contentVocabulary = metadata.metadataVocabulary = void 0;
metadata.metadataVocabulary = [
  "title",
  "description",
  "default",
  "deprecated",
  "readOnly",
  "writeOnly",
  "examples"
];
metadata.contentVocabulary = [
  "contentMediaType",
  "contentEncoding",
  "contentSchema"
];
Object.defineProperty(draft7, "__esModule", { value: true });
const core_1 = core$1;
const validation_1 = validation$1;
const applicator_1 = applicator;
const format_1 = format$2;
const metadata_1 = metadata;
const draft7Vocabularies = [
  core_1.default,
  validation_1.default,
  (0, applicator_1.default)(),
  format_1.default,
  metadata_1.metadataVocabulary,
  metadata_1.contentVocabulary
];
draft7.default = draft7Vocabularies;
var discriminator = {};
var types$1 = {};
Object.defineProperty(types$1, "__esModule", { value: true });
types$1.DiscrError = void 0;
var DiscrError;
(function(DiscrError2) {
  DiscrError2["Tag"] = "tag";
  DiscrError2["Mapping"] = "mapping";
})(DiscrError || (types$1.DiscrError = DiscrError = {}));
Object.defineProperty(discriminator, "__esModule", { value: true });
const codegen_1 = codegen;
const types_1 = types$1;
const compile_1 = compile;
const ref_error_1 = ref_error;
const util_1 = util;
const error = {
  message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
  params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
};
const def = {
  keyword: "discriminator",
  type: "object",
  schemaType: "object",
  error,
  code(cxt) {
    const { gen, data, schema, parentSchema, it: it2 } = cxt;
    const { oneOf: oneOf2 } = parentSchema;
    if (!it2.opts.discriminator) {
      throw new Error("discriminator: requires discriminator option");
    }
    const tagName = schema.propertyName;
    if (typeof tagName != "string")
      throw new Error("discriminator: requires propertyName");
    if (schema.mapping)
      throw new Error("discriminator: mapping is not supported");
    if (!oneOf2)
      throw new Error("discriminator: requires oneOf keyword");
    const valid2 = gen.let("valid", false);
    const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
    gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
    cxt.ok(valid2);
    function validateMapping() {
      const mapping = getMapping();
      gen.if(false);
      for (const tagValue in mapping) {
        gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
        gen.assign(valid2, applyTagSchema(mapping[tagValue]));
      }
      gen.else();
      cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
      gen.endIf();
    }
    function applyTagSchema(schemaProp) {
      const _valid = gen.name("valid");
      const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
      cxt.mergeEvaluated(schCxt, codegen_1.Name);
      return _valid;
    }
    function getMapping() {
      var _a3;
      const oneOfMapping = {};
      const topRequired = hasRequired(parentSchema);
      let tagRequired = true;
      for (let i = 0; i < oneOf2.length; i++) {
        let sch = oneOf2[i];
        if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it2.self.RULES)) {
          const ref2 = sch.$ref;
          sch = compile_1.resolveRef.call(it2.self, it2.schemaEnv.root, it2.baseId, ref2);
          if (sch instanceof compile_1.SchemaEnv)
            sch = sch.schema;
          if (sch === void 0)
            throw new ref_error_1.default(it2.opts.uriResolver, it2.baseId, ref2);
        }
        const propSch = (_a3 = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a3 === void 0 ? void 0 : _a3[tagName];
        if (typeof propSch != "object") {
          throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
        }
        tagRequired = tagRequired && (topRequired || hasRequired(sch));
        addMappings(propSch, i);
      }
      if (!tagRequired)
        throw new Error(`discriminator: "${tagName}" must be required`);
      return oneOfMapping;
      function hasRequired({ required: required2 }) {
        return Array.isArray(required2) && required2.includes(tagName);
      }
      function addMappings(sch, i) {
        if (sch.const) {
          addMapping(sch.const, i);
        } else if (sch.enum) {
          for (const tagValue of sch.enum) {
            addMapping(tagValue, i);
          }
        } else {
          throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
        }
      }
      function addMapping(tagValue, i) {
        if (typeof tagValue != "string" || tagValue in oneOfMapping) {
          throw new Error(`discriminator: "${tagName}" values must be unique strings`);
        }
        oneOfMapping[tagValue] = i;
      }
    }
  }
};
discriminator.default = def;
const $schema = "http://json-schema.org/draft-07/schema#";
const $id = "http://json-schema.org/draft-07/schema#";
const title = "Core schema meta-schema";
const definitions = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $ref: "#"
    }
  },
  nonNegativeInteger: {
    type: "integer",
    minimum: 0
  },
  nonNegativeIntegerDefault0: {
    allOf: [
      {
        $ref: "#/definitions/nonNegativeInteger"
      },
      {
        "default": 0
      }
    ]
  },
  simpleTypes: {
    "enum": [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    uniqueItems: true,
    "default": []
  }
};
const type = [
  "object",
  "boolean"
];
const properties = {
  $id: {
    type: "string",
    format: "uri-reference"
  },
  $schema: {
    type: "string",
    format: "uri"
  },
  $ref: {
    type: "string",
    format: "uri-reference"
  },
  $comment: {
    type: "string"
  },
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  "default": true,
  readOnly: {
    type: "boolean",
    "default": false
  },
  examples: {
    type: "array",
    items: true
  },
  multipleOf: {
    type: "number",
    exclusiveMinimum: 0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "number"
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "number"
  },
  maxLength: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minLength: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  additionalItems: {
    $ref: "#"
  },
  items: {
    anyOf: [
      {
        $ref: "#"
      },
      {
        $ref: "#/definitions/schemaArray"
      }
    ],
    "default": true
  },
  maxItems: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minItems: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    "default": false
  },
  contains: {
    $ref: "#"
  },
  maxProperties: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minProperties: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  required: {
    $ref: "#/definitions/stringArray"
  },
  additionalProperties: {
    $ref: "#"
  },
  definitions: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    "default": {}
  },
  properties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    "default": {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    propertyNames: {
      format: "regex"
    },
    "default": {}
  },
  dependencies: {
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $ref: "#"
        },
        {
          $ref: "#/definitions/stringArray"
        }
      ]
    }
  },
  propertyNames: {
    $ref: "#"
  },
  "const": true,
  "enum": {
    type: "array",
    items: true,
    minItems: 1,
    uniqueItems: true
  },
  type: {
    anyOf: [
      {
        $ref: "#/definitions/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/definitions/simpleTypes"
        },
        minItems: 1,
        uniqueItems: true
      }
    ]
  },
  format: {
    type: "string"
  },
  contentMediaType: {
    type: "string"
  },
  contentEncoding: {
    type: "string"
  },
  "if": {
    $ref: "#"
  },
  then: {
    $ref: "#"
  },
  "else": {
    $ref: "#"
  },
  allOf: {
    $ref: "#/definitions/schemaArray"
  },
  anyOf: {
    $ref: "#/definitions/schemaArray"
  },
  oneOf: {
    $ref: "#/definitions/schemaArray"
  },
  not: {
    $ref: "#"
  }
};
const require$$3 = {
  $schema,
  $id,
  title,
  definitions,
  type,
  properties,
  "default": true
};
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = void 0;
  const core_12 = core$2;
  const draft7_1 = draft7;
  const discriminator_1 = discriminator;
  const draft7MetaSchema = require$$3;
  const META_SUPPORT_DATA = ["/properties"];
  const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
  class Ajv extends core_12.default {
    _addVocabularies() {
      super._addVocabularies();
      draft7_1.default.forEach((v2) => this.addVocabulary(v2));
      if (this.opts.discriminator)
        this.addKeyword(discriminator_1.default);
    }
    _addDefaultMetaSchema() {
      super._addDefaultMetaSchema();
      if (!this.opts.meta)
        return;
      const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
      this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
      this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
    }
  }
  exports.Ajv = Ajv;
  module.exports = exports = Ajv;
  module.exports.Ajv = Ajv;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = Ajv;
  var validate_12 = validate;
  Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
    return validate_12.KeywordCxt;
  } });
  var codegen_12 = codegen;
  Object.defineProperty(exports, "_", { enumerable: true, get: function() {
    return codegen_12._;
  } });
  Object.defineProperty(exports, "str", { enumerable: true, get: function() {
    return codegen_12.str;
  } });
  Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
    return codegen_12.stringify;
  } });
  Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
    return codegen_12.nil;
  } });
  Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
    return codegen_12.Name;
  } });
  Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
    return codegen_12.CodeGen;
  } });
  var validation_error_12 = validation_error;
  Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function() {
    return validation_error_12.default;
  } });
  var ref_error_12 = ref_error;
  Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function() {
    return ref_error_12.default;
  } });
})(ajv, ajv.exports);
var httpErrors = { exports: {} };
/*!
 * depd
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var browser = depd;
function depd(namespace) {
  if (!namespace) {
    throw new TypeError("argument namespace is required");
  }
  function deprecate(message) {
  }
  deprecate._file = void 0;
  deprecate._ignored = true;
  deprecate._namespace = namespace;
  deprecate._traced = false;
  deprecate._warned = /* @__PURE__ */ Object.create(null);
  deprecate.function = wrapfunction;
  deprecate.property = wrapproperty;
  return deprecate;
}
function wrapfunction(fn2, message) {
  if (typeof fn2 !== "function") {
    throw new TypeError("argument fn must be a function");
  }
  return fn2;
}
function wrapproperty(obj, prop, message) {
  if (!obj || typeof obj !== "object" && typeof obj !== "function") {
    throw new TypeError("argument obj must be object");
  }
  var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
  if (!descriptor) {
    throw new TypeError("must call property on owner object");
  }
  if (!descriptor.configurable) {
    throw new TypeError("property must be configurable");
  }
}
var setprototypeof = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);
function setProtoOf(obj, proto) {
  obj.__proto__ = proto;
  return obj;
}
function mixinProperties(obj, proto) {
  for (var prop in proto) {
    if (!Object.prototype.hasOwnProperty.call(obj, prop)) {
      obj[prop] = proto[prop];
    }
  }
  return obj;
}
const require$$0 = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "103": "Early Hints",
  "200": "OK",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "208": "Already Reported",
  "226": "IM Used",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Found",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Timeout",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Payload Too Large",
  "414": "URI Too Long",
  "415": "Unsupported Media Type",
  "416": "Range Not Satisfiable",
  "417": "Expectation Failed",
  "418": "I'm a Teapot",
  "421": "Misdirected Request",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Too Early",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "431": "Request Header Fields Too Large",
  "451": "Unavailable For Legal Reasons",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Timeout",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "508": "Loop Detected",
  "509": "Bandwidth Limit Exceeded",
  "510": "Not Extended",
  "511": "Network Authentication Required"
};
/*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var codes = require$$0;
var statuses = status;
status.message = codes;
status.code = createMessageToStatusCodeMap(codes);
status.codes = createStatusCodeList(codes);
status.redirect = {
  300: true,
  301: true,
  302: true,
  303: true,
  305: true,
  307: true,
  308: true
};
status.empty = {
  204: true,
  205: true,
  304: true
};
status.retry = {
  502: true,
  503: true,
  504: true
};
function createMessageToStatusCodeMap(codes2) {
  var map2 = {};
  Object.keys(codes2).forEach(function forEachCode(code2) {
    var message = codes2[code2];
    var status2 = Number(code2);
    map2[message.toLowerCase()] = status2;
  });
  return map2;
}
function createStatusCodeList(codes2) {
  return Object.keys(codes2).map(function mapCode(code2) {
    return Number(code2);
  });
}
function getStatusCode(message) {
  var msg = message.toLowerCase();
  if (!Object.prototype.hasOwnProperty.call(status.code, msg)) {
    throw new Error('invalid status message: "' + message + '"');
  }
  return status.code[msg];
}
function getStatusMessage(code2) {
  if (!Object.prototype.hasOwnProperty.call(status.message, code2)) {
    throw new Error("invalid status code: " + code2);
  }
  return status.message[code2];
}
function status(code2) {
  if (typeof code2 === "number") {
    return getStatusMessage(code2);
  }
  if (typeof code2 !== "string") {
    throw new TypeError("code must be a number or string");
  }
  var n2 = parseInt(code2, 10);
  if (!isNaN(n2)) {
    return getStatusMessage(n2);
  }
  return getStatusCode(code2);
}
var inherits_browser = { exports: {} };
if (typeof Object.create === "function") {
  inherits_browser.exports = function inherits2(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  inherits_browser.exports = function inherits2(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}
var inherits_browserExports = inherits_browser.exports;
/*!
 * toidentifier
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var toidentifier = toIdentifier;
function toIdentifier(str) {
  return str.split(" ").map(function(token2) {
    return token2.slice(0, 1).toUpperCase() + token2.slice(1);
  }).join("").replace(/[^ _0-9a-z]/gi, "");
}
/*!
 * http-errors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
(function(module) {
  browser("http-errors");
  var setPrototypeOf2 = setprototypeof;
  var statuses$1 = statuses;
  var inherits2 = inherits_browserExports;
  var toIdentifier2 = toidentifier;
  module.exports = createError;
  module.exports.HttpError = createHttpErrorConstructor();
  module.exports.isHttpError = createIsHttpErrorFunction(module.exports.HttpError);
  populateConstructorExports(module.exports, statuses$1.codes, module.exports.HttpError);
  function codeClass(status2) {
    return Number(String(status2).charAt(0) + "00");
  }
  function createError() {
    var err;
    var msg;
    var status2 = 500;
    var props = {};
    for (var i = 0; i < arguments.length; i++) {
      var arg = arguments[i];
      var type2 = typeof arg;
      if (type2 === "object" && arg instanceof Error) {
        err = arg;
        status2 = err.status || err.statusCode || status2;
      } else if (type2 === "number" && i === 0) {
        status2 = arg;
      } else if (type2 === "string") {
        msg = arg;
      } else if (type2 === "object") {
        props = arg;
      } else {
        throw new TypeError("argument #" + (i + 1) + " unsupported type " + type2);
      }
    }
    if (typeof status2 !== "number" || !statuses$1.message[status2] && (status2 < 400 || status2 >= 600)) {
      status2 = 500;
    }
    var HttpError = createError[status2] || createError[codeClass(status2)];
    if (!err) {
      err = HttpError ? new HttpError(msg) : new Error(msg || statuses$1.message[status2]);
      Error.captureStackTrace(err, createError);
    }
    if (!HttpError || !(err instanceof HttpError) || err.status !== status2) {
      err.expose = status2 < 500;
      err.status = err.statusCode = status2;
    }
    for (var key in props) {
      if (key !== "status" && key !== "statusCode") {
        err[key] = props[key];
      }
    }
    return err;
  }
  function createHttpErrorConstructor() {
    function HttpError() {
      throw new TypeError("cannot construct abstract class");
    }
    inherits2(HttpError, Error);
    return HttpError;
  }
  function createClientErrorConstructor(HttpError, name2, code2) {
    var className = toClassName(name2);
    function ClientError(message) {
      var msg = message != null ? message : statuses$1.message[code2];
      var err = new Error(msg);
      Error.captureStackTrace(err, ClientError);
      setPrototypeOf2(err, ClientError.prototype);
      Object.defineProperty(err, "message", {
        enumerable: true,
        configurable: true,
        value: msg,
        writable: true
      });
      Object.defineProperty(err, "name", {
        enumerable: false,
        configurable: true,
        value: className,
        writable: true
      });
      return err;
    }
    inherits2(ClientError, HttpError);
    nameFunc(ClientError, className);
    ClientError.prototype.status = code2;
    ClientError.prototype.statusCode = code2;
    ClientError.prototype.expose = true;
    return ClientError;
  }
  function createIsHttpErrorFunction(HttpError) {
    return function isHttpError(val) {
      if (!val || typeof val !== "object") {
        return false;
      }
      if (val instanceof HttpError) {
        return true;
      }
      return val instanceof Error && typeof val.expose === "boolean" && typeof val.statusCode === "number" && val.status === val.statusCode;
    };
  }
  function createServerErrorConstructor(HttpError, name2, code2) {
    var className = toClassName(name2);
    function ServerError(message) {
      var msg = message != null ? message : statuses$1.message[code2];
      var err = new Error(msg);
      Error.captureStackTrace(err, ServerError);
      setPrototypeOf2(err, ServerError.prototype);
      Object.defineProperty(err, "message", {
        enumerable: true,
        configurable: true,
        value: msg,
        writable: true
      });
      Object.defineProperty(err, "name", {
        enumerable: false,
        configurable: true,
        value: className,
        writable: true
      });
      return err;
    }
    inherits2(ServerError, HttpError);
    nameFunc(ServerError, className);
    ServerError.prototype.status = code2;
    ServerError.prototype.statusCode = code2;
    ServerError.prototype.expose = false;
    return ServerError;
  }
  function nameFunc(func, name2) {
    var desc = Object.getOwnPropertyDescriptor(func, "name");
    if (desc && desc.configurable) {
      desc.value = name2;
      Object.defineProperty(func, "name", desc);
    }
  }
  function populateConstructorExports(exports, codes2, HttpError) {
    codes2.forEach(function forEachCode(code2) {
      var CodeError;
      var name2 = toIdentifier2(statuses$1.message[code2]);
      switch (codeClass(code2)) {
        case 400:
          CodeError = createClientErrorConstructor(HttpError, name2, code2);
          break;
        case 500:
          CodeError = createServerErrorConstructor(HttpError, name2, code2);
          break;
      }
      if (CodeError) {
        exports[code2] = CodeError;
        exports[name2] = CodeError;
      }
    });
  }
  function toClassName(name2) {
    return name2.substr(-5) !== "Error" ? name2 + "Error" : name2;
  }
})(httpErrors);
var ApiGatewayContract = class {
  constructor(props) {
    __publicField(this, "contractType", "apiGateway");
    __publicField(this, "id");
    __publicField(this, "path");
    __publicField(this, "method");
    __publicField(this, "integrationType");
    __publicField(this, "authorizerType");
    __publicField(this, "pathParametersSchema");
    __publicField(this, "queryStringParametersSchema");
    __publicField(this, "headersSchema");
    __publicField(this, "requestContextSchema");
    __publicField(this, "bodySchema");
    __publicField(this, "outputSchema");
    __publicField(this, "inputSchema");
    this.id = props.id;
    this.path = props.path;
    this.method = props.method;
    this.integrationType = props.integrationType;
    this.authorizerType = props.authorizerType ?? void 0;
    this.pathParametersSchema = props.pathParametersSchema ?? void 0;
    this.queryStringParametersSchema = props.queryStringParametersSchema ?? void 0;
    this.headersSchema = props.headersSchema ?? void 0;
    this.requestContextSchema = props.requestContextSchema ?? void 0;
    this.bodySchema = props.bodySchema ?? void 0;
    this.outputSchema = props.outputSchema ?? void 0;
    this.inputSchema = this.getInputSchema();
  }
  getInputSchema() {
    const properties2 = omitBy3(
      {
        pathParameters: this.pathParametersSchema,
        queryStringParameters: this.queryStringParametersSchema,
        headers: this.headersSchema,
        requestContext: this.requestContextSchema,
        body: this.bodySchema
      },
      isUndefined3
    );
    return {
      type: "object",
      properties: properties2,
      required: Object.keys(properties2),
      additionalProperties: true
    };
  }
};
var fillPathTemplate = (template, values) => values === void 0 ? template : Object.entries(values).reduce((accumulator, [key, value]) => {
  const re2 = new RegExp(`{${key}}`, "g");
  return accumulator.replace(re2, value);
}, template);
var getRequestParameters = (contract, requestArguments) => {
  const { pathParameters, queryStringParameters, headers, body } = requestArguments;
  const path2 = typeof pathParameters !== "undefined" ? fillPathTemplate(contract.path, pathParameters) : contract.path;
  return omitBy3(
    {
      method: contract.method,
      path: path2,
      body,
      queryStringParameters: omitBy3(
        queryStringParameters,
        isUndefined3
      ),
      headers: { ...headers, "Content-Type": "application/json" }
    },
    isUndefined3
  );
};
var getAxiosRequest = async (contract, axiosClient, requestArguments) => {
  const { path: path2, method, queryStringParameters, body, headers } = getRequestParameters(contract, requestArguments);
  return axiosClient.request({
    method,
    url: path2,
    headers,
    data: body,
    params: queryStringParameters
  });
};
function bind(fn2, thisArg) {
  return function wrap2() {
    return fn2.apply(thisArg, arguments);
  };
}
const { toString: toString$2 } = Object.prototype;
const { getPrototypeOf: getPrototypeOf$1 } = Object;
const kindOf = /* @__PURE__ */ ((cache) => (thing) => {
  const str = toString$2.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
const kindOfTest = (type2) => {
  type2 = type2.toLowerCase();
  return (thing) => kindOf(thing) === type2;
};
const typeOfTest = (type2) => (thing) => typeof thing === type2;
const { isArray: isArray$1 } = Array;
const isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
const isString = typeOfTest("string");
const isFunction = typeOfTest("function");
const isNumber = typeOfTest("number");
const isObject = (thing) => thing !== null && typeof thing === "object";
const isBoolean = (thing) => thing === true || thing === false;
const isPlainObject$2 = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype2 = getPrototypeOf$1(val);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
const isDate = kindOfTest("Date");
const isFile = kindOfTest("File");
const isBlob = kindOfTest("Blob");
const isFileList = kindOfTest("FileList");
const isStream = (val) => isObject(val) && isFunction(val.pipe);
const isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
const isURLSearchParams = kindOfTest("URLSearchParams");
const [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
const trim$1 = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn2, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l2;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray$1(obj)) {
    for (i = 0, l2 = obj.length; i < l2; i++) {
      fn2.call(null, obj[i], i, obj);
    }
  } else {
    const keys2 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys2.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys2[i];
      fn2.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys2 = Object.keys(obj);
  let i = keys2.length;
  let _key;
  while (i-- > 0) {
    _key = keys2[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
const _global = (() => {
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : _global$1;
})();
const isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge$1() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue2 = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject$2(result[targetKey]) && isPlainObject$2(val)) {
      result[targetKey] = merge$1(result[targetKey], val);
    } else if (isPlainObject$2(val)) {
      result[targetKey] = merge$1({}, val);
    } else if (isArray$1(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l2 = arguments.length; i < l2; i++) {
    arguments[i] && forEach(arguments[i], assignValue2);
  }
  return result;
}
const extend$2 = (a2, b2, thisArg, { allOwnKeys } = {}) => {
  forEach(b2, (val, key) => {
    if (thisArg && isFunction(val)) {
      a2[key] = bind(val, thisArg);
    } else {
      a2[key] = val;
    }
  }, { allOwnKeys });
  return a2;
};
const stripBOM = (content2) => {
  if (content2.charCodeAt(0) === 65279) {
    content2 = content2.slice(1);
  }
  return content2;
};
const inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
const toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null) return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf$1(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
const endsWith = (str, searchString, position2) => {
  str = String(str);
  if (position2 === void 0 || position2 > str.length) {
    position2 = str.length;
  }
  position2 -= searchString.length;
  const lastIndex = str.indexOf(searchString, position2);
  return lastIndex !== -1 && lastIndex === position2;
};
const toArray$1 = (thing) => {
  if (!thing) return null;
  if (isArray$1(thing)) return thing;
  let i = thing.length;
  if (!isNumber(i)) return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};
const isTypedArray = /* @__PURE__ */ ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf$1(Uint8Array));
const forEachEntry = (obj, fn2) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn2.call(obj, pair[0], pair[1]);
  }
};
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
const isHTMLForm = kindOfTest("HTMLFormElement");
const toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m2, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
const hasOwnProperty$1 = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
const isRegExp = kindOfTest("RegExp");
const reduceDescriptors = (obj, reducer2) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name2) => {
    let ret;
    if ((ret = reducer2(descriptor, name2, obj)) !== false) {
      reducedDescriptors[name2] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name2) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name2) !== -1) {
      return false;
    }
    const value = obj[name2];
    if (!isFunction(value)) return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name2 + "'");
      };
    }
  });
};
const toObjectSet = (arrayOrString, delimiter2) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray$1(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter2));
  return obj;
};
const noop$1 = () => {
};
const toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};
const ALPHA = "abcdefghijklmnopqrstuvwxyz";
const DIGIT = "0123456789";
const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length: length2 } = alphabet;
  while (size--) {
    str += alphabet[Math.random() * length2 | 0];
  }
  return str;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
const toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit2 = (source, i) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i] = source;
        const target = isArray$1(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit2(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit2(obj, 0);
};
const isAsyncFn = kindOfTest("AsyncFunction");
const isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }
  return postMessageSupported ? ((token2, callbacks) => {
    _global.addEventListener("message", ({ source, data }) => {
      if (source === _global && data === token2) {
        callbacks.length && callbacks.shift()();
      }
    }, false);
    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token2, "*");
    };
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === "function",
  isFunction(_global.postMessage)
);
const asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
const utils$1 = {
  isArray: isArray$1,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject: isPlainObject$2,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge: merge$1,
  extend: extend$2,
  trim: trim$1,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray: toArray$1,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty: hasOwnProperty$1,
  hasOwnProp: hasOwnProperty$1,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop: noop$1,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap
};
function AxiosError(message, code2, config2, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code2 && (this.code = code2);
  config2 && (this.config = config2);
  request && (this.request = request);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}
utils$1.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils$1.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const prototype$1 = AxiosError.prototype;
const descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code2) => {
  descriptors[code2] = { value: code2 };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: true });
AxiosError.from = (error2, code2, config2, request, response, customProps) => {
  const axiosError = Object.create(prototype$1);
  utils$1.toFlatObject(error2, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error2.message, code2, config2, request, response);
  axiosError.cause = error2;
  axiosError.name = error2.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
const httpAdapter = null;
function isVisitable(thing) {
  return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
}
function removeBrackets(key) {
  return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path2, key, dots) {
  if (!path2) return key;
  return path2.concat(key).map(function each2(token2, i) {
    token2 = removeBrackets(token2);
    return !dots && i ? "[" + token2 + "]" : token2;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils$1.isArray(arr) && !arr.some(isVisitable);
}
const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils$1.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new FormData();
  options = utils$1.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils$1.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
  if (!utils$1.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null) return "";
    if (utils$1.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils$1.isBlob(value)) {
      throw new AxiosError("Blob is not supported. Use a Buffer instead.");
    }
    if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : buffer.Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path2) {
    let arr = value;
    if (value && !path2 && typeof value === "object") {
      if (utils$1.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each2(el, index2) {
          !(utils$1.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index2, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path2, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path2) {
    if (utils$1.isUndefined(value)) return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path2.join("."));
    }
    stack.push(value);
    utils$1.forEach(value, function each2(el, key) {
      const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils$1.isString(key) ? key.trim() : key,
        path2,
        exposedHelpers
      );
      if (result === true) {
        build(el, path2 ? path2.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils$1.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
function encode$1(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match2) {
    return charMap[match2];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData(params, this, options);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append2(name2, value) {
  this._pairs.push([name2, value]);
};
prototype.toString = function toString(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode$1);
  } : encode$1;
  return this._pairs.map(function each2(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode;
  if (utils$1.isFunction(options)) {
    options = {
      serialize: options
    };
  }
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id2) {
    if (this.handlers[id2]) {
      this.handlers[id2] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn2) {
    utils$1.forEach(this.handlers, function forEachHandler(h2) {
      if (h2 !== null) {
        fn2(h2);
      }
    });
  }
}
const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
const platform$1 = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
const _navigator = typeof navigator === "object" && navigator || void 0;
const hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
const hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
const origin = hasBrowserEnv && window.location.href || "http://localhost";
const utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv,
  hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv,
  navigator: _navigator,
  origin
}, Symbol.toStringTag, { value: "Module" }));
const platform = {
  ...utils,
  ...platform$1
};
function toURLEncodedForm(data, options) {
  return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path2, helpers) {
      if (platform.isNode && utils$1.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}
function parsePropPath(name2) {
  return utils$1.matchAll(/\w+|\[(\w*)]/g, name2).map((match2) => {
    return match2[0] === "[]" ? "" : match2[1] || match2[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys2 = Object.keys(arr);
  let i;
  const len = keys2.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys2[i];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path2, value, target, index2) {
    let name2 = path2[index2++];
    if (name2 === "__proto__") return true;
    const isNumericKey = Number.isFinite(+name2);
    const isLast = index2 >= path2.length;
    name2 = !name2 && utils$1.isArray(target) ? target.length : name2;
    if (isLast) {
      if (utils$1.hasOwnProp(target, name2)) {
        target[name2] = [target[name2], value];
      } else {
        target[name2] = value;
      }
      return !isNumericKey;
    }
    if (!target[name2] || !utils$1.isObject(target[name2])) {
      target[name2] = [];
    }
    const result = buildPath(path2, value, target[name2], index2);
    if (result && utils$1.isArray(target[name2])) {
      target[name2] = arrayToObject(target[name2]);
    }
    return !isNumericKey;
  }
  if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
    const obj = {};
    utils$1.forEachEntry(formData, (name2, value) => {
      buildPath(parsePropPath(name2), value, obj, 0);
    });
    return obj;
  }
  return null;
}
function stringifySafely(rawValue, parser, encoder) {
  if (utils$1.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$1.trim(rawValue);
    } catch (e2) {
      if (e2.name !== "SyntaxError") {
        throw e2;
      }
    }
  }
  return (0, JSON.stringify)(rawValue);
}
const defaults$1 = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils$1.isObject(data);
    if (isObjectPayload && utils$1.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils$1.isFormData(data);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }
    if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data) || utils$1.isReadableStream(data)) {
      return data;
    }
    if (utils$1.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils$1.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults$1.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {
      return data;
    }
    if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e2) {
        if (strictJSONParsing) {
          if (e2.name === "SyntaxError") {
            throw AxiosError.from(e2, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e2;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },
  validateStatus: function validateStatus(status2) {
    return status2 >= 200 && status2 < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults$1.headers[method] = {};
});
const ignoreDuplicateOf = utils$1.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
const parseHeaders = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line2) {
    i = line2.indexOf(":");
    key = line2.substring(0, i).trim().toLowerCase();
    val = line2.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};
const $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match2;
  while (match2 = tokensRE.exec(str)) {
    tokens[match2[1]] = match2[2];
  }
  return tokens;
}
const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils$1.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils$1.isString(value)) return;
  if (utils$1.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils$1.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char2, str) => {
    return char2.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils$1.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils$1.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else if (utils$1.isHeaders(header)) {
      for (const [key, value] of header.entries()) {
        setHeader(value, key, rewrite);
      }
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils$1.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils$1.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils$1.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils$1.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils$1.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils$1.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys2 = Object.keys(this);
    let i = keys2.length;
    let deleted = false;
    while (i--) {
      const key = keys2[i];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format2) {
    const self2 = this;
    const headers = {};
    utils$1.forEach(this, (value, header) => {
      const key = utils$1.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format2 ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils$1.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype2 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype2, _header);
        accessors[lHeader] = true;
      }
    }
    utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
}
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils$1.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils$1.freezeMethods(AxiosHeaders);
function transformData(fns, response) {
  const config2 = this || defaults$1;
  const context = response || config2;
  const headers = AxiosHeaders.from(context.headers);
  let data = context.data;
  utils$1.forEach(fns, function transform(fn2) {
    data = fn2.call(config2, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}
function CanceledError(message, config2, request) {
  AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config2, request);
  this.name = "CanceledError";
}
utils$1.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});
function settle(resolve2, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve2(response);
  } else {
    reject(new AxiosError(
      "Request failed with status code " + response.status,
      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}
function parseProtocol(url) {
  const match2 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match2 && match2[1] || "";
}
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push2(chunkLength) {
    const now2 = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now2;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now2;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now2 - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now2 - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
function throttle(fn2, freq) {
  let timestamp = 0;
  let threshold = 1e3 / freq;
  let lastArgs;
  let timer;
  const invoke = (args, now2 = Date.now()) => {
    timestamp = now2;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn2.apply(null, args);
  };
  const throttled = (...args) => {
    const now2 = Date.now();
    const passed = now2 - timestamp;
    if (passed >= threshold) {
      invoke(args, now2);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };
  const flush2 = () => lastArgs && invoke(lastArgs);
  return [throttled, flush2];
}
const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);
  return throttle((e2) => {
    const loaded = e2.loaded;
    const total = e2.lengthComputable ? e2.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e2,
      lengthComputable: total != null,
      [isDownloadStream ? "download" : "upload"]: true
    };
    listener(data);
  }, freq);
};
const progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;
  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};
const asyncDecorator = (fn2) => (...args) => utils$1.asap(() => fn2(...args));
const isURLSameOrigin = platform.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url) => {
  url = new URL(url, platform.origin);
  return origin2.protocol === url.protocol && origin2.host === url.host && (isMSIE || origin2.port === url.port);
})(
  new URL(platform.origin),
  platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)
) : () => true;
const cookies = platform.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name2, value, expires, path2, domain2, secure) {
      const cookie = [name2 + "=" + encodeURIComponent(value)];
      utils$1.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
      utils$1.isString(path2) && cookie.push("path=" + path2);
      utils$1.isString(domain2) && cookie.push("domain=" + domain2);
      secure === true && cookie.push("secure");
      document.cookie = cookie.join("; ");
    },
    read(name2) {
      const match2 = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
      return match2 ? decodeURIComponent(match2[3]) : null;
    },
    remove(name2) {
      this.write(name2, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
const headersToObject = (thing) => thing instanceof AxiosHeaders ? { ...thing } : thing;
function mergeConfig$1(config1, config2) {
  config2 = config2 || {};
  const config3 = {};
  function getMergedValue(target, source, prop, caseless) {
    if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
      return utils$1.merge.call({ caseless }, target, source);
    } else if (utils$1.isPlainObject(source)) {
      return utils$1.merge({}, source);
    } else if (utils$1.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a2, b2, prop, caseless) {
    if (!utils$1.isUndefined(b2)) {
      return getMergedValue(a2, b2, prop, caseless);
    } else if (!utils$1.isUndefined(a2)) {
      return getMergedValue(void 0, a2, prop, caseless);
    }
  }
  function valueFromConfig2(a2, b2) {
    if (!utils$1.isUndefined(b2)) {
      return getMergedValue(void 0, b2);
    }
  }
  function defaultToConfig2(a2, b2) {
    if (!utils$1.isUndefined(b2)) {
      return getMergedValue(void 0, b2);
    } else if (!utils$1.isUndefined(a2)) {
      return getMergedValue(void 0, a2);
    }
  }
  function mergeDirectKeys(a2, b2, prop) {
    if (prop in config2) {
      return getMergedValue(a2, b2);
    } else if (prop in config1) {
      return getMergedValue(void 0, a2);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a2, b2, prop) => mergeDeepProperties(headersToObject(a2), headersToObject(b2), prop, true)
  };
  utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config3[prop] = configValue);
  });
  return config3;
}
const resolveConfig = (config2) => {
  const newConfig = mergeConfig$1({}, config2);
  let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
  newConfig.headers = headers = AxiosHeaders.from(headers);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url), config2.params, config2.paramsSerializer);
  if (auth) {
    headers.set(
      "Authorization",
      "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
    );
  }
  let contentType;
  if (utils$1.isFormData(data)) {
    if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(void 0);
    } else if ((contentType = headers.getContentType()) !== false) {
      const [type2, ...tokens] = contentType ? contentType.split(";").map((token2) => token2.trim()).filter(Boolean) : [];
      headers.setContentType([type2 || "multipart/form-data", ...tokens].join("; "));
    }
  }
  if (platform.hasStandardBrowserEnv) {
    withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};
const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
const xhrAdapter = isXHRAdapterSupported && function(config2) {
  return new Promise(function dispatchXhrRequest(resolve2, reject) {
    const _config = resolveConfig(config2);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders.from(_config.headers).normalize();
    let { responseType, onUploadProgress, onDownloadProgress } = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;
    function done() {
      flushUpload && flushUpload();
      flushDownload && flushDownload();
      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
      _config.signal && _config.signal.removeEventListener("abort", onCanceled);
    }
    let request = new XMLHttpRequest();
    request.open(_config.method.toUpperCase(), _config.url, true);
    request.timeout = _config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config2,
        request
      };
      settle(function _resolve(value) {
        resolve2(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config2, request));
      request = null;
    };
    request.onerror = function handleError() {
      reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config2, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = _config.transitional || transitionalDefaults;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        config2,
        request
      ));
      request = null;
    };
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils$1.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = _config.responseType;
    }
    if (onDownloadProgress) {
      [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
      request.addEventListener("progress", downloadThrottled);
    }
    if (onUploadProgress && request.upload) {
      [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
      request.upload.addEventListener("progress", uploadThrottled);
      request.upload.addEventListener("loadend", flushUpload);
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError(null, config2, request) : cancel);
        request.abort();
        request = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(_config.url);
    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config2));
      return;
    }
    request.send(requestData || null);
  });
};
const composeSignals = (signals, timeout) => {
  const { length: length2 } = signals = signals ? signals.filter(Boolean) : [];
  if (timeout || length2) {
    let controller = new AbortController();
    let aborted;
    const onabort = function(reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof AxiosError ? err : new CanceledError(err instanceof Error ? err.message : err));
      }
    };
    let timer = timeout && setTimeout(() => {
      timer = null;
      onabort(new AxiosError(`timeout ${timeout} of ms exceeded`, AxiosError.ETIMEDOUT));
    }, timeout);
    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach((signal2) => {
          signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
        });
        signals = null;
      }
    };
    signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
    const { signal } = controller;
    signal.unsubscribe = () => utils$1.asap(unsubscribe);
    return signal;
  }
};
const streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end;
  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};
const readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
};
const readStream = async function* (stream) {
  if (stream[Symbol.asyncIterator]) {
    yield* stream;
    return;
  }
  const reader = stream.getReader();
  try {
    for (; ; ) {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
};
const trackStream = (stream, chunkSize, onProgress, onFinish) => {
  const iterator = readBytes(stream, chunkSize);
  let bytes = 0;
  let done;
  let _onFinish = (e2) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e2);
    }
  };
  return new ReadableStream({
    async pull(controller) {
      try {
        const { done: done2, value } = await iterator.next();
        if (done2) {
          _onFinish();
          controller.close();
          return;
        }
        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator.return();
    }
  }, {
    highWaterMark: 2
  });
};
const isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
const encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
const test = (fn2, ...args) => {
  try {
    return !!fn2(...args);
  } catch (e2) {
    return false;
  }
};
const supportsRequestStream = isReadableStreamSupported && test(() => {
  let duplexAccessed = false;
  const hasContentType = new Request(platform.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      duplexAccessed = true;
      return "half";
    }
  }).headers.has("Content-Type");
  return duplexAccessed && !hasContentType;
});
const DEFAULT_CHUNK_SIZE = 64 * 1024;
const supportsResponseStream = isReadableStreamSupported && test(() => utils$1.isReadableStream(new Response("").body));
const resolvers = {
  stream: supportsResponseStream && ((res) => res.body)
};
isFetchSupported && ((res) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type2) => {
    !resolvers[type2] && (resolvers[type2] = utils$1.isFunction(res[type2]) ? (res2) => res2[type2]() : (_2, config2) => {
      throw new AxiosError(`Response type '${type2}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config2);
    });
  });
})(new Response());
const getBodyLength = async (body) => {
  if (body == null) {
    return 0;
  }
  if (utils$1.isBlob(body)) {
    return body.size;
  }
  if (utils$1.isSpecCompliantForm(body)) {
    const _request = new Request(platform.origin, {
      method: "POST",
      body
    });
    return (await _request.arrayBuffer()).byteLength;
  }
  if (utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
    return body.byteLength;
  }
  if (utils$1.isURLSearchParams(body)) {
    body = body + "";
  }
  if (utils$1.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
};
const resolveBodyLength = async (headers, body) => {
  const length2 = utils$1.toFiniteNumber(headers.getContentLength());
  return length2 == null ? getBodyLength(body) : length2;
};
const fetchAdapter = isFetchSupported && (async (config2) => {
  let {
    url,
    method,
    data,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = "same-origin",
    fetchOptions
  } = resolveConfig(config2);
  responseType = responseType ? (responseType + "").toLowerCase() : "text";
  let composedSignal = composeSignals([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
  let request;
  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
    composedSignal.unsubscribe();
  });
  let requestContentLength;
  try {
    if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
      let _request = new Request(url, {
        method: "POST",
        body: data,
        duplex: "half"
      });
      let contentTypeHeader;
      if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
        headers.setContentType(contentTypeHeader);
      }
      if (_request.body) {
        const [onProgress, flush2] = progressEventDecorator(
          requestContentLength,
          progressEventReducer(asyncDecorator(onUploadProgress))
        );
        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush2);
      }
    }
    if (!utils$1.isString(withCredentials)) {
      withCredentials = withCredentials ? "include" : "omit";
    }
    const isCredentialsSupported = "credentials" in Request.prototype;
    request = new Request(url, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data,
      duplex: "half",
      credentials: isCredentialsSupported ? withCredentials : void 0
    });
    let response = await fetch(request);
    const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
    if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
      const options = {};
      ["status", "statusText", "headers"].forEach((prop) => {
        options[prop] = response[prop];
      });
      const responseContentLength = utils$1.toFiniteNumber(response.headers.get("content-length"));
      const [onProgress, flush2] = onDownloadProgress && progressEventDecorator(
        responseContentLength,
        progressEventReducer(asyncDecorator(onDownloadProgress), true)
      ) || [];
      response = new Response(
        trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
          flush2 && flush2();
          unsubscribe && unsubscribe();
        }),
        options
      );
    }
    responseType = responseType || "text";
    let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || "text"](response, config2);
    !isStreamResponse && unsubscribe && unsubscribe();
    return await new Promise((resolve2, reject) => {
      settle(resolve2, reject, {
        data: responseData,
        headers: AxiosHeaders.from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config: config2,
        request
      });
    });
  } catch (err) {
    unsubscribe && unsubscribe();
    if (err && err.name === "TypeError" && /fetch/i.test(err.message)) {
      throw Object.assign(
        new AxiosError("Network Error", AxiosError.ERR_NETWORK, config2, request),
        {
          cause: err.cause || err
        }
      );
    }
    throw AxiosError.from(err, err && err.code, config2, request);
  }
});
const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter,
  fetch: fetchAdapter
};
utils$1.forEach(knownAdapters, (fn2, value) => {
  if (fn2) {
    try {
      Object.defineProperty(fn2, "name", { value });
    } catch (e2) {
    }
    Object.defineProperty(fn2, "adapterName", { value });
  }
});
const renderReason = (reason) => `- ${reason}`;
const isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
const adapters = {
  getAdapter: (adapters2) => {
    adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
    const { length: length2 } = adapters2;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i = 0; i < length2; i++) {
      nameOrAdapter = adapters2[i];
      let id2;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id2 = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError(`Unknown adapter '${id2}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id2 || "#" + i] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id2, state]) => `adapter ${id2} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s2 = length2 ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError(
        `There is no suitable adapter to dispatch the request ` + s2,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  },
  adapters: knownAdapters
};
function throwIfCancellationRequested(config2) {
  if (config2.cancelToken) {
    config2.cancelToken.throwIfRequested();
  }
  if (config2.signal && config2.signal.aborted) {
    throw new CanceledError(null, config2);
  }
}
function dispatchRequest(config2) {
  throwIfCancellationRequested(config2);
  config2.headers = AxiosHeaders.from(config2.headers);
  config2.data = transformData.call(
    config2,
    config2.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config2.method) !== -1) {
    config2.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters.getAdapter(config2.adapter || defaults$1.adapter);
  return adapter(config2).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config2);
    response.data = transformData.call(
      config2,
      config2.transformResponse,
      response
    );
    response.headers = AxiosHeaders.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config2);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config2,
          config2.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}
const VERSION = "1.7.9";
const validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type2, i) => {
  validators$1[type2] = function validator2(thing) {
    return typeof thing === type2 || "a" + (i < 1 ? "n " : " ") + type2;
  };
});
const deprecatedWarnings = {};
validators$1.transitional = function transitional(validator2, version, message) {
  function formatMessage2(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator2 === false) {
      throw new AxiosError(
        formatMessage2(opt, " has been removed" + (version ? " in " + version : "")),
        AxiosError.ERR_DEPRECATED
      );
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage2(
          opt,
          " has been deprecated since v" + version + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
validators$1.spelling = function spelling(correctSpelling) {
  return (value, opt) => {
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys2 = Object.keys(options);
  let i = keys2.length;
  while (i-- > 0) {
    const opt = keys2[i];
    const validator2 = schema[opt];
    if (validator2) {
      const value = options[opt];
      const result = value === void 0 || validator2(value, opt, options);
      if (result !== true) {
        throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}
const validator = {
  assertOptions,
  validators: validators$1
};
const validators = validator.validators;
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config2) {
    try {
      return await this._request(configOrUrl, config2);
    } catch (err) {
      if (err instanceof Error) {
        let dummy = {};
        Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err.stack) {
            err.stack = stack;
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
            err.stack += "\n" + stack;
          }
        } catch (e2) {
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config2) {
    if (typeof configOrUrl === "string") {
      config2 = config2 || {};
      config2.url = configOrUrl;
    } else {
      config2 = configOrUrl || {};
    }
    config2 = mergeConfig$1(this.defaults, config2);
    const { transitional: transitional2, paramsSerializer, headers } = config2;
    if (transitional2 !== void 0) {
      validator.assertOptions(transitional2, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils$1.isFunction(paramsSerializer)) {
        config2.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }
    validator.assertOptions(config2, {
      baseUrl: validators.spelling("baseURL"),
      withXsrfToken: validators.spelling("withXSRFToken")
    }, true);
    config2.method = (config2.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils$1.merge(
      headers.common,
      headers[config2.method]
    );
    headers && utils$1.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config2.headers = AxiosHeaders.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config2);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config2;
    i = 0;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error2) {
        onRejected.call(this, error2);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error2) {
      return Promise.reject(error2);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config2) {
    config2 = mergeConfig$1(this.defaults, config2);
    const fullPath = buildFullPath(config2.baseURL, config2.url);
    return buildURL(fullPath, config2.params, config2.paramsSerializer);
  }
}
utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url, config2) {
    return this.request(mergeConfig$1(config2 || {}, {
      method,
      url,
      data: (config2 || {}).data
    }));
  };
});
utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config2) {
      return this.request(mergeConfig$1(config2 || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
class CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve2) {
      resolvePromise = resolve2;
    });
    const token2 = this;
    this.promise.then((cancel) => {
      if (!token2._listeners) return;
      let i = token2._listeners.length;
      while (i-- > 0) {
        token2._listeners[i](cancel);
      }
      token2._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve2) => {
        token2.subscribe(resolve2);
        _resolve = resolve2;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token2.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config2, request) {
      if (token2.reason) {
        return;
      }
      token2.reason = new CanceledError(message, config2, request);
      resolvePromise(token2.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index2 = this._listeners.indexOf(listener);
    if (index2 !== -1) {
      this._listeners.splice(index2, 1);
    }
  }
  toAbortSignal() {
    const controller = new AbortController();
    const abort = (err) => {
      controller.abort(err);
    };
    this.subscribe(abort);
    controller.signal.unsubscribe = () => this.unsubscribe(abort);
    return controller.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token2 = new CancelToken(function executor(c6) {
      cancel = c6;
    });
    return {
      token: token2,
      cancel
    };
  }
}
function spread(callback) {
  return function wrap2(arr) {
    return callback.apply(null, arr);
  };
}
function isAxiosError(payload) {
  return utils$1.isObject(payload) && payload.isAxiosError === true;
}
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
function createInstance(defaultConfig) {
  const context = new Axios(defaultConfig);
  const instance = bind(Axios.prototype.request, context);
  utils$1.extend(instance, Axios.prototype, context, { allOwnKeys: true });
  utils$1.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create3(instanceConfig) {
    return createInstance(mergeConfig$1(defaultConfig, instanceConfig));
  };
  return instance;
}
const axios = createInstance(defaults$1);
axios.Axios = Axios;
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData;
axios.AxiosError = AxiosError;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig$1;
axios.AxiosHeaders = AxiosHeaders;
axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters.getAdapter;
axios.HttpStatusCode = HttpStatusCode;
axios.default = axios;
var recommendationSchema = {
  type: "object",
  required: ["pageContent", "metadata"],
  properties: {
    pageContent: {
      type: "string"
    },
    metadata: {
      type: "object",
      required: ["variantId"],
      properties: {
        stock: {
          type: "number"
        },
        price: {
          type: "number"
        },
        handle: {
          type: "string"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        mediaUrl: {
          type: "string"
        },
        variantId: {
          type: "string"
        }
      }
    }
  }
};
var messageSchema = {
  type: "object",
  properties: {
    created: {
      type: "string"
    },
    messageId: {
      type: "string"
    },
    text: {
      type: "string"
    },
    type: {
      type: "string",
      "enum": ["human", "ai"]
    },
    recommendations: {
      type: "array",
      items: recommendationSchema
    },
    pictureUrl: {
      type: "string"
    }
  },
  required: ["text", "type", "messageId", "created"]
};
var getChatHistoryContract = new ApiGatewayContract({
  id: "post-message",
  path: "/ai/chat-history/{userId}",
  method: "GET",
  integrationType: "httpApi",
  authorizerType: "lambda",
  pathParametersSchema: {
    type: "object",
    properties: {
      userId: {
        type: "string"
      }
    },
    required: ["userId"]
  },
  outputSchema: {
    type: "array",
    items: messageSchema
  }
});
var QUESTION_TOO_LONG = "QUESTION_TOO_LONG";
var ANSWER_TOO_LONG = "ANSWER_TOO_LONG";
var MAX_WORDS_PER_QUESTION = 800;
var MAX_CHARACTERS_PER_QUESTION = 5e3;
var MAX_WORDS_PER_ANSWER = 100;
var MAX_CHARACTERS_PER_ANSWER = 500;
var Features = /* @__PURE__ */ function(Features2) {
  Features2["FEEDBACKS"] = "feedbacks";
  Features2["PRODUCT_CARD"] = "productCard";
  Features2["RECOMMENDATIONS"] = "recommendations";
  Features2["SUGGESTIONS"] = "suggestions";
  Features2["ADD_TO_CART"] = "addToCart";
  Features2["DIAGNOSTIC"] = "diagnostic";
  return Features2;
}({});
var textTranslationsSchema = {
  type: "object",
  patternProperties: {
    "[a-z]*": {
      type: "string"
    }
  },
  additionalProperties: false
};
function ownKeys$1(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e2);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$1(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$1(Object(t2), true).forEach(function(r3) {
      _defineProperty$1(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$1(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
var EUR_CURRENCY_CODE = "EUR";
var USD_CURRENCY_CODE = "USD";
var CAD_CURRENCY_CODE = "CAD";
var GBP_CURRENCY_CODE = "GBP";
var currenciesCode = [EUR_CURRENCY_CODE, USD_CURRENCY_CODE, CAD_CURRENCY_CODE, GBP_CURRENCY_CODE];
var ACTIVE_STATUS = "ACTIVE";
var ARCHIVED_STATUS = "ARCHIVED";
var DRAFT_STATUS = "DRAFT";
var STATUS = [ACTIVE_STATUS, ARCHIVED_STATUS, DRAFT_STATUS];
var translationsSchema = {
  type: "object",
  additionalProperties: false,
  properties: {
    key: {
      type: "string"
    },
    value: {
      type: "string"
    }
  },
  required: ["key", "value"]
};
var collectionSchema = {
  type: "object",
  additionalProperties: false,
  required: ["id", "__parentId"],
  properties: {
    description: {
      type: "string"
    },
    title: {
      type: "string"
    },
    id: {
      type: ["string"]
    },
    __parentId: {
      type: "string"
    }
  }
};
var variantPricingSchema = {
  type: "object",
  properties: {
    price: {
      type: "object",
      properties: {
        amount: {
          type: ["string", "number"]
        },
        currencyCode: {
          type: "string",
          "enum": currenciesCode
        }
      },
      required: ["amount"]
    },
    compareAtPrice: {
      type: "object",
      nullable: true,
      required: ["amount", "currencyCode"],
      properties: {
        amount: {
          type: ["string"]
        },
        currencyCode: {
          type: "string",
          "enum": currenciesCode
        }
      }
    }
  },
  required: []
};
var metafieldSchema = {
  type: "object",
  additionalProperties: false,
  properties: {
    id: {
      type: "string"
    },
    key: {
      type: "string"
    },
    type: {
      type: "string"
    },
    value: {
      type: "string"
    },
    __parentId: {
      type: "string"
    }
  },
  required: ["key", "value", "id", "__parentId"]
};
var commonVariantProperties = {
  id: {
    type: "string"
  },
  title: {
    type: "string"
  },
  inventoryPolicy: {
    type: "string",
    "enum": ["DENY", "CONTINUE"]
  },
  selectedOptions: {
    type: "array",
    items: {
      type: "object",
      properties: {
        name: {
          type: "string"
        },
        value: {
          type: "string"
        }
      },
      required: ["name", "value"]
    }
  },
  metafields: {
    type: "array",
    items: _objectSpread$1(_objectSpread$1({}, metafieldSchema), {}, {
      required: ["key", "value", "id", "__parentId"]
    })
  },
  displayName: {
    type: "string"
  },
  __parentId: {
    type: "string"
  },
  image: {
    anyOf: [{
      type: "object",
      required: ["url"],
      properties: {
        url: {
          type: "string"
        }
      }
    }, {
      type: "null"
    }]
  },
  inventoryQuantity: {
    type: "number"
  },
  price: {
    type: "string"
  },
  compareAtPrice: {
    type: "string",
    nullable: true
  }
};
var variantSchema = {
  type: "object",
  additionalProperties: false,
  properties: _objectSpread$1(_objectSpread$1({}, commonVariantProperties), {}, {
    __parentId: {
      type: "string"
    }
  }),
  required: ["id", "__parentId", "inventoryPolicy"]
};
var variantShopifySchema = _objectSpread$1(_objectSpread$1({}, variantSchema), {}, {
  properties: _objectSpread$1(_objectSpread$1({}, commonVariantProperties), {}, {
    translations: {
      type: "array",
      items: translationsSchema
    },
    currencyCode: {
      type: "string",
      "enum": currenciesCode
    }
  }),
  additionalProperties: true,
  required: variantSchema.required
});
var variantGQLSchema = _objectSpread$1(_objectSpread$1({}, variantSchema), {}, {
  additionalProperties: true,
  required: variantSchema.required,
  properties: _objectSpread$1(_objectSpread$1({}, variantShopifySchema.properties), {}, {
    contextualPricing: variantPricingSchema,
    metafields: {
      type: "object",
      additionalProperties: false,
      properties: {
        edges: {
          additionalProperties: false,
          type: "array",
          items: {
            type: "object",
            properties: {
              node: metafieldSchema
            }
          }
        }
      }
    },
    translations: {
      type: "array",
      items: translationsSchema
    }
  })
});
var optionSchema = {
  type: "object",
  additionalProperties: false,
  properties: {
    id: {
      type: "string"
    },
    name: {
      type: "string"
    },
    values: {
      type: "array",
      items: {
        type: "string"
      }
    },
    position: {
      type: "number"
    },
    translations: {
      type: "array",
      items: translationsSchema
    }
  },
  required: ["id", "name", "values", "position"]
};
var optionShopifySchema = {
  type: "object",
  properties: _objectSpread$1(_objectSpread$1({}, optionSchema.properties), {}, {
    translations: {
      type: "array",
      items: translationsSchema
    }
  }),
  required: _toConsumableArray(optionSchema.required)
};
var productSchema = {
  type: "object",
  additionalProperties: false,
  properties: {
    description: {
      type: "string"
    },
    priceRange: {
      type: "object",
      required: ["maxVariantPrice", "minVariantPrice"],
      properties: {
        maxVariantPrice: {
          type: "object",
          properties: {
            amount: {
              type: "string"
            },
            currencyCode: {
              type: "string"
            }
          },
          required: ["amount", "currencyCode"]
        },
        minVariantPrice: {
          type: "object",
          properties: {
            amount: {
              type: "string"
            },
            currencyCode: {
              type: "string"
            }
          },
          required: ["amount", "currencyCode"]
        }
      }
    },
    descriptionHtml: {
      type: "string"
    },
    title: {
      type: "string"
    },
    tags: {
      type: "array",
      items: {
        type: "string"
      }
    },
    publishedAt: {
      type: ["string", "null"]
    },
    featuredImage: {
      anyOf: [{
        type: "object",
        properties: {
          url: {
            type: "string"
          }
        },
        required: ["url"]
      }, {
        type: "null"
      }]
    },
    handle: {
      type: "string"
    },
    id: {
      type: "string"
    },
    totalInventory: {
      type: "number"
    },
    tracksInventory: {
      type: "boolean"
    },
    hasOnlyDefaultVariant: {
      type: "boolean"
    },
    totalVariants: {
      type: "number"
    },
    productType: {
      type: "string"
    },
    status: {
      type: "string",
      "enum": STATUS
    },
    options: {
      type: "array",
      items: optionSchema
    },
    metadata: {
      type: "array",
      items: metafieldSchema
    },
    collections: {
      type: "array",
      items: collectionSchema
    },
    variants: {
      type: "array",
      items: variantSchema
    }
  },
  required: ["id", "handle", "totalVariants", "variants", "publishedAt", "title", "totalInventory", "hasOnlyDefaultVariant", "status"]
};
({
  type: "object",
  additionalProperties: false,
  required: _toConsumableArray(productSchema.required),
  properties: _objectSpread$1(_objectSpread$1({}, productSchema.properties), {}, {
    options: {
      type: "array",
      items: optionShopifySchema
    },
    variants: {
      type: "array",
      items: variantShopifySchema
    },
    metadata: {
      type: "array",
      items: metafieldSchema
    },
    translations: {
      type: "array",
      items: translationsSchema
    }
  })
});
({
  type: "object",
  additionalProperties: false,
  required: productSchema.required,
  properties: _objectSpread$1(_objectSpread$1({}, productSchema.properties), {}, {
    variantsCount: {
      type: "object",
      properties: {
        count: {
          type: "number"
        }
      },
      required: ["count"],
      additionalProperties: false
    },
    translations: {
      type: "array",
      items: translationsSchema
    },
    collections: {
      type: "object",
      properties: {
        edges: {
          type: "array",
          items: {
            type: "object",
            properties: {
              node: collectionSchema
            },
            additionalProperties: false
          }
        }
      }
    },
    metafields: {
      type: "object",
      additionalProperties: false,
      properties: {
        edges: {
          additionalProperties: false,
          type: "array",
          items: {
            type: "object",
            properties: {
              node: metafieldSchema
            }
          }
        }
      }
    },
    variants: {
      type: "object",
      required: ["edges"],
      properties: {
        edges: {
          type: "array",
          items: {
            type: "object",
            properties: {
              node: variantGQLSchema
            },
            required: ["node"],
            additionalProperties: false
          }
        }
      }
    }
  })
});
var modalProductQuestionSchema = {
  type: "object",
  properties: {
    question: textTranslationsSchema,
    answer: textTranslationsSchema
  },
  required: ["question"]
};
var productQuestionSchema = {
  type: "object",
  properties: {
    question: {
      type: "string"
    },
    answer: {
      type: "string"
    }
  },
  required: ["question"],
  additionalProperties: false
};
var textTranslation = {
  type: "object",
  patternProperties: {
    "[a-z]*": {
      type: "string"
    }
  },
  additionalProperties: false
};
var AddToCartIcons = /* @__PURE__ */ function(AddToCartIcons2) {
  AddToCartIcons2["CART"] = "cart";
  AddToCartIcons2["BAG"] = "bag";
  return AddToCartIcons2;
}({});
({
  type: "object",
  properties: {
    addToCartIcon: {
      type: "string",
      "enum": Object.values(AddToCartIcons),
      "default": AddToCartIcons.CART
    },
    bookmarkLogoUrl: {
      type: "string"
    },
    assistantNameTranslations: textTranslation,
    assistantDescriptionTranslations: textTranslation,
    dialogInputPlaceholderTranslations: textTranslation,
    disclaimerName: {
      type: "string"
    }
  },
  additionalProperties: false
});
function ownKeys(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e2);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys(Object(t2), true).forEach(function(r3) {
      _defineProperty$1(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
var SCROLL_EVENT = "scroll";
var INSTANT_EVENT = "instant";
var ON_LOAD_EVENT = "load";
var modalEvents$1 = [SCROLL_EVENT, ON_LOAD_EVENT, INSTANT_EVENT];
var modalConfigSchema = {
  type: "object",
  properties: {
    organizationSlug: {
      type: "string"
    },
    id: {
      type: "string"
    },
    duration: {
      type: "number"
    },
    events: {
      type: "array",
      items: {
        type: "string",
        "enum": modalEvents$1
      }
    },
    location: {
      type: "string",
      value: "*"
    },
    suggestions: {
      type: "array",
      items: modalProductQuestionSchema
    },
    assistantName: {
      type: "string"
    },
    description: {
      type: "string"
    },
    inputPlaceholder: {
      type: "string"
    }
  },
  required: ["id", "organizationSlug", "events"]
};
({
  type: "object",
  required: modalConfigSchema.required,
  properties: _objectSpread(_objectSpread({}, modalConfigSchema.properties), {}, {
    displayPoweredByDialog: {
      type: "boolean"
    },
    initialAssistantMessage: {
      type: "string"
    }
  })
});
var dialogConfigSchema = {
  type: "object",
  required: ["modalTriggers", "displayPoweredByDialog"],
  properties: {
    modalTriggers: {
      type: "array",
      items: modalConfigSchema
    },
    displayPoweredByDialog: {
      type: "boolean"
    },
    initialAssistantMessage: {
      type: "string"
    },
    bookmarkLogoUrl: {
      type: "string"
    },
    disclaimerName: {
      type: "string"
    },
    disabledFeatures: {
      type: "array",
      items: {
        type: "string",
        "enum": Object.values(Features)
      }
    },
    addToCartIcon: {
      type: "string",
      "enum": Object.values(AddToCartIcons),
      "default": AddToCartIcons.CART
    }
  }
};
var streamMessageBodySchema = {
  type: "object",
  properties: {
    message: {
      type: "string"
    },
    messageId: {
      type: "string"
    },
    fromQuestionSuggestion: {
      type: "boolean"
    },
    userId: {
      type: "string"
    },
    sessionId: {
      type: "string"
    },
    title: {
      type: "string"
    },
    handle: {
      type: "string"
    },
    variantId: {
      type: "string"
    },
    language: {
      type: "string"
    },
    locale: {
      type: "string"
    },
    countryCode: {
      type: "string"
    },
    analyticsId: {
      type: "string"
    }
  },
  required: ["message", "sessionId", "userId", "messageId", "language", "locale", "countryCode"]
};
var streamMessageContract = new ApiGatewayContract({
  id: "stream-message",
  path: "/ai/stream-message",
  method: "POST",
  integrationType: "httpApi",
  authorizerType: "lambda",
  headersSchema: {
    type: "object",
    properties: {
      "x-dialog-ref": {
        type: "string"
      }
    }
  },
  bodySchema: streamMessageBodySchema
});
var outputSchema = {
  type: "object",
  properties: {
    assistantName: {
      type: "string"
    },
    description: {
      type: "string"
    },
    inputPlaceholder: {
      type: "string"
    },
    questions: {
      type: "array",
      items: productQuestionSchema
    }
  },
  additionalProperties: false,
  required: ["questions"]
};
var legacyOutputSchema = {
  type: "array",
  items: productQuestionSchema
};
var getProductPageQuestionsByIdContract = new ApiGatewayContract({
  method: "GET",
  integrationType: "httpApi",
  authorizerType: "lambda",
  requestContextSchema: {
    type: "object",
    properties: {
      authorizer: {
        type: "object",
        properties: {
          lambda: {
            type: "object",
            properties: {
              organizationSlug: {
                type: "string"
              }
            },
            required: ["organizationSlug"]
          }
        },
        required: []
      }
    },
    required: []
  },
  queryStringParametersSchema: {
    type: "object",
    properties: {
      pagePath: {
        type: "string"
      },
      locale: {
        type: "string"
      },
      productId: {
        type: "string"
      }
    },
    required: []
  },
  outputSchema: {
    anyOf: [outputSchema, legacyOutputSchema]
  },
  id: "get-product-questions-assistant",
  path: "/ai/product-questions"
});
var saveQuestionWithAnswerContract = new ApiGatewayContract({
  id: "save-message-with-answer",
  path: "/save-message",
  method: "POST",
  integrationType: "httpApi",
  authorizerType: "lambda",
  outputSchema: {
    type: "object",
    properties: {
      messageId: {
        type: "string"
      }
    },
    required: ["messageId"]
  },
  bodySchema: {
    type: "object",
    properties: {
      question: {
        type: "string"
      },
      answer: {
        type: "string"
      },
      sessionId: {
        type: "string"
      },
      userId: {
        type: "string"
      },
      messageId: {
        type: "string"
      },
      countryCode: {
        type: "string"
      }
    },
    required: ["question", "sessionId", "messageId", "answer", "userId", "countryCode"]
  }
});
var SKIP_ANSWER = "skipped";
var saveAnswerQualificationQuestionContract = new ApiGatewayContract({
  id: "save-answer-qualification-question",
  path: "/save-answer-qualification-question",
  method: "POST",
  integrationType: "httpApi",
  authorizerType: "lambda",
  bodySchema: {
    type: "object",
    properties: {
      aiMessageId: {
        type: "string"
      },
      answer: {
        type: "string"
      },
      sessionId: {
        type: "string"
      },
      userId: {
        type: "string"
      },
      language: {
        type: "string"
      },
      locale: {
        type: "string"
      },
      countryCode: {
        type: "string"
      }
    },
    required: ["answer", "aiMessageId", "sessionId", "userId", "language", "locale", "countryCode"]
  }
});
var getDialogConfigContract = new ApiGatewayContract({
  id: "get-modal-contract",
  path: "/ai/dialog-config",
  method: "GET",
  queryStringParametersSchema: {
    type: "object",
    properties: {
      locale: {
        type: "string"
      }
    },
    required: ["locale"],
    additionalProperties: false
  },
  integrationType: "httpApi",
  authorizerType: "lambda",
  outputSchema: dialogConfigSchema
});
var sendFeedbackContract = new ApiGatewayContract({
  id: "send-feedback",
  path: "/ai/feedback",
  method: "POST",
  integrationType: "httpApi",
  authorizerType: "lambda",
  bodySchema: {
    type: "object",
    properties: {
      value: {
        type: "number"
      },
      messageId: {
        type: "string"
      },
      userId: {
        type: "string"
      },
      sessionId: {
        type: "string"
      }
    },
    additionalProperties: false,
    required: ["value", "userId", "sessionId", "messageId"]
  },
  outputSchema: void 0
});
var presignedPostSchema = {
  type: "object",
  properties: {
    url: {
      type: "string"
    },
    fields: {
      type: "object",
      required: [],
      additionalProperties: true
    }
  },
  required: ["url"],
  additionalProperties: false
};
var uploadPictureUrlSchema = {
  type: "object",
  properties: {
    pngUploadUrl: presignedPostSchema,
    jpgUploadUrl: presignedPostSchema
  },
  required: ["pngUploadUrl", "jpgUploadUrl"],
  additionalProperties: false
};
var getDiagnosticPictureUrlQueryStringParametersSchema = {
  type: "object",
  properties: {
    userId: {
      type: "string"
    },
    sessionId: {
      type: "string"
    },
    language: {
      type: "string"
    },
    locale: {
      type: "string"
    },
    countryCode: {
      type: "string"
    }
  },
  required: ["userId", "sessionId", "language", "locale", "countryCode"],
  additionalProperties: false
};
var getDiagnosticPictureUrlContract = new ApiGatewayContract({
  id: "get-diagnostic-picture-url",
  path: "/ai/diagnosticPictureUrl",
  method: "GET",
  integrationType: "httpApi",
  queryStringParametersSchema: getDiagnosticPictureUrlQueryStringParametersSchema,
  authorizerType: "lambda",
  outputSchema: uploadPictureUrlSchema
});
var diagnosticMessageBodySchema = {
  type: "object",
  properties: {
    message: {
      type: "string"
    },
    userId: {
      type: "string"
    },
    sessionId: {
      type: "string"
    },
    language: {
      type: "string"
    },
    locale: {
      type: "string"
    },
    countryCode: {
      type: "string"
    },
    messageId: {
      type: "string"
    }
  },
  required: ["userId", "sessionId", "message", "language", "locale", "countryCode", "messageId"],
  additionalProperties: false
};
var diagnosticMessageContract = new ApiGatewayContract({
  id: "diagnostic-message",
  path: "/ai/diagnostic-message",
  method: "POST",
  integrationType: "httpApi",
  bodySchema: diagnosticMessageBodySchema,
  authorizerType: "lambda"
});
var AI_TOKEN_TOPIC = "AI_TOKEN_TOPIC";
var RECOMMENDATION_TOPIC = "RECOMMENDATION_TOPIC";
var ANSWER_SUGGESTIONS_TOPIC = "ANSWER_SUGGESTIONS_TOPIC";
var QUALIFICATION_TOPIC = "QUALIFICATION_TOPIC";
var STATES_TOPIC = "STATES_TOPIC";
const baseApiUrl = "https://rtbzcxkmwj.execute-api.eu-west-1.amazonaws.com";
axios.create({
  baseURL: baseApiUrl
});
const createAuthClientByApiKey = (apiKey2) => {
  return axios.create({
    baseURL: baseApiUrl,
    headers: {
      Authorization: `${apiKey2}`
    }
  });
};
const getMessagesAI = async ({
  userId: userId2,
  apiKey: apiKey2
}) => {
  const client = createAuthClientByApiKey(apiKey2);
  if (apiKey2 === "a00906a2-0f3e-4be6-94fa-d1aa08f50bb5") {
    const response2 = await client.get(`user-chat-history/${userId2}`);
    return response2.data;
  }
  const response = await getAxiosRequest(
    getChatHistoryContract,
    client,
    {
      pathParameters: { userId: userId2 }
    }
  );
  return response.data;
};
const saveQuestionWithAnswer = async ({
  apiKey: apiKey2,
  sessionId,
  userId: userId2,
  messageId,
  question,
  answer,
  countryCode: countryCode2
}) => {
  const response = await getAxiosRequest(
    saveQuestionWithAnswerContract,
    createAuthClientByApiKey(apiKey2),
    {
      body: {
        userId: userId2,
        sessionId,
        question,
        messageId,
        answer,
        countryCode: countryCode2
      }
    }
  );
  return response.data.messageId;
};
const sendDiagnosticMessage = async ({
  apiKey: apiKey2,
  userId: userId2,
  sessionId,
  language: language2,
  locale: locale2,
  countryCode: countryCode2,
  message,
  messageId
}) => {
  await getAxiosRequest(
    diagnosticMessageContract,
    createAuthClientByApiKey(apiKey2),
    {
      body: {
        messageId,
        userId: userId2,
        sessionId,
        message,
        language: language2,
        locale: locale2,
        countryCode: countryCode2
      }
    }
  );
};
const sendMessageStream = async ({
  apiKey: apiKey2,
  sessionId,
  userId: userId2,
  messageId,
  message,
  language: language2,
  locale: locale2,
  countryCode: countryCode2,
  title: title2,
  handle: handle2,
  variantId,
  analyticsId,
  fromQuestionSuggestion
}) => {
  const client = createAuthClientByApiKey(apiKey2);
  if (apiKey2 === "a00906a2-0f3e-4be6-94fa-d1aa08f50bb5") {
    await client.post("assistant-test", {
      userId: userId2,
      message,
      sessionId,
      countryCode: "FR",
      language: "fr",
      locale: "fr-FR",
      messageId
    });
    return;
  }
  const response = await getAxiosRequest(
    streamMessageContract,
    client,
    {
      headers: {
        "x-dialog-ref": document.location.href
      },
      body: {
        userId: userId2,
        sessionId,
        message,
        language: language2,
        locale: locale2,
        countryCode: countryCode2,
        messageId,
        title: title2,
        handle: handle2,
        variantId,
        analyticsId,
        fromQuestionSuggestion
      }
    }
  );
  return response.data;
};
const getProductPageQuestions = async ({
  apiKey: apiKey2,
  pagePath,
  locale: locale2,
  productId
}) => {
  const response = await getAxiosRequest(getProductPageQuestionsByIdContract, createAuthClientByApiKey(apiKey2), {
    queryStringParameters: { pagePath, locale: locale2, productId }
  });
  return response.data;
};
const getDialogConfig = async ({
  apiKey: apiKey2,
  locale: locale2
}) => {
  const response = await getAxiosRequest(
    getDialogConfigContract,
    createAuthClientByApiKey(apiKey2),
    {
      queryStringParameters: { locale: locale2 }
    }
  );
  return response.data;
};
const saveAnswerQualificationQuestion = async ({
  apiKey: apiKey2,
  aiMessageId,
  answer,
  userId: userId2,
  sessionId,
  language: language2,
  locale: locale2,
  countryCode: countryCode2
}) => {
  await getAxiosRequest(
    saveAnswerQualificationQuestionContract,
    createAuthClientByApiKey(apiKey2),
    {
      body: {
        language: language2,
        locale: locale2,
        countryCode: countryCode2,
        aiMessageId,
        answer,
        sessionId,
        userId: userId2
      }
    }
  );
};
const sendFeedback = async ({
  apiKey: apiKey2,
  userId: userId2,
  sessionId,
  messageId,
  value
}) => {
  const response = await getAxiosRequest(
    sendFeedbackContract,
    createAuthClientByApiKey(apiKey2),
    {
      body: { value, userId: userId2, sessionId, messageId }
    }
  );
  return response.data;
};
const getDiagnosticPictureUrl = async ({
  apiKey: apiKey2,
  userId: userId2,
  sessionId,
  language: language2,
  locale: locale2,
  countryCode: countryCode2
}) => {
  const response = await getAxiosRequest(getDiagnosticPictureUrlContract, createAuthClientByApiKey(apiKey2), {
    queryStringParameters: {
      userId: userId2,
      sessionId,
      language: language2,
      locale: locale2,
      countryCode: countryCode2
    }
  });
  return response.data;
};
const PICTURE_SIZE_LIMIT = 5e6;
const isUnderPictureLimitSize = (size) => size !== void 0 && size <= PICTURE_SIZE_LIMIT;
const uploadPicture = async ({
  path: path2,
  file,
  fields
}) => {
  if (!isUnderPictureLimitSize(file.size)) {
    throw new Error("EntityTooLarge");
  }
  const formData = new FormData();
  formData.append("Content-Type", file.type);
  if (fields !== void 0) {
    Object.keys(fields).forEach((key) => {
      formData.append(key, fields[key]);
    });
  }
  formData.append("file", file);
  await axios({
    method: "POST",
    data: formData,
    url: path2
  });
  return { status: "success" };
};
const makeDefaultCartRequest = async (urlShop, quantity, variantId) => {
  const response = await axios.post(
    `${urlShop}/cart/add.json?quantity=${quantity}&id=${variantId}&sections=cart-icon-bubble,cart-drawer,theme_cart`
  );
  if (response.status !== 200) {
    return;
  }
  return response.data;
};
const cartHandlers = {
  ohmycream: async (urlShop, quantity, variantId) => {
    await makeDefaultCartRequest(urlShop, quantity, variantId);
    const { data } = await axios.get(`${urlShop}/cart.js`);
    if (window.$ !== void 0) {
      window.$(document).trigger("cart.updated", [data]);
    }
    setTimeout(() => {
      const overlay = document.getElementsByClassName("mini-cart__overlay")[0];
      if (overlay !== void 0) {
        overlay.classList.remove("active");
      }
      const cartDrawer = document.querySelector(
        '[data-section-id="cart-section"]'
      );
      if (cartDrawer !== null) {
        cartDrawer.classList.remove("active");
      }
    }, 50);
  },
  frenchbloom: async (urlShop, quantity, variantId) => {
    await makeDefaultCartRequest(urlShop, quantity, variantId);
    const { data } = await axios.get(`${urlShop}/cart`);
    const $2 = window.$;
    if ($2 === void 0) {
      return;
    }
    const cartUpdateSelector = '#site-control .cart:not(.nav-search), [data-section-type="cart-template"]';
    const $newCartObj = $2($2.parseHTML(`<div>${data}</div>`)).find(
      cartUpdateSelector
    );
    $2(cartUpdateSelector).each(function(index2) {
      $2($newCartObj[index2]).find("[data-cc-animate]").removeAttr("data-cc-animate");
      $2(this).replaceWith($newCartObj[index2]);
      $2(this).parent().find("[data-cc-animate]").removeAttr("data-cc-animate");
    });
  },
  // eslint-disable-next-line complexity
  martinecosmetics: async (urlShop, quantity, variantId) => {
    var _a3;
    const response = await makeDefaultCartRequest(urlShop, quantity, variantId);
    if (!response) return;
    const themeCart = document.getElementById("shopify-section-theme_cart");
    if (themeCart !== null) {
      const newDiv = document.createElement("div");
      newDiv.innerHTML = response.sections["theme_cart"] ?? "";
      const updatedCart = (_a3 = newDiv.querySelector(
        "#shopify-section-theme_cart"
      )) == null ? void 0 : _a3.innerHTML;
      const cartElement = newDiv.querySelector("cart");
      if (cartElement !== null) {
        const { itemCount } = cartElement.dataset;
        if (itemCount !== void 0) {
          document.querySelectorAll(".item-count").forEach((d2) => {
            d2.textContent = itemCount;
          });
        }
      }
      if (updatedCart !== void 0 && updatedCart !== "") {
        themeCart.innerHTML = updatedCart;
      }
    }
  },
  secretsdeloly: async (urlShop, quantity, variantId) => {
    const response = await axios.post(
      `${urlShop}/cart/add.js`,
      {
        items: [
          {
            quantity,
            id: variantId
          }
        ]
      }
    );
    const customEvent = new CustomEvent("cartUpdated", {
      detail: {
        ...response.data,
        skipEvents: false
      }
    });
    document.dispatchEvent(customEvent);
  },
  nubiance: async (urlShop, quantity, variantId) => {
    var _a3, _b2;
    const response = await makeDefaultCartRequest(urlShop, quantity, variantId);
    if (!response) return;
    await ((_b2 = (_a3 = window.cart) == null ? void 0 : _a3.getCart) == null ? void 0 : _b2.call(_a3));
  },
  mylubie: async (urlShop, quantity, variantId) => {
    var _a3;
    await makeDefaultCartRequest(urlShop, quantity, variantId);
    (_a3 = window.goCart) == null ? void 0 : _a3.fetchAndOpenCart(true);
  },
  obsidianPiercing: async (urlShop, quantity, variantId) => {
    const response = await axios.post(
      `${urlShop}/cart/add.json?quantity=${quantity}&id=${variantId}&sections=mini-cart`
    );
    if (response.status !== 200) {
      return;
    }
    const cartRequest = await axios.get(`${urlShop}/cart.js`);
    document.documentElement.dispatchEvent(
      new CustomEvent("cart:updated", {
        bubbles: true,
        detail: {
          cart: cartRequest.data
        }
      })
    );
  },
  default: async (urlShop, quantity, variantId) => {
    const response = await makeDefaultCartRequest(urlShop, quantity, variantId);
    if (!response) return;
    const iconBubble = document.getElementById("cart-icon-bubble");
    const drawer = document.getElementsByTagName("cart-drawer");
    if (iconBubble !== null) {
      iconBubble.innerHTML = response.sections["cart-icon-bubble"] ?? "";
    }
    if (drawer.length !== 0) {
      drawer[0].innerHTML = response.sections["cart-drawer"] ?? "";
    }
  }
};
const getCartHandler = (hostname) => {
  switch (true) {
    case (hostname.includes("ohmycream") || hostname.includes("oh-my-cream")):
      return cartHandlers["ohmycream"];
    case hostname.includes("frenchbloom"):
      return cartHandlers["frenchbloom"];
    case hostname.includes("martinecosmetics"):
      return cartHandlers["martinecosmetics"];
    case hostname.includes("secretsdeloly"):
      return cartHandlers["secretsdeloly"];
    case hostname.includes("nubiance"):
      return cartHandlers["nubiance"];
    case hostname.includes("mylubie.com"):
      return cartHandlers["mylubie"];
    case hostname.includes("obsidianpiercing"):
      return cartHandlers["obsidianPiercing"];
    default:
      return cartHandlers["default"];
  }
};
const addToCart = async ({
  urlShop,
  quantity,
  variantId
}) => {
  const hostname = window.location.hostname;
  const event = new CustomEvent("dialog:cart:updated", {
    detail: {
      cart: {
        items: [{ quantity, id: variantId }]
      }
    }
  });
  document.dispatchEvent(event);
  const handler = getCartHandler(hostname);
  await handler(urlShop, quantity, variantId);
  return;
};
const getProduct = async ({
  apiKey: apiKey2,
  id: id2,
  locale: locale2,
  countryCode: countryCode2
}) => {
  if (id2 === void 0) {
    return;
  }
  const response = await axios.get(
    `/apps/dialog/shopify-product/${id2}`,
    {
      headers: {
        Authorization: `${apiKey2}`
      },
      params: {
        locale: locale2,
        countryCode: countryCode2
      }
    }
  );
  return response.data;
};
const useSaveQuestionWithAnswer = ({
  onSuccess,
  onError
} = {}) => {
  const onMutationError = (error2) => {
    onError == null ? void 0 : onError(error2);
  };
  return useMutation(
    async ({
      userId: userId2,
      sessionId,
      apiKey: apiKey2,
      question,
      answer,
      messageId,
      countryCode: countryCode2
    }) => saveQuestionWithAnswer({
      sessionId,
      userId: userId2,
      apiKey: apiKey2,
      messageId,
      question,
      answer,
      countryCode: countryCode2
    }),
    {
      onSuccess,
      onError: onMutationError
    }
  );
};
const useSendDiagnosticMessage = ({
  onSuccess,
  onError,
  onMutate
} = {}) => {
  const onMutationError = (error2) => {
    onError == null ? void 0 : onError(error2);
  };
  return useMutation(
    async ({
      sessionId,
      userId: userId2,
      apiKey: apiKey2,
      message,
      language: language2,
      locale: locale2,
      countryCode: countryCode2,
      messageId
    }) => sendDiagnosticMessage({
      sessionId,
      userId: userId2,
      apiKey: apiKey2,
      message,
      language: language2,
      locale: locale2,
      countryCode: countryCode2,
      messageId
    }),
    {
      onSuccess,
      onError: onMutationError,
      onMutate
    }
  );
};
const useSendNewMessageStream = ({
  onSuccess,
  onError,
  onMutate
} = {}) => {
  const onMutationError = (error2) => {
    onError == null ? void 0 : onError(error2);
  };
  const postHog = usePostHog();
  return useMutation(
    async ({
      sessionId,
      userId: userId2,
      apiKey: apiKey2,
      message,
      messageId,
      language: language2,
      locale: locale2,
      countryCode: countryCode2,
      title: title2,
      handle: handle2,
      variantId,
      fromQuestionSuggestion
    }) => sendMessageStream({
      sessionId,
      userId: userId2,
      apiKey: apiKey2,
      message,
      language: language2,
      locale: locale2,
      countryCode: countryCode2,
      messageId,
      title: title2,
      handle: handle2,
      variantId,
      fromQuestionSuggestion,
      analyticsId: postHog.get_distinct_id()
    }),
    {
      onSuccess,
      onError: onMutationError,
      onMutate
    }
  );
};
const SESSION_DURATION = 10 * 60 * 1e3;
const LocalStorageContext = E$2({
  storedValue: {
    hasSeenInitialMessage: false
  },
  dispatch: () => console.error("Local storage context is not well initialized")
});
const useLocalStorage = () => P$1(LocalStorageContext);
const computeNewState = (state, action) => {
  switch (action.type) {
    case "modalHasBeenSeen":
      return {
        ...state,
        displayBookmarkInfo: {
          modalHasBeenSeen: action.payload.modalHasBeenSeen,
          expiry: action.payload.expiry
        }
      };
    case "initialMessageSeen":
      return {
        ...state,
        hasSeenInitialMessage: true
      };
    case "startedConversation":
      if (state.session === void 0) return state;
      return {
        ...state,
        session: {
          ...state.session,
          hasStartedConversation: true
        }
      };
    case "createSession":
      return {
        ...state,
        session: {
          ...state.session,
          hasStartedConversation: false,
          sessionId: crypto.randomUUID(),
          expiry: (/* @__PURE__ */ new Date()).getTime() + SESSION_DURATION
        }
      };
    case "extendSession":
      if (state.session === void 0) return state;
      if (state.session.expiry < (/* @__PURE__ */ new Date()).getTime()) return state;
      return {
        ...state,
        session: {
          ...state.session,
          expiry: (/* @__PURE__ */ new Date()).getTime() + SESSION_DURATION
        }
      };
    case "newSession":
      if (state.session === void 0 || state.session.expiry > (/* @__PURE__ */ new Date()).getTime()) {
        return state;
      }
      return {
        ...state,
        session: {
          ...state.session,
          hasStartedConversation: false,
          sessionId: action.payload.sessionId,
          expiry: (/* @__PURE__ */ new Date()).getTime() + SESSION_DURATION
        }
      };
    default:
      return state;
  }
};
const reducer = (state, action) => {
  const newState = computeNewState(state, action);
  const anonymousId = window.localStorage.getItem("ANONYMOUS_CUSTOMER_ID");
  if (anonymousId === null) {
    return newState;
  }
  window.localStorage.setItem(anonymousId, JSON.stringify(newState));
  return newState;
};
const LocalStorageProvider = ({
  children
}) => {
  const [storedValue, dispatch] = y$1(reducer, void 0, () => {
    try {
      const anonymousId = window.localStorage.getItem("ANONYMOUS_CUSTOMER_ID");
      if (anonymousId === null) {
        return {
          hasSeenInitialMessage: false
        };
      }
      const item = window.localStorage.getItem(anonymousId);
      return item !== null ? JSON.parse(item) : { hasSeenInitialMessage: false };
    } catch {
      return { hasSeenInitialMessage: false };
    }
  });
  return (
    //@ts-expect-error weird compat issues with preact - don't know how to fix
    /* @__PURE__ */ u$2(LocalStorageContext.Provider, { value: { storedValue, dispatch }, children })
  );
};
const useSession = () => {
  const { storedValue, dispatch } = useLocalStorage();
  _(() => {
    if (storedValue.session === void 0) {
      dispatch({ type: "createSession" });
    }
  }, [storedValue, dispatch]);
  const extendSession = x$2(() => {
    const currentSession = storedValue.session;
    if (currentSession === void 0) return;
    dispatch({ type: "extendSession" });
  }, [dispatch, storedValue]);
  const getSessionId = x$2(() => {
    const currentSession = storedValue.session;
    if (currentSession === void 0) {
      const newSessionId = crypto.randomUUID();
      dispatch({ type: "newSession", payload: { sessionId: newSessionId } });
      return newSessionId;
    }
    if (currentSession.expiry < (/* @__PURE__ */ new Date()).getTime()) {
      const newSessionId = crypto.randomUUID();
      dispatch({ type: "newSession", payload: { sessionId: newSessionId } });
      return newSessionId;
    }
    return currentSession.sessionId;
  }, [dispatch, storedValue]);
  return { getSessionId, extendSession };
};
const updateMessagesWithChunk = (messages, historicChunks, newChunk) => {
  const newMessages = [...messages];
  const currentMessage = newMessages.find(
    (msg) => msg.messageId === newChunk.messageId
  );
  if (currentMessage === void 0) {
    newMessages.push({
      output: newChunk.aiToken,
      senderId: "ai",
      messageId: newChunk.messageId,
      humanMessageId: newChunk.humanMessageId,
      messageBySentences: []
    });
    return { messages: newMessages };
  }
  const chunksByMessage = historicChunks.filter((msg) => msg.messageId === currentMessage.messageId).sort((msgA, msgB) => msgA.order - msgB.order);
  const chunkOrdered = [];
  let previousChunk = chunksByMessage[0];
  chunksByMessage.forEach((currentChunk) => {
    if (previousChunk === void 0) return;
    if (previousChunk.order === currentChunk.order || previousChunk.order + 1 === currentChunk.order) {
      chunkOrdered.push(currentChunk);
      previousChunk = currentChunk;
    }
  });
  currentMessage.output = chunkOrdered.map((msg) => msg.aiToken).join("");
  const result = splitIntoSentences(currentMessage.output);
  currentMessage.messageBySentences = result ?? void 0;
  return {
    messages: newMessages
  };
};
const splitIntoSentences = (text2) => {
  return text2.split(new RegExp("(?<=[.!?])\\s+(?=[A-Z])")).map((sentence) => sentence.trim());
};
const isWebsocketMessage = (message) => message.topic === AI_TOKEN_TOPIC;
const isWebsocketRecommendation = (message) => message.topic === RECOMMENDATION_TOPIC;
const isWebsocketSuggestions = (message) => message.topic === ANSWER_SUGGESTIONS_TOPIC;
const isWebsocketQualification = (message) => message.topic === QUALIFICATION_TOPIC;
const priceFormatter = (price, currencyCode = USD_CURRENCY_CODE, locale2 = navigator.language) => {
  if (price === void 0 || price === null) {
    return;
  }
  const formatter = new Intl.NumberFormat(locale2, {
    style: "currency",
    currency: currencyCode
  });
  if (typeof price === "number") {
    return formatter.format(price);
  }
  return `${formatter.format(parseFloat(price))}`;
};
const getRawProductId = (id2) => {
  if (id2.match(/gid/) !== null) {
    const splittedId = id2.split("/");
    return splittedId[splittedId.length - 1];
  }
  return id2;
};
const formatProductId = (productId) => {
  if (productId.match(/gid/) !== null) {
    return productId.replace("gid://shopify/Product/", "");
  }
  return productId;
};
const formatProductVariantId = (productId) => {
  if (productId.match(/gid/) !== null) {
    return productId.replace("gid://shopify/ProductVariant/", "");
  }
  return productId;
};
const useConsent = () => {
  const postHog = usePostHog();
  _(() => {
    const onVisitorConsentCollected = (event) => {
      if (typeof event === "object" && event !== null && "detail" in event && typeof event.detail === "object" && event.detail !== null && "analyticsAllowed" in event.detail && event.detail.analyticsAllowed === true) {
        postHog.register({ useCookie: true });
        postHog.set_config({
          persistence: "localStorage+cookie"
        });
        postHog.capture(TRACKING_EVENTS.NEW_SESSION);
      }
    };
    document.addEventListener(
      "visitorConsentCollected",
      onVisitorConsentCollected
    );
    return () => document.removeEventListener(
      "visitorConsentCollected",
      onVisitorConsentCollected
    );
  }, [postHog]);
};
const defaultFunctionContext$2 = () => console.error("Asssistant state context is not well initialized");
const defaultAssistantState = {
  messageId: "",
  isLoadingToWrite: false,
  isWriting: false,
  isQualifying: false,
  isSearchingForQualificationQuestion: false,
  isLookingForRecommendations: false,
  isSuggestingQuestion: false,
  isReadyToSend: true,
  displayFeedbacks: false,
  displayDiagnostic: false,
  isRunningDiagnostic: false,
  displayCustomDiagnosticLoader: false,
  hasError: false
};
const AssistantStateContext = E$2({
  ...defaultAssistantState,
  updateAssistantState: defaultFunctionContext$2,
  resetAssistantState: defaultFunctionContext$2
});
const useAssistantState = () => P$1(AssistantStateContext);
const AssistantStateProvider = ({
  children
}) => {
  useConsent();
  const [assistantState, setAssistantState] = p$1(
    defaultAssistantState
  );
  const updateAssistantState = (state) => {
    setAssistantState((prev2) => ({ ...prev2, ...state }));
  };
  const resetAssistantState = () => {
    setAssistantState(defaultAssistantState);
  };
  useWebSocket({
    topic: [STATES_TOPIC],
    onMessage: (msg) => {
      setAssistantState((prev2) => ({ ...prev2, ...msg.content }));
    }
  });
  const context = q$2(() => {
    return {
      ...assistantState,
      updateAssistantState,
      resetAssistantState
    };
  }, [assistantState]);
  return /* @__PURE__ */ u$2(AssistantStateContext.Provider, { value: context, children });
};
const enUSMessages = {
  customDisclaimer: "{disclaimerName} can be wrong, check key info",
  defaultDisclaimer: "Dialog can be wrong, check key info",
  you: "You",
  assistant: "Assistant",
  assist: "Assist",
  convertingToText: "Converting to text...",
  recording: "Recording...",
  productsShowcase: {
    title: "Hello, I'm your assistant",
    description: "Ask anything like you were talking to me"
  },
  errors: {
    internalError: "Internal error, please retry...",
    conversationLimitReached: "Sorry for the inconvenience, the shop owner has reached his conversation limit."
  },
  addToCart: "Add to cart",
  outOfStock: "Out of stock",
  productAdded: "Added!",
  seeProduct: "See product on site",
  analyzingCatalog: "Thinking...",
  info: "Info",
  askAnything: "Continue the conversation",
  askFollowUp: "Ask anything",
  askAnythingAboutProduct: "Any questions about this product?",
  titleAssistantModal: "Your expert",
  descriptionAssistantModal: "Ask any questions on this product",
  description: "Description",
  thinking: "Thinking...",
  modal: {
    title: "Looking for something special?"
  },
  loadPreviousMessages: "Load previous messages",
  seeProductOrigin: "See product",
  answers: "Answers",
  customAnswer: "Type your custom answer",
  skipAnswer: "Skip Answer",
  conversationEmpty: "Need any information about a product? Ask me about it!",
  animations: {
    thinking: "Thinking...",
    indexing: "Understanding question...",
    finding: "Retrieving information...",
    uploadingPicture: "Uploading the picture...",
    analyzingPicture: "Analyzing the picture...",
    createDiagnostic: "Creating diagnostic..."
  },
  useful: "Useful",
  useless: "Useless",
  diagnostic: {
    loading: "Loading...",
    allowCameraAccess: "Please allow camera access",
    takePicture: "Take a picture",
    uploadPicture: "Upload photo",
    defaultMessage: "Lets make your diagnostic! Share a picture of your face without any make up or filter. If you cant, we can continue with a quick survey"
  }
};
const esESMessages = {
  customDisclaimer: "{disclaimerName} puede estar equivocado",
  defaultDisclaimer: "Pueden ocurrir errores ocasionales",
  you: "T",
  assistant: "Asistente",
  assist: "Asistir",
  convertingToText: "Convirtiendo a texto...",
  recording: "Grabando...",
  productsShowcase: {
    title: "Hola, soy tu asistente",
    description: "Pregunta cualquier cosa como si estuvieras hablando conmigo"
  },
  errors: {
    internalError: "Error interno, por favor reintenta...",
    conversationLimitReached: "Lo siento por la molestia, el dueo de la tienda ha alcanzado su lmite de conversaciones."
  },
  addToCart: "Aadir",
  outOfStock: "Sin stock",
  productAdded: "Aadido!",
  seeProduct: "Ver producto en el sitio",
  analyzingCatalog: "Pensando...",
  info: "Info",
  askAnything: "Continuar la conversacin",
  askFollowUp: "Pregunta cualquier cosa",
  askAnythingAboutProduct: "Alguna pregunta sobre este producto?",
  titleAssistantModal: "Tu experto",
  descriptionAssistantModal: "Haz cualquier pregunta sobre este producto",
  description: "Descripcin",
  thinking: "Pensando...",
  modal: {
    title: "Buscas algo especial?"
  },
  loadPreviousMessages: "Cargar mensajes anteriores",
  seeProductOrigin: "Ver producto",
  answers: "Respuestas",
  customAnswer: "Escribe tu respuesta personalizada",
  skipAnswer: "Saltar respuesta",
  conversationEmpty: "Necesita informacin sobre un producto? Pregnteme!",
  animations: {
    thinking: "Pensando...",
    indexing: "Entendiendo la pregunta...",
    finding: "Recuperando informacin...",
    uploadingPicture: "Subiendo la imagen...",
    analyzingPicture: "Analizando la imagen...",
    createDiagnostic: "Creando diagnstico..."
  },
  useful: "til",
  useless: "Intil",
  diagnostic: {
    loading: "Cargando...",
    allowCameraAccess: "Por favor, permite el acceso a la cmara",
    takePicture: "Tomar una foto",
    uploadPicture: "Subir foto",
    defaultMessage: "Hagamos tu diagnstico! Comparte una foto de tu rostro sin maquillaje ni filtros. Si no puedes, podemos continuar con una encuesta rpida"
  }
};
const frFRMessages = {
  customDisclaimer: "{disclaimerName} peut se tromper, vrifiez les infos cls",
  defaultDisclaimer: "Dialog peut se tromper, vrifiez les infos cls",
  you: "Vous",
  assistant: "Assistant",
  assist: "Assistant",
  convertingToText: "Conversion en texte...",
  recording: "Enregistrement...",
  productsShowcase: {
    title: "Bonjour, je suis votre assistant",
    description: "Demandez n'importe quoi comme si vous me parliez"
  },
  errors: {
    internalError: "Erreur interne, veuillez ressayer...",
    conversationLimitReached: "Dsol pour le dsagrment, le propritaire du site a atteint sa limite de conversations."
  },
  addToCart: "Ajouter au panier",
  outOfStock: "puis",
  productAdded: "Ajout !",
  seeProduct: "Voir le produit sur le site",
  analyzingCatalog: "Rflexion...",
  info: "Info",
  askAnything: "Continuer la conversation",
  askFollowUp: "Posez n'importe quelle question",
  askAnythingAboutProduct: "Des questions sur ce produit ?",
  titleAssistantModal: "Votre expert",
  descriptionAssistantModal: "Posez n'importe quelle question sur ce produit",
  description: "Description",
  thinking: "Rflexion...",
  modal: {
    title: "Vous cherchez quelque chose de spcial ?"
  },
  loadPreviousMessages: "Charger les messages prcdents",
  seeProductOrigin: "Voir le produit",
  answers: "Rponses",
  customAnswer: "Entrez votre rponse",
  skipAnswer: "Passer la rponse",
  conversationEmpty: "Vous avez besoin d'informations sur un produit ? Posez-moi la question !",
  animations: {
    thinking: "Rflexion en cours...",
    indexing: "Analyse de la question...",
    finding: "Rcupration des informations...",
    uploadingPicture: "Tlchargement de limage...",
    analyzingPicture: "Analyse de limage...",
    createDiagnostic: "Cration du diagnostic..."
  },
  useful: "Utile",
  useless: "Inutile",
  diagnostic: {
    loading: "Chargement...",
    allowCameraAccess: "Veuillez autoriser l'accs  la camra",
    takePicture: "Prendre une photo",
    uploadPicture: "Tlcharger une photo",
    defaultMessage: "Faisons votre diagnostic ! Partagez une photo de votre visage sans maquillage ni filtre. Si ce nest pas possible, nous pouvons continuer avec un rapide questionnaire"
  }
};
const itITMessages = {
  customDisclaimer: "{disclaimerName} potrebbe essere sbagliato",
  defaultDisclaimer: "Possono verificarsi errori occasionali",
  you: "Tu",
  assistant: "Assistente",
  assist: "Assisti",
  convertingToText: "Conversione in testo...",
  recording: "Registrazione...",
  productsShowcase: {
    title: "Ciao, sono il tuo assistente",
    description: "Chiedi qualsiasi cosa come se stessi parlando con me"
  },
  errors: {
    internalError: "Errore interno, per favore riprova...",
    conversationLimitReached: "Ci scusiamo per il disagio, il proprietario del negozio ha raggiunto il limite di conversazioni."
  },
  addToCart: "Aggiungi",
  outOfStock: "Esaurito",
  productAdded: "Aggiunto!",
  seeProduct: "Vedi prodotto sul sito",
  analyzingCatalog: "Sto pensando...",
  info: "Info",
  askAnything: "Continua la conversazione",
  askFollowUp: "Chiedi qualsiasi cosa",
  askAnythingAboutProduct: "Domande su questo prodotto?",
  titleAssistantModal: "Il tuo esperto",
  descriptionAssistantModal: "Fai qualsiasi domanda su questo prodotto",
  description: "Descrizione",
  thinking: "Sto pensando...",
  modal: {
    title: "Cerchi qualcosa di speciale?"
  },
  loadPreviousMessages: "Carica messaggi precedenti",
  seeProductOrigin: "Vedi prodotto",
  answers: "Risposte",
  customAnswer: "Scrivi la tua risposta personalizzata",
  skipAnswer: "Salta risposta",
  conversationEmpty: "Hai bisogno di informazioni su un prodotto? Chiedimi pure!",
  animations: {
    thinking: "Sto pensando...",
    indexing: "Comprendo la domanda...",
    finding: "Recupero informazioni...",
    uploadingPicture: "Caricamento dell'immagine...",
    analyzingPicture: "Analisi dell'immagine...",
    createDiagnostic: "Creazione della diagnosi..."
  },
  useful: "Utile",
  useless: "Inutile",
  diagnostic: {
    loading: "Caricamento...",
    allowCameraAccess: "Si prega di autorizzare l'accesso alla fotocamera",
    takePicture: "Scattare una foto",
    uploadPicture: "Caricare una foto",
    defaultMessage: "Facciamo la tua diagnosi! Condividi una foto del tuo viso senza trucco n filtri. Se non  possibile, possiamo continuare con un rapido questionario"
  }
};
const getTranslation = (countryCode2) => {
  switch (countryCode2.slice(0, 2)) {
    case "fr":
      return frFRMessages;
    case "es":
      return esESMessages;
    case "it":
      return itITMessages;
    case "us":
    case "en":
      return enUSMessages;
    default:
      return enUSMessages;
  }
};
const LocalizationContext = E$2({
  countryCode: "US",
  languageIsoCode: "en",
  language: "English"
});
const useLocalization = () => P$1(LocalizationContext);
const languageMapping = {
  en: "English",
  es: "Espaol",
  fr: "Franais",
  it: "Italiano"
};
const LocalizationProvider = ({
  children,
  countryCode: countryCode2,
  languageIsoCode: languageIsoCode2,
  language: language2,
  locale: locale2
}) => {
  const [modifiedLocale, setModifiedLocale] = p$1(locale2);
  _(() => {
    if (window.Weglot !== void 0) {
      setModifiedLocale(window.Weglot.getCurrentLang());
      window.Weglot.on("languageChanged", () => {
        var _a3;
        setModifiedLocale((_a3 = window.Weglot) == null ? void 0 : _a3.getCurrentLang());
      });
      return () => {
        var _a3;
        (_a3 = window.Weglot) == null ? void 0 : _a3.off("languageChanged");
      };
    }
    return;
  }, []);
  const contextValue = q$2(() => {
    return {
      countryCode: countryCode2,
      // not necessarily iso code but can also be BCT-47 language tag ie en or en-US
      languageIsoCode: modifiedLocale,
      language: (
        // some Shopify stores do not use correctly internationalization feature so we must create the language ourselves
        // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with
        modifiedLocale.slice(0, 2) !== languageIsoCode2.slice(0, 2) ? languageMapping[modifiedLocale.slice(0, 2)] ?? language2 : language2
      )
    };
  }, [language2, countryCode2, modifiedLocale, languageIsoCode2]);
  const intlMessages = _flattenMessages(getTranslation(modifiedLocale));
  return (
    //@ts-expect-error weird compat issues with preact - don't know how to fix
    /* @__PURE__ */ u$2(LocalizationContext.Provider, { value: contextValue, children: /* @__PURE__ */ u$2(
      IntlProvider,
      {
        messages: intlMessages,
        locale: modifiedLocale,
        defaultLocale: "en-US",
        children
      }
    ) })
  );
};
const getDialogConfigKey = ({
  apiKey: apiKey2,
  locale: locale2
}) => {
  return ["modal-config", { apiKey: apiKey2, locale: locale2 }];
};
const useGetDialogConfig = ({
  locale: locale2,
  apiKey: apiKey2,
  onSuccess,
  onError
}) => {
  const key = getDialogConfigKey({ apiKey: apiKey2, locale: locale2 });
  const onMutationSuccess = (data) => {
    onSuccess == null ? void 0 : onSuccess(data);
  };
  const onMutationError = (error2) => {
    onError == null ? void 0 : onError(error2);
  };
  return useQuery(
    key,
    async () => getDialogConfig({
      apiKey: apiKey2,
      locale: locale2
    }),
    {
      cacheTime: 18e5,
      staleTime: 18e5,
      refetchOnWindowFocus: false,
      retry: 3,
      onSuccess: onMutationSuccess,
      onError: onMutationError
    }
  );
};
const DialogConfigContext = E$2({
  config: void 0,
  error: void 0,
  isLoading: false,
  isFeatureDisabled: () => false
});
const useDialogConfig = () => P$1(DialogConfigContext);
const DialogConfigProvider = ({
  children,
  apiKey: apiKey2
}) => {
  const postHog = usePostHog();
  const { languageIsoCode: languageIsoCode2 } = useLocalization();
  const { data, isLoading, error: error2 } = useGetDialogConfig({
    apiKey: apiKey2,
    locale: languageIsoCode2,
    onError: (err) => {
      var _a3;
      if (((_a3 = err.response) == null ? void 0 : _a3.status) === 429 && err.response.data === "maxConversationReached") {
        postHog.capture(TRACKING_EVENTS.CONVERSATION_LIMIT_REACHED, {
          apiKey: apiKey2
        });
      }
    }
  });
  const isFeatureDisabled = x$2(
    (feature) => {
      var _a3;
      return ((_a3 = data == null ? void 0 : data.disabledFeatures) == null ? void 0 : _a3.includes(feature)) ?? false;
    },
    [data == null ? void 0 : data.disabledFeatures]
  );
  const contextValue = q$2(() => {
    return {
      config: data,
      error: error2 ?? void 0,
      isLoading,
      isFeatureDisabled
    };
  }, [data, error2, isLoading, isFeatureDisabled]);
  return /* @__PURE__ */ u$2(DialogConfigContext.Provider, { value: contextValue, children });
};
const defaultFunctionContext$1 = () => console.error("Messages context is not well initialized");
const AssistantMessagesContext = E$2({
  messages: [],
  sendMessage: defaultFunctionContext$1,
  saveQuestionAndAnswer: defaultFunctionContext$1,
  assistantHasError: false,
  apiKey: "",
  getSessionId: () => "",
  userId: "",
  askSomethingOnProduct: defaultFunctionContext$1,
  updateExistingMessage: defaultFunctionContext$1,
  handleAddToCart: () => Promise.resolve(),
  retryLastMessage: defaultFunctionContext$1,
  closeAssistant: defaultFunctionContext$1,
  openAssistant: defaultFunctionContext$1,
  clearAssistantMessages: defaultFunctionContext$1,
  setMessages: defaultFunctionContext$1,
  conversationLimitIsReached: false
});
const useAssistantMessages = () => P$1(AssistantMessagesContext);
const AssistantMessagesProvider = ({
  children,
  apiKey: apiKey2,
  userId: userId2
}) => {
  const [conversationLimitIsReached, setConversationLimitIsReached] = p$1(false);
  const {
    updateAssistantState,
    isReadyToSend,
    resetAssistantState,
    displayDiagnostic,
    isRunningDiagnostic
  } = useAssistantState();
  const [qualificationsNotAssociated, setQualificationsNotAssociated] = p$1([]);
  const { storedValue } = useLocalStorage();
  const postHog = usePostHog();
  const { activateWebSocket: activateWebSocket2 } = P$1(WebSocketContext);
  const { config: dialogConfig } = useDialogConfig();
  const { getSessionId, extendSession } = useSession();
  const [assistantIsClosed, setAssistantIsClosed] = p$1(true);
  const [assistantHasError, setAssistantHasError] = p$1(false);
  const [messages, setMessages] = p$1([]);
  const { mutateAsync: sendDiagnosticMessage2 } = useSendDiagnosticMessage();
  _(() => {
    var _a3;
    if ((dialogConfig == null ? void 0 : dialogConfig.initialAssistantMessage) !== void 0 && ((_a3 = messages[0]) == null ? void 0 : _a3.messageId) !== "initialMessage" && !storedValue.hasSeenInitialMessage) {
      setMessages((prev2) => [
        {
          messageId: "initialMessage",
          senderId: "ai",
          done: true,
          output: dialogConfig.initialAssistantMessage,
          message: dialogConfig.initialAssistantMessage
        },
        ...prev2
      ]);
    }
  }, [dialogConfig == null ? void 0 : dialogConfig.initialAssistantMessage, messages, storedValue]);
  const [, setChunks] = p$1([]);
  const localization = useLocalization();
  const [messageQueue, setMessageQueue] = p$1();
  const openAssistant = x$2(() => {
    setAssistantIsClosed(false);
  }, []);
  const closeAssistant = x$2(() => {
    resetAssistantState();
    setAssistantIsClosed(true);
  }, [resetAssistantState]);
  const getLastHumanMessage = x$2(() => {
    if (messages.length === 0) return void 0;
    const messagesSorted = [...messages].reverse();
    const lastMessage = messagesSorted.find(
      (message) => message.senderId === "human" || message.senderId === "questionMessage"
    );
    return lastMessage;
  }, [messages]);
  _(() => {
    var _a3;
    if (messages.length > 0 && assistantIsClosed && !(messages.length === 1 && ((_a3 = messages[0]) == null ? void 0 : _a3.messageId) === "initialMessage")) {
      setMessages([]);
    }
  }, [messages, assistantIsClosed]);
  const clearAssistantMessages = x$2(() => {
    setMessages([]);
  }, []);
  const handleWebsocketMessage = (msg) => {
    if (msg.content.completeMessage !== void 0) {
      updateExistingMessage(msg.content.messageId, {
        content: msg.content.completeMessage,
        done: true
      });
      return;
    }
    updateAssistantState({
      isLoadingToWrite: false,
      displayCustomDiagnosticLoader: false
    });
    setChunks((prevChunks) => {
      const newChunks = [...prevChunks, msg.content];
      const { messages: updateMessages } = updateMessagesWithChunk(
        messages,
        newChunks,
        msg.content
      );
      setMessages(updateMessages);
      return newChunks;
    });
    associateLostQualifications();
  };
  const associateLostQualifications = () => {
    qualificationsNotAssociated.forEach((qualification) => {
      const messageFound = messages.find(
        (message) => message.messageId === qualification.messageId
      );
      if (messageFound !== void 0) {
        if (messageFound.qualifications === void 0) {
          messageFound.qualifications = [];
        }
        const alreadyExist = messageFound.qualifications.find(
          (q2) => q2.question === qualification.question
        );
        if (alreadyExist) return;
        messageFound.qualifications.push(qualification);
      }
    });
  };
  const handleWebsocketRecommendations = (msg) => {
    setMessages((previousMessages) => {
      const newMessages = [...previousMessages];
      const currentMessage = newMessages.find(
        (message) => message.messageId === msg.content.messageId
      );
      if (currentMessage !== void 0) {
        currentMessage.recommendations = msg.content.recommendations;
      }
      return newMessages;
    });
  };
  const updateExistingMessage = (messageId, {
    recommendations,
    savedAnswers,
    content: content2,
    done
  }) => {
    setMessages((previousMessages) => {
      const newMessages = [...previousMessages];
      const currentMessage = newMessages.find(
        (message) => message.messageId === messageId
      );
      if (currentMessage === void 0 && done === true) {
        newMessages.push({
          messageId,
          senderId: "ai",
          done,
          output: content2 ?? ""
        });
      }
      if (currentMessage !== void 0) {
        if (done !== void 0) {
          currentMessage.done = done;
        }
        if (content2 !== void 0) {
          currentMessage.output = content2;
        }
        if (recommendations !== void 0) {
          currentMessage.recommendations = recommendations;
        }
        if (savedAnswers !== void 0) {
          currentMessage.savedAnswers = savedAnswers;
        }
      }
      return newMessages;
    });
  };
  const handleWebsocketQualification = (msg) => {
    updateAssistantState({ isSearchingForQualificationQuestion: false });
    setMessages((previousMessages) => {
      const newMessages = [...previousMessages];
      const currentMessage = newMessages.find(
        (message) => message.messageId === msg.content.messageId
      );
      if (currentMessage === void 0) {
        setQualificationsNotAssociated((prev2) => [...prev2, msg.content]);
        return newMessages;
      }
      if (currentMessage.qualifications === void 0) {
        currentMessage.qualifications = [];
      }
      currentMessage.qualifications.push(msg.content);
      return newMessages;
    });
  };
  const handleWebsocketSuggestions = (msg) => {
    setMessages((previousMessages) => {
      const newMessages = [...previousMessages];
      const currentMessage = newMessages.find(
        (message) => message.messageId === msg.content.messageId
      );
      if (currentMessage !== void 0) {
        currentMessage.suggestions = msg.content.answers;
      }
      return newMessages;
    });
  };
  useWebSocket({
    topic: [
      AI_TOKEN_TOPIC,
      RECOMMENDATION_TOPIC,
      ANSWER_SUGGESTIONS_TOPIC,
      QUALIFICATION_TOPIC
    ],
    onMessage: (msg) => {
      if (isWebsocketMessage(msg)) {
        handleWebsocketMessage(msg);
      }
      if (isWebsocketRecommendation(msg)) {
        handleWebsocketRecommendations(msg);
      }
      if (isWebsocketSuggestions(msg)) {
        handleWebsocketSuggestions(msg);
      }
      if (isWebsocketQualification(msg)) {
        handleWebsocketQualification(msg);
      }
    }
  });
  const handleConversationLimitIsReachedError = () => {
    setConversationLimitIsReached(true);
    updateAssistantState({
      isReadyToSend: true,
      isWriting: false,
      isLoadingToWrite: false
    });
    postHog.capture(TRACKING_EVENTS.CONVERSATION_LIMIT_REACHED, {
      apiKey: apiKey2
    });
  };
  const handleAssistantInternalError = () => {
    setAssistantHasError(true);
    updateAssistantState({
      isReadyToSend: true,
      isWriting: false,
      isLoadingToWrite: false
    });
  };
  const sendMessageAI = useSendNewMessageStream({
    onMutate: () => {
      updateAssistantState({ displayFeedbacks: false });
    },
    onSuccess: () => {
      updateAssistantState({ displayFeedbacks: true });
    },
    onError: (error2) => {
      var _a3, _b2;
      if (((_a3 = error2.response) == null ? void 0 : _a3.status) === 429 && error2.response.data === "maxConversationReached") {
        handleConversationLimitIsReachedError();
        return;
      }
      if (((_b2 = error2.response) == null ? void 0 : _b2.status) >= 500) {
        handleAssistantInternalError();
        return;
      }
      updateAssistantState({ isReadyToSend: true });
    }
  });
  const saveQuestionWithAnswer2 = useSaveQuestionWithAnswer({
    onError: (error2) => {
      var _a3, _b2;
      if (((_a3 = error2.response) == null ? void 0 : _a3.status) === 429 && error2.response.data === "maxConversationReached") {
        handleConversationLimitIsReachedError();
        return;
      }
      if (((_b2 = error2.response) == null ? void 0 : _b2.status) >= 500) {
        handleAssistantInternalError();
        return;
      }
      updateAssistantState({ isReadyToSend: true });
    }
  });
  const sendNewMessageAI = sendMessageAI.mutateAsync;
  const askSomethingOnProduct = x$2(
    // eslint-disable-next-line complexity
    async ({
      question,
      answer,
      product
    }) => {
      const messageId = crypto.randomUUID();
      activateWebSocket2();
      extendSession();
      updateAssistantState({ isReadyToSend: false });
      storeMessage({
        messageId,
        output: question,
        product,
        senderId: "questionMessage"
      });
      if (answer !== void 0) {
        storeMessage({
          messageId,
          output: answer,
          product,
          senderId: "ai"
        });
        return;
      }
      const msgParams = {
        sessionId: getSessionId(),
        userId: userId2,
        message: question,
        messageId,
        language: localization.language,
        locale: localization.languageIsoCode,
        countryCode: localization.countryCode,
        apiKey: apiKey2,
        title: product == null ? void 0 : product.title,
        handle: product == null ? void 0 : product.handle,
        productId: product == null ? void 0 : product.id,
        productTitle: product == null ? void 0 : product.title
      };
      if (isReadyToSend === false) {
        setMessageQueue(msgParams);
        return;
      }
      await sendNewMessageAI(msgParams);
      postHog.capture(TRACKING_EVENTS.USER_SEND_MESSAGE, {
        userId: userId2,
        sessionId: getSessionId(),
        product: product == null ? void 0 : product.id,
        productTitle: product == null ? void 0 : product.title,
        message: question
      });
    },
    [
      activateWebSocket2,
      extendSession,
      updateAssistantState,
      getSessionId,
      userId2,
      localization.language,
      localization.languageIsoCode,
      localization.countryCode,
      apiKey2,
      isReadyToSend,
      sendNewMessageAI,
      postHog
    ]
  );
  const trackAddToCartEvent = x$2(
    (variantId) => {
      if (window.gtag !== void 0) {
        window.gtag("event", "dialog_add_to_cart", {
          dialogId: userId2,
          variantId
        });
      }
      postHog.capture(TRACKING_EVENTS.ADD_TO_CART, {
        userId: userId2,
        sessionId: getSessionId(),
        variantId,
        quantity: 1
      });
    },
    [getSessionId, postHog, userId2]
  );
  const retryLastMessage = x$2(async () => {
    var _a3, _b2;
    setAssistantHasError(false);
    extendSession();
    if (messages.length === 0) return;
    const lastMessage = getLastHumanMessage();
    if (lastMessage === void 0) return;
    await sendNewMessageAI({
      sessionId: getSessionId(),
      userId: userId2,
      message: lastMessage.output,
      messageId: lastMessage.messageId,
      language: localization.language,
      locale: localization.languageIsoCode,
      countryCode: localization.countryCode,
      apiKey: apiKey2,
      title: (_a3 = lastMessage.selectedProduct) == null ? void 0 : _a3.title,
      variantId: (_b2 = lastMessage.selectedProduct) == null ? void 0 : _b2.selectedVariantId
    });
  }, [
    apiKey2,
    extendSession,
    userId2,
    getLastHumanMessage,
    localization,
    messages.length,
    sendNewMessageAI,
    getSessionId
  ]);
  const handleAddToCart = x$2(
    async (variantId) => {
      const variantIdFound = getRawProductId(variantId);
      if (variantIdFound === void 0) return;
      await addToCart({
        quantity: "1",
        variantId: variantIdFound,
        urlShop: window.location.origin
      });
      trackAddToCartEvent(variantIdFound);
    },
    [trackAddToCartEvent]
  );
  const storeMessage = (message) => {
    setMessages((prev2) => [...prev2, message]);
  };
  _(() => {
    if (messageQueue === void 0 || isReadyToSend === false) return;
    const sendMsg = async () => {
      const msgQueue = messageQueue;
      setMessageQueue(void 0);
      await sendNewMessageAI(msgQueue);
      postHog.capture(TRACKING_EVENTS.USER_SEND_MESSAGE, {
        userId: userId2,
        sessionId: getSessionId(),
        product: msgQueue.productId,
        productTitle: msgQueue.productTitle,
        message: msgQueue.message
      });
    };
    void sendMsg();
  }, [
    messageQueue,
    isReadyToSend,
    sendNewMessageAI,
    postHog,
    userId2,
    getSessionId
  ]);
  const sendMessage = x$2(
    // eslint-disable-next-line complexity
    async (output, selectedProduct, senderId) => {
      activateWebSocket2();
      extendSession();
      updateAssistantState({
        isLoadingToWrite: true,
        isReadyToSend: false,
        displayCustomDiagnosticLoader: false
      });
      const messageId = crypto.randomUUID();
      storeMessage({
        messageId,
        output,
        senderId: senderId ?? "human",
        selectedProduct
      });
      const commonMsgParams = {
        sessionId: getSessionId(),
        userId: userId2,
        message: output,
        messageId,
        language: localization.language,
        locale: localization.languageIsoCode,
        countryCode: localization.countryCode,
        apiKey: apiKey2
      };
      const sendStreamMessageParams = {
        ...commonMsgParams,
        fromQuestionSuggestion: selectedProduct == null ? void 0 : selectedProduct.fromQuestionSuggestion,
        title: selectedProduct == null ? void 0 : selectedProduct.title,
        handle: selectedProduct == null ? void 0 : selectedProduct.handle,
        product: selectedProduct == null ? void 0 : selectedProduct.id,
        productTitle: selectedProduct == null ? void 0 : selectedProduct.title,
        variantId: selectedProduct == null ? void 0 : selectedProduct.selectedVariantId
      };
      if (isReadyToSend === false) {
        setMessageQueue(sendStreamMessageParams);
        return;
      }
      if (displayDiagnostic === true && isRunningDiagnostic === true) {
        await sendDiagnosticMessage2(commonMsgParams);
      } else {
        await sendNewMessageAI(sendStreamMessageParams);
      }
      postHog.capture(TRACKING_EVENTS.USER_SEND_MESSAGE, {
        userId: userId2,
        sessionId: getSessionId(),
        product: selectedProduct == null ? void 0 : selectedProduct.id,
        productTitle: selectedProduct == null ? void 0 : selectedProduct.title,
        message: output
      });
    },
    [
      activateWebSocket2,
      extendSession,
      updateAssistantState,
      getSessionId,
      userId2,
      localization.language,
      localization.languageIsoCode,
      localization.countryCode,
      apiKey2,
      isReadyToSend,
      displayDiagnostic,
      isRunningDiagnostic,
      postHog,
      sendDiagnosticMessage2,
      sendNewMessageAI
    ]
  );
  const saveQuestionAndAnswer = x$2(
    async (question, answer, selectedProduct, senderId) => {
      const messageId = crypto.randomUUID();
      activateWebSocket2();
      extendSession();
      postHog.capture(TRACKING_EVENTS.USER_SEND_MESSAGE, {
        userId: userId2,
        sessionId: getSessionId(),
        product: selectedProduct == null ? void 0 : selectedProduct.id,
        productTitle: selectedProduct == null ? void 0 : selectedProduct.title,
        message: question
      });
      storeMessage({
        messageId,
        output: question,
        done: true,
        senderId: senderId ?? "human",
        selectedProduct
      });
      const aiMessageId = await saveQuestionWithAnswer2.mutateAsync({
        userId: userId2,
        sessionId: getSessionId(),
        question,
        answer,
        messageId,
        apiKey: apiKey2,
        countryCode: localization.countryCode
      });
      storeMessage({
        messageId: aiMessageId,
        output: answer,
        done: true,
        senderId: "ai",
        selectedProduct
      });
    },
    [
      activateWebSocket2,
      apiKey2,
      saveQuestionWithAnswer2,
      extendSession,
      getSessionId,
      userId2,
      localization.countryCode,
      postHog
    ]
  );
  const assistantMessagesContext = q$2(
    () => ({
      messages,
      sendMessage,
      getSessionId,
      apiKey: apiKey2,
      userId: userId2,
      handleAddToCart,
      askSomethingOnProduct,
      assistantHasError,
      retryLastMessage,
      closeAssistant,
      openAssistant,
      updateExistingMessage,
      saveQuestionAndAnswer,
      setMessages,
      conversationLimitIsReached,
      clearAssistantMessages
    }),
    [
      messages,
      sendMessage,
      apiKey2,
      getSessionId,
      userId2,
      handleAddToCart,
      askSomethingOnProduct,
      assistantHasError,
      retryLastMessage,
      closeAssistant,
      openAssistant,
      saveQuestionAndAnswer,
      setMessages,
      clearAssistantMessages,
      conversationLimitIsReached
    ]
  );
  return /* @__PURE__ */ u$2(AssistantMessagesContext.Provider, { value: assistantMessagesContext, children });
};
const defaultFunctionContext = () => console.error("Recommendation drawer context is not well initialized");
const RecommendationDrawerContext = E$2({
  displayRecommendationDrawer: false,
  selectedRecommendation: void 0,
  openRecommendationDrawer: defaultFunctionContext,
  setSelectedRecommendation: defaultFunctionContext,
  setDisplayRecommendationDrawer: defaultFunctionContext
});
const useRecommendationDrawer = () => P$1(RecommendationDrawerContext);
const RecommendationDrawerProvider = ({
  children
}) => {
  const postHog = usePostHog();
  const [selectedRecommendation, setSelectedRecommendation] = p$1();
  const [displayRecommendationDrawer, setDisplayRecommendationDrawer] = p$1(false);
  const openRecommendationDrawer = x$2(
    (recommendation, selectedVariantId, selectedVariantTitle) => {
      setSelectedRecommendation({
        product: recommendation,
        selectedVariantId,
        selectedVariantTitle
      });
      setDisplayRecommendationDrawer(true);
      postHog.capture(TRACKING_EVENTS.USER_OPENED_RECOMMENDATION, {
        recommendationId: recommendation.id
      });
    },
    [setDisplayRecommendationDrawer, setSelectedRecommendation, postHog]
  );
  const recommendationDrawerContext = q$2(
    () => ({
      selectedRecommendation,
      displayRecommendationDrawer,
      setDisplayRecommendationDrawer,
      openRecommendationDrawer,
      setSelectedRecommendation
    }),
    [
      selectedRecommendation,
      displayRecommendationDrawer,
      setDisplayRecommendationDrawer,
      openRecommendationDrawer,
      setSelectedRecommendation
    ]
  );
  return /* @__PURE__ */ u$2(RecommendationDrawerContext.Provider, { value: recommendationDrawerContext, children });
};
const CurrentProductIdContext = E$2({
  setProductId: () => {
    console.error("CurrentProductIdContext not well initialized");
  }
});
const useCurrentProductId = () => P$1(CurrentProductIdContext);
const CurrentProductIdProvider = ({
  children
}) => {
  const [productId, setProductId] = p$1();
  const contextValue = q$2(() => {
    return {
      productId,
      setProductId
    };
  }, [productId, setProductId]);
  return (
    //@ts-expect-error weird compat issues with preact - don't know how to fix
    /* @__PURE__ */ u$2(CurrentProductIdContext.Provider, { value: contextValue, children })
  );
};
const ThemeContext = E$2({
  theme
});
const applyShopFontFamily = (fontFamily2) => {
  const style = document.createElement("style");
  const cssRule = `#dialog-shopify-ai * { font-family: ${fontFamily2}; }
  #dialog-drawer * { font-family: ${fontFamily2}; }`;
  style.appendChild(document.createTextNode(cssRule));
  document.head.appendChild(style);
};
const ThemeProvider2 = ({
  children,
  primaryColor: primaryColor2 = "#000000",
  ctaTextColor: ctaTextColor2 = "#FFFFFF",
  backgroundColor: backgroundColor2 = "#FFFFFF",
  ctaBorderType: ctaBorderType2 = "rounded",
  fontFamily: fontFamily2 = "Inter, sans-serif",
  capitalizeCtas: capitalizeCtas2,
  highlightProductName: highlightProductName2
}) => {
  _(() => {
    applyShopFontFamily(fontFamily2);
  }, [fontFamily2]);
  const [customTheme] = p$1({
    ...theme,
    capitalizeCtas: capitalizeCtas2,
    highlightProductName: highlightProductName2,
    palette: {
      ...theme.palette,
      custom: {
        primaryColor: primaryColor2,
        ctaTextColor: ctaTextColor2,
        backgroundColor: backgroundColor2,
        ctaBorderType: ctaBorderType2
      }
    }
  });
  const contextValue = q$2(() => {
    return {
      theme: customTheme
    };
  }, [customTheme]);
  return (
    //@ts-expect-error weird compat issues with preact - don't know how to fix
    /* @__PURE__ */ u$2(ThemeContext.Provider, { value: contextValue, children: /* @__PURE__ */ u$2(ThemeProvider$1, { theme: customTheme, children }) })
  );
};
const ContainerWatcherContext = E$2({
  containerInformations: void 0,
  additionalContainerInformations: void 0,
  setupAdditionalContainerInformations: () => console.log("ContainerWatch not initialized")
});
const useContainerWatcher = () => P$1(ContainerWatcherContext);
const getContainerInformations = (element2) => {
  const { x: x2, y: y2, width, height, top, left, right } = element2.getBoundingClientRect();
  return {
    x: x2,
    y: y2,
    width,
    height,
    top,
    left,
    right,
    scrollHeight: element2.scrollHeight,
    scrollTop: element2.scrollTop
  };
};
const ContainerWatcherProvider = ({
  children,
  containerRef,
  watchScroll
}) => {
  const savedContainerRef = F$1(containerRef.current);
  const [containerInformations, setContainerInformations] = p$1();
  const [additionalContainerInformations, setAdditionalContainerInformations] = p$1();
  const setupAdditionalContainerInformations = x$2(
    (container) => {
      setAdditionalContainerInformations(getContainerInformations(container));
    },
    [setAdditionalContainerInformations]
  );
  const updateInformationOnScroll = x$2(() => {
    if (containerRef.current === null) return;
    setContainerInformations(getContainerInformations(containerRef.current));
  }, [containerRef]);
  _(() => {
    if (containerRef.current === null) return;
    savedContainerRef.current = containerRef.current;
    setContainerInformations(getContainerInformations(containerRef.current));
    if (watchScroll === true) {
      containerRef.current.addEventListener(
        "scroll",
        updateInformationOnScroll
      );
    }
    return () => {
      if (savedContainerRef.current === null) return;
      savedContainerRef.current.removeEventListener(
        "scroll",
        updateInformationOnScroll
      );
    };
  }, [containerRef, savedContainerRef, updateInformationOnScroll, watchScroll]);
  const contextValue = q$2(() => {
    return {
      containerInformations,
      setupAdditionalContainerInformations,
      additionalContainerInformations
    };
  }, [
    additionalContainerInformations,
    containerInformations,
    setupAdditionalContainerInformations
  ]);
  return /* @__PURE__ */ u$2(ContainerWatcherContext.Provider, { value: contextValue, children });
};
var Fragment = g$3;
var jsx2 = function jsx3(type2, props, key) {
  if (!hasOwn$1.call(props, "css")) {
    return u$2(type2, props, key);
  }
  return u$2(Emotion$1, createEmotionProps(type2, props), key);
};
var jsxs = function jsxs2(type2, props, key) {
  if (!hasOwn$1.call(props, "css")) {
    return u$2(type2, props, key);
  }
  return u$2(Emotion$1, createEmotionProps(type2, props), key);
};
const MODAL_STATE = "MODAL_VIEW";
const CHAT_STATE = "MESSAGES_VIEW";
const HIDDEN_STATE = "HIDDEN_VIEW";
const CLOSED_STATE = "CLOSED_VIEW";
const BOOKMARK_STATE = "BOOKMARK_VIEW";
const assistantChatShoppingContainerStyle = css({
  width: "100%",
  height: "100%",
  display: "flex",
  flexDirection: "column",
  boxSizing: "border-box"
});
const AssistantChatShoppingHeader = ({
  title: title2,
  description: description2,
  onClose
}) => {
  const isMobile = useIsMobile({ size: MEDIUM_MOBILE_NUMBER });
  const { messages } = useAssistantMessages();
  const { config: dialogConfig } = useDialogConfig();
  const hasProductQuestion = messages.some(
    (msg) => msg.selectedProduct !== void 0
  );
  const config2 = (dialogConfig == null ? void 0 : dialogConfig.modalTriggers) !== void 0 ? dialogConfig.modalTriggers[0] : void 0;
  return /* @__PURE__ */ jsxs(
    "div",
    {
      css: css({
        width: "100%",
        display: "flex",
        justifyContent: "space-between"
      }),
      children: [
        /* @__PURE__ */ jsxs("div", { css: css({ display: "flex", flexDirection: "column" }), children: [
          /* @__PURE__ */ jsx2(
            Typography,
            {
              variant: "xs-md",
              customCss: css({
                display: "block",
                textAlign: "left",
                color: theme.palette.grey400,
                textTransform: "uppercase"
              }),
              children: (config2 == null ? void 0 : config2.assistantName) ?? title2
            }
          ),
          hasProductQuestion && /* @__PURE__ */ jsx2(
            Typography,
            {
              variant: isMobile ? "sm-md" : "base-md",
              customCss: css({
                display: "block",
                textAlign: "left"
              }),
              color: theme.palette.primary.main,
              children: (config2 == null ? void 0 : config2.description) ?? description2
            }
          )
        ] }),
        /* @__PURE__ */ jsx2(
          Button,
          {
            enableCleanIconOnlyStyle: true,
            variant: "blank",
            iconLeft: /* @__PURE__ */ jsx2(CrossIcon, {}),
            onClick: onClose
          }
        )
      ]
    }
  );
};
const blockTypoStyle = css({
  paddingRight: spacings.md,
  whiteSpace: "normal",
  [`@media screen and (max-width: ${TABLET_BP})`]: {
    fontSize: "12px"
  }
});
const blockStyle = css({
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "flex-start",
  verticalAlign: "bottom",
  width: "fit-content",
  border: `1px solid ${theme.palette.grey200}`,
  borderRadius: theme.borderRadius.xxl,
  padding: `${spacings.md} ${spacings.lg}`,
  background: theme.palette.classic.white,
  gap: spacings.sm,
  "&:not(&:last-of-type)": {
    marginRight: spacings.sm
  },
  "&:hover": {
    transform: "scale(1.01)"
  },
  [`@media screen and (max-width: ${TABLET_BP})`]: {
    padding: `${spacings.sm} ${spacings.sm}`
  }
});
const Suggestion = ({
  title: title2,
  onSelect,
  customStyle,
  theme: theme$1 = theme
}) => {
  const postHog = usePostHog();
  const onClick = () => {
    onSelect(title2);
    postHog.capture(TRACKING_EVENTS.USER_CLICKED_SUGGESTION, {
      question: title2
    });
  };
  return /* @__PURE__ */ jsxs(
    DivClickable,
    {
      customCss: [blockStyle, customStyle ?? css({})],
      onClick,
      children: [
        /* @__PURE__ */ jsx2(StarsIcon, { color: theme$1.palette.custom.primaryColor }),
        /* @__PURE__ */ jsx2(
          Typography,
          {
            variant: "sm-md",
            customCss: blockTypoStyle,
            color: theme$1.palette.classic.black,
            children: title2
          }
        )
      ]
    }
  );
};
const SuggestionThemed = withTheme(Suggestion);
const Suggestions = ({
  suggestions,
  sendMessage
}) => {
  const { isFeatureDisabled } = useDialogConfig();
  if (suggestions === void 0 || isFeatureDisabled(Features.SUGGESTIONS))
    return /* @__PURE__ */ jsx2(Fragment, {});
  return /* @__PURE__ */ jsx2(
    ScrollContainer,
    {
      scrollType: "full",
      customContainerStyle: css({
        display: "block",
        whiteSpace: "nowrap",
        padding: `0 ${spacings.xs}`
      }),
      children: suggestions.map((question, index2) => /* @__PURE__ */ jsx2(
        SuggestionThemed,
        {
          title: question,
          onSelect: sendMessage,
          customStyle: css({ maxWidth: "90%" })
        },
        `${question}-${index2}`
      ))
    }
  );
};
const getMessagesAIKey = ({
  userId: userId2
}) => {
  return ["messages-ai", { userId: userId2 }];
};
const useGetMessagesAI = ({
  apiKey: apiKey2,
  enabled = true,
  userId: userId2,
  onSuccess,
  onError
}) => {
  const key = getMessagesAIKey({ userId: userId2 });
  const onMutationSuccess = (data) => {
    onSuccess == null ? void 0 : onSuccess(data);
  };
  return useQuery(
    key,
    async () => getMessagesAI({
      apiKey: apiKey2,
      userId: userId2
    }),
    {
      enabled,
      retry: false,
      onSuccess: onMutationSuccess,
      onError
    }
  );
};
const parseAiMessage = (message) => {
  const messageWithoutContext = message.replace(
    /<ProductPage>.*?<\/ProductPage>/s,
    ""
  );
  const legacyPattern = /question asked on the page of the product:.*?:/;
  return messageWithoutContext.replace(legacyPattern, "").trim();
};
function ccount(value, character2) {
  const source = String(value);
  if (typeof character2 !== "string") {
    throw new TypeError("Expected character");
  }
  let count = 0;
  let index2 = source.indexOf(character2);
  while (index2 !== -1) {
    count++;
    index2 = source.indexOf(character2, index2 + character2.length);
  }
  return count;
}
function ok$1() {
}
function unreachable() {
}
const asciiAlpha = regexCheck(/[A-Za-z]/);
const asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
const asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
function asciiControl(code2) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    code2 !== null && (code2 < 32 || code2 === 127)
  );
}
const asciiDigit = regexCheck(/\d/);
const asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
function markdownLineEnding(code2) {
  return code2 !== null && code2 < -2;
}
function markdownLineEndingOrSpace(code2) {
  return code2 !== null && (code2 < 0 || code2 === 32);
}
function markdownSpace(code2) {
  return code2 === -2 || code2 === -1 || code2 === 32;
}
const unicodePunctuation = regexCheck(new RegExp("\\p{P}|\\p{S}", "u"));
const unicodeWhitespace = regexCheck(/\s/);
function regexCheck(regex) {
  return check;
  function check(code2) {
    return code2 !== null && code2 > -1 && regex.test(String.fromCharCode(code2));
  }
}
function escapeStringRegexp(string2) {
  if (typeof string2 !== "string") {
    throw new TypeError("Expected a string");
  }
  return string2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
const convert = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(test2) {
    if (test2 === null || test2 === void 0) {
      return ok;
    }
    if (typeof test2 === "function") {
      return castFactory(test2);
    }
    if (typeof test2 === "object") {
      return Array.isArray(test2) ? anyFactory(test2) : propsFactory(test2);
    }
    if (typeof test2 === "string") {
      return typeFactory(test2);
    }
    throw new Error("Expected function, string, or object as test");
  }
);
function anyFactory(tests) {
  const checks2 = [];
  let index2 = -1;
  while (++index2 < tests.length) {
    checks2[index2] = convert(tests[index2]);
  }
  return castFactory(any);
  function any(...parameters) {
    let index3 = -1;
    while (++index3 < checks2.length) {
      if (checks2[index3].apply(this, parameters)) return true;
    }
    return false;
  }
}
function propsFactory(check) {
  const checkAsRecord = (
    /** @type {Record<string, unknown>} */
    check
  );
  return castFactory(all3);
  function all3(node2) {
    const nodeAsRecord = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      node2
    );
    let key;
    for (key in check) {
      if (nodeAsRecord[key] !== checkAsRecord[key]) return false;
    }
    return true;
  }
}
function typeFactory(check) {
  return castFactory(type2);
  function type2(node2) {
    return node2 && node2.type === check;
  }
}
function castFactory(testFunction) {
  return check;
  function check(value, index2, parent) {
    return Boolean(
      looksLikeANode(value) && testFunction.call(
        this,
        value,
        typeof index2 === "number" ? index2 : void 0,
        parent || void 0
      )
    );
  }
}
function ok() {
  return true;
}
function looksLikeANode(value) {
  return value !== null && typeof value === "object" && "type" in value;
}
function color(d2) {
  return d2;
}
const empty$1 = [];
const CONTINUE = true;
const EXIT = false;
const SKIP = "skip";
function visitParents(tree, test2, visitor, reverse) {
  let check;
  if (typeof test2 === "function" && typeof visitor !== "function") {
    reverse = visitor;
    visitor = test2;
  } else {
    check = test2;
  }
  const is2 = convert(check);
  const step = reverse ? -1 : 1;
  factory(tree, void 0, [])();
  function factory(node2, index2, parents) {
    const value = (
      /** @type {Record<string, unknown>} */
      node2 && typeof node2 === "object" ? node2 : {}
    );
    if (typeof value.type === "string") {
      const name2 = (
        // `hast`
        typeof value.tagName === "string" ? value.tagName : (
          // `xast`
          typeof value.name === "string" ? value.name : void 0
        )
      );
      Object.defineProperty(visit2, "name", {
        value: "node (" + color(node2.type + (name2 ? "<" + name2 + ">" : "")) + ")"
      });
    }
    return visit2;
    function visit2() {
      let result = empty$1;
      let subresult;
      let offset;
      let grandparents;
      if (!test2 || is2(node2, index2, parents[parents.length - 1] || void 0)) {
        result = toResult(visitor(node2, parents));
        if (result[0] === EXIT) {
          return result;
        }
      }
      if ("children" in node2 && node2.children) {
        const nodeAsParent = (
          /** @type {UnistParent} */
          node2
        );
        if (nodeAsParent.children && result[0] !== SKIP) {
          offset = (reverse ? nodeAsParent.children.length : -1) + step;
          grandparents = parents.concat(nodeAsParent);
          while (offset > -1 && offset < nodeAsParent.children.length) {
            const child = nodeAsParent.children[offset];
            subresult = factory(child, offset, grandparents)();
            if (subresult[0] === EXIT) {
              return subresult;
            }
            offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
          }
        }
      }
      return result;
    }
  }
}
function toResult(value) {
  if (Array.isArray(value)) {
    return value;
  }
  if (typeof value === "number") {
    return [CONTINUE, value];
  }
  return value === null || value === void 0 ? empty$1 : [value];
}
function findAndReplace(tree, list2, options) {
  const settings = options;
  const ignored = convert(settings.ignore || []);
  const pairs = toPairs(list2);
  let pairIndex = -1;
  while (++pairIndex < pairs.length) {
    visitParents(tree, "text", visitor);
  }
  function visitor(node2, parents) {
    let index2 = -1;
    let grandparent;
    while (++index2 < parents.length) {
      const parent = parents[index2];
      const siblings = grandparent ? grandparent.children : void 0;
      if (ignored(
        parent,
        siblings ? siblings.indexOf(parent) : void 0,
        grandparent
      )) {
        return;
      }
      grandparent = parent;
    }
    if (grandparent) {
      return handler(node2, parents);
    }
  }
  function handler(node2, parents) {
    const parent = parents[parents.length - 1];
    const find2 = pairs[pairIndex][0];
    const replace2 = pairs[pairIndex][1];
    let start2 = 0;
    const siblings = parent.children;
    const index2 = siblings.indexOf(node2);
    let change = false;
    let nodes = [];
    find2.lastIndex = 0;
    let match2 = find2.exec(node2.value);
    while (match2) {
      const position2 = match2.index;
      const matchObject = {
        index: match2.index,
        input: match2.input,
        stack: [...parents, node2]
      };
      let value = replace2(...match2, matchObject);
      if (typeof value === "string") {
        value = value.length > 0 ? { type: "text", value } : void 0;
      }
      if (value === false) {
        find2.lastIndex = position2 + 1;
      } else {
        if (start2 !== position2) {
          nodes.push({
            type: "text",
            value: node2.value.slice(start2, position2)
          });
        }
        if (Array.isArray(value)) {
          nodes.push(...value);
        } else if (value) {
          nodes.push(value);
        }
        start2 = position2 + match2[0].length;
        change = true;
      }
      if (!find2.global) {
        break;
      }
      match2 = find2.exec(node2.value);
    }
    if (change) {
      if (start2 < node2.value.length) {
        nodes.push({ type: "text", value: node2.value.slice(start2) });
      }
      parent.children.splice(index2, 1, ...nodes);
    } else {
      nodes = [node2];
    }
    return index2 + nodes.length;
  }
}
function toPairs(tupleOrList) {
  const result = [];
  if (!Array.isArray(tupleOrList)) {
    throw new TypeError("Expected find and replace tuple or list of tuples");
  }
  const list2 = !tupleOrList[0] || Array.isArray(tupleOrList[0]) ? tupleOrList : [tupleOrList];
  let index2 = -1;
  while (++index2 < list2.length) {
    const tuple = list2[index2];
    result.push([toExpression(tuple[0]), toFunction(tuple[1])]);
  }
  return result;
}
function toExpression(find2) {
  return typeof find2 === "string" ? new RegExp(escapeStringRegexp(find2), "g") : find2;
}
function toFunction(replace2) {
  return typeof replace2 === "function" ? replace2 : function() {
    return replace2;
  };
}
const inConstruct = "phrasing";
const notInConstruct = ["autolink", "link", "image", "label"];
function gfmAutolinkLiteralFromMarkdown() {
  return {
    transforms: [transformGfmAutolinkLiterals],
    enter: {
      literalAutolink: enterLiteralAutolink,
      literalAutolinkEmail: enterLiteralAutolinkValue,
      literalAutolinkHttp: enterLiteralAutolinkValue,
      literalAutolinkWww: enterLiteralAutolinkValue
    },
    exit: {
      literalAutolink: exitLiteralAutolink,
      literalAutolinkEmail: exitLiteralAutolinkEmail,
      literalAutolinkHttp: exitLiteralAutolinkHttp,
      literalAutolinkWww: exitLiteralAutolinkWww
    }
  };
}
function gfmAutolinkLiteralToMarkdown() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct,
        notInConstruct
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct,
        notInConstruct
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct,
        notInConstruct
      }
    ]
  };
}
function enterLiteralAutolink(token2) {
  this.enter({ type: "link", title: null, url: "", children: [] }, token2);
}
function enterLiteralAutolinkValue(token2) {
  this.config.enter.autolinkProtocol.call(this, token2);
}
function exitLiteralAutolinkHttp(token2) {
  this.config.exit.autolinkProtocol.call(this, token2);
}
function exitLiteralAutolinkWww(token2) {
  this.config.exit.data.call(this, token2);
  const node2 = this.stack[this.stack.length - 1];
  ok$1(node2.type === "link");
  node2.url = "http://" + this.sliceSerialize(token2);
}
function exitLiteralAutolinkEmail(token2) {
  this.config.exit.autolinkEmail.call(this, token2);
}
function exitLiteralAutolink(token2) {
  this.exit(token2);
}
function transformGfmAutolinkLiterals(tree) {
  findAndReplace(
    tree,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, findUrl],
      [new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), findEmail]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function findUrl(_2, protocol, domain2, path2, match2) {
  let prefix2 = "";
  if (!previous$1(match2)) {
    return false;
  }
  if (/^w/i.test(protocol)) {
    domain2 = protocol + domain2;
    protocol = "";
    prefix2 = "http://";
  }
  if (!isCorrectDomain(domain2)) {
    return false;
  }
  const parts = splitUrl(domain2 + path2);
  if (!parts[0]) return false;
  const result = {
    type: "link",
    title: null,
    url: prefix2 + protocol + parts[0],
    children: [{ type: "text", value: protocol + parts[0] }]
  };
  if (parts[1]) {
    return [result, { type: "text", value: parts[1] }];
  }
  return result;
}
function findEmail(_2, atext, label, match2) {
  if (
    // Not an expected previous character.
    !previous$1(match2, true) || // Label ends in not allowed character.
    /[-\d_]$/.test(label)
  ) {
    return false;
  }
  return {
    type: "link",
    title: null,
    url: "mailto:" + atext + "@" + label,
    children: [{ type: "text", value: atext + "@" + label }]
  };
}
function isCorrectDomain(domain2) {
  const parts = domain2.split(".");
  if (parts.length < 2 || parts[parts.length - 1] && (/_/.test(parts[parts.length - 1]) || !/[a-zA-Z\d]/.test(parts[parts.length - 1])) || parts[parts.length - 2] && (/_/.test(parts[parts.length - 2]) || !/[a-zA-Z\d]/.test(parts[parts.length - 2]))) {
    return false;
  }
  return true;
}
function splitUrl(url) {
  const trailExec = /[!"&'),.:;<>?\]}]+$/.exec(url);
  if (!trailExec) {
    return [url, void 0];
  }
  url = url.slice(0, trailExec.index);
  let trail2 = trailExec[0];
  let closingParenIndex = trail2.indexOf(")");
  const openingParens = ccount(url, "(");
  let closingParens = ccount(url, ")");
  while (closingParenIndex !== -1 && openingParens > closingParens) {
    url += trail2.slice(0, closingParenIndex + 1);
    trail2 = trail2.slice(closingParenIndex + 1);
    closingParenIndex = trail2.indexOf(")");
    closingParens++;
  }
  return [url, trail2];
}
function previous$1(match2, email) {
  const code2 = match2.input.charCodeAt(match2.index - 1);
  return (match2.index === 0 || unicodeWhitespace(code2) || unicodePunctuation(code2)) && // If its an email, the previous character should not be a slash.
  (!email || code2 !== 47);
}
function normalizeIdentifier(value) {
  return value.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
footnoteReference$1.peek = footnoteReferencePeek;
function gfmFootnoteFromMarkdown() {
  return {
    enter: {
      gfmFootnoteDefinition: enterFootnoteDefinition,
      gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,
      gfmFootnoteCall: enterFootnoteCall,
      gfmFootnoteCallString: enterFootnoteCallString
    },
    exit: {
      gfmFootnoteDefinition: exitFootnoteDefinition,
      gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,
      gfmFootnoteCall: exitFootnoteCall,
      gfmFootnoteCallString: exitFootnoteCallString
    }
  };
}
function gfmFootnoteToMarkdown() {
  return {
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["phrasing", "label", "reference"] }],
    handlers: { footnoteDefinition, footnoteReference: footnoteReference$1 }
  };
}
function enterFootnoteDefinition(token2) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    token2
  );
}
function enterFootnoteDefinitionLabelString() {
  this.buffer();
}
function exitFootnoteDefinitionLabelString(token2) {
  const label = this.resume();
  const node2 = this.stack[this.stack.length - 1];
  ok$1(node2.type === "footnoteDefinition");
  node2.label = label;
  node2.identifier = normalizeIdentifier(
    this.sliceSerialize(token2)
  ).toLowerCase();
}
function exitFootnoteDefinition(token2) {
  this.exit(token2);
}
function enterFootnoteCall(token2) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, token2);
}
function enterFootnoteCallString() {
  this.buffer();
}
function exitFootnoteCallString(token2) {
  const label = this.resume();
  const node2 = this.stack[this.stack.length - 1];
  ok$1(node2.type === "footnoteReference");
  node2.label = label;
  node2.identifier = normalizeIdentifier(
    this.sliceSerialize(token2)
  ).toLowerCase();
}
function exitFootnoteCall(token2) {
  this.exit(token2);
}
function footnoteReference$1(node2, _2, state, info) {
  const tracker = state.createTracker(info);
  let value = tracker.move("[^");
  const exit2 = state.enter("footnoteReference");
  const subexit = state.enter("reference");
  value += tracker.move(
    state.safe(state.associationId(node2), {
      ...tracker.current(),
      before: value,
      after: "]"
    })
  );
  subexit();
  exit2();
  value += tracker.move("]");
  return value;
}
function footnoteReferencePeek() {
  return "[";
}
function footnoteDefinition(node2, _2, state, info) {
  const tracker = state.createTracker(info);
  let value = tracker.move("[^");
  const exit2 = state.enter("footnoteDefinition");
  const subexit = state.enter("label");
  value += tracker.move(
    state.safe(state.associationId(node2), {
      ...tracker.current(),
      before: value,
      after: "]"
    })
  );
  subexit();
  value += tracker.move(
    "]:" + (node2.children && node2.children.length > 0 ? " " : "")
  );
  tracker.shift(4);
  value += tracker.move(
    state.indentLines(state.containerFlow(node2, tracker.current()), map$2)
  );
  exit2();
  return value;
}
function map$2(line2, index2, blank) {
  if (index2 === 0) {
    return line2;
  }
  return (blank ? "" : "    ") + line2;
}
const constructsWithoutStrikethrough = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
handleDelete.peek = peekDelete;
function gfmStrikethroughFromMarkdown() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: enterStrikethrough },
    exit: { strikethrough: exitStrikethrough }
  };
}
function gfmStrikethroughToMarkdown() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: constructsWithoutStrikethrough
      }
    ],
    handlers: { delete: handleDelete }
  };
}
function enterStrikethrough(token2) {
  this.enter({ type: "delete", children: [] }, token2);
}
function exitStrikethrough(token2) {
  this.exit(token2);
}
function handleDelete(node2, _2, state, info) {
  const tracker = state.createTracker(info);
  const exit2 = state.enter("strikethrough");
  let value = tracker.move("~~");
  value += state.containerPhrasing(node2, {
    ...tracker.current(),
    before: value,
    after: "~"
  });
  value += tracker.move("~~");
  exit2();
  return value;
}
function peekDelete() {
  return "~";
}
function defaultStringLength(value) {
  return value.length;
}
function markdownTable(table2, options) {
  const settings = options;
  const align = (settings.align || []).concat();
  const stringLength = settings.stringLength || defaultStringLength;
  const alignments = [];
  const cellMatrix = [];
  const sizeMatrix = [];
  const longestCellByColumn = [];
  let mostCellsPerRow = 0;
  let rowIndex = -1;
  while (++rowIndex < table2.length) {
    const row2 = [];
    const sizes2 = [];
    let columnIndex2 = -1;
    if (table2[rowIndex].length > mostCellsPerRow) {
      mostCellsPerRow = table2[rowIndex].length;
    }
    while (++columnIndex2 < table2[rowIndex].length) {
      const cell = serialize$1(table2[rowIndex][columnIndex2]);
      if (settings.alignDelimiters !== false) {
        const size = stringLength(cell);
        sizes2[columnIndex2] = size;
        if (longestCellByColumn[columnIndex2] === void 0 || size > longestCellByColumn[columnIndex2]) {
          longestCellByColumn[columnIndex2] = size;
        }
      }
      row2.push(cell);
    }
    cellMatrix[rowIndex] = row2;
    sizeMatrix[rowIndex] = sizes2;
  }
  let columnIndex = -1;
  if (typeof align === "object" && "length" in align) {
    while (++columnIndex < mostCellsPerRow) {
      alignments[columnIndex] = toAlignment(align[columnIndex]);
    }
  } else {
    const code2 = toAlignment(align);
    while (++columnIndex < mostCellsPerRow) {
      alignments[columnIndex] = code2;
    }
  }
  columnIndex = -1;
  const row = [];
  const sizes = [];
  while (++columnIndex < mostCellsPerRow) {
    const code2 = alignments[columnIndex];
    let before = "";
    let after = "";
    if (code2 === 99) {
      before = ":";
      after = ":";
    } else if (code2 === 108) {
      before = ":";
    } else if (code2 === 114) {
      after = ":";
    }
    let size = settings.alignDelimiters === false ? 1 : Math.max(
      1,
      longestCellByColumn[columnIndex] - before.length - after.length
    );
    const cell = before + "-".repeat(size) + after;
    if (settings.alignDelimiters !== false) {
      size = before.length + size + after.length;
      if (size > longestCellByColumn[columnIndex]) {
        longestCellByColumn[columnIndex] = size;
      }
      sizes[columnIndex] = size;
    }
    row[columnIndex] = cell;
  }
  cellMatrix.splice(1, 0, row);
  sizeMatrix.splice(1, 0, sizes);
  rowIndex = -1;
  const lines = [];
  while (++rowIndex < cellMatrix.length) {
    const row2 = cellMatrix[rowIndex];
    const sizes2 = sizeMatrix[rowIndex];
    columnIndex = -1;
    const line2 = [];
    while (++columnIndex < mostCellsPerRow) {
      const cell = row2[columnIndex] || "";
      let before = "";
      let after = "";
      if (settings.alignDelimiters !== false) {
        const size = longestCellByColumn[columnIndex] - (sizes2[columnIndex] || 0);
        const code2 = alignments[columnIndex];
        if (code2 === 114) {
          before = " ".repeat(size);
        } else if (code2 === 99) {
          if (size % 2) {
            before = " ".repeat(size / 2 + 0.5);
            after = " ".repeat(size / 2 - 0.5);
          } else {
            before = " ".repeat(size / 2);
            after = before;
          }
        } else {
          after = " ".repeat(size);
        }
      }
      if (settings.delimiterStart !== false && !columnIndex) {
        line2.push("|");
      }
      if (settings.padding !== false && // Dont add the opening space if were not aligning and the cell is
      // empty: there will be a closing space.
      !(settings.alignDelimiters === false && cell === "") && (settings.delimiterStart !== false || columnIndex)) {
        line2.push(" ");
      }
      if (settings.alignDelimiters !== false) {
        line2.push(before);
      }
      line2.push(cell);
      if (settings.alignDelimiters !== false) {
        line2.push(after);
      }
      if (settings.padding !== false) {
        line2.push(" ");
      }
      if (settings.delimiterEnd !== false || columnIndex !== mostCellsPerRow - 1) {
        line2.push("|");
      }
    }
    lines.push(
      settings.delimiterEnd === false ? line2.join("").replace(/ +$/, "") : line2.join("")
    );
  }
  return lines.join("\n");
}
function serialize$1(value) {
  return value === null || value === void 0 ? "" : String(value);
}
function toAlignment(value) {
  const code2 = typeof value === "string" ? value.codePointAt(0) : 0;
  return code2 === 67 || code2 === 99 ? 99 : code2 === 76 || code2 === 108 ? 108 : code2 === 82 || code2 === 114 ? 114 : 0;
}
function blockquote$1(node2, _2, state, info) {
  const exit2 = state.enter("blockquote");
  const tracker = state.createTracker(info);
  tracker.move("> ");
  tracker.shift(2);
  const value = state.indentLines(
    state.containerFlow(node2, tracker.current()),
    map$1
  );
  exit2();
  return value;
}
function map$1(line2, _2, blank) {
  return ">" + (blank ? "" : " ") + line2;
}
function patternInScope(stack, pattern2) {
  return listInScope(stack, pattern2.inConstruct, true) && !listInScope(stack, pattern2.notInConstruct, false);
}
function listInScope(stack, list2, none) {
  if (typeof list2 === "string") {
    list2 = [list2];
  }
  if (!list2 || list2.length === 0) {
    return none;
  }
  let index2 = -1;
  while (++index2 < list2.length) {
    if (stack.includes(list2[index2])) {
      return true;
    }
  }
  return false;
}
function hardBreak$1(_2, _1, state, info) {
  let index2 = -1;
  while (++index2 < state.unsafe.length) {
    if (state.unsafe[index2].character === "\n" && patternInScope(state.stack, state.unsafe[index2])) {
      return /[ \t]/.test(info.before) ? "" : " ";
    }
  }
  return "\\\n";
}
function longestStreak(value, substring) {
  const source = String(value);
  let index2 = source.indexOf(substring);
  let expected = index2;
  let count = 0;
  let max = 0;
  if (typeof substring !== "string") {
    throw new TypeError("Expected substring");
  }
  while (index2 !== -1) {
    if (index2 === expected) {
      if (++count > max) {
        max = count;
      }
    } else {
      count = 1;
    }
    expected = index2 + substring.length;
    index2 = source.indexOf(substring, expected);
  }
  return max;
}
function formatCodeAsIndented(node2, state) {
  return Boolean(
    state.options.fences === false && node2.value && // If theres no info
    !node2.lang && // And theres a non-whitespace character
    /[^ \r\n]/.test(node2.value) && // And the value doesnt start or end in a blank
    !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(node2.value)
  );
}
function checkFence(state) {
  const marker = state.options.fence || "`";
  if (marker !== "`" && marker !== "~") {
    throw new Error(
      "Cannot serialize code with `" + marker + "` for `options.fence`, expected `` ` `` or `~`"
    );
  }
  return marker;
}
function code$2(node2, _2, state, info) {
  const marker = checkFence(state);
  const raw = node2.value || "";
  const suffix = marker === "`" ? "GraveAccent" : "Tilde";
  if (formatCodeAsIndented(node2, state)) {
    const exit3 = state.enter("codeIndented");
    const value2 = state.indentLines(raw, map);
    exit3();
    return value2;
  }
  const tracker = state.createTracker(info);
  const sequence = marker.repeat(Math.max(longestStreak(raw, marker) + 1, 3));
  const exit2 = state.enter("codeFenced");
  let value = tracker.move(sequence);
  if (node2.lang) {
    const subexit = state.enter(`codeFencedLang${suffix}`);
    value += tracker.move(
      state.safe(node2.lang, {
        before: value,
        after: " ",
        encode: ["`"],
        ...tracker.current()
      })
    );
    subexit();
  }
  if (node2.lang && node2.meta) {
    const subexit = state.enter(`codeFencedMeta${suffix}`);
    value += tracker.move(" ");
    value += tracker.move(
      state.safe(node2.meta, {
        before: value,
        after: "\n",
        encode: ["`"],
        ...tracker.current()
      })
    );
    subexit();
  }
  value += tracker.move("\n");
  if (raw) {
    value += tracker.move(raw + "\n");
  }
  value += tracker.move(sequence);
  exit2();
  return value;
}
function map(line2, _2, blank) {
  return (blank ? "" : "    ") + line2;
}
function checkQuote(state) {
  const marker = state.options.quote || '"';
  if (marker !== '"' && marker !== "'") {
    throw new Error(
      "Cannot serialize title with `" + marker + "` for `options.quote`, expected `\"`, or `'`"
    );
  }
  return marker;
}
function definition$1(node2, _2, state, info) {
  const quote = checkQuote(state);
  const suffix = quote === '"' ? "Quote" : "Apostrophe";
  const exit2 = state.enter("definition");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value = tracker.move("[");
  value += tracker.move(
    state.safe(state.associationId(node2), {
      before: value,
      after: "]",
      ...tracker.current()
    })
  );
  value += tracker.move("]: ");
  subexit();
  if (
    // If theres no url, or
    !node2.url || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(node2.url)
  ) {
    subexit = state.enter("destinationLiteral");
    value += tracker.move("<");
    value += tracker.move(
      state.safe(node2.url, { before: value, after: ">", ...tracker.current() })
    );
    value += tracker.move(">");
  } else {
    subexit = state.enter("destinationRaw");
    value += tracker.move(
      state.safe(node2.url, {
        before: value,
        after: node2.title ? " " : "\n",
        ...tracker.current()
      })
    );
  }
  subexit();
  if (node2.title) {
    subexit = state.enter(`title${suffix}`);
    value += tracker.move(" " + quote);
    value += tracker.move(
      state.safe(node2.title, {
        before: value,
        after: quote,
        ...tracker.current()
      })
    );
    value += tracker.move(quote);
    subexit();
  }
  exit2();
  return value;
}
function checkEmphasis(state) {
  const marker = state.options.emphasis || "*";
  if (marker !== "*" && marker !== "_") {
    throw new Error(
      "Cannot serialize emphasis with `" + marker + "` for `options.emphasis`, expected `*`, or `_`"
    );
  }
  return marker;
}
function encodeCharacterReference(code2) {
  return "&#x" + code2.toString(16).toUpperCase() + ";";
}
function classifyCharacter(code2) {
  if (code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
    return 1;
  }
  if (unicodePunctuation(code2)) {
    return 2;
  }
}
function encodeInfo(outside, inside, marker) {
  const outsideKind = classifyCharacter(outside);
  const insideKind = classifyCharacter(inside);
  if (outsideKind === void 0) {
    return insideKind === void 0 ? (
      // Letter inside:
      // we have to encode *both* letters for `_` as it is looser.
      // it already forms for `*` (and GFMs `~`).
      marker === "_" ? { inside: true, outside: true } : { inside: false, outside: false }
    ) : insideKind === 1 ? (
      // Whitespace inside: encode both (letter, whitespace).
      { inside: true, outside: true }
    ) : (
      // Punctuation inside: encode outer (letter)
      { inside: false, outside: true }
    );
  }
  if (outsideKind === 1) {
    return insideKind === void 0 ? (
      // Letter inside: already forms.
      { inside: false, outside: false }
    ) : insideKind === 1 ? (
      // Whitespace inside: encode both (whitespace).
      { inside: true, outside: true }
    ) : (
      // Punctuation inside: already forms.
      { inside: false, outside: false }
    );
  }
  return insideKind === void 0 ? (
    // Letter inside: already forms.
    { inside: false, outside: false }
  ) : insideKind === 1 ? (
    // Whitespace inside: encode inner (whitespace).
    { inside: true, outside: false }
  ) : (
    // Punctuation inside: already forms.
    { inside: false, outside: false }
  );
}
emphasis$1.peek = emphasisPeek;
function emphasis$1(node2, _2, state, info) {
  const marker = checkEmphasis(state);
  const exit2 = state.enter("emphasis");
  const tracker = state.createTracker(info);
  const before = tracker.move(marker);
  let between = tracker.move(
    state.containerPhrasing(node2, {
      after: marker,
      before,
      ...tracker.current()
    })
  );
  const betweenHead = between.charCodeAt(0);
  const open = encodeInfo(
    info.before.charCodeAt(info.before.length - 1),
    betweenHead,
    marker
  );
  if (open.inside) {
    between = encodeCharacterReference(betweenHead) + between.slice(1);
  }
  const betweenTail = between.charCodeAt(between.length - 1);
  const close = encodeInfo(info.after.charCodeAt(0), betweenTail, marker);
  if (close.inside) {
    between = between.slice(0, -1) + encodeCharacterReference(betweenTail);
  }
  const after = tracker.move(marker);
  exit2();
  state.attentionEncodeSurroundingInfo = {
    after: close.outside,
    before: open.outside
  };
  return before + between + after;
}
function emphasisPeek(_2, _1, state) {
  return state.options.emphasis || "*";
}
function visit(tree, testOrVisitor, visitorOrReverse, maybeReverse) {
  let reverse;
  let test2;
  let visitor;
  if (typeof testOrVisitor === "function" && typeof visitorOrReverse !== "function") {
    test2 = void 0;
    visitor = testOrVisitor;
    reverse = visitorOrReverse;
  } else {
    test2 = testOrVisitor;
    visitor = visitorOrReverse;
    reverse = maybeReverse;
  }
  visitParents(tree, test2, overload, reverse);
  function overload(node2, parents) {
    const parent = parents[parents.length - 1];
    const index2 = parent ? parent.children.indexOf(node2) : void 0;
    return visitor(node2, index2, parent);
  }
}
const emptyOptions$3 = {};
function toString$1(value, options) {
  const settings = emptyOptions$3;
  const includeImageAlt = typeof settings.includeImageAlt === "boolean" ? settings.includeImageAlt : true;
  const includeHtml = typeof settings.includeHtml === "boolean" ? settings.includeHtml : true;
  return one$1(value, includeImageAlt, includeHtml);
}
function one$1(value, includeImageAlt, includeHtml) {
  if (node(value)) {
    if ("value" in value) {
      return value.type === "html" && !includeHtml ? "" : value.value;
    }
    if (includeImageAlt && "alt" in value && value.alt) {
      return value.alt;
    }
    if ("children" in value) {
      return all2(value.children, includeImageAlt, includeHtml);
    }
  }
  if (Array.isArray(value)) {
    return all2(value, includeImageAlt, includeHtml);
  }
  return "";
}
function all2(values, includeImageAlt, includeHtml) {
  const result = [];
  let index2 = -1;
  while (++index2 < values.length) {
    result[index2] = one$1(values[index2], includeImageAlt, includeHtml);
  }
  return result.join("");
}
function node(value) {
  return Boolean(value && typeof value === "object");
}
function formatHeadingAsSetext(node2, state) {
  let literalWithBreak = false;
  visit(node2, function(node3) {
    if ("value" in node3 && /\r?\n|\r/.test(node3.value) || node3.type === "break") {
      literalWithBreak = true;
      return EXIT;
    }
  });
  return Boolean(
    (!node2.depth || node2.depth < 3) && toString$1(node2) && (state.options.setext || literalWithBreak)
  );
}
function heading$1(node2, _2, state, info) {
  const rank = Math.max(Math.min(6, node2.depth || 1), 1);
  const tracker = state.createTracker(info);
  if (formatHeadingAsSetext(node2, state)) {
    const exit3 = state.enter("headingSetext");
    const subexit2 = state.enter("phrasing");
    const value2 = state.containerPhrasing(node2, {
      ...tracker.current(),
      before: "\n",
      after: "\n"
    });
    subexit2();
    exit3();
    return value2 + "\n" + (rank === 1 ? "=" : "-").repeat(
      // The whole size
      value2.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)
      (Math.max(value2.lastIndexOf("\r"), value2.lastIndexOf("\n")) + 1)
    );
  }
  const sequence = "#".repeat(rank);
  const exit2 = state.enter("headingAtx");
  const subexit = state.enter("phrasing");
  tracker.move(sequence + " ");
  let value = state.containerPhrasing(node2, {
    before: "# ",
    after: "\n",
    ...tracker.current()
  });
  if (/^[\t ]/.test(value)) {
    value = encodeCharacterReference(value.charCodeAt(0)) + value.slice(1);
  }
  value = value ? sequence + " " + value : sequence;
  if (state.options.closeAtx) {
    value += " " + sequence;
  }
  subexit();
  exit2();
  return value;
}
html$5.peek = htmlPeek;
function html$5(node2) {
  return node2.value || "";
}
function htmlPeek() {
  return "<";
}
image$1.peek = imagePeek;
function image$1(node2, _2, state, info) {
  const quote = checkQuote(state);
  const suffix = quote === '"' ? "Quote" : "Apostrophe";
  const exit2 = state.enter("image");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value = tracker.move("![");
  value += tracker.move(
    state.safe(node2.alt, { before: value, after: "]", ...tracker.current() })
  );
  value += tracker.move("](");
  subexit();
  if (
    // If theres no url but there is a title
    !node2.url && node2.title || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(node2.url)
  ) {
    subexit = state.enter("destinationLiteral");
    value += tracker.move("<");
    value += tracker.move(
      state.safe(node2.url, { before: value, after: ">", ...tracker.current() })
    );
    value += tracker.move(">");
  } else {
    subexit = state.enter("destinationRaw");
    value += tracker.move(
      state.safe(node2.url, {
        before: value,
        after: node2.title ? " " : ")",
        ...tracker.current()
      })
    );
  }
  subexit();
  if (node2.title) {
    subexit = state.enter(`title${suffix}`);
    value += tracker.move(" " + quote);
    value += tracker.move(
      state.safe(node2.title, {
        before: value,
        after: quote,
        ...tracker.current()
      })
    );
    value += tracker.move(quote);
    subexit();
  }
  value += tracker.move(")");
  exit2();
  return value;
}
function imagePeek() {
  return "!";
}
imageReference$1.peek = imageReferencePeek;
function imageReference$1(node2, _2, state, info) {
  const type2 = node2.referenceType;
  const exit2 = state.enter("imageReference");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value = tracker.move("![");
  const alt = state.safe(node2.alt, {
    before: value,
    after: "]",
    ...tracker.current()
  });
  value += tracker.move(alt + "][");
  subexit();
  const stack = state.stack;
  state.stack = [];
  subexit = state.enter("reference");
  const reference = state.safe(state.associationId(node2), {
    before: value,
    after: "]",
    ...tracker.current()
  });
  subexit();
  state.stack = stack;
  exit2();
  if (type2 === "full" || !alt || alt !== reference) {
    value += tracker.move(reference + "]");
  } else if (type2 === "shortcut") {
    value = value.slice(0, -1);
  } else {
    value += tracker.move("]");
  }
  return value;
}
function imageReferencePeek() {
  return "!";
}
inlineCode$1.peek = inlineCodePeek;
function inlineCode$1(node2, _2, state) {
  let value = node2.value || "";
  let sequence = "`";
  let index2 = -1;
  while (new RegExp("(^|[^`])" + sequence + "([^`]|$)").test(value)) {
    sequence += "`";
  }
  if (/[^ \r\n]/.test(value) && (/^[ \r\n]/.test(value) && /[ \r\n]$/.test(value) || /^`|`$/.test(value))) {
    value = " " + value + " ";
  }
  while (++index2 < state.unsafe.length) {
    const pattern2 = state.unsafe[index2];
    const expression = state.compilePattern(pattern2);
    let match2;
    if (!pattern2.atBreak) continue;
    while (match2 = expression.exec(value)) {
      let position2 = match2.index;
      if (value.charCodeAt(position2) === 10 && value.charCodeAt(position2 - 1) === 13) {
        position2--;
      }
      value = value.slice(0, position2) + " " + value.slice(match2.index + 1);
    }
  }
  return sequence + value + sequence;
}
function inlineCodePeek() {
  return "`";
}
function formatLinkAsAutolink(node2, state) {
  const raw = toString$1(node2);
  return Boolean(
    !state.options.resourceLink && // If theres a url
    node2.url && // And theres a no title
    !node2.title && // And the content of `node` is a single text node
    node2.children && node2.children.length === 1 && node2.children[0].type === "text" && // And if the url is the same as the content
    (raw === node2.url || "mailto:" + raw === node2.url) && // And that starts w/ a protocol
    /^[a-z][a-z+.-]+:/i.test(node2.url) && // And that doesnt contain ASCII control codes (character escapes and
    // references dont work), space, or angle brackets
    !/[\0- <>\u007F]/.test(node2.url)
  );
}
link$1.peek = linkPeek;
function link$1(node2, _2, state, info) {
  const quote = checkQuote(state);
  const suffix = quote === '"' ? "Quote" : "Apostrophe";
  const tracker = state.createTracker(info);
  let exit2;
  let subexit;
  if (formatLinkAsAutolink(node2, state)) {
    const stack = state.stack;
    state.stack = [];
    exit2 = state.enter("autolink");
    let value2 = tracker.move("<");
    value2 += tracker.move(
      state.containerPhrasing(node2, {
        before: value2,
        after: ">",
        ...tracker.current()
      })
    );
    value2 += tracker.move(">");
    exit2();
    state.stack = stack;
    return value2;
  }
  exit2 = state.enter("link");
  subexit = state.enter("label");
  let value = tracker.move("[");
  value += tracker.move(
    state.containerPhrasing(node2, {
      before: value,
      after: "](",
      ...tracker.current()
    })
  );
  value += tracker.move("](");
  subexit();
  if (
    // If theres no url but there is a title
    !node2.url && node2.title || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(node2.url)
  ) {
    subexit = state.enter("destinationLiteral");
    value += tracker.move("<");
    value += tracker.move(
      state.safe(node2.url, { before: value, after: ">", ...tracker.current() })
    );
    value += tracker.move(">");
  } else {
    subexit = state.enter("destinationRaw");
    value += tracker.move(
      state.safe(node2.url, {
        before: value,
        after: node2.title ? " " : ")",
        ...tracker.current()
      })
    );
  }
  subexit();
  if (node2.title) {
    subexit = state.enter(`title${suffix}`);
    value += tracker.move(" " + quote);
    value += tracker.move(
      state.safe(node2.title, {
        before: value,
        after: quote,
        ...tracker.current()
      })
    );
    value += tracker.move(quote);
    subexit();
  }
  value += tracker.move(")");
  exit2();
  return value;
}
function linkPeek(node2, _2, state) {
  return formatLinkAsAutolink(node2, state) ? "<" : "[";
}
linkReference$1.peek = linkReferencePeek;
function linkReference$1(node2, _2, state, info) {
  const type2 = node2.referenceType;
  const exit2 = state.enter("linkReference");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value = tracker.move("[");
  const text2 = state.containerPhrasing(node2, {
    before: value,
    after: "]",
    ...tracker.current()
  });
  value += tracker.move(text2 + "][");
  subexit();
  const stack = state.stack;
  state.stack = [];
  subexit = state.enter("reference");
  const reference = state.safe(state.associationId(node2), {
    before: value,
    after: "]",
    ...tracker.current()
  });
  subexit();
  state.stack = stack;
  exit2();
  if (type2 === "full" || !text2 || text2 !== reference) {
    value += tracker.move(reference + "]");
  } else if (type2 === "shortcut") {
    value = value.slice(0, -1);
  } else {
    value += tracker.move("]");
  }
  return value;
}
function linkReferencePeek() {
  return "[";
}
function checkBullet(state) {
  const marker = state.options.bullet || "*";
  if (marker !== "*" && marker !== "+" && marker !== "-") {
    throw new Error(
      "Cannot serialize items with `" + marker + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  }
  return marker;
}
function checkBulletOther(state) {
  const bullet = checkBullet(state);
  const bulletOther = state.options.bulletOther;
  if (!bulletOther) {
    return bullet === "*" ? "-" : "*";
  }
  if (bulletOther !== "*" && bulletOther !== "+" && bulletOther !== "-") {
    throw new Error(
      "Cannot serialize items with `" + bulletOther + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  }
  if (bulletOther === bullet) {
    throw new Error(
      "Expected `bullet` (`" + bullet + "`) and `bulletOther` (`" + bulletOther + "`) to be different"
    );
  }
  return bulletOther;
}
function checkBulletOrdered(state) {
  const marker = state.options.bulletOrdered || ".";
  if (marker !== "." && marker !== ")") {
    throw new Error(
      "Cannot serialize items with `" + marker + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  }
  return marker;
}
function checkRule(state) {
  const marker = state.options.rule || "*";
  if (marker !== "*" && marker !== "-" && marker !== "_") {
    throw new Error(
      "Cannot serialize rules with `" + marker + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  }
  return marker;
}
function list$2(node2, parent, state, info) {
  const exit2 = state.enter("list");
  const bulletCurrent = state.bulletCurrent;
  let bullet = node2.ordered ? checkBulletOrdered(state) : checkBullet(state);
  const bulletOther = node2.ordered ? bullet === "." ? ")" : "." : checkBulletOther(state);
  let useDifferentMarker = parent && state.bulletLastUsed ? bullet === state.bulletLastUsed : false;
  if (!node2.ordered) {
    const firstListItem = node2.children ? node2.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (bullet === "*" || bullet === "-") && // Empty first list item:
      firstListItem && (!firstListItem.children || !firstListItem.children[0]) && // Directly in two other list items:
      state.stack[state.stack.length - 1] === "list" && state.stack[state.stack.length - 2] === "listItem" && state.stack[state.stack.length - 3] === "list" && state.stack[state.stack.length - 4] === "listItem" && // That are each the first child.
      state.indexStack[state.indexStack.length - 1] === 0 && state.indexStack[state.indexStack.length - 2] === 0 && state.indexStack[state.indexStack.length - 3] === 0
    ) {
      useDifferentMarker = true;
    }
    if (checkRule(state) === bullet && firstListItem) {
      let index2 = -1;
      while (++index2 < node2.children.length) {
        const item = node2.children[index2];
        if (item && item.type === "listItem" && item.children && item.children[0] && item.children[0].type === "thematicBreak") {
          useDifferentMarker = true;
          break;
        }
      }
    }
  }
  if (useDifferentMarker) {
    bullet = bulletOther;
  }
  state.bulletCurrent = bullet;
  const value = state.containerFlow(node2, info);
  state.bulletLastUsed = bullet;
  state.bulletCurrent = bulletCurrent;
  exit2();
  return value;
}
function checkListItemIndent(state) {
  const style = state.options.listItemIndent || "one";
  if (style !== "tab" && style !== "one" && style !== "mixed") {
    throw new Error(
      "Cannot serialize items with `" + style + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  }
  return style;
}
function listItem$1(node2, parent, state, info) {
  const listItemIndent = checkListItemIndent(state);
  let bullet = state.bulletCurrent || checkBullet(state);
  if (parent && parent.type === "list" && parent.ordered) {
    bullet = (typeof parent.start === "number" && parent.start > -1 ? parent.start : 1) + (state.options.incrementListMarker === false ? 0 : parent.children.indexOf(node2)) + bullet;
  }
  let size = bullet.length + 1;
  if (listItemIndent === "tab" || listItemIndent === "mixed" && (parent && parent.type === "list" && parent.spread || node2.spread)) {
    size = Math.ceil(size / 4) * 4;
  }
  const tracker = state.createTracker(info);
  tracker.move(bullet + " ".repeat(size - bullet.length));
  tracker.shift(size);
  const exit2 = state.enter("listItem");
  const value = state.indentLines(
    state.containerFlow(node2, tracker.current()),
    map2
  );
  exit2();
  return value;
  function map2(line2, index2, blank) {
    if (index2) {
      return (blank ? "" : " ".repeat(size)) + line2;
    }
    return (blank ? bullet : bullet + " ".repeat(size - bullet.length)) + line2;
  }
}
function paragraph$1(node2, _2, state, info) {
  const exit2 = state.enter("paragraph");
  const subexit = state.enter("phrasing");
  const value = state.containerPhrasing(node2, info);
  subexit();
  exit2();
  return value;
}
const phrasing = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  convert([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function root$2(node2, _2, state, info) {
  const hasPhrasing = node2.children.some(function(d2) {
    return phrasing(d2);
  });
  const container = hasPhrasing ? state.containerPhrasing : state.containerFlow;
  return container.call(state, node2, info);
}
function checkStrong(state) {
  const marker = state.options.strong || "*";
  if (marker !== "*" && marker !== "_") {
    throw new Error(
      "Cannot serialize strong with `" + marker + "` for `options.strong`, expected `*`, or `_`"
    );
  }
  return marker;
}
strong$1.peek = strongPeek;
function strong$1(node2, _2, state, info) {
  const marker = checkStrong(state);
  const exit2 = state.enter("strong");
  const tracker = state.createTracker(info);
  const before = tracker.move(marker + marker);
  let between = tracker.move(
    state.containerPhrasing(node2, {
      after: marker,
      before,
      ...tracker.current()
    })
  );
  const betweenHead = between.charCodeAt(0);
  const open = encodeInfo(
    info.before.charCodeAt(info.before.length - 1),
    betweenHead,
    marker
  );
  if (open.inside) {
    between = encodeCharacterReference(betweenHead) + between.slice(1);
  }
  const betweenTail = between.charCodeAt(between.length - 1);
  const close = encodeInfo(info.after.charCodeAt(0), betweenTail, marker);
  if (close.inside) {
    between = between.slice(0, -1) + encodeCharacterReference(betweenTail);
  }
  const after = tracker.move(marker + marker);
  exit2();
  state.attentionEncodeSurroundingInfo = {
    after: close.outside,
    before: open.outside
  };
  return before + between + after;
}
function strongPeek(_2, _1, state) {
  return state.options.strong || "*";
}
function text$6(node2, _2, state, info) {
  return state.safe(node2.value, info);
}
function checkRuleRepetition(state) {
  const repetition = state.options.ruleRepetition || 3;
  if (repetition < 3) {
    throw new Error(
      "Cannot serialize rules with repetition `" + repetition + "` for `options.ruleRepetition`, expected `3` or more"
    );
  }
  return repetition;
}
function thematicBreak$2(_2, _1, state) {
  const value = (checkRule(state) + (state.options.ruleSpaces ? " " : "")).repeat(checkRuleRepetition(state));
  return state.options.ruleSpaces ? value.slice(0, -1) : value;
}
const handle = {
  blockquote: blockquote$1,
  break: hardBreak$1,
  code: code$2,
  definition: definition$1,
  emphasis: emphasis$1,
  hardBreak: hardBreak$1,
  heading: heading$1,
  html: html$5,
  image: image$1,
  imageReference: imageReference$1,
  inlineCode: inlineCode$1,
  link: link$1,
  linkReference: linkReference$1,
  list: list$2,
  listItem: listItem$1,
  paragraph: paragraph$1,
  root: root$2,
  strong: strong$1,
  text: text$6,
  thematicBreak: thematicBreak$2
};
const element$1 = document.createElement("i");
function decodeNamedCharacterReference(value) {
  const characterReference2 = "&" + value + ";";
  element$1.innerHTML = characterReference2;
  const char2 = element$1.textContent;
  if (char2.charCodeAt(char2.length - 1) === 59 && value !== "semi") {
    return false;
  }
  return char2 === characterReference2 ? false : char2;
}
function decodeNumericCharacterReference(value, base) {
  const code2 = Number.parseInt(value, base);
  if (
    // C0 except for HT, LF, FF, CR, space.
    code2 < 9 || code2 === 11 || code2 > 13 && code2 < 32 || // Control character (DEL) of C0, and C1 controls.
    code2 > 126 && code2 < 160 || // Lone high surrogates and low surrogates.
    code2 > 55295 && code2 < 57344 || // Noncharacters.
    code2 > 64975 && code2 < 65008 || /* eslint-disable no-bitwise */
    (code2 & 65535) === 65535 || (code2 & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    code2 > 1114111
  ) {
    return "";
  }
  return String.fromCodePoint(code2);
}
const characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function decodeString(value) {
  return value.replace(characterEscapeOrReference, decode);
}
function decode($0, $1, $2) {
  if ($1) {
    return $1;
  }
  const head = $2.charCodeAt(0);
  if (head === 35) {
    const head2 = $2.charCodeAt(1);
    const hex = head2 === 120 || head2 === 88;
    return decodeNumericCharacterReference($2.slice(hex ? 2 : 1), hex ? 16 : 10);
  }
  return decodeNamedCharacterReference($2) || $0;
}
function gfmTableFromMarkdown() {
  return {
    enter: {
      table: enterTable,
      tableData: enterCell,
      tableHeader: enterCell,
      tableRow: enterRow
    },
    exit: {
      codeText: exitCodeText,
      table: exitTable,
      tableData: exit$1,
      tableHeader: exit$1,
      tableRow: exit$1
    }
  };
}
function enterTable(token2) {
  const align = token2._align;
  this.enter(
    {
      type: "table",
      align: align.map(function(d2) {
        return d2 === "none" ? null : d2;
      }),
      children: []
    },
    token2
  );
  this.data.inTable = true;
}
function exitTable(token2) {
  this.exit(token2);
  this.data.inTable = void 0;
}
function enterRow(token2) {
  this.enter({ type: "tableRow", children: [] }, token2);
}
function exit$1(token2) {
  this.exit(token2);
}
function enterCell(token2) {
  this.enter({ type: "tableCell", children: [] }, token2);
}
function exitCodeText(token2) {
  let value = this.resume();
  if (this.data.inTable) {
    value = value.replace(/\\([\\|])/g, replace);
  }
  const node2 = this.stack[this.stack.length - 1];
  ok$1(node2.type === "inlineCode");
  node2.value = value;
  this.exit(token2);
}
function replace($0, $1) {
  return $1 === "|" ? $1 : $0;
}
function gfmTableToMarkdown(options) {
  const settings = options;
  const padding = settings.tableCellPadding;
  const alignDelimiters = settings.tablePipeAlign;
  const stringLength = settings.stringLength;
  const around = padding ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: "\n", inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: true, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: true, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: true, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: inlineCodeWithTable,
      table: handleTable,
      tableCell: handleTableCell,
      tableRow: handleTableRow
    }
  };
  function handleTable(node2, _2, state, info) {
    return serializeData(handleTableAsData(node2, state, info), node2.align);
  }
  function handleTableRow(node2, _2, state, info) {
    const row = handleTableRowAsData(node2, state, info);
    const value = serializeData([row]);
    return value.slice(0, value.indexOf("\n"));
  }
  function handleTableCell(node2, _2, state, info) {
    const exit2 = state.enter("tableCell");
    const subexit = state.enter("phrasing");
    const value = state.containerPhrasing(node2, {
      ...info,
      before: around,
      after: around
    });
    subexit();
    exit2();
    return value;
  }
  function serializeData(matrix, align) {
    return markdownTable(matrix, {
      align,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength
    });
  }
  function handleTableAsData(node2, state, info) {
    const children = node2.children;
    let index2 = -1;
    const result = [];
    const subexit = state.enter("table");
    while (++index2 < children.length) {
      result[index2] = handleTableRowAsData(children[index2], state, info);
    }
    subexit();
    return result;
  }
  function handleTableRowAsData(node2, state, info) {
    const children = node2.children;
    let index2 = -1;
    const result = [];
    const subexit = state.enter("tableRow");
    while (++index2 < children.length) {
      result[index2] = handleTableCell(children[index2], node2, state, info);
    }
    subexit();
    return result;
  }
  function inlineCodeWithTable(node2, parent, state) {
    let value = handle.inlineCode(node2, parent, state);
    if (state.stack.includes("tableCell")) {
      value = value.replace(/\|/g, "\\$&");
    }
    return value;
  }
}
function gfmTaskListItemFromMarkdown() {
  return {
    exit: {
      taskListCheckValueChecked: exitCheck,
      taskListCheckValueUnchecked: exitCheck,
      paragraph: exitParagraphWithTaskListItem
    }
  };
}
function gfmTaskListItemToMarkdown() {
  return {
    unsafe: [{ atBreak: true, character: "-", after: "[:|-]" }],
    handlers: { listItem: listItemWithTaskListItem }
  };
}
function exitCheck(token2) {
  const node2 = this.stack[this.stack.length - 2];
  ok$1(node2.type === "listItem");
  node2.checked = token2.type === "taskListCheckValueChecked";
}
function exitParagraphWithTaskListItem(token2) {
  const parent = this.stack[this.stack.length - 2];
  if (parent && parent.type === "listItem" && typeof parent.checked === "boolean") {
    const node2 = this.stack[this.stack.length - 1];
    ok$1(node2.type === "paragraph");
    const head = node2.children[0];
    if (head && head.type === "text") {
      const siblings = parent.children;
      let index2 = -1;
      let firstParaghraph;
      while (++index2 < siblings.length) {
        const sibling = siblings[index2];
        if (sibling.type === "paragraph") {
          firstParaghraph = sibling;
          break;
        }
      }
      if (firstParaghraph === node2) {
        head.value = head.value.slice(1);
        if (head.value.length === 0) {
          node2.children.shift();
        } else if (node2.position && head.position && typeof head.position.start.offset === "number") {
          head.position.start.column++;
          head.position.start.offset++;
          node2.position.start = Object.assign({}, head.position.start);
        }
      }
    }
  }
  this.exit(token2);
}
function listItemWithTaskListItem(node2, parent, state, info) {
  const head = node2.children[0];
  const checkable = typeof node2.checked === "boolean" && head && head.type === "paragraph";
  const checkbox = "[" + (node2.checked ? "x" : " ") + "] ";
  const tracker = state.createTracker(info);
  if (checkable) {
    tracker.move(checkbox);
  }
  let value = handle.listItem(node2, parent, state, {
    ...info,
    ...tracker.current()
  });
  if (checkable) {
    value = value.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, check);
  }
  return value;
  function check($0) {
    return $0 + checkbox;
  }
}
function gfmFromMarkdown() {
  return [
    gfmAutolinkLiteralFromMarkdown(),
    gfmFootnoteFromMarkdown(),
    gfmStrikethroughFromMarkdown(),
    gfmTableFromMarkdown(),
    gfmTaskListItemFromMarkdown()
  ];
}
function gfmToMarkdown(options) {
  return {
    extensions: [
      gfmAutolinkLiteralToMarkdown(),
      gfmFootnoteToMarkdown(),
      gfmStrikethroughToMarkdown(),
      gfmTableToMarkdown(options),
      gfmTaskListItemToMarkdown()
    ]
  };
}
function splice(list2, start2, remove, items2) {
  const end = list2.length;
  let chunkStart = 0;
  let parameters;
  if (start2 < 0) {
    start2 = -start2 > end ? 0 : end + start2;
  } else {
    start2 = start2 > end ? end : start2;
  }
  remove = remove > 0 ? remove : 0;
  if (items2.length < 1e4) {
    parameters = Array.from(items2);
    parameters.unshift(start2, remove);
    list2.splice(...parameters);
  } else {
    if (remove) list2.splice(start2, remove);
    while (chunkStart < items2.length) {
      parameters = items2.slice(chunkStart, chunkStart + 1e4);
      parameters.unshift(start2, 0);
      list2.splice(...parameters);
      chunkStart += 1e4;
      start2 += 1e4;
    }
  }
}
function push(list2, items2) {
  if (list2.length > 0) {
    splice(list2, list2.length, 0, items2);
    return list2;
  }
  return items2;
}
const hasOwnProperty = {}.hasOwnProperty;
function combineExtensions(extensions) {
  const all3 = {};
  let index2 = -1;
  while (++index2 < extensions.length) {
    syntaxExtension(all3, extensions[index2]);
  }
  return all3;
}
function syntaxExtension(all3, extension2) {
  let hook;
  for (hook in extension2) {
    const maybe = hasOwnProperty.call(all3, hook) ? all3[hook] : void 0;
    const left = maybe || (all3[hook] = {});
    const right = extension2[hook];
    let code2;
    if (right) {
      for (code2 in right) {
        if (!hasOwnProperty.call(left, code2)) left[code2] = [];
        const value = right[code2];
        constructs(
          // @ts-expect-error Looks like a list.
          left[code2],
          Array.isArray(value) ? value : value ? [value] : []
        );
      }
    }
  }
}
function constructs(existing, list2) {
  let index2 = -1;
  const before = [];
  while (++index2 < list2.length) {
    (list2[index2].add === "after" ? existing : before).push(list2[index2]);
  }
  splice(existing, 0, 0, before);
}
const wwwPrefix = {
  tokenize: tokenizeWwwPrefix,
  partial: true
};
const domain = {
  tokenize: tokenizeDomain,
  partial: true
};
const path = {
  tokenize: tokenizePath,
  partial: true
};
const trail = {
  tokenize: tokenizeTrail,
  partial: true
};
const emailDomainDotTrail = {
  tokenize: tokenizeEmailDomainDotTrail,
  partial: true
};
const wwwAutolink = {
  name: "wwwAutolink",
  tokenize: tokenizeWwwAutolink,
  previous: previousWww
};
const protocolAutolink = {
  name: "protocolAutolink",
  tokenize: tokenizeProtocolAutolink,
  previous: previousProtocol
};
const emailAutolink = {
  name: "emailAutolink",
  tokenize: tokenizeEmailAutolink,
  previous: previousEmail
};
const text$5 = {};
function gfmAutolinkLiteral() {
  return {
    text: text$5
  };
}
let code$1 = 48;
while (code$1 < 123) {
  text$5[code$1] = emailAutolink;
  code$1++;
  if (code$1 === 58) code$1 = 65;
  else if (code$1 === 91) code$1 = 97;
}
text$5[43] = emailAutolink;
text$5[45] = emailAutolink;
text$5[46] = emailAutolink;
text$5[95] = emailAutolink;
text$5[72] = [emailAutolink, protocolAutolink];
text$5[104] = [emailAutolink, protocolAutolink];
text$5[87] = [emailAutolink, wwwAutolink];
text$5[119] = [emailAutolink, wwwAutolink];
function tokenizeEmailAutolink(effects, ok2, nok) {
  const self2 = this;
  let dot;
  let data;
  return start2;
  function start2(code2) {
    if (!gfmAtext(code2) || !previousEmail.call(self2, self2.previous) || previousUnbalanced(self2.events)) {
      return nok(code2);
    }
    effects.enter("literalAutolink");
    effects.enter("literalAutolinkEmail");
    return atext(code2);
  }
  function atext(code2) {
    if (gfmAtext(code2)) {
      effects.consume(code2);
      return atext;
    }
    if (code2 === 64) {
      effects.consume(code2);
      return emailDomain;
    }
    return nok(code2);
  }
  function emailDomain(code2) {
    if (code2 === 46) {
      return effects.check(emailDomainDotTrail, emailDomainAfter, emailDomainDot)(code2);
    }
    if (code2 === 45 || code2 === 95 || asciiAlphanumeric(code2)) {
      data = true;
      effects.consume(code2);
      return emailDomain;
    }
    return emailDomainAfter(code2);
  }
  function emailDomainDot(code2) {
    effects.consume(code2);
    dot = true;
    return emailDomain;
  }
  function emailDomainAfter(code2) {
    if (data && dot && asciiAlpha(self2.previous)) {
      effects.exit("literalAutolinkEmail");
      effects.exit("literalAutolink");
      return ok2(code2);
    }
    return nok(code2);
  }
}
function tokenizeWwwAutolink(effects, ok2, nok) {
  const self2 = this;
  return wwwStart;
  function wwwStart(code2) {
    if (code2 !== 87 && code2 !== 119 || !previousWww.call(self2, self2.previous) || previousUnbalanced(self2.events)) {
      return nok(code2);
    }
    effects.enter("literalAutolink");
    effects.enter("literalAutolinkWww");
    return effects.check(wwwPrefix, effects.attempt(domain, effects.attempt(path, wwwAfter), nok), nok)(code2);
  }
  function wwwAfter(code2) {
    effects.exit("literalAutolinkWww");
    effects.exit("literalAutolink");
    return ok2(code2);
  }
}
function tokenizeProtocolAutolink(effects, ok2, nok) {
  const self2 = this;
  let buffer2 = "";
  let seen = false;
  return protocolStart;
  function protocolStart(code2) {
    if ((code2 === 72 || code2 === 104) && previousProtocol.call(self2, self2.previous) && !previousUnbalanced(self2.events)) {
      effects.enter("literalAutolink");
      effects.enter("literalAutolinkHttp");
      buffer2 += String.fromCodePoint(code2);
      effects.consume(code2);
      return protocolPrefixInside;
    }
    return nok(code2);
  }
  function protocolPrefixInside(code2) {
    if (asciiAlpha(code2) && buffer2.length < 5) {
      buffer2 += String.fromCodePoint(code2);
      effects.consume(code2);
      return protocolPrefixInside;
    }
    if (code2 === 58) {
      const protocol = buffer2.toLowerCase();
      if (protocol === "http" || protocol === "https") {
        effects.consume(code2);
        return protocolSlashesInside;
      }
    }
    return nok(code2);
  }
  function protocolSlashesInside(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      if (seen) {
        return afterProtocol;
      }
      seen = true;
      return protocolSlashesInside;
    }
    return nok(code2);
  }
  function afterProtocol(code2) {
    return code2 === null || asciiControl(code2) || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2) || unicodePunctuation(code2) ? nok(code2) : effects.attempt(domain, effects.attempt(path, protocolAfter), nok)(code2);
  }
  function protocolAfter(code2) {
    effects.exit("literalAutolinkHttp");
    effects.exit("literalAutolink");
    return ok2(code2);
  }
}
function tokenizeWwwPrefix(effects, ok2, nok) {
  let size = 0;
  return wwwPrefixInside;
  function wwwPrefixInside(code2) {
    if ((code2 === 87 || code2 === 119) && size < 3) {
      size++;
      effects.consume(code2);
      return wwwPrefixInside;
    }
    if (code2 === 46 && size === 3) {
      effects.consume(code2);
      return wwwPrefixAfter;
    }
    return nok(code2);
  }
  function wwwPrefixAfter(code2) {
    return code2 === null ? nok(code2) : ok2(code2);
  }
}
function tokenizeDomain(effects, ok2, nok) {
  let underscoreInLastSegment;
  let underscoreInLastLastSegment;
  let seen;
  return domainInside;
  function domainInside(code2) {
    if (code2 === 46 || code2 === 95) {
      return effects.check(trail, domainAfter, domainAtPunctuation)(code2);
    }
    if (code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2) || code2 !== 45 && unicodePunctuation(code2)) {
      return domainAfter(code2);
    }
    seen = true;
    effects.consume(code2);
    return domainInside;
  }
  function domainAtPunctuation(code2) {
    if (code2 === 95) {
      underscoreInLastSegment = true;
    } else {
      underscoreInLastLastSegment = underscoreInLastSegment;
      underscoreInLastSegment = void 0;
    }
    effects.consume(code2);
    return domainInside;
  }
  function domainAfter(code2) {
    if (underscoreInLastLastSegment || underscoreInLastSegment || !seen) {
      return nok(code2);
    }
    return ok2(code2);
  }
}
function tokenizePath(effects, ok2) {
  let sizeOpen = 0;
  let sizeClose = 0;
  return pathInside;
  function pathInside(code2) {
    if (code2 === 40) {
      sizeOpen++;
      effects.consume(code2);
      return pathInside;
    }
    if (code2 === 41 && sizeClose < sizeOpen) {
      return pathAtPunctuation(code2);
    }
    if (code2 === 33 || code2 === 34 || code2 === 38 || code2 === 39 || code2 === 41 || code2 === 42 || code2 === 44 || code2 === 46 || code2 === 58 || code2 === 59 || code2 === 60 || code2 === 63 || code2 === 93 || code2 === 95 || code2 === 126) {
      return effects.check(trail, ok2, pathAtPunctuation)(code2);
    }
    if (code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
      return ok2(code2);
    }
    effects.consume(code2);
    return pathInside;
  }
  function pathAtPunctuation(code2) {
    if (code2 === 41) {
      sizeClose++;
    }
    effects.consume(code2);
    return pathInside;
  }
}
function tokenizeTrail(effects, ok2, nok) {
  return trail2;
  function trail2(code2) {
    if (code2 === 33 || code2 === 34 || code2 === 39 || code2 === 41 || code2 === 42 || code2 === 44 || code2 === 46 || code2 === 58 || code2 === 59 || code2 === 63 || code2 === 95 || code2 === 126) {
      effects.consume(code2);
      return trail2;
    }
    if (code2 === 38) {
      effects.consume(code2);
      return trailCharacterReferenceStart;
    }
    if (code2 === 93) {
      effects.consume(code2);
      return trailBracketAfter;
    }
    if (
      // `<` is an end.
      code2 === 60 || // So is whitespace.
      code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)
    ) {
      return ok2(code2);
    }
    return nok(code2);
  }
  function trailBracketAfter(code2) {
    if (code2 === null || code2 === 40 || code2 === 91 || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
      return ok2(code2);
    }
    return trail2(code2);
  }
  function trailCharacterReferenceStart(code2) {
    return asciiAlpha(code2) ? trailCharacterReferenceInside(code2) : nok(code2);
  }
  function trailCharacterReferenceInside(code2) {
    if (code2 === 59) {
      effects.consume(code2);
      return trail2;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return trailCharacterReferenceInside;
    }
    return nok(code2);
  }
}
function tokenizeEmailDomainDotTrail(effects, ok2, nok) {
  return start2;
  function start2(code2) {
    effects.consume(code2);
    return after;
  }
  function after(code2) {
    return asciiAlphanumeric(code2) ? nok(code2) : ok2(code2);
  }
}
function previousWww(code2) {
  return code2 === null || code2 === 40 || code2 === 42 || code2 === 95 || code2 === 91 || code2 === 93 || code2 === 126 || markdownLineEndingOrSpace(code2);
}
function previousProtocol(code2) {
  return !asciiAlpha(code2);
}
function previousEmail(code2) {
  return !(code2 === 47 || gfmAtext(code2));
}
function gfmAtext(code2) {
  return code2 === 43 || code2 === 45 || code2 === 46 || code2 === 95 || asciiAlphanumeric(code2);
}
function previousUnbalanced(events) {
  let index2 = events.length;
  let result = false;
  while (index2--) {
    const token2 = events[index2][1];
    if ((token2.type === "labelLink" || token2.type === "labelImage") && !token2._balanced) {
      result = true;
      break;
    }
    if (token2._gfmAutolinkLiteralWalkedInto) {
      result = false;
      break;
    }
  }
  if (events.length > 0 && !result) {
    events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true;
  }
  return result;
}
function normalizeUri(value) {
  const result = [];
  let index2 = -1;
  let start2 = 0;
  let skip = 0;
  while (++index2 < value.length) {
    const code2 = value.charCodeAt(index2);
    let replace2 = "";
    if (code2 === 37 && asciiAlphanumeric(value.charCodeAt(index2 + 1)) && asciiAlphanumeric(value.charCodeAt(index2 + 2))) {
      skip = 2;
    } else if (code2 < 128) {
      if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code2))) {
        replace2 = String.fromCharCode(code2);
      }
    } else if (code2 > 55295 && code2 < 57344) {
      const next2 = value.charCodeAt(index2 + 1);
      if (code2 < 56320 && next2 > 56319 && next2 < 57344) {
        replace2 = String.fromCharCode(code2, next2);
        skip = 1;
      } else {
        replace2 = "";
      }
    } else {
      replace2 = String.fromCharCode(code2);
    }
    if (replace2) {
      result.push(value.slice(start2, index2), encodeURIComponent(replace2));
      start2 = index2 + skip + 1;
      replace2 = "";
    }
    if (skip) {
      index2 += skip;
      skip = 0;
    }
  }
  return result.join("") + value.slice(start2);
}
function resolveAll(constructs2, events, context) {
  const called = [];
  let index2 = -1;
  while (++index2 < constructs2.length) {
    const resolve2 = constructs2[index2].resolveAll;
    if (resolve2 && !called.includes(resolve2)) {
      events = resolve2(events, context);
      called.push(resolve2);
    }
  }
  return events;
}
const attention = {
  name: "attention",
  resolveAll: resolveAllAttention,
  tokenize: tokenizeAttention
};
function resolveAllAttention(events, context) {
  let index2 = -1;
  let open;
  let group;
  let text2;
  let openingSequence;
  let closingSequence;
  let use;
  let nextEvents;
  let offset;
  while (++index2 < events.length) {
    if (events[index2][0] === "enter" && events[index2][1].type === "attentionSequence" && events[index2][1]._close) {
      open = index2;
      while (open--) {
        if (events[open][0] === "exit" && events[open][1].type === "attentionSequence" && events[open][1]._open && // If the markers are the same:
        context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index2][1]).charCodeAt(0)) {
          if ((events[open][1]._close || events[index2][1]._open) && (events[index2][1].end.offset - events[index2][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index2][1].end.offset - events[index2][1].start.offset) % 3)) {
            continue;
          }
          use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index2][1].end.offset - events[index2][1].start.offset > 1 ? 2 : 1;
          const start2 = {
            ...events[open][1].end
          };
          const end = {
            ...events[index2][1].start
          };
          movePoint(start2, -use);
          movePoint(end, use);
          openingSequence = {
            type: use > 1 ? "strongSequence" : "emphasisSequence",
            start: start2,
            end: {
              ...events[open][1].end
            }
          };
          closingSequence = {
            type: use > 1 ? "strongSequence" : "emphasisSequence",
            start: {
              ...events[index2][1].start
            },
            end
          };
          text2 = {
            type: use > 1 ? "strongText" : "emphasisText",
            start: {
              ...events[open][1].end
            },
            end: {
              ...events[index2][1].start
            }
          };
          group = {
            type: use > 1 ? "strong" : "emphasis",
            start: {
              ...openingSequence.start
            },
            end: {
              ...closingSequence.end
            }
          };
          events[open][1].end = {
            ...openingSequence.start
          };
          events[index2][1].start = {
            ...closingSequence.end
          };
          nextEvents = [];
          if (events[open][1].end.offset - events[open][1].start.offset) {
            nextEvents = push(nextEvents, [["enter", events[open][1], context], ["exit", events[open][1], context]]);
          }
          nextEvents = push(nextEvents, [["enter", group, context], ["enter", openingSequence, context], ["exit", openingSequence, context], ["enter", text2, context]]);
          nextEvents = push(nextEvents, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + 1, index2), context));
          nextEvents = push(nextEvents, [["exit", text2, context], ["enter", closingSequence, context], ["exit", closingSequence, context], ["exit", group, context]]);
          if (events[index2][1].end.offset - events[index2][1].start.offset) {
            offset = 2;
            nextEvents = push(nextEvents, [["enter", events[index2][1], context], ["exit", events[index2][1], context]]);
          } else {
            offset = 0;
          }
          splice(events, open - 1, index2 - open + 3, nextEvents);
          index2 = open + nextEvents.length - offset - 2;
          break;
        }
      }
    }
  }
  index2 = -1;
  while (++index2 < events.length) {
    if (events[index2][1].type === "attentionSequence") {
      events[index2][1].type = "data";
    }
  }
  return events;
}
function tokenizeAttention(effects, ok2) {
  const attentionMarkers2 = this.parser.constructs.attentionMarkers.null;
  const previous2 = this.previous;
  const before = classifyCharacter(previous2);
  let marker;
  return start2;
  function start2(code2) {
    marker = code2;
    effects.enter("attentionSequence");
    return inside(code2);
  }
  function inside(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      return inside;
    }
    const token2 = effects.exit("attentionSequence");
    const after = classifyCharacter(code2);
    const open = !after || after === 2 && before || attentionMarkers2.includes(code2);
    const close = !before || before === 2 && after || attentionMarkers2.includes(previous2);
    token2._open = Boolean(marker === 42 ? open : open && (before || !close));
    token2._close = Boolean(marker === 42 ? close : close && (after || !open));
    return ok2(code2);
  }
}
function movePoint(point2, offset) {
  point2.column += offset;
  point2.offset += offset;
  point2._bufferIndex += offset;
}
const autolink = {
  name: "autolink",
  tokenize: tokenizeAutolink
};
function tokenizeAutolink(effects, ok2, nok) {
  let size = 0;
  return start2;
  function start2(code2) {
    effects.enter("autolink");
    effects.enter("autolinkMarker");
    effects.consume(code2);
    effects.exit("autolinkMarker");
    effects.enter("autolinkProtocol");
    return open;
  }
  function open(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return schemeOrEmailAtext;
    }
    if (code2 === 64) {
      return nok(code2);
    }
    return emailAtext(code2);
  }
  function schemeOrEmailAtext(code2) {
    if (code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric(code2)) {
      size = 1;
      return schemeInsideOrEmailAtext(code2);
    }
    return emailAtext(code2);
  }
  function schemeInsideOrEmailAtext(code2) {
    if (code2 === 58) {
      effects.consume(code2);
      size = 0;
      return urlInside;
    }
    if ((code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric(code2)) && size++ < 32) {
      effects.consume(code2);
      return schemeInsideOrEmailAtext;
    }
    size = 0;
    return emailAtext(code2);
  }
  function urlInside(code2) {
    if (code2 === 62) {
      effects.exit("autolinkProtocol");
      effects.enter("autolinkMarker");
      effects.consume(code2);
      effects.exit("autolinkMarker");
      effects.exit("autolink");
      return ok2;
    }
    if (code2 === null || code2 === 32 || code2 === 60 || asciiControl(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return urlInside;
  }
  function emailAtext(code2) {
    if (code2 === 64) {
      effects.consume(code2);
      return emailAtSignOrDot;
    }
    if (asciiAtext(code2)) {
      effects.consume(code2);
      return emailAtext;
    }
    return nok(code2);
  }
  function emailAtSignOrDot(code2) {
    return asciiAlphanumeric(code2) ? emailLabel(code2) : nok(code2);
  }
  function emailLabel(code2) {
    if (code2 === 46) {
      effects.consume(code2);
      size = 0;
      return emailAtSignOrDot;
    }
    if (code2 === 62) {
      effects.exit("autolinkProtocol").type = "autolinkEmail";
      effects.enter("autolinkMarker");
      effects.consume(code2);
      effects.exit("autolinkMarker");
      effects.exit("autolink");
      return ok2;
    }
    return emailValue(code2);
  }
  function emailValue(code2) {
    if ((code2 === 45 || asciiAlphanumeric(code2)) && size++ < 63) {
      const next2 = code2 === 45 ? emailValue : emailLabel;
      effects.consume(code2);
      return next2;
    }
    return nok(code2);
  }
}
function factorySpace(effects, ok2, type2, max) {
  const limit = max ? max - 1 : Number.POSITIVE_INFINITY;
  let size = 0;
  return start2;
  function start2(code2) {
    if (markdownSpace(code2)) {
      effects.enter(type2);
      return prefix2(code2);
    }
    return ok2(code2);
  }
  function prefix2(code2) {
    if (markdownSpace(code2) && size++ < limit) {
      effects.consume(code2);
      return prefix2;
    }
    effects.exit(type2);
    return ok2(code2);
  }
}
const blankLine = {
  partial: true,
  tokenize: tokenizeBlankLine
};
function tokenizeBlankLine(effects, ok2, nok) {
  return start2;
  function start2(code2) {
    return markdownSpace(code2) ? factorySpace(effects, after, "linePrefix")(code2) : after(code2);
  }
  function after(code2) {
    return code2 === null || markdownLineEnding(code2) ? ok2(code2) : nok(code2);
  }
}
const blockQuote = {
  continuation: {
    tokenize: tokenizeBlockQuoteContinuation
  },
  exit,
  name: "blockQuote",
  tokenize: tokenizeBlockQuoteStart
};
function tokenizeBlockQuoteStart(effects, ok2, nok) {
  const self2 = this;
  return start2;
  function start2(code2) {
    if (code2 === 62) {
      const state = self2.containerState;
      if (!state.open) {
        effects.enter("blockQuote", {
          _container: true
        });
        state.open = true;
      }
      effects.enter("blockQuotePrefix");
      effects.enter("blockQuoteMarker");
      effects.consume(code2);
      effects.exit("blockQuoteMarker");
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    if (markdownSpace(code2)) {
      effects.enter("blockQuotePrefixWhitespace");
      effects.consume(code2);
      effects.exit("blockQuotePrefixWhitespace");
      effects.exit("blockQuotePrefix");
      return ok2;
    }
    effects.exit("blockQuotePrefix");
    return ok2(code2);
  }
}
function tokenizeBlockQuoteContinuation(effects, ok2, nok) {
  const self2 = this;
  return contStart;
  function contStart(code2) {
    if (markdownSpace(code2)) {
      return factorySpace(effects, contBefore, "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code2);
    }
    return contBefore(code2);
  }
  function contBefore(code2) {
    return effects.attempt(blockQuote, ok2, nok)(code2);
  }
}
function exit(effects) {
  effects.exit("blockQuote");
}
const characterEscape = {
  name: "characterEscape",
  tokenize: tokenizeCharacterEscape
};
function tokenizeCharacterEscape(effects, ok2, nok) {
  return start2;
  function start2(code2) {
    effects.enter("characterEscape");
    effects.enter("escapeMarker");
    effects.consume(code2);
    effects.exit("escapeMarker");
    return inside;
  }
  function inside(code2) {
    if (asciiPunctuation(code2)) {
      effects.enter("characterEscapeValue");
      effects.consume(code2);
      effects.exit("characterEscapeValue");
      effects.exit("characterEscape");
      return ok2;
    }
    return nok(code2);
  }
}
const characterReference = {
  name: "characterReference",
  tokenize: tokenizeCharacterReference
};
function tokenizeCharacterReference(effects, ok2, nok) {
  const self2 = this;
  let size = 0;
  let max;
  let test2;
  return start2;
  function start2(code2) {
    effects.enter("characterReference");
    effects.enter("characterReferenceMarker");
    effects.consume(code2);
    effects.exit("characterReferenceMarker");
    return open;
  }
  function open(code2) {
    if (code2 === 35) {
      effects.enter("characterReferenceMarkerNumeric");
      effects.consume(code2);
      effects.exit("characterReferenceMarkerNumeric");
      return numeric;
    }
    effects.enter("characterReferenceValue");
    max = 31;
    test2 = asciiAlphanumeric;
    return value(code2);
  }
  function numeric(code2) {
    if (code2 === 88 || code2 === 120) {
      effects.enter("characterReferenceMarkerHexadecimal");
      effects.consume(code2);
      effects.exit("characterReferenceMarkerHexadecimal");
      effects.enter("characterReferenceValue");
      max = 6;
      test2 = asciiHexDigit;
      return value;
    }
    effects.enter("characterReferenceValue");
    max = 7;
    test2 = asciiDigit;
    return value(code2);
  }
  function value(code2) {
    if (code2 === 59 && size) {
      const token2 = effects.exit("characterReferenceValue");
      if (test2 === asciiAlphanumeric && !decodeNamedCharacterReference(self2.sliceSerialize(token2))) {
        return nok(code2);
      }
      effects.enter("characterReferenceMarker");
      effects.consume(code2);
      effects.exit("characterReferenceMarker");
      effects.exit("characterReference");
      return ok2;
    }
    if (test2(code2) && size++ < max) {
      effects.consume(code2);
      return value;
    }
    return nok(code2);
  }
}
const nonLazyContinuation = {
  partial: true,
  tokenize: tokenizeNonLazyContinuation
};
const codeFenced = {
  concrete: true,
  name: "codeFenced",
  tokenize: tokenizeCodeFenced
};
function tokenizeCodeFenced(effects, ok2, nok) {
  const self2 = this;
  const closeStart = {
    partial: true,
    tokenize: tokenizeCloseStart
  };
  let initialPrefix = 0;
  let sizeOpen = 0;
  let marker;
  return start2;
  function start2(code2) {
    return beforeSequenceOpen(code2);
  }
  function beforeSequenceOpen(code2) {
    const tail = self2.events[self2.events.length - 1];
    initialPrefix = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
    marker = code2;
    effects.enter("codeFenced");
    effects.enter("codeFencedFence");
    effects.enter("codeFencedFenceSequence");
    return sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    if (code2 === marker) {
      sizeOpen++;
      effects.consume(code2);
      return sequenceOpen;
    }
    if (sizeOpen < 3) {
      return nok(code2);
    }
    effects.exit("codeFencedFenceSequence");
    return markdownSpace(code2) ? factorySpace(effects, infoBefore, "whitespace")(code2) : infoBefore(code2);
  }
  function infoBefore(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("codeFencedFence");
      return self2.interrupt ? ok2(code2) : effects.check(nonLazyContinuation, atNonLazyBreak, after)(code2);
    }
    effects.enter("codeFencedFenceInfo");
    effects.enter("chunkString", {
      contentType: "string"
    });
    return info(code2);
  }
  function info(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceInfo");
      return infoBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceInfo");
      return factorySpace(effects, metaBefore, "whitespace")(code2);
    }
    if (code2 === 96 && code2 === marker) {
      return nok(code2);
    }
    effects.consume(code2);
    return info;
  }
  function metaBefore(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return infoBefore(code2);
    }
    effects.enter("codeFencedFenceMeta");
    effects.enter("chunkString", {
      contentType: "string"
    });
    return meta(code2);
  }
  function meta(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceMeta");
      return infoBefore(code2);
    }
    if (code2 === 96 && code2 === marker) {
      return nok(code2);
    }
    effects.consume(code2);
    return meta;
  }
  function atNonLazyBreak(code2) {
    return effects.attempt(closeStart, after, contentBefore)(code2);
  }
  function contentBefore(code2) {
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return contentStart;
  }
  function contentStart(code2) {
    return initialPrefix > 0 && markdownSpace(code2) ? factorySpace(effects, beforeContentChunk, "linePrefix", initialPrefix + 1)(code2) : beforeContentChunk(code2);
  }
  function beforeContentChunk(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return effects.check(nonLazyContinuation, atNonLazyBreak, after)(code2);
    }
    effects.enter("codeFlowValue");
    return contentChunk(code2);
  }
  function contentChunk(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("codeFlowValue");
      return beforeContentChunk(code2);
    }
    effects.consume(code2);
    return contentChunk;
  }
  function after(code2) {
    effects.exit("codeFenced");
    return ok2(code2);
  }
  function tokenizeCloseStart(effects2, ok3, nok2) {
    let size = 0;
    return startBefore;
    function startBefore(code2) {
      effects2.enter("lineEnding");
      effects2.consume(code2);
      effects2.exit("lineEnding");
      return start3;
    }
    function start3(code2) {
      effects2.enter("codeFencedFence");
      return markdownSpace(code2) ? factorySpace(effects2, beforeSequenceClose, "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code2) : beforeSequenceClose(code2);
    }
    function beforeSequenceClose(code2) {
      if (code2 === marker) {
        effects2.enter("codeFencedFenceSequence");
        return sequenceClose(code2);
      }
      return nok2(code2);
    }
    function sequenceClose(code2) {
      if (code2 === marker) {
        size++;
        effects2.consume(code2);
        return sequenceClose;
      }
      if (size >= sizeOpen) {
        effects2.exit("codeFencedFenceSequence");
        return markdownSpace(code2) ? factorySpace(effects2, sequenceCloseAfter, "whitespace")(code2) : sequenceCloseAfter(code2);
      }
      return nok2(code2);
    }
    function sequenceCloseAfter(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        effects2.exit("codeFencedFence");
        return ok3(code2);
      }
      return nok2(code2);
    }
  }
}
function tokenizeNonLazyContinuation(effects, ok2, nok) {
  const self2 = this;
  return start2;
  function start2(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return lineStart;
  }
  function lineStart(code2) {
    return self2.parser.lazy[self2.now().line] ? nok(code2) : ok2(code2);
  }
}
const codeIndented = {
  name: "codeIndented",
  tokenize: tokenizeCodeIndented
};
const furtherStart = {
  partial: true,
  tokenize: tokenizeFurtherStart
};
function tokenizeCodeIndented(effects, ok2, nok) {
  const self2 = this;
  return start2;
  function start2(code2) {
    effects.enter("codeIndented");
    return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1)(code2);
  }
  function afterPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? atBreak(code2) : nok(code2);
  }
  function atBreak(code2) {
    if (code2 === null) {
      return after(code2);
    }
    if (markdownLineEnding(code2)) {
      return effects.attempt(furtherStart, atBreak, after)(code2);
    }
    effects.enter("codeFlowValue");
    return inside(code2);
  }
  function inside(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("codeFlowValue");
      return atBreak(code2);
    }
    effects.consume(code2);
    return inside;
  }
  function after(code2) {
    effects.exit("codeIndented");
    return ok2(code2);
  }
}
function tokenizeFurtherStart(effects, ok2, nok) {
  const self2 = this;
  return furtherStart2;
  function furtherStart2(code2) {
    if (self2.parser.lazy[self2.now().line]) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return furtherStart2;
    }
    return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1)(code2);
  }
  function afterPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? ok2(code2) : markdownLineEnding(code2) ? furtherStart2(code2) : nok(code2);
  }
}
const codeText = {
  name: "codeText",
  previous,
  resolve: resolveCodeText,
  tokenize: tokenizeCodeText
};
function resolveCodeText(events) {
  let tailExitIndex = events.length - 4;
  let headEnterIndex = 3;
  let index2;
  let enter;
  if ((events[headEnterIndex][1].type === "lineEnding" || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === "lineEnding" || events[tailExitIndex][1].type === "space")) {
    index2 = headEnterIndex;
    while (++index2 < tailExitIndex) {
      if (events[index2][1].type === "codeTextData") {
        events[headEnterIndex][1].type = "codeTextPadding";
        events[tailExitIndex][1].type = "codeTextPadding";
        headEnterIndex += 2;
        tailExitIndex -= 2;
        break;
      }
    }
  }
  index2 = headEnterIndex - 1;
  tailExitIndex++;
  while (++index2 <= tailExitIndex) {
    if (enter === void 0) {
      if (index2 !== tailExitIndex && events[index2][1].type !== "lineEnding") {
        enter = index2;
      }
    } else if (index2 === tailExitIndex || events[index2][1].type === "lineEnding") {
      events[enter][1].type = "codeTextData";
      if (index2 !== enter + 2) {
        events[enter][1].end = events[index2 - 1][1].end;
        events.splice(enter + 2, index2 - enter - 2);
        tailExitIndex -= index2 - enter - 2;
        index2 = enter + 2;
      }
      enter = void 0;
    }
  }
  return events;
}
function previous(code2) {
  return code2 !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function tokenizeCodeText(effects, ok2, nok) {
  let sizeOpen = 0;
  let size;
  let token2;
  return start2;
  function start2(code2) {
    effects.enter("codeText");
    effects.enter("codeTextSequence");
    return sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    if (code2 === 96) {
      effects.consume(code2);
      sizeOpen++;
      return sequenceOpen;
    }
    effects.exit("codeTextSequence");
    return between(code2);
  }
  function between(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 32) {
      effects.enter("space");
      effects.consume(code2);
      effects.exit("space");
      return between;
    }
    if (code2 === 96) {
      token2 = effects.enter("codeTextSequence");
      size = 0;
      return sequenceClose(code2);
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return between;
    }
    effects.enter("codeTextData");
    return data(code2);
  }
  function data(code2) {
    if (code2 === null || code2 === 32 || code2 === 96 || markdownLineEnding(code2)) {
      effects.exit("codeTextData");
      return between(code2);
    }
    effects.consume(code2);
    return data;
  }
  function sequenceClose(code2) {
    if (code2 === 96) {
      effects.consume(code2);
      size++;
      return sequenceClose;
    }
    if (size === sizeOpen) {
      effects.exit("codeTextSequence");
      effects.exit("codeText");
      return ok2(code2);
    }
    token2.type = "codeTextData";
    return data(code2);
  }
}
class SpliceBuffer {
  /**
   * @param {ReadonlyArray<T> | null | undefined} [initial]
   *   Initial items (optional).
   * @returns
   *   Splice buffer.
   */
  constructor(initial) {
    this.left = initial ? [...initial] : [];
    this.right = [];
  }
  /**
   * Array access;
   * does not move the cursor.
   *
   * @param {number} index
   *   Index.
   * @return {T}
   *   Item.
   */
  get(index2) {
    if (index2 < 0 || index2 >= this.left.length + this.right.length) {
      throw new RangeError("Cannot access index `" + index2 + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
    }
    if (index2 < this.left.length) return this.left[index2];
    return this.right[this.right.length - index2 + this.left.length - 1];
  }
  /**
   * The length of the splice buffer, one greater than the largest index in the
   * array.
   */
  get length() {
    return this.left.length + this.right.length;
  }
  /**
   * Remove and return `list[0]`;
   * moves the cursor to `0`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  shift() {
    this.setCursor(0);
    return this.right.pop();
  }
  /**
   * Slice the buffer to get an array;
   * does not move the cursor.
   *
   * @param {number} start
   *   Start.
   * @param {number | null | undefined} [end]
   *   End (optional).
   * @returns {Array<T>}
   *   Array of items.
   */
  slice(start2, end) {
    const stop2 = end === null || end === void 0 ? Number.POSITIVE_INFINITY : end;
    if (stop2 < this.left.length) {
      return this.left.slice(start2, stop2);
    }
    if (start2 > this.left.length) {
      return this.right.slice(this.right.length - stop2 + this.left.length, this.right.length - start2 + this.left.length).reverse();
    }
    return this.left.slice(start2).concat(this.right.slice(this.right.length - stop2 + this.left.length).reverse());
  }
  /**
   * Mimics the behavior of Array.prototype.splice() except for the change of
   * interface necessary to avoid segfaults when patching in very large arrays.
   *
   * This operation moves cursor is moved to `start` and results in the cursor
   * placed after any inserted items.
   *
   * @param {number} start
   *   Start;
   *   zero-based index at which to start changing the array;
   *   negative numbers count backwards from the end of the array and values
   *   that are out-of bounds are clamped to the appropriate end of the array.
   * @param {number | null | undefined} [deleteCount=0]
   *   Delete count (default: `0`);
   *   maximum number of elements to delete, starting from start.
   * @param {Array<T> | null | undefined} [items=[]]
   *   Items to include in place of the deleted items (default: `[]`).
   * @return {Array<T>}
   *   Any removed items.
   */
  splice(start2, deleteCount, items2) {
    const count = deleteCount || 0;
    this.setCursor(Math.trunc(start2));
    const removed = this.right.splice(this.right.length - count, Number.POSITIVE_INFINITY);
    if (items2) chunkedPush(this.left, items2);
    return removed.reverse();
  }
  /**
   * Remove and return the highest-numbered item in the array, so
   * `list[list.length - 1]`;
   * Moves the cursor to `length`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  pop() {
    this.setCursor(Number.POSITIVE_INFINITY);
    return this.left.pop();
  }
  /**
   * Inserts a single item to the high-numbered side of the array;
   * moves the cursor to `length`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  push(item) {
    this.setCursor(Number.POSITIVE_INFINITY);
    this.left.push(item);
  }
  /**
   * Inserts many items to the high-numbered side of the array.
   * Moves the cursor to `length`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  pushMany(items2) {
    this.setCursor(Number.POSITIVE_INFINITY);
    chunkedPush(this.left, items2);
  }
  /**
   * Inserts a single item to the low-numbered side of the array;
   * Moves the cursor to `0`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  unshift(item) {
    this.setCursor(0);
    this.right.push(item);
  }
  /**
   * Inserts many items to the low-numbered side of the array;
   * moves the cursor to `0`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  unshiftMany(items2) {
    this.setCursor(0);
    chunkedPush(this.right, items2.reverse());
  }
  /**
   * Move the cursor to a specific position in the array. Requires
   * time proportional to the distance moved.
   *
   * If `n < 0`, the cursor will end up at the beginning.
   * If `n > length`, the cursor will end up at the end.
   *
   * @param {number} n
   *   Position.
   * @return {undefined}
   *   Nothing.
   */
  setCursor(n2) {
    if (n2 === this.left.length || n2 > this.left.length && this.right.length === 0 || n2 < 0 && this.left.length === 0) return;
    if (n2 < this.left.length) {
      const removed = this.left.splice(n2, Number.POSITIVE_INFINITY);
      chunkedPush(this.right, removed.reverse());
    } else {
      const removed = this.right.splice(this.left.length + this.right.length - n2, Number.POSITIVE_INFINITY);
      chunkedPush(this.left, removed.reverse());
    }
  }
}
function chunkedPush(list2, right) {
  let chunkStart = 0;
  if (right.length < 1e4) {
    list2.push(...right);
  } else {
    while (chunkStart < right.length) {
      list2.push(...right.slice(chunkStart, chunkStart + 1e4));
      chunkStart += 1e4;
    }
  }
}
function subtokenize(eventsArray) {
  const jumps = {};
  let index2 = -1;
  let event;
  let lineIndex;
  let otherIndex;
  let otherEvent;
  let parameters;
  let subevents;
  let more;
  const events = new SpliceBuffer(eventsArray);
  while (++index2 < events.length) {
    while (index2 in jumps) {
      index2 = jumps[index2];
    }
    event = events.get(index2);
    if (index2 && event[1].type === "chunkFlow" && events.get(index2 - 1)[1].type === "listItemPrefix") {
      subevents = event[1]._tokenizer.events;
      otherIndex = 0;
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === "lineEndingBlank") {
        otherIndex += 2;
      }
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === "content") {
        while (++otherIndex < subevents.length) {
          if (subevents[otherIndex][1].type === "content") {
            break;
          }
          if (subevents[otherIndex][1].type === "chunkText") {
            subevents[otherIndex][1]._isInFirstContentOfListItem = true;
            otherIndex++;
          }
        }
      }
    }
    if (event[0] === "enter") {
      if (event[1].contentType) {
        Object.assign(jumps, subcontent(events, index2));
        index2 = jumps[index2];
        more = true;
      }
    } else if (event[1]._container) {
      otherIndex = index2;
      lineIndex = void 0;
      while (otherIndex--) {
        otherEvent = events.get(otherIndex);
        if (otherEvent[1].type === "lineEnding" || otherEvent[1].type === "lineEndingBlank") {
          if (otherEvent[0] === "enter") {
            if (lineIndex) {
              events.get(lineIndex)[1].type = "lineEndingBlank";
            }
            otherEvent[1].type = "lineEnding";
            lineIndex = otherIndex;
          }
        } else {
          break;
        }
      }
      if (lineIndex) {
        event[1].end = {
          ...events.get(lineIndex)[1].start
        };
        parameters = events.slice(lineIndex, index2);
        parameters.unshift(event);
        events.splice(lineIndex, index2 - lineIndex + 1, parameters);
      }
    }
  }
  splice(eventsArray, 0, Number.POSITIVE_INFINITY, events.slice(0));
  return !more;
}
function subcontent(events, eventIndex) {
  const token2 = events.get(eventIndex)[1];
  const context = events.get(eventIndex)[2];
  let startPosition = eventIndex - 1;
  const startPositions = [];
  const tokenizer = token2._tokenizer || context.parser[token2.contentType](token2.start);
  const childEvents = tokenizer.events;
  const jumps = [];
  const gaps = {};
  let stream;
  let previous2;
  let index2 = -1;
  let current = token2;
  let adjust = 0;
  let start2 = 0;
  const breaks = [start2];
  while (current) {
    while (events.get(++startPosition)[1] !== current) {
    }
    startPositions.push(startPosition);
    if (!current._tokenizer) {
      stream = context.sliceStream(current);
      if (!current.next) {
        stream.push(null);
      }
      if (previous2) {
        tokenizer.defineSkip(current.start);
      }
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = true;
      }
      tokenizer.write(stream);
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = void 0;
      }
    }
    previous2 = current;
    current = current.next;
  }
  current = token2;
  while (++index2 < childEvents.length) {
    if (
      // Find a void token that includes a break.
      childEvents[index2][0] === "exit" && childEvents[index2 - 1][0] === "enter" && childEvents[index2][1].type === childEvents[index2 - 1][1].type && childEvents[index2][1].start.line !== childEvents[index2][1].end.line
    ) {
      start2 = index2 + 1;
      breaks.push(start2);
      current._tokenizer = void 0;
      current.previous = void 0;
      current = current.next;
    }
  }
  tokenizer.events = [];
  if (current) {
    current._tokenizer = void 0;
    current.previous = void 0;
  } else {
    breaks.pop();
  }
  index2 = breaks.length;
  while (index2--) {
    const slice2 = childEvents.slice(breaks[index2], breaks[index2 + 1]);
    const start3 = startPositions.pop();
    jumps.push([start3, start3 + slice2.length - 1]);
    events.splice(start3, 2, slice2);
  }
  jumps.reverse();
  index2 = -1;
  while (++index2 < jumps.length) {
    gaps[adjust + jumps[index2][0]] = adjust + jumps[index2][1];
    adjust += jumps[index2][1] - jumps[index2][0] - 1;
  }
  return gaps;
}
const content$1 = {
  resolve: resolveContent,
  tokenize: tokenizeContent
};
const continuationConstruct = {
  partial: true,
  tokenize: tokenizeContinuation
};
function resolveContent(events) {
  subtokenize(events);
  return events;
}
function tokenizeContent(effects, ok2) {
  let previous2;
  return chunkStart;
  function chunkStart(code2) {
    effects.enter("content");
    previous2 = effects.enter("chunkContent", {
      contentType: "content"
    });
    return chunkInside(code2);
  }
  function chunkInside(code2) {
    if (code2 === null) {
      return contentEnd(code2);
    }
    if (markdownLineEnding(code2)) {
      return effects.check(continuationConstruct, contentContinue, contentEnd)(code2);
    }
    effects.consume(code2);
    return chunkInside;
  }
  function contentEnd(code2) {
    effects.exit("chunkContent");
    effects.exit("content");
    return ok2(code2);
  }
  function contentContinue(code2) {
    effects.consume(code2);
    effects.exit("chunkContent");
    previous2.next = effects.enter("chunkContent", {
      contentType: "content",
      previous: previous2
    });
    previous2 = previous2.next;
    return chunkInside;
  }
}
function tokenizeContinuation(effects, ok2, nok) {
  const self2 = this;
  return startLookahead;
  function startLookahead(code2) {
    effects.exit("chunkContent");
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return factorySpace(effects, prefixed, "linePrefix");
  }
  function prefixed(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return nok(code2);
    }
    const tail = self2.events[self2.events.length - 1];
    if (!self2.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4) {
      return ok2(code2);
    }
    return effects.interrupt(self2.parser.constructs.flow, nok, ok2)(code2);
  }
}
function factoryDestination(effects, ok2, nok, type2, literalType, literalMarkerType, rawType, stringType, max) {
  const limit = max || Number.POSITIVE_INFINITY;
  let balance = 0;
  return start2;
  function start2(code2) {
    if (code2 === 60) {
      effects.enter(type2);
      effects.enter(literalType);
      effects.enter(literalMarkerType);
      effects.consume(code2);
      effects.exit(literalMarkerType);
      return enclosedBefore;
    }
    if (code2 === null || code2 === 32 || code2 === 41 || asciiControl(code2)) {
      return nok(code2);
    }
    effects.enter(type2);
    effects.enter(rawType);
    effects.enter(stringType);
    effects.enter("chunkString", {
      contentType: "string"
    });
    return raw(code2);
  }
  function enclosedBefore(code2) {
    if (code2 === 62) {
      effects.enter(literalMarkerType);
      effects.consume(code2);
      effects.exit(literalMarkerType);
      effects.exit(literalType);
      effects.exit(type2);
      return ok2;
    }
    effects.enter(stringType);
    effects.enter("chunkString", {
      contentType: "string"
    });
    return enclosed(code2);
  }
  function enclosed(code2) {
    if (code2 === 62) {
      effects.exit("chunkString");
      effects.exit(stringType);
      return enclosedBefore(code2);
    }
    if (code2 === null || code2 === 60 || markdownLineEnding(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? enclosedEscape : enclosed;
  }
  function enclosedEscape(code2) {
    if (code2 === 60 || code2 === 62 || code2 === 92) {
      effects.consume(code2);
      return enclosed;
    }
    return enclosed(code2);
  }
  function raw(code2) {
    if (!balance && (code2 === null || code2 === 41 || markdownLineEndingOrSpace(code2))) {
      effects.exit("chunkString");
      effects.exit(stringType);
      effects.exit(rawType);
      effects.exit(type2);
      return ok2(code2);
    }
    if (balance < limit && code2 === 40) {
      effects.consume(code2);
      balance++;
      return raw;
    }
    if (code2 === 41) {
      effects.consume(code2);
      balance--;
      return raw;
    }
    if (code2 === null || code2 === 32 || code2 === 40 || asciiControl(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? rawEscape : raw;
  }
  function rawEscape(code2) {
    if (code2 === 40 || code2 === 41 || code2 === 92) {
      effects.consume(code2);
      return raw;
    }
    return raw(code2);
  }
}
function factoryLabel(effects, ok2, nok, type2, markerType, stringType) {
  const self2 = this;
  let size = 0;
  let seen;
  return start2;
  function start2(code2) {
    effects.enter(type2);
    effects.enter(markerType);
    effects.consume(code2);
    effects.exit(markerType);
    effects.enter(stringType);
    return atBreak;
  }
  function atBreak(code2) {
    if (size > 999 || code2 === null || code2 === 91 || code2 === 93 && !seen || // To do: remove in the future once weve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesnt need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    code2 === 94 && !size && "_hiddenFootnoteSupport" in self2.parser.constructs) {
      return nok(code2);
    }
    if (code2 === 93) {
      effects.exit(stringType);
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      effects.exit(type2);
      return ok2;
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return atBreak;
    }
    effects.enter("chunkString", {
      contentType: "string"
    });
    return labelInside(code2);
  }
  function labelInside(code2) {
    if (code2 === null || code2 === 91 || code2 === 93 || markdownLineEnding(code2) || size++ > 999) {
      effects.exit("chunkString");
      return atBreak(code2);
    }
    effects.consume(code2);
    if (!seen) seen = !markdownSpace(code2);
    return code2 === 92 ? labelEscape : labelInside;
  }
  function labelEscape(code2) {
    if (code2 === 91 || code2 === 92 || code2 === 93) {
      effects.consume(code2);
      size++;
      return labelInside;
    }
    return labelInside(code2);
  }
}
function factoryTitle(effects, ok2, nok, type2, markerType, stringType) {
  let marker;
  return start2;
  function start2(code2) {
    if (code2 === 34 || code2 === 39 || code2 === 40) {
      effects.enter(type2);
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      marker = code2 === 40 ? 41 : code2;
      return begin;
    }
    return nok(code2);
  }
  function begin(code2) {
    if (code2 === marker) {
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      effects.exit(type2);
      return ok2;
    }
    effects.enter(stringType);
    return atBreak(code2);
  }
  function atBreak(code2) {
    if (code2 === marker) {
      effects.exit(stringType);
      return begin(marker);
    }
    if (code2 === null) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return factorySpace(effects, atBreak, "linePrefix");
    }
    effects.enter("chunkString", {
      contentType: "string"
    });
    return inside(code2);
  }
  function inside(code2) {
    if (code2 === marker || code2 === null || markdownLineEnding(code2)) {
      effects.exit("chunkString");
      return atBreak(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? escape2 : inside;
  }
  function escape2(code2) {
    if (code2 === marker || code2 === 92) {
      effects.consume(code2);
      return inside;
    }
    return inside(code2);
  }
}
function factoryWhitespace(effects, ok2) {
  let seen;
  return start2;
  function start2(code2) {
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      seen = true;
      return start2;
    }
    if (markdownSpace(code2)) {
      return factorySpace(effects, start2, seen ? "linePrefix" : "lineSuffix")(code2);
    }
    return ok2(code2);
  }
}
const definition = {
  name: "definition",
  tokenize: tokenizeDefinition
};
const titleBefore = {
  partial: true,
  tokenize: tokenizeTitleBefore
};
function tokenizeDefinition(effects, ok2, nok) {
  const self2 = this;
  let identifier2;
  return start2;
  function start2(code2) {
    effects.enter("definition");
    return before(code2);
  }
  function before(code2) {
    return factoryLabel.call(
      self2,
      effects,
      labelAfter,
      // Note: we dont need to reset the way `markdown-rs` does.
      nok,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(code2);
  }
  function labelAfter(code2) {
    identifier2 = normalizeIdentifier(self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1));
    if (code2 === 58) {
      effects.enter("definitionMarker");
      effects.consume(code2);
      effects.exit("definitionMarker");
      return markerAfter;
    }
    return nok(code2);
  }
  function markerAfter(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, destinationBefore)(code2) : destinationBefore(code2);
  }
  function destinationBefore(code2) {
    return factoryDestination(
      effects,
      destinationAfter,
      // Note: we dont need to reset the way `markdown-rs` does.
      nok,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(code2);
  }
  function destinationAfter(code2) {
    return effects.attempt(titleBefore, after, after)(code2);
  }
  function after(code2) {
    return markdownSpace(code2) ? factorySpace(effects, afterWhitespace, "whitespace")(code2) : afterWhitespace(code2);
  }
  function afterWhitespace(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("definition");
      self2.parser.defined.push(identifier2);
      return ok2(code2);
    }
    return nok(code2);
  }
}
function tokenizeTitleBefore(effects, ok2, nok) {
  return titleBefore2;
  function titleBefore2(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, beforeMarker)(code2) : nok(code2);
  }
  function beforeMarker(code2) {
    return factoryTitle(effects, titleAfter, nok, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(code2);
  }
  function titleAfter(code2) {
    return markdownSpace(code2) ? factorySpace(effects, titleAfterOptionalWhitespace, "whitespace")(code2) : titleAfterOptionalWhitespace(code2);
  }
  function titleAfterOptionalWhitespace(code2) {
    return code2 === null || markdownLineEnding(code2) ? ok2(code2) : nok(code2);
  }
}
const hardBreakEscape = {
  name: "hardBreakEscape",
  tokenize: tokenizeHardBreakEscape
};
function tokenizeHardBreakEscape(effects, ok2, nok) {
  return start2;
  function start2(code2) {
    effects.enter("hardBreakEscape");
    effects.consume(code2);
    return after;
  }
  function after(code2) {
    if (markdownLineEnding(code2)) {
      effects.exit("hardBreakEscape");
      return ok2(code2);
    }
    return nok(code2);
  }
}
const headingAtx = {
  name: "headingAtx",
  resolve: resolveHeadingAtx,
  tokenize: tokenizeHeadingAtx
};
function resolveHeadingAtx(events, context) {
  let contentEnd = events.length - 2;
  let contentStart = 3;
  let content2;
  let text2;
  if (events[contentStart][1].type === "whitespace") {
    contentStart += 2;
  }
  if (contentEnd - 2 > contentStart && events[contentEnd][1].type === "whitespace") {
    contentEnd -= 2;
  }
  if (events[contentEnd][1].type === "atxHeadingSequence" && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === "whitespace")) {
    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
  }
  if (contentEnd > contentStart) {
    content2 = {
      type: "atxHeadingText",
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end
    };
    text2 = {
      type: "chunkText",
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end,
      contentType: "text"
    };
    splice(events, contentStart, contentEnd - contentStart + 1, [["enter", content2, context], ["enter", text2, context], ["exit", text2, context], ["exit", content2, context]]);
  }
  return events;
}
function tokenizeHeadingAtx(effects, ok2, nok) {
  let size = 0;
  return start2;
  function start2(code2) {
    effects.enter("atxHeading");
    return before(code2);
  }
  function before(code2) {
    effects.enter("atxHeadingSequence");
    return sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    if (code2 === 35 && size++ < 6) {
      effects.consume(code2);
      return sequenceOpen;
    }
    if (code2 === null || markdownLineEndingOrSpace(code2)) {
      effects.exit("atxHeadingSequence");
      return atBreak(code2);
    }
    return nok(code2);
  }
  function atBreak(code2) {
    if (code2 === 35) {
      effects.enter("atxHeadingSequence");
      return sequenceFurther(code2);
    }
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("atxHeading");
      return ok2(code2);
    }
    if (markdownSpace(code2)) {
      return factorySpace(effects, atBreak, "whitespace")(code2);
    }
    effects.enter("atxHeadingText");
    return data(code2);
  }
  function sequenceFurther(code2) {
    if (code2 === 35) {
      effects.consume(code2);
      return sequenceFurther;
    }
    effects.exit("atxHeadingSequence");
    return atBreak(code2);
  }
  function data(code2) {
    if (code2 === null || code2 === 35 || markdownLineEndingOrSpace(code2)) {
      effects.exit("atxHeadingText");
      return atBreak(code2);
    }
    effects.consume(code2);
    return data;
  }
}
const htmlBlockNames = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
const htmlRawNames = ["pre", "script", "style", "textarea"];
const htmlFlow = {
  concrete: true,
  name: "htmlFlow",
  resolveTo: resolveToHtmlFlow,
  tokenize: tokenizeHtmlFlow
};
const blankLineBefore = {
  partial: true,
  tokenize: tokenizeBlankLineBefore
};
const nonLazyContinuationStart = {
  partial: true,
  tokenize: tokenizeNonLazyContinuationStart
};
function resolveToHtmlFlow(events) {
  let index2 = events.length;
  while (index2--) {
    if (events[index2][0] === "enter" && events[index2][1].type === "htmlFlow") {
      break;
    }
  }
  if (index2 > 1 && events[index2 - 2][1].type === "linePrefix") {
    events[index2][1].start = events[index2 - 2][1].start;
    events[index2 + 1][1].start = events[index2 - 2][1].start;
    events.splice(index2 - 2, 2);
  }
  return events;
}
function tokenizeHtmlFlow(effects, ok2, nok) {
  const self2 = this;
  let marker;
  let closingTag;
  let buffer2;
  let index2;
  let markerB;
  return start2;
  function start2(code2) {
    return before(code2);
  }
  function before(code2) {
    effects.enter("htmlFlow");
    effects.enter("htmlFlowData");
    effects.consume(code2);
    return open;
  }
  function open(code2) {
    if (code2 === 33) {
      effects.consume(code2);
      return declarationOpen;
    }
    if (code2 === 47) {
      effects.consume(code2);
      closingTag = true;
      return tagCloseStart;
    }
    if (code2 === 63) {
      effects.consume(code2);
      marker = 3;
      return self2.interrupt ? ok2 : continuationDeclarationInside;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      buffer2 = String.fromCharCode(code2);
      return tagName;
    }
    return nok(code2);
  }
  function declarationOpen(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      marker = 2;
      return commentOpenInside;
    }
    if (code2 === 91) {
      effects.consume(code2);
      marker = 5;
      index2 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      marker = 4;
      return self2.interrupt ? ok2 : continuationDeclarationInside;
    }
    return nok(code2);
  }
  function commentOpenInside(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return self2.interrupt ? ok2 : continuationDeclarationInside;
    }
    return nok(code2);
  }
  function cdataOpenInside(code2) {
    const value = "CDATA[";
    if (code2 === value.charCodeAt(index2++)) {
      effects.consume(code2);
      if (index2 === value.length) {
        return self2.interrupt ? ok2 : continuation;
      }
      return cdataOpenInside;
    }
    return nok(code2);
  }
  function tagCloseStart(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      buffer2 = String.fromCharCode(code2);
      return tagName;
    }
    return nok(code2);
  }
  function tagName(code2) {
    if (code2 === null || code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
      const slash = code2 === 47;
      const name2 = buffer2.toLowerCase();
      if (!slash && !closingTag && htmlRawNames.includes(name2)) {
        marker = 1;
        return self2.interrupt ? ok2(code2) : continuation(code2);
      }
      if (htmlBlockNames.includes(buffer2.toLowerCase())) {
        marker = 6;
        if (slash) {
          effects.consume(code2);
          return basicSelfClosing;
        }
        return self2.interrupt ? ok2(code2) : continuation(code2);
      }
      marker = 7;
      return self2.interrupt && !self2.parser.lazy[self2.now().line] ? nok(code2) : closingTag ? completeClosingTagAfter(code2) : completeAttributeNameBefore(code2);
    }
    if (code2 === 45 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      buffer2 += String.fromCharCode(code2);
      return tagName;
    }
    return nok(code2);
  }
  function basicSelfClosing(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      return self2.interrupt ? ok2 : continuation;
    }
    return nok(code2);
  }
  function completeClosingTagAfter(code2) {
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeClosingTagAfter;
    }
    return completeEnd(code2);
  }
  function completeAttributeNameBefore(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      return completeEnd;
    }
    if (code2 === 58 || code2 === 95 || asciiAlpha(code2)) {
      effects.consume(code2);
      return completeAttributeName;
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAttributeNameBefore;
    }
    return completeEnd(code2);
  }
  function completeAttributeName(code2) {
    if (code2 === 45 || code2 === 46 || code2 === 58 || code2 === 95 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return completeAttributeName;
    }
    return completeAttributeNameAfter(code2);
  }
  function completeAttributeNameAfter(code2) {
    if (code2 === 61) {
      effects.consume(code2);
      return completeAttributeValueBefore;
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAttributeNameAfter;
    }
    return completeAttributeNameBefore(code2);
  }
  function completeAttributeValueBefore(code2) {
    if (code2 === null || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96) {
      return nok(code2);
    }
    if (code2 === 34 || code2 === 39) {
      effects.consume(code2);
      markerB = code2;
      return completeAttributeValueQuoted;
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAttributeValueBefore;
    }
    return completeAttributeValueUnquoted(code2);
  }
  function completeAttributeValueQuoted(code2) {
    if (code2 === markerB) {
      effects.consume(code2);
      markerB = null;
      return completeAttributeValueQuotedAfter;
    }
    if (code2 === null || markdownLineEnding(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return completeAttributeValueQuoted;
  }
  function completeAttributeValueUnquoted(code2) {
    if (code2 === null || code2 === 34 || code2 === 39 || code2 === 47 || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96 || markdownLineEndingOrSpace(code2)) {
      return completeAttributeNameAfter(code2);
    }
    effects.consume(code2);
    return completeAttributeValueUnquoted;
  }
  function completeAttributeValueQuotedAfter(code2) {
    if (code2 === 47 || code2 === 62 || markdownSpace(code2)) {
      return completeAttributeNameBefore(code2);
    }
    return nok(code2);
  }
  function completeEnd(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      return completeAfter;
    }
    return nok(code2);
  }
  function completeAfter(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return continuation(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAfter;
    }
    return nok(code2);
  }
  function continuation(code2) {
    if (code2 === 45 && marker === 2) {
      effects.consume(code2);
      return continuationCommentInside;
    }
    if (code2 === 60 && marker === 1) {
      effects.consume(code2);
      return continuationRawTagOpen;
    }
    if (code2 === 62 && marker === 4) {
      effects.consume(code2);
      return continuationClose;
    }
    if (code2 === 63 && marker === 3) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    if (code2 === 93 && marker === 5) {
      effects.consume(code2);
      return continuationCdataInside;
    }
    if (markdownLineEnding(code2) && (marker === 6 || marker === 7)) {
      effects.exit("htmlFlowData");
      return effects.check(blankLineBefore, continuationAfter, continuationStart)(code2);
    }
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("htmlFlowData");
      return continuationStart(code2);
    }
    effects.consume(code2);
    return continuation;
  }
  function continuationStart(code2) {
    return effects.check(nonLazyContinuationStart, continuationStartNonLazy, continuationAfter)(code2);
  }
  function continuationStartNonLazy(code2) {
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return continuationBefore;
  }
  function continuationBefore(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return continuationStart(code2);
    }
    effects.enter("htmlFlowData");
    return continuation(code2);
  }
  function continuationCommentInside(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationRawTagOpen(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      buffer2 = "";
      return continuationRawEndTag;
    }
    return continuation(code2);
  }
  function continuationRawEndTag(code2) {
    if (code2 === 62) {
      const name2 = buffer2.toLowerCase();
      if (htmlRawNames.includes(name2)) {
        effects.consume(code2);
        return continuationClose;
      }
      return continuation(code2);
    }
    if (asciiAlpha(code2) && buffer2.length < 8) {
      effects.consume(code2);
      buffer2 += String.fromCharCode(code2);
      return continuationRawEndTag;
    }
    return continuation(code2);
  }
  function continuationCdataInside(code2) {
    if (code2 === 93) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationDeclarationInside(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      return continuationClose;
    }
    if (code2 === 45 && marker === 2) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationClose(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("htmlFlowData");
      return continuationAfter(code2);
    }
    effects.consume(code2);
    return continuationClose;
  }
  function continuationAfter(code2) {
    effects.exit("htmlFlow");
    return ok2(code2);
  }
}
function tokenizeNonLazyContinuationStart(effects, ok2, nok) {
  const self2 = this;
  return start2;
  function start2(code2) {
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    return self2.parser.lazy[self2.now().line] ? nok(code2) : ok2(code2);
  }
}
function tokenizeBlankLineBefore(effects, ok2, nok) {
  return start2;
  function start2(code2) {
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return effects.attempt(blankLine, ok2, nok);
  }
}
const htmlText = {
  name: "htmlText",
  tokenize: tokenizeHtmlText
};
function tokenizeHtmlText(effects, ok2, nok) {
  const self2 = this;
  let marker;
  let index2;
  let returnState;
  return start2;
  function start2(code2) {
    effects.enter("htmlText");
    effects.enter("htmlTextData");
    effects.consume(code2);
    return open;
  }
  function open(code2) {
    if (code2 === 33) {
      effects.consume(code2);
      return declarationOpen;
    }
    if (code2 === 47) {
      effects.consume(code2);
      return tagCloseStart;
    }
    if (code2 === 63) {
      effects.consume(code2);
      return instruction;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return tagOpen;
    }
    return nok(code2);
  }
  function declarationOpen(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return commentOpenInside;
    }
    if (code2 === 91) {
      effects.consume(code2);
      index2 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return declaration2;
    }
    return nok(code2);
  }
  function commentOpenInside(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return commentEnd;
    }
    return nok(code2);
  }
  function comment2(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 45) {
      effects.consume(code2);
      return commentClose;
    }
    if (markdownLineEnding(code2)) {
      returnState = comment2;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return comment2;
  }
  function commentClose(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return commentEnd;
    }
    return comment2(code2);
  }
  function commentEnd(code2) {
    return code2 === 62 ? end(code2) : code2 === 45 ? commentClose(code2) : comment2(code2);
  }
  function cdataOpenInside(code2) {
    const value = "CDATA[";
    if (code2 === value.charCodeAt(index2++)) {
      effects.consume(code2);
      return index2 === value.length ? cdata : cdataOpenInside;
    }
    return nok(code2);
  }
  function cdata(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 93) {
      effects.consume(code2);
      return cdataClose;
    }
    if (markdownLineEnding(code2)) {
      returnState = cdata;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return cdata;
  }
  function cdataClose(code2) {
    if (code2 === 93) {
      effects.consume(code2);
      return cdataEnd;
    }
    return cdata(code2);
  }
  function cdataEnd(code2) {
    if (code2 === 62) {
      return end(code2);
    }
    if (code2 === 93) {
      effects.consume(code2);
      return cdataEnd;
    }
    return cdata(code2);
  }
  function declaration2(code2) {
    if (code2 === null || code2 === 62) {
      return end(code2);
    }
    if (markdownLineEnding(code2)) {
      returnState = declaration2;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return declaration2;
  }
  function instruction(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 63) {
      effects.consume(code2);
      return instructionClose;
    }
    if (markdownLineEnding(code2)) {
      returnState = instruction;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return instruction;
  }
  function instructionClose(code2) {
    return code2 === 62 ? end(code2) : instruction(code2);
  }
  function tagCloseStart(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return tagClose;
    }
    return nok(code2);
  }
  function tagClose(code2) {
    if (code2 === 45 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return tagClose;
    }
    return tagCloseBetween(code2);
  }
  function tagCloseBetween(code2) {
    if (markdownLineEnding(code2)) {
      returnState = tagCloseBetween;
      return lineEndingBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagCloseBetween;
    }
    return end(code2);
  }
  function tagOpen(code2) {
    if (code2 === 45 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return tagOpen;
    }
    if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
      return tagOpenBetween(code2);
    }
    return nok(code2);
  }
  function tagOpenBetween(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      return end;
    }
    if (code2 === 58 || code2 === 95 || asciiAlpha(code2)) {
      effects.consume(code2);
      return tagOpenAttributeName;
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenBetween;
      return lineEndingBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagOpenBetween;
    }
    return end(code2);
  }
  function tagOpenAttributeName(code2) {
    if (code2 === 45 || code2 === 46 || code2 === 58 || code2 === 95 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return tagOpenAttributeName;
    }
    return tagOpenAttributeNameAfter(code2);
  }
  function tagOpenAttributeNameAfter(code2) {
    if (code2 === 61) {
      effects.consume(code2);
      return tagOpenAttributeValueBefore;
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenAttributeNameAfter;
      return lineEndingBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagOpenAttributeNameAfter;
    }
    return tagOpenBetween(code2);
  }
  function tagOpenAttributeValueBefore(code2) {
    if (code2 === null || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96) {
      return nok(code2);
    }
    if (code2 === 34 || code2 === 39) {
      effects.consume(code2);
      marker = code2;
      return tagOpenAttributeValueQuoted;
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenAttributeValueBefore;
      return lineEndingBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagOpenAttributeValueBefore;
    }
    effects.consume(code2);
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuoted(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      marker = void 0;
      return tagOpenAttributeValueQuotedAfter;
    }
    if (code2 === null) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenAttributeValueQuoted;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return tagOpenAttributeValueQuoted;
  }
  function tagOpenAttributeValueUnquoted(code2) {
    if (code2 === null || code2 === 34 || code2 === 39 || code2 === 60 || code2 === 61 || code2 === 96) {
      return nok(code2);
    }
    if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
      return tagOpenBetween(code2);
    }
    effects.consume(code2);
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuotedAfter(code2) {
    if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
      return tagOpenBetween(code2);
    }
    return nok(code2);
  }
  function end(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      effects.exit("htmlTextData");
      effects.exit("htmlText");
      return ok2;
    }
    return nok(code2);
  }
  function lineEndingBefore(code2) {
    effects.exit("htmlTextData");
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return lineEndingAfter;
  }
  function lineEndingAfter(code2) {
    return markdownSpace(code2) ? factorySpace(effects, lineEndingAfterPrefix, "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code2) : lineEndingAfterPrefix(code2);
  }
  function lineEndingAfterPrefix(code2) {
    effects.enter("htmlTextData");
    return returnState(code2);
  }
}
const labelEnd = {
  name: "labelEnd",
  resolveAll: resolveAllLabelEnd,
  resolveTo: resolveToLabelEnd,
  tokenize: tokenizeLabelEnd
};
const resourceConstruct = {
  tokenize: tokenizeResource
};
const referenceFullConstruct = {
  tokenize: tokenizeReferenceFull
};
const referenceCollapsedConstruct = {
  tokenize: tokenizeReferenceCollapsed
};
function resolveAllLabelEnd(events) {
  let index2 = -1;
  const newEvents = [];
  while (++index2 < events.length) {
    const token2 = events[index2][1];
    newEvents.push(events[index2]);
    if (token2.type === "labelImage" || token2.type === "labelLink" || token2.type === "labelEnd") {
      const offset = token2.type === "labelImage" ? 4 : 2;
      token2.type = "data";
      index2 += offset;
    }
  }
  if (events.length !== newEvents.length) {
    splice(events, 0, events.length, newEvents);
  }
  return events;
}
function resolveToLabelEnd(events, context) {
  let index2 = events.length;
  let offset = 0;
  let token2;
  let open;
  let close;
  let media;
  while (index2--) {
    token2 = events[index2][1];
    if (open) {
      if (token2.type === "link" || token2.type === "labelLink" && token2._inactive) {
        break;
      }
      if (events[index2][0] === "enter" && token2.type === "labelLink") {
        token2._inactive = true;
      }
    } else if (close) {
      if (events[index2][0] === "enter" && (token2.type === "labelImage" || token2.type === "labelLink") && !token2._balanced) {
        open = index2;
        if (token2.type !== "labelLink") {
          offset = 2;
          break;
        }
      }
    } else if (token2.type === "labelEnd") {
      close = index2;
    }
  }
  const group = {
    type: events[open][1].type === "labelLink" ? "link" : "image",
    start: {
      ...events[open][1].start
    },
    end: {
      ...events[events.length - 1][1].end
    }
  };
  const label = {
    type: "label",
    start: {
      ...events[open][1].start
    },
    end: {
      ...events[close][1].end
    }
  };
  const text2 = {
    type: "labelText",
    start: {
      ...events[open + offset + 2][1].end
    },
    end: {
      ...events[close - 2][1].start
    }
  };
  media = [["enter", group, context], ["enter", label, context]];
  media = push(media, events.slice(open + 1, open + offset + 3));
  media = push(media, [["enter", text2, context]]);
  media = push(media, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + offset + 4, close - 3), context));
  media = push(media, [["exit", text2, context], events[close - 2], events[close - 1], ["exit", label, context]]);
  media = push(media, events.slice(close + 1));
  media = push(media, [["exit", group, context]]);
  splice(events, open, events.length, media);
  return events;
}
function tokenizeLabelEnd(effects, ok2, nok) {
  const self2 = this;
  let index2 = self2.events.length;
  let labelStart;
  let defined;
  while (index2--) {
    if ((self2.events[index2][1].type === "labelImage" || self2.events[index2][1].type === "labelLink") && !self2.events[index2][1]._balanced) {
      labelStart = self2.events[index2][1];
      break;
    }
  }
  return start2;
  function start2(code2) {
    if (!labelStart) {
      return nok(code2);
    }
    if (labelStart._inactive) {
      return labelEndNok(code2);
    }
    defined = self2.parser.defined.includes(normalizeIdentifier(self2.sliceSerialize({
      start: labelStart.end,
      end: self2.now()
    })));
    effects.enter("labelEnd");
    effects.enter("labelMarker");
    effects.consume(code2);
    effects.exit("labelMarker");
    effects.exit("labelEnd");
    return after;
  }
  function after(code2) {
    if (code2 === 40) {
      return effects.attempt(resourceConstruct, labelEndOk, defined ? labelEndOk : labelEndNok)(code2);
    }
    if (code2 === 91) {
      return effects.attempt(referenceFullConstruct, labelEndOk, defined ? referenceNotFull : labelEndNok)(code2);
    }
    return defined ? labelEndOk(code2) : labelEndNok(code2);
  }
  function referenceNotFull(code2) {
    return effects.attempt(referenceCollapsedConstruct, labelEndOk, labelEndNok)(code2);
  }
  function labelEndOk(code2) {
    return ok2(code2);
  }
  function labelEndNok(code2) {
    labelStart._balanced = true;
    return nok(code2);
  }
}
function tokenizeResource(effects, ok2, nok) {
  return resourceStart;
  function resourceStart(code2) {
    effects.enter("resource");
    effects.enter("resourceMarker");
    effects.consume(code2);
    effects.exit("resourceMarker");
    return resourceBefore;
  }
  function resourceBefore(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceOpen)(code2) : resourceOpen(code2);
  }
  function resourceOpen(code2) {
    if (code2 === 41) {
      return resourceEnd(code2);
    }
    return factoryDestination(effects, resourceDestinationAfter, resourceDestinationMissing, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(code2);
  }
  function resourceDestinationAfter(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceBetween)(code2) : resourceEnd(code2);
  }
  function resourceDestinationMissing(code2) {
    return nok(code2);
  }
  function resourceBetween(code2) {
    if (code2 === 34 || code2 === 39 || code2 === 40) {
      return factoryTitle(effects, resourceTitleAfter, nok, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(code2);
    }
    return resourceEnd(code2);
  }
  function resourceTitleAfter(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceEnd)(code2) : resourceEnd(code2);
  }
  function resourceEnd(code2) {
    if (code2 === 41) {
      effects.enter("resourceMarker");
      effects.consume(code2);
      effects.exit("resourceMarker");
      effects.exit("resource");
      return ok2;
    }
    return nok(code2);
  }
}
function tokenizeReferenceFull(effects, ok2, nok) {
  const self2 = this;
  return referenceFull;
  function referenceFull(code2) {
    return factoryLabel.call(self2, effects, referenceFullAfter, referenceFullMissing, "reference", "referenceMarker", "referenceString")(code2);
  }
  function referenceFullAfter(code2) {
    return self2.parser.defined.includes(normalizeIdentifier(self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1))) ? ok2(code2) : nok(code2);
  }
  function referenceFullMissing(code2) {
    return nok(code2);
  }
}
function tokenizeReferenceCollapsed(effects, ok2, nok) {
  return referenceCollapsedStart;
  function referenceCollapsedStart(code2) {
    effects.enter("reference");
    effects.enter("referenceMarker");
    effects.consume(code2);
    effects.exit("referenceMarker");
    return referenceCollapsedOpen;
  }
  function referenceCollapsedOpen(code2) {
    if (code2 === 93) {
      effects.enter("referenceMarker");
      effects.consume(code2);
      effects.exit("referenceMarker");
      effects.exit("reference");
      return ok2;
    }
    return nok(code2);
  }
}
const labelStartImage = {
  name: "labelStartImage",
  resolveAll: labelEnd.resolveAll,
  tokenize: tokenizeLabelStartImage
};
function tokenizeLabelStartImage(effects, ok2, nok) {
  const self2 = this;
  return start2;
  function start2(code2) {
    effects.enter("labelImage");
    effects.enter("labelImageMarker");
    effects.consume(code2);
    effects.exit("labelImageMarker");
    return open;
  }
  function open(code2) {
    if (code2 === 91) {
      effects.enter("labelMarker");
      effects.consume(code2);
      effects.exit("labelMarker");
      effects.exit("labelImage");
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    return code2 === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code2) : ok2(code2);
  }
}
const labelStartLink = {
  name: "labelStartLink",
  resolveAll: labelEnd.resolveAll,
  tokenize: tokenizeLabelStartLink
};
function tokenizeLabelStartLink(effects, ok2, nok) {
  const self2 = this;
  return start2;
  function start2(code2) {
    effects.enter("labelLink");
    effects.enter("labelMarker");
    effects.consume(code2);
    effects.exit("labelMarker");
    effects.exit("labelLink");
    return after;
  }
  function after(code2) {
    return code2 === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code2) : ok2(code2);
  }
}
const lineEnding = {
  name: "lineEnding",
  tokenize: tokenizeLineEnding
};
function tokenizeLineEnding(effects, ok2) {
  return start2;
  function start2(code2) {
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return factorySpace(effects, ok2, "linePrefix");
  }
}
const thematicBreak$1 = {
  name: "thematicBreak",
  tokenize: tokenizeThematicBreak
};
function tokenizeThematicBreak(effects, ok2, nok) {
  let size = 0;
  let marker;
  return start2;
  function start2(code2) {
    effects.enter("thematicBreak");
    return before(code2);
  }
  function before(code2) {
    marker = code2;
    return atBreak(code2);
  }
  function atBreak(code2) {
    if (code2 === marker) {
      effects.enter("thematicBreakSequence");
      return sequence(code2);
    }
    if (size >= 3 && (code2 === null || markdownLineEnding(code2))) {
      effects.exit("thematicBreak");
      return ok2(code2);
    }
    return nok(code2);
  }
  function sequence(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      size++;
      return sequence;
    }
    effects.exit("thematicBreakSequence");
    return markdownSpace(code2) ? factorySpace(effects, atBreak, "whitespace")(code2) : atBreak(code2);
  }
}
const list$1 = {
  continuation: {
    tokenize: tokenizeListContinuation
  },
  exit: tokenizeListEnd,
  name: "list",
  tokenize: tokenizeListStart
};
const listItemPrefixWhitespaceConstruct = {
  partial: true,
  tokenize: tokenizeListItemPrefixWhitespace
};
const indentConstruct = {
  partial: true,
  tokenize: tokenizeIndent$1
};
function tokenizeListStart(effects, ok2, nok) {
  const self2 = this;
  const tail = self2.events[self2.events.length - 1];
  let initialSize = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
  let size = 0;
  return start2;
  function start2(code2) {
    const kind = self2.containerState.type || (code2 === 42 || code2 === 43 || code2 === 45 ? "listUnordered" : "listOrdered");
    if (kind === "listUnordered" ? !self2.containerState.marker || code2 === self2.containerState.marker : asciiDigit(code2)) {
      if (!self2.containerState.type) {
        self2.containerState.type = kind;
        effects.enter(kind, {
          _container: true
        });
      }
      if (kind === "listUnordered") {
        effects.enter("listItemPrefix");
        return code2 === 42 || code2 === 45 ? effects.check(thematicBreak$1, nok, atMarker)(code2) : atMarker(code2);
      }
      if (!self2.interrupt || code2 === 49) {
        effects.enter("listItemPrefix");
        effects.enter("listItemValue");
        return inside(code2);
      }
    }
    return nok(code2);
  }
  function inside(code2) {
    if (asciiDigit(code2) && ++size < 10) {
      effects.consume(code2);
      return inside;
    }
    if ((!self2.interrupt || size < 2) && (self2.containerState.marker ? code2 === self2.containerState.marker : code2 === 41 || code2 === 46)) {
      effects.exit("listItemValue");
      return atMarker(code2);
    }
    return nok(code2);
  }
  function atMarker(code2) {
    effects.enter("listItemMarker");
    effects.consume(code2);
    effects.exit("listItemMarker");
    self2.containerState.marker = self2.containerState.marker || code2;
    return effects.check(
      blankLine,
      // Cant be empty when interrupting.
      self2.interrupt ? nok : onBlank,
      effects.attempt(listItemPrefixWhitespaceConstruct, endOfPrefix, otherPrefix)
    );
  }
  function onBlank(code2) {
    self2.containerState.initialBlankLine = true;
    initialSize++;
    return endOfPrefix(code2);
  }
  function otherPrefix(code2) {
    if (markdownSpace(code2)) {
      effects.enter("listItemPrefixWhitespace");
      effects.consume(code2);
      effects.exit("listItemPrefixWhitespace");
      return endOfPrefix;
    }
    return nok(code2);
  }
  function endOfPrefix(code2) {
    self2.containerState.size = initialSize + self2.sliceSerialize(effects.exit("listItemPrefix"), true).length;
    return ok2(code2);
  }
}
function tokenizeListContinuation(effects, ok2, nok) {
  const self2 = this;
  self2.containerState._closeFlow = void 0;
  return effects.check(blankLine, onBlank, notBlank);
  function onBlank(code2) {
    self2.containerState.furtherBlankLines = self2.containerState.furtherBlankLines || self2.containerState.initialBlankLine;
    return factorySpace(effects, ok2, "listItemIndent", self2.containerState.size + 1)(code2);
  }
  function notBlank(code2) {
    if (self2.containerState.furtherBlankLines || !markdownSpace(code2)) {
      self2.containerState.furtherBlankLines = void 0;
      self2.containerState.initialBlankLine = void 0;
      return notInCurrentItem(code2);
    }
    self2.containerState.furtherBlankLines = void 0;
    self2.containerState.initialBlankLine = void 0;
    return effects.attempt(indentConstruct, ok2, notInCurrentItem)(code2);
  }
  function notInCurrentItem(code2) {
    self2.containerState._closeFlow = true;
    self2.interrupt = void 0;
    return factorySpace(effects, effects.attempt(list$1, ok2, nok), "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code2);
  }
}
function tokenizeIndent$1(effects, ok2, nok) {
  const self2 = this;
  return factorySpace(effects, afterPrefix, "listItemIndent", self2.containerState.size + 1);
  function afterPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === "listItemIndent" && tail[2].sliceSerialize(tail[1], true).length === self2.containerState.size ? ok2(code2) : nok(code2);
  }
}
function tokenizeListEnd(effects) {
  effects.exit(this.containerState.type);
}
function tokenizeListItemPrefixWhitespace(effects, ok2, nok) {
  const self2 = this;
  return factorySpace(effects, afterPrefix, "listItemPrefixWhitespace", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4 + 1);
  function afterPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return !markdownSpace(code2) && tail && tail[1].type === "listItemPrefixWhitespace" ? ok2(code2) : nok(code2);
  }
}
const setextUnderline = {
  name: "setextUnderline",
  resolveTo: resolveToSetextUnderline,
  tokenize: tokenizeSetextUnderline
};
function resolveToSetextUnderline(events, context) {
  let index2 = events.length;
  let content2;
  let text2;
  let definition2;
  while (index2--) {
    if (events[index2][0] === "enter") {
      if (events[index2][1].type === "content") {
        content2 = index2;
        break;
      }
      if (events[index2][1].type === "paragraph") {
        text2 = index2;
      }
    } else {
      if (events[index2][1].type === "content") {
        events.splice(index2, 1);
      }
      if (!definition2 && events[index2][1].type === "definition") {
        definition2 = index2;
      }
    }
  }
  const heading2 = {
    type: "setextHeading",
    start: {
      ...events[text2][1].start
    },
    end: {
      ...events[events.length - 1][1].end
    }
  };
  events[text2][1].type = "setextHeadingText";
  if (definition2) {
    events.splice(text2, 0, ["enter", heading2, context]);
    events.splice(definition2 + 1, 0, ["exit", events[content2][1], context]);
    events[content2][1].end = {
      ...events[definition2][1].end
    };
  } else {
    events[content2][1] = heading2;
  }
  events.push(["exit", heading2, context]);
  return events;
}
function tokenizeSetextUnderline(effects, ok2, nok) {
  const self2 = this;
  let marker;
  return start2;
  function start2(code2) {
    let index2 = self2.events.length;
    let paragraph2;
    while (index2--) {
      if (self2.events[index2][1].type !== "lineEnding" && self2.events[index2][1].type !== "linePrefix" && self2.events[index2][1].type !== "content") {
        paragraph2 = self2.events[index2][1].type === "paragraph";
        break;
      }
    }
    if (!self2.parser.lazy[self2.now().line] && (self2.interrupt || paragraph2)) {
      effects.enter("setextHeadingLine");
      marker = code2;
      return before(code2);
    }
    return nok(code2);
  }
  function before(code2) {
    effects.enter("setextHeadingLineSequence");
    return inside(code2);
  }
  function inside(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      return inside;
    }
    effects.exit("setextHeadingLineSequence");
    return markdownSpace(code2) ? factorySpace(effects, after, "lineSuffix")(code2) : after(code2);
  }
  function after(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("setextHeadingLine");
      return ok2(code2);
    }
    return nok(code2);
  }
}
const indent = {
  tokenize: tokenizeIndent,
  partial: true
};
function gfmFootnote() {
  return {
    document: {
      [91]: {
        name: "gfmFootnoteDefinition",
        tokenize: tokenizeDefinitionStart,
        continuation: {
          tokenize: tokenizeDefinitionContinuation
        },
        exit: gfmFootnoteDefinitionEnd
      }
    },
    text: {
      [91]: {
        name: "gfmFootnoteCall",
        tokenize: tokenizeGfmFootnoteCall
      },
      [93]: {
        name: "gfmPotentialFootnoteCall",
        add: "after",
        tokenize: tokenizePotentialGfmFootnoteCall,
        resolveTo: resolveToPotentialGfmFootnoteCall
      }
    }
  };
}
function tokenizePotentialGfmFootnoteCall(effects, ok2, nok) {
  const self2 = this;
  let index2 = self2.events.length;
  const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
  let labelStart;
  while (index2--) {
    const token2 = self2.events[index2][1];
    if (token2.type === "labelImage") {
      labelStart = token2;
      break;
    }
    if (token2.type === "gfmFootnoteCall" || token2.type === "labelLink" || token2.type === "label" || token2.type === "image" || token2.type === "link") {
      break;
    }
  }
  return start2;
  function start2(code2) {
    if (!labelStart || !labelStart._balanced) {
      return nok(code2);
    }
    const id2 = normalizeIdentifier(self2.sliceSerialize({
      start: labelStart.end,
      end: self2.now()
    }));
    if (id2.codePointAt(0) !== 94 || !defined.includes(id2.slice(1))) {
      return nok(code2);
    }
    effects.enter("gfmFootnoteCallLabelMarker");
    effects.consume(code2);
    effects.exit("gfmFootnoteCallLabelMarker");
    return ok2(code2);
  }
}
function resolveToPotentialGfmFootnoteCall(events, context) {
  let index2 = events.length;
  while (index2--) {
    if (events[index2][1].type === "labelImage" && events[index2][0] === "enter") {
      events[index2][1];
      break;
    }
  }
  events[index2 + 1][1].type = "data";
  events[index2 + 3][1].type = "gfmFootnoteCallLabelMarker";
  const call2 = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, events[index2 + 3][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  const marker = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, events[index2 + 3][1].end),
    end: Object.assign({}, events[index2 + 3][1].end)
  };
  marker.end.column++;
  marker.end.offset++;
  marker.end._bufferIndex++;
  const string2 = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, marker.end),
    end: Object.assign({}, events[events.length - 1][1].start)
  };
  const chunk = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, string2.start),
    end: Object.assign({}, string2.end)
  };
  const replacement = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    events[index2 + 1],
    events[index2 + 2],
    ["enter", call2, context],
    // The `[`
    events[index2 + 3],
    events[index2 + 4],
    // The `^`.
    ["enter", marker, context],
    ["exit", marker, context],
    // Everything in between.
    ["enter", string2, context],
    ["enter", chunk, context],
    ["exit", chunk, context],
    ["exit", string2, context],
    // The ending (`]`, properly parsed and labelled).
    events[events.length - 2],
    events[events.length - 1],
    ["exit", call2, context]
  ];
  events.splice(index2, events.length - index2 + 1, ...replacement);
  return events;
}
function tokenizeGfmFootnoteCall(effects, ok2, nok) {
  const self2 = this;
  const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
  let size = 0;
  let data;
  return start2;
  function start2(code2) {
    effects.enter("gfmFootnoteCall");
    effects.enter("gfmFootnoteCallLabelMarker");
    effects.consume(code2);
    effects.exit("gfmFootnoteCallLabelMarker");
    return callStart;
  }
  function callStart(code2) {
    if (code2 !== 94) return nok(code2);
    effects.enter("gfmFootnoteCallMarker");
    effects.consume(code2);
    effects.exit("gfmFootnoteCallMarker");
    effects.enter("gfmFootnoteCallString");
    effects.enter("chunkString").contentType = "string";
    return callData;
  }
  function callData(code2) {
    if (
      // Too long.
      size > 999 || // Closing brace with nothing.
      code2 === 93 && !data || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      code2 === null || code2 === 91 || markdownLineEndingOrSpace(code2)
    ) {
      return nok(code2);
    }
    if (code2 === 93) {
      effects.exit("chunkString");
      const token2 = effects.exit("gfmFootnoteCallString");
      if (!defined.includes(normalizeIdentifier(self2.sliceSerialize(token2)))) {
        return nok(code2);
      }
      effects.enter("gfmFootnoteCallLabelMarker");
      effects.consume(code2);
      effects.exit("gfmFootnoteCallLabelMarker");
      effects.exit("gfmFootnoteCall");
      return ok2;
    }
    if (!markdownLineEndingOrSpace(code2)) {
      data = true;
    }
    size++;
    effects.consume(code2);
    return code2 === 92 ? callEscape : callData;
  }
  function callEscape(code2) {
    if (code2 === 91 || code2 === 92 || code2 === 93) {
      effects.consume(code2);
      size++;
      return callData;
    }
    return callData(code2);
  }
}
function tokenizeDefinitionStart(effects, ok2, nok) {
  const self2 = this;
  const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
  let identifier2;
  let size = 0;
  let data;
  return start2;
  function start2(code2) {
    effects.enter("gfmFootnoteDefinition")._container = true;
    effects.enter("gfmFootnoteDefinitionLabel");
    effects.enter("gfmFootnoteDefinitionLabelMarker");
    effects.consume(code2);
    effects.exit("gfmFootnoteDefinitionLabelMarker");
    return labelAtMarker;
  }
  function labelAtMarker(code2) {
    if (code2 === 94) {
      effects.enter("gfmFootnoteDefinitionMarker");
      effects.consume(code2);
      effects.exit("gfmFootnoteDefinitionMarker");
      effects.enter("gfmFootnoteDefinitionLabelString");
      effects.enter("chunkString").contentType = "string";
      return labelInside;
    }
    return nok(code2);
  }
  function labelInside(code2) {
    if (
      // Too long.
      size > 999 || // Closing brace with nothing.
      code2 === 93 && !data || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      code2 === null || code2 === 91 || markdownLineEndingOrSpace(code2)
    ) {
      return nok(code2);
    }
    if (code2 === 93) {
      effects.exit("chunkString");
      const token2 = effects.exit("gfmFootnoteDefinitionLabelString");
      identifier2 = normalizeIdentifier(self2.sliceSerialize(token2));
      effects.enter("gfmFootnoteDefinitionLabelMarker");
      effects.consume(code2);
      effects.exit("gfmFootnoteDefinitionLabelMarker");
      effects.exit("gfmFootnoteDefinitionLabel");
      return labelAfter;
    }
    if (!markdownLineEndingOrSpace(code2)) {
      data = true;
    }
    size++;
    effects.consume(code2);
    return code2 === 92 ? labelEscape : labelInside;
  }
  function labelEscape(code2) {
    if (code2 === 91 || code2 === 92 || code2 === 93) {
      effects.consume(code2);
      size++;
      return labelInside;
    }
    return labelInside(code2);
  }
  function labelAfter(code2) {
    if (code2 === 58) {
      effects.enter("definitionMarker");
      effects.consume(code2);
      effects.exit("definitionMarker");
      if (!defined.includes(identifier2)) {
        defined.push(identifier2);
      }
      return factorySpace(effects, whitespaceAfter, "gfmFootnoteDefinitionWhitespace");
    }
    return nok(code2);
  }
  function whitespaceAfter(code2) {
    return ok2(code2);
  }
}
function tokenizeDefinitionContinuation(effects, ok2, nok) {
  return effects.check(blankLine, ok2, effects.attempt(indent, ok2, nok));
}
function gfmFootnoteDefinitionEnd(effects) {
  effects.exit("gfmFootnoteDefinition");
}
function tokenizeIndent(effects, ok2, nok) {
  const self2 = this;
  return factorySpace(effects, afterPrefix, "gfmFootnoteDefinitionIndent", 4 + 1);
  function afterPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === "gfmFootnoteDefinitionIndent" && tail[2].sliceSerialize(tail[1], true).length === 4 ? ok2(code2) : nok(code2);
  }
}
function gfmStrikethrough(options) {
  const options_ = options;
  let single = options_.singleTilde;
  const tokenizer = {
    name: "strikethrough",
    tokenize: tokenizeStrikethrough,
    resolveAll: resolveAllStrikethrough
  };
  if (single === null || single === void 0) {
    single = true;
  }
  return {
    text: {
      [126]: tokenizer
    },
    insideSpan: {
      null: [tokenizer]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function resolveAllStrikethrough(events, context) {
    let index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][0] === "enter" && events[index2][1].type === "strikethroughSequenceTemporary" && events[index2][1]._close) {
        let open = index2;
        while (open--) {
          if (events[open][0] === "exit" && events[open][1].type === "strikethroughSequenceTemporary" && events[open][1]._open && // If the sizes are the same:
          events[index2][1].end.offset - events[index2][1].start.offset === events[open][1].end.offset - events[open][1].start.offset) {
            events[index2][1].type = "strikethroughSequence";
            events[open][1].type = "strikethroughSequence";
            const strikethrough2 = {
              type: "strikethrough",
              start: Object.assign({}, events[open][1].start),
              end: Object.assign({}, events[index2][1].end)
            };
            const text2 = {
              type: "strikethroughText",
              start: Object.assign({}, events[open][1].end),
              end: Object.assign({}, events[index2][1].start)
            };
            const nextEvents = [["enter", strikethrough2, context], ["enter", events[open][1], context], ["exit", events[open][1], context], ["enter", text2, context]];
            const insideSpan2 = context.parser.constructs.insideSpan.null;
            if (insideSpan2) {
              splice(nextEvents, nextEvents.length, 0, resolveAll(insideSpan2, events.slice(open + 1, index2), context));
            }
            splice(nextEvents, nextEvents.length, 0, [["exit", text2, context], ["enter", events[index2][1], context], ["exit", events[index2][1], context], ["exit", strikethrough2, context]]);
            splice(events, open - 1, index2 - open + 3, nextEvents);
            index2 = open + nextEvents.length - 2;
            break;
          }
        }
      }
    }
    index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][1].type === "strikethroughSequenceTemporary") {
        events[index2][1].type = "data";
      }
    }
    return events;
  }
  function tokenizeStrikethrough(effects, ok2, nok) {
    const previous2 = this.previous;
    const events = this.events;
    let size = 0;
    return start2;
    function start2(code2) {
      if (previous2 === 126 && events[events.length - 1][1].type !== "characterEscape") {
        return nok(code2);
      }
      effects.enter("strikethroughSequenceTemporary");
      return more(code2);
    }
    function more(code2) {
      const before = classifyCharacter(previous2);
      if (code2 === 126) {
        if (size > 1) return nok(code2);
        effects.consume(code2);
        size++;
        return more;
      }
      if (size < 2 && !single) return nok(code2);
      const token2 = effects.exit("strikethroughSequenceTemporary");
      const after = classifyCharacter(code2);
      token2._open = !after || after === 2 && Boolean(before);
      token2._close = !before || before === 2 && Boolean(after);
      return ok2(code2);
    }
  }
}
class EditMap {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(index2, remove, add) {
    addImplementation(this, index2, remove, add);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImplementation(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(events) {
    this.map.sort(function(a2, b2) {
      return a2[0] - b2[0];
    });
    if (this.map.length === 0) {
      return;
    }
    let index2 = this.map.length;
    const vecs = [];
    while (index2 > 0) {
      index2 -= 1;
      vecs.push(events.slice(this.map[index2][0] + this.map[index2][1]), this.map[index2][2]);
      events.length = this.map[index2][0];
    }
    vecs.push([...events]);
    events.length = 0;
    let slice2 = vecs.pop();
    while (slice2) {
      events.push(...slice2);
      slice2 = vecs.pop();
    }
    this.map.length = 0;
  }
}
function addImplementation(editMap, at2, remove, add) {
  let index2 = 0;
  if (remove === 0 && add.length === 0) {
    return;
  }
  while (index2 < editMap.map.length) {
    if (editMap.map[index2][0] === at2) {
      editMap.map[index2][1] += remove;
      editMap.map[index2][2].push(...add);
      return;
    }
    index2 += 1;
  }
  editMap.map.push([at2, remove, add]);
}
function gfmTableAlign(events, index2) {
  let inDelimiterRow = false;
  const align = [];
  while (index2 < events.length) {
    const event = events[index2];
    if (inDelimiterRow) {
      if (event[0] === "enter") {
        if (event[1].type === "tableContent") {
          align.push(events[index2 + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
        }
      } else if (event[1].type === "tableContent") {
        if (events[index2 - 1][1].type === "tableDelimiterMarker") {
          const alignIndex = align.length - 1;
          align[alignIndex] = align[alignIndex] === "left" ? "center" : "right";
        }
      } else if (event[1].type === "tableDelimiterRow") {
        break;
      }
    } else if (event[0] === "enter" && event[1].type === "tableDelimiterRow") {
      inDelimiterRow = true;
    }
    index2 += 1;
  }
  return align;
}
function gfmTable() {
  return {
    flow: {
      null: {
        name: "table",
        tokenize: tokenizeTable,
        resolveAll: resolveTable
      }
    }
  };
}
function tokenizeTable(effects, ok2, nok) {
  const self2 = this;
  let size = 0;
  let sizeB = 0;
  let seen;
  return start2;
  function start2(code2) {
    let index2 = self2.events.length - 1;
    while (index2 > -1) {
      const type2 = self2.events[index2][1].type;
      if (type2 === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      type2 === "linePrefix") index2--;
      else break;
    }
    const tail = index2 > -1 ? self2.events[index2][1].type : null;
    const next2 = tail === "tableHead" || tail === "tableRow" ? bodyRowStart : headRowBefore;
    if (next2 === bodyRowStart && self2.parser.lazy[self2.now().line]) {
      return nok(code2);
    }
    return next2(code2);
  }
  function headRowBefore(code2) {
    effects.enter("tableHead");
    effects.enter("tableRow");
    return headRowStart(code2);
  }
  function headRowStart(code2) {
    if (code2 === 124) {
      return headRowBreak(code2);
    }
    seen = true;
    sizeB += 1;
    return headRowBreak(code2);
  }
  function headRowBreak(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      if (sizeB > 1) {
        sizeB = 0;
        self2.interrupt = true;
        effects.exit("tableRow");
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return headDelimiterStart;
      }
      return nok(code2);
    }
    if (markdownSpace(code2)) {
      return factorySpace(effects, headRowBreak, "whitespace")(code2);
    }
    sizeB += 1;
    if (seen) {
      seen = false;
      size += 1;
    }
    if (code2 === 124) {
      effects.enter("tableCellDivider");
      effects.consume(code2);
      effects.exit("tableCellDivider");
      seen = true;
      return headRowBreak;
    }
    effects.enter("data");
    return headRowData(code2);
  }
  function headRowData(code2) {
    if (code2 === null || code2 === 124 || markdownLineEndingOrSpace(code2)) {
      effects.exit("data");
      return headRowBreak(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? headRowEscape : headRowData;
  }
  function headRowEscape(code2) {
    if (code2 === 92 || code2 === 124) {
      effects.consume(code2);
      return headRowData;
    }
    return headRowData(code2);
  }
  function headDelimiterStart(code2) {
    self2.interrupt = false;
    if (self2.parser.lazy[self2.now().line]) {
      return nok(code2);
    }
    effects.enter("tableDelimiterRow");
    seen = false;
    if (markdownSpace(code2)) {
      return factorySpace(effects, headDelimiterBefore, "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code2);
    }
    return headDelimiterBefore(code2);
  }
  function headDelimiterBefore(code2) {
    if (code2 === 45 || code2 === 58) {
      return headDelimiterValueBefore(code2);
    }
    if (code2 === 124) {
      seen = true;
      effects.enter("tableCellDivider");
      effects.consume(code2);
      effects.exit("tableCellDivider");
      return headDelimiterCellBefore;
    }
    return headDelimiterNok(code2);
  }
  function headDelimiterCellBefore(code2) {
    if (markdownSpace(code2)) {
      return factorySpace(effects, headDelimiterValueBefore, "whitespace")(code2);
    }
    return headDelimiterValueBefore(code2);
  }
  function headDelimiterValueBefore(code2) {
    if (code2 === 58) {
      sizeB += 1;
      seen = true;
      effects.enter("tableDelimiterMarker");
      effects.consume(code2);
      effects.exit("tableDelimiterMarker");
      return headDelimiterLeftAlignmentAfter;
    }
    if (code2 === 45) {
      sizeB += 1;
      return headDelimiterLeftAlignmentAfter(code2);
    }
    if (code2 === null || markdownLineEnding(code2)) {
      return headDelimiterCellAfter(code2);
    }
    return headDelimiterNok(code2);
  }
  function headDelimiterLeftAlignmentAfter(code2) {
    if (code2 === 45) {
      effects.enter("tableDelimiterFiller");
      return headDelimiterFiller(code2);
    }
    return headDelimiterNok(code2);
  }
  function headDelimiterFiller(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return headDelimiterFiller;
    }
    if (code2 === 58) {
      seen = true;
      effects.exit("tableDelimiterFiller");
      effects.enter("tableDelimiterMarker");
      effects.consume(code2);
      effects.exit("tableDelimiterMarker");
      return headDelimiterRightAlignmentAfter;
    }
    effects.exit("tableDelimiterFiller");
    return headDelimiterRightAlignmentAfter(code2);
  }
  function headDelimiterRightAlignmentAfter(code2) {
    if (markdownSpace(code2)) {
      return factorySpace(effects, headDelimiterCellAfter, "whitespace")(code2);
    }
    return headDelimiterCellAfter(code2);
  }
  function headDelimiterCellAfter(code2) {
    if (code2 === 124) {
      return headDelimiterBefore(code2);
    }
    if (code2 === null || markdownLineEnding(code2)) {
      if (!seen || size !== sizeB) {
        return headDelimiterNok(code2);
      }
      effects.exit("tableDelimiterRow");
      effects.exit("tableHead");
      return ok2(code2);
    }
    return headDelimiterNok(code2);
  }
  function headDelimiterNok(code2) {
    return nok(code2);
  }
  function bodyRowStart(code2) {
    effects.enter("tableRow");
    return bodyRowBreak(code2);
  }
  function bodyRowBreak(code2) {
    if (code2 === 124) {
      effects.enter("tableCellDivider");
      effects.consume(code2);
      effects.exit("tableCellDivider");
      return bodyRowBreak;
    }
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("tableRow");
      return ok2(code2);
    }
    if (markdownSpace(code2)) {
      return factorySpace(effects, bodyRowBreak, "whitespace")(code2);
    }
    effects.enter("data");
    return bodyRowData(code2);
  }
  function bodyRowData(code2) {
    if (code2 === null || code2 === 124 || markdownLineEndingOrSpace(code2)) {
      effects.exit("data");
      return bodyRowBreak(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? bodyRowEscape : bodyRowData;
  }
  function bodyRowEscape(code2) {
    if (code2 === 92 || code2 === 124) {
      effects.consume(code2);
      return bodyRowData;
    }
    return bodyRowData(code2);
  }
}
function resolveTable(events, context) {
  let index2 = -1;
  let inFirstCellAwaitingPipe = true;
  let rowKind = 0;
  let lastCell = [0, 0, 0, 0];
  let cell = [0, 0, 0, 0];
  let afterHeadAwaitingFirstBodyRow = false;
  let lastTableEnd = 0;
  let currentTable;
  let currentBody;
  let currentCell;
  const map2 = new EditMap();
  while (++index2 < events.length) {
    const event = events[index2];
    const token2 = event[1];
    if (event[0] === "enter") {
      if (token2.type === "tableHead") {
        afterHeadAwaitingFirstBodyRow = false;
        if (lastTableEnd !== 0) {
          flushTableEnd(map2, context, lastTableEnd, currentTable, currentBody);
          currentBody = void 0;
          lastTableEnd = 0;
        }
        currentTable = {
          type: "table",
          start: Object.assign({}, token2.start),
          // Note: correct end is set later.
          end: Object.assign({}, token2.end)
        };
        map2.add(index2, 0, [["enter", currentTable, context]]);
      } else if (token2.type === "tableRow" || token2.type === "tableDelimiterRow") {
        inFirstCellAwaitingPipe = true;
        currentCell = void 0;
        lastCell = [0, 0, 0, 0];
        cell = [0, index2 + 1, 0, 0];
        if (afterHeadAwaitingFirstBodyRow) {
          afterHeadAwaitingFirstBodyRow = false;
          currentBody = {
            type: "tableBody",
            start: Object.assign({}, token2.start),
            // Note: correct end is set later.
            end: Object.assign({}, token2.end)
          };
          map2.add(index2, 0, [["enter", currentBody, context]]);
        }
        rowKind = token2.type === "tableDelimiterRow" ? 2 : currentBody ? 3 : 1;
      } else if (rowKind && (token2.type === "data" || token2.type === "tableDelimiterMarker" || token2.type === "tableDelimiterFiller")) {
        inFirstCellAwaitingPipe = false;
        if (cell[2] === 0) {
          if (lastCell[1] !== 0) {
            cell[0] = cell[1];
            currentCell = flushCell(map2, context, lastCell, rowKind, void 0, currentCell);
            lastCell = [0, 0, 0, 0];
          }
          cell[2] = index2;
        }
      } else if (token2.type === "tableCellDivider") {
        if (inFirstCellAwaitingPipe) {
          inFirstCellAwaitingPipe = false;
        } else {
          if (lastCell[1] !== 0) {
            cell[0] = cell[1];
            currentCell = flushCell(map2, context, lastCell, rowKind, void 0, currentCell);
          }
          lastCell = cell;
          cell = [lastCell[1], index2, 0, 0];
        }
      }
    } else if (token2.type === "tableHead") {
      afterHeadAwaitingFirstBodyRow = true;
      lastTableEnd = index2;
    } else if (token2.type === "tableRow" || token2.type === "tableDelimiterRow") {
      lastTableEnd = index2;
      if (lastCell[1] !== 0) {
        cell[0] = cell[1];
        currentCell = flushCell(map2, context, lastCell, rowKind, index2, currentCell);
      } else if (cell[1] !== 0) {
        currentCell = flushCell(map2, context, cell, rowKind, index2, currentCell);
      }
      rowKind = 0;
    } else if (rowKind && (token2.type === "data" || token2.type === "tableDelimiterMarker" || token2.type === "tableDelimiterFiller")) {
      cell[3] = index2;
    }
  }
  if (lastTableEnd !== 0) {
    flushTableEnd(map2, context, lastTableEnd, currentTable, currentBody);
  }
  map2.consume(context.events);
  index2 = -1;
  while (++index2 < context.events.length) {
    const event = context.events[index2];
    if (event[0] === "enter" && event[1].type === "table") {
      event[1]._align = gfmTableAlign(context.events, index2);
    }
  }
  return events;
}
function flushCell(map2, context, range, rowKind, rowEnd, previousCell) {
  const groupName = rowKind === 1 ? "tableHeader" : rowKind === 2 ? "tableDelimiter" : "tableData";
  const valueName = "tableContent";
  if (range[0] !== 0) {
    previousCell.end = Object.assign({}, getPoint(context.events, range[0]));
    map2.add(range[0], 0, [["exit", previousCell, context]]);
  }
  const now2 = getPoint(context.events, range[1]);
  previousCell = {
    type: groupName,
    start: Object.assign({}, now2),
    // Note: correct end is set later.
    end: Object.assign({}, now2)
  };
  map2.add(range[1], 0, [["enter", previousCell, context]]);
  if (range[2] !== 0) {
    const relatedStart = getPoint(context.events, range[2]);
    const relatedEnd = getPoint(context.events, range[3]);
    const valueToken = {
      type: valueName,
      start: Object.assign({}, relatedStart),
      end: Object.assign({}, relatedEnd)
    };
    map2.add(range[2], 0, [["enter", valueToken, context]]);
    if (rowKind !== 2) {
      const start2 = context.events[range[2]];
      const end = context.events[range[3]];
      start2[1].end = Object.assign({}, end[1].end);
      start2[1].type = "chunkText";
      start2[1].contentType = "text";
      if (range[3] > range[2] + 1) {
        const a2 = range[2] + 1;
        const b2 = range[3] - range[2] - 1;
        map2.add(a2, b2, []);
      }
    }
    map2.add(range[3] + 1, 0, [["exit", valueToken, context]]);
  }
  if (rowEnd !== void 0) {
    previousCell.end = Object.assign({}, getPoint(context.events, rowEnd));
    map2.add(rowEnd, 0, [["exit", previousCell, context]]);
    previousCell = void 0;
  }
  return previousCell;
}
function flushTableEnd(map2, context, index2, table2, tableBody) {
  const exits = [];
  const related = getPoint(context.events, index2);
  if (tableBody) {
    tableBody.end = Object.assign({}, related);
    exits.push(["exit", tableBody, context]);
  }
  table2.end = Object.assign({}, related);
  exits.push(["exit", table2, context]);
  map2.add(index2 + 1, 0, exits);
}
function getPoint(events, index2) {
  const event = events[index2];
  const side = event[0] === "enter" ? "start" : "end";
  return event[1][side];
}
const tasklistCheck = {
  name: "tasklistCheck",
  tokenize: tokenizeTasklistCheck
};
function gfmTaskListItem() {
  return {
    text: {
      [91]: tasklistCheck
    }
  };
}
function tokenizeTasklistCheck(effects, ok2, nok) {
  const self2 = this;
  return open;
  function open(code2) {
    if (
      // Exit if theres stuff before.
      self2.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !self2._gfmTasklistFirstContentOfListItem
    ) {
      return nok(code2);
    }
    effects.enter("taskListCheck");
    effects.enter("taskListCheckMarker");
    effects.consume(code2);
    effects.exit("taskListCheckMarker");
    return inside;
  }
  function inside(code2) {
    if (markdownLineEndingOrSpace(code2)) {
      effects.enter("taskListCheckValueUnchecked");
      effects.consume(code2);
      effects.exit("taskListCheckValueUnchecked");
      return close;
    }
    if (code2 === 88 || code2 === 120) {
      effects.enter("taskListCheckValueChecked");
      effects.consume(code2);
      effects.exit("taskListCheckValueChecked");
      return close;
    }
    return nok(code2);
  }
  function close(code2) {
    if (code2 === 93) {
      effects.enter("taskListCheckMarker");
      effects.consume(code2);
      effects.exit("taskListCheckMarker");
      effects.exit("taskListCheck");
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    if (markdownLineEnding(code2)) {
      return ok2(code2);
    }
    if (markdownSpace(code2)) {
      return effects.check({
        tokenize: spaceThenNonSpace
      }, ok2, nok)(code2);
    }
    return nok(code2);
  }
}
function spaceThenNonSpace(effects, ok2, nok) {
  return factorySpace(effects, after, "whitespace");
  function after(code2) {
    return code2 === null ? nok(code2) : ok2(code2);
  }
}
function gfm(options) {
  return combineExtensions([
    gfmAutolinkLiteral(),
    gfmFootnote(),
    gfmStrikethrough(options),
    gfmTable(),
    gfmTaskListItem()
  ]);
}
const emptyOptions$2 = {};
function remarkGfm(options) {
  const self2 = (
    /** @type {Processor} */
    this
  );
  const settings = options || emptyOptions$2;
  const data = self2.data();
  const micromarkExtensions = data.micromarkExtensions || (data.micromarkExtensions = []);
  const fromMarkdownExtensions = data.fromMarkdownExtensions || (data.fromMarkdownExtensions = []);
  const toMarkdownExtensions = data.toMarkdownExtensions || (data.toMarkdownExtensions = []);
  micromarkExtensions.push(gfm(settings));
  fromMarkdownExtensions.push(gfmFromMarkdown());
  toMarkdownExtensions.push(gfmToMarkdown(settings));
}
function stringify$1(values, options) {
  const settings = {};
  const input = values[values.length - 1] === "" ? [...values, ""] : values;
  return input.join(
    (settings.padRight ? " " : "") + "," + (settings.padLeft === false ? "" : " ")
  ).trim();
}
const nameRe = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u;
const nameReJsx = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u;
const emptyOptions$1 = {};
function name(name2, options) {
  const settings = emptyOptions$1;
  const re2 = settings.jsx ? nameReJsx : nameRe;
  return re2.test(name2);
}
const re = /[ \t\n\f\r]/g;
function whitespace(thing) {
  return typeof thing === "object" ? thing.type === "text" ? empty(thing.value) : false : empty(thing);
}
function empty(value) {
  return value.replace(re, "") === "";
}
class Schema {
  /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */
  constructor(property2, normal, space2) {
    this.property = property2;
    this.normal = normal;
    if (space2) {
      this.space = space2;
    }
  }
}
Schema.prototype.property = {};
Schema.prototype.normal = {};
Schema.prototype.space = null;
function merge(definitions2, space2) {
  const property2 = {};
  const normal = {};
  let index2 = -1;
  while (++index2 < definitions2.length) {
    Object.assign(property2, definitions2[index2].property);
    Object.assign(normal, definitions2[index2].normal);
  }
  return new Schema(property2, normal, space2);
}
function normalize$1(value) {
  return value.toLowerCase();
}
class Info {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */
  constructor(property2, attribute) {
    this.property = property2;
    this.attribute = attribute;
  }
}
Info.prototype.space = null;
Info.prototype.boolean = false;
Info.prototype.booleanish = false;
Info.prototype.overloadedBoolean = false;
Info.prototype.number = false;
Info.prototype.commaSeparated = false;
Info.prototype.spaceSeparated = false;
Info.prototype.commaOrSpaceSeparated = false;
Info.prototype.mustUseProperty = false;
Info.prototype.defined = false;
let powers = 0;
const boolean = increment();
const booleanish = increment();
const overloadedBoolean = increment();
const number = increment();
const spaceSeparated = increment();
const commaSeparated = increment();
const commaOrSpaceSeparated = increment();
function increment() {
  return 2 ** ++powers;
}
const types = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean,
  booleanish,
  commaOrSpaceSeparated,
  commaSeparated,
  number,
  overloadedBoolean,
  spaceSeparated
}, Symbol.toStringTag, { value: "Module" }));
const checks = Object.keys(types);
class DefinedInfo extends Info {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */
  constructor(property2, attribute, mask, space2) {
    let index2 = -1;
    super(property2, attribute);
    mark(this, "space", space2);
    if (typeof mask === "number") {
      while (++index2 < checks.length) {
        const check = checks[index2];
        mark(this, checks[index2], (mask & types[check]) === types[check]);
      }
    }
  }
}
DefinedInfo.prototype.defined = true;
function mark(values, key, value) {
  if (value) {
    values[key] = value;
  }
}
const own$4 = {}.hasOwnProperty;
function create$1(definition2) {
  const property2 = {};
  const normal = {};
  let prop;
  for (prop in definition2.properties) {
    if (own$4.call(definition2.properties, prop)) {
      const value = definition2.properties[prop];
      const info = new DefinedInfo(
        prop,
        definition2.transform(definition2.attributes || {}, prop),
        value,
        definition2.space
      );
      if (definition2.mustUseProperty && definition2.mustUseProperty.includes(prop)) {
        info.mustUseProperty = true;
      }
      property2[prop] = info;
      normal[normalize$1(prop)] = prop;
      normal[normalize$1(info.attribute)] = prop;
    }
  }
  return new Schema(property2, normal, definition2.space);
}
const xlink = create$1({
  space: "xlink",
  transform(_2, prop) {
    return "xlink:" + prop.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
});
const xml$1 = create$1({
  space: "xml",
  transform(_2, prop) {
    return "xml:" + prop.slice(3).toLowerCase();
  },
  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
});
function caseSensitiveTransform(attributes, attribute) {
  return attribute in attributes ? attributes[attribute] : attribute;
}
function caseInsensitiveTransform(attributes, property2) {
  return caseSensitiveTransform(attributes, property2.toLowerCase());
}
const xmlns = create$1({
  space: "xmlns",
  attributes: { xmlnsxlink: "xmlns:xlink" },
  transform: caseInsensitiveTransform,
  properties: { xmlns: null, xmlnsXLink: null }
});
const aria = create$1({
  transform(_2, prop) {
    return prop === "role" ? prop : "aria-" + prop.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: booleanish,
    ariaAutoComplete: null,
    ariaBusy: booleanish,
    ariaChecked: booleanish,
    ariaColCount: number,
    ariaColIndex: number,
    ariaColSpan: number,
    ariaControls: spaceSeparated,
    ariaCurrent: null,
    ariaDescribedBy: spaceSeparated,
    ariaDetails: null,
    ariaDisabled: booleanish,
    ariaDropEffect: spaceSeparated,
    ariaErrorMessage: null,
    ariaExpanded: booleanish,
    ariaFlowTo: spaceSeparated,
    ariaGrabbed: booleanish,
    ariaHasPopup: null,
    ariaHidden: booleanish,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: spaceSeparated,
    ariaLevel: number,
    ariaLive: null,
    ariaModal: booleanish,
    ariaMultiLine: booleanish,
    ariaMultiSelectable: booleanish,
    ariaOrientation: null,
    ariaOwns: spaceSeparated,
    ariaPlaceholder: null,
    ariaPosInSet: number,
    ariaPressed: booleanish,
    ariaReadOnly: booleanish,
    ariaRelevant: null,
    ariaRequired: booleanish,
    ariaRoleDescription: spaceSeparated,
    ariaRowCount: number,
    ariaRowIndex: number,
    ariaRowSpan: number,
    ariaSelected: booleanish,
    ariaSetSize: number,
    ariaSort: null,
    ariaValueMax: number,
    ariaValueMin: number,
    ariaValueNow: number,
    ariaValueText: null,
    role: null
  }
});
const html$4 = create$1({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: caseInsensitiveTransform,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: commaSeparated,
    acceptCharset: spaceSeparated,
    accessKey: spaceSeparated,
    action: null,
    allow: null,
    allowFullScreen: boolean,
    allowPaymentRequest: boolean,
    allowUserMedia: boolean,
    alt: null,
    as: null,
    async: boolean,
    autoCapitalize: null,
    autoComplete: spaceSeparated,
    autoFocus: boolean,
    autoPlay: boolean,
    blocking: spaceSeparated,
    capture: null,
    charSet: null,
    checked: boolean,
    cite: null,
    className: spaceSeparated,
    cols: number,
    colSpan: null,
    content: null,
    contentEditable: booleanish,
    controls: boolean,
    controlsList: spaceSeparated,
    coords: number | commaSeparated,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: boolean,
    defer: boolean,
    dir: null,
    dirName: null,
    disabled: boolean,
    download: overloadedBoolean,
    draggable: booleanish,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: boolean,
    formTarget: null,
    headers: spaceSeparated,
    height: number,
    hidden: boolean,
    high: number,
    href: null,
    hrefLang: null,
    htmlFor: spaceSeparated,
    httpEquiv: spaceSeparated,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: boolean,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: boolean,
    itemId: null,
    itemProp: spaceSeparated,
    itemRef: spaceSeparated,
    itemScope: boolean,
    itemType: spaceSeparated,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: boolean,
    low: number,
    manifest: null,
    max: null,
    maxLength: number,
    media: null,
    method: null,
    min: null,
    minLength: number,
    multiple: boolean,
    muted: boolean,
    name: null,
    nonce: null,
    noModule: boolean,
    noValidate: boolean,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: boolean,
    optimum: number,
    pattern: null,
    ping: spaceSeparated,
    placeholder: null,
    playsInline: boolean,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: boolean,
    referrerPolicy: null,
    rel: spaceSeparated,
    required: boolean,
    reversed: boolean,
    rows: number,
    rowSpan: number,
    sandbox: spaceSeparated,
    scope: null,
    scoped: boolean,
    seamless: boolean,
    selected: boolean,
    shadowRootClonable: boolean,
    shadowRootDelegatesFocus: boolean,
    shadowRootMode: null,
    shape: null,
    size: number,
    sizes: null,
    slot: null,
    span: number,
    spellCheck: booleanish,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: number,
    step: null,
    style: null,
    tabIndex: number,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: boolean,
    useMap: null,
    value: booleanish,
    width: number,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: spaceSeparated,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: number,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: number,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: boolean,
    // Lists. Use CSS to reduce space between items instead
    declare: boolean,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: number,
    // `<img>` and `<object>`
    leftMargin: number,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: number,
    // `<body>`
    marginWidth: number,
    // `<body>`
    noResize: boolean,
    // `<frame>`
    noHref: boolean,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: boolean,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: boolean,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: number,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: booleanish,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: number,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: number,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: boolean,
    disableRemotePlayback: boolean,
    prefix: null,
    property: null,
    results: number,
    security: null,
    unselectable: null
  }
});
const svg$3 = create$1({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: caseSensitiveTransform,
  properties: {
    about: commaOrSpaceSeparated,
    accentHeight: number,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: number,
    amplitude: number,
    arabicForm: null,
    ascent: number,
    attributeName: null,
    attributeType: null,
    azimuth: number,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: number,
    by: null,
    calcMode: null,
    capHeight: number,
    className: spaceSeparated,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: number,
    diffuseConstant: number,
    direction: null,
    display: null,
    dur: null,
    divisor: number,
    dominantBaseline: null,
    download: boolean,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: number,
    enableBackground: null,
    end: null,
    event: null,
    exponent: number,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: number,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: commaSeparated,
    g2: commaSeparated,
    glyphName: commaSeparated,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: number,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: number,
    horizOriginX: number,
    horizOriginY: number,
    id: null,
    ideographic: number,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: number,
    k: number,
    k1: number,
    k2: number,
    k3: number,
    k4: number,
    kernelMatrix: commaOrSpaceSeparated,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: number,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: number,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: number,
    overlineThickness: number,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: number,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: spaceSeparated,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: number,
    pointsAtY: number,
    pointsAtZ: number,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: commaOrSpaceSeparated,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: commaOrSpaceSeparated,
    rev: commaOrSpaceSeparated,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: commaOrSpaceSeparated,
    requiredFeatures: commaOrSpaceSeparated,
    requiredFonts: commaOrSpaceSeparated,
    requiredFormats: commaOrSpaceSeparated,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: number,
    specularExponent: number,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: number,
    strikethroughThickness: number,
    string: null,
    stroke: null,
    strokeDashArray: commaOrSpaceSeparated,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: number,
    strokeOpacity: number,
    strokeWidth: null,
    style: null,
    surfaceScale: number,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: commaOrSpaceSeparated,
    tabIndex: number,
    tableValues: null,
    target: null,
    targetX: number,
    targetY: number,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: commaOrSpaceSeparated,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: number,
    underlineThickness: number,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: number,
    values: null,
    vAlphabetic: number,
    vMathematical: number,
    vectorEffect: null,
    vHanging: number,
    vIdeographic: number,
    version: null,
    vertAdvY: number,
    vertOriginX: number,
    vertOriginY: number,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: number,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
});
const valid = /^data[-\w.:]+$/i;
const dash = /-[a-z]/g;
const cap$1 = /[A-Z]/g;
function find(schema, value) {
  const normal = normalize$1(value);
  let prop = value;
  let Type2 = Info;
  if (normal in schema.normal) {
    return schema.property[schema.normal[normal]];
  }
  if (normal.length > 4 && normal.slice(0, 4) === "data" && valid.test(value)) {
    if (value.charAt(4) === "-") {
      const rest = value.slice(5).replace(dash, camelcase);
      prop = "data" + rest.charAt(0).toUpperCase() + rest.slice(1);
    } else {
      const rest = value.slice(4);
      if (!dash.test(rest)) {
        let dashes = rest.replace(cap$1, kebab);
        if (dashes.charAt(0) !== "-") {
          dashes = "-" + dashes;
        }
        value = "data" + dashes;
      }
    }
    Type2 = DefinedInfo;
  }
  return new Type2(prop, value);
}
function kebab($0) {
  return "-" + $0.toLowerCase();
}
function camelcase($0) {
  return $0.charAt(1).toUpperCase();
}
const hastToReact = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
};
const html$3 = merge([xml$1, xlink, xmlns, aria, html$4], "html");
const svg$2 = merge([xml$1, xlink, xmlns, aria, svg$3], "svg");
function stringify(values) {
  return values.join(" ").trim();
}
var cjs = {};
var COMMENT_REGEX = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;
var NEWLINE_REGEX = /\n/g;
var WHITESPACE_REGEX = /^\s*/;
var PROPERTY_REGEX = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/;
var COLON_REGEX = /^:\s*/;
var VALUE_REGEX = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/;
var SEMICOLON_REGEX = /^[;\s]*/;
var TRIM_REGEX = /^\s+|\s+$/g;
var NEWLINE = "\n";
var FORWARD_SLASH = "/";
var ASTERISK = "*";
var EMPTY_STRING = "";
var TYPE_COMMENT = "comment";
var TYPE_DECLARATION = "declaration";
var inlineStyleParser = function(style, options) {
  if (typeof style !== "string") {
    throw new TypeError("First argument must be a string");
  }
  if (!style) return [];
  options = options || {};
  var lineno = 1;
  var column2 = 1;
  function updatePosition(str) {
    var lines = str.match(NEWLINE_REGEX);
    if (lines) lineno += lines.length;
    var i = str.lastIndexOf(NEWLINE);
    column2 = ~i ? str.length - i : column2 + str.length;
  }
  function position2() {
    var start2 = { line: lineno, column: column2 };
    return function(node2) {
      node2.position = new Position(start2);
      whitespace2();
      return node2;
    };
  }
  function Position(start2) {
    this.start = start2;
    this.end = { line: lineno, column: column2 };
    this.source = options.source;
  }
  Position.prototype.content = style;
  function error2(msg) {
    var err = new Error(
      options.source + ":" + lineno + ":" + column2 + ": " + msg
    );
    err.reason = msg;
    err.filename = options.source;
    err.line = lineno;
    err.column = column2;
    err.source = style;
    if (options.silent) ;
    else {
      throw err;
    }
  }
  function match2(re2) {
    var m2 = re2.exec(style);
    if (!m2) return;
    var str = m2[0];
    updatePosition(str);
    style = style.slice(str.length);
    return m2;
  }
  function whitespace2() {
    match2(WHITESPACE_REGEX);
  }
  function comments(rules2) {
    var c6;
    rules2 = rules2 || [];
    while (c6 = comment2()) {
      if (c6 !== false) {
        rules2.push(c6);
      }
    }
    return rules2;
  }
  function comment2() {
    var pos = position2();
    if (FORWARD_SLASH != style.charAt(0) || ASTERISK != style.charAt(1)) return;
    var i = 2;
    while (EMPTY_STRING != style.charAt(i) && (ASTERISK != style.charAt(i) || FORWARD_SLASH != style.charAt(i + 1))) {
      ++i;
    }
    i += 2;
    if (EMPTY_STRING === style.charAt(i - 1)) {
      return error2("End of comment missing");
    }
    var str = style.slice(2, i - 2);
    column2 += 2;
    updatePosition(str);
    style = style.slice(i);
    column2 += 2;
    return pos({
      type: TYPE_COMMENT,
      comment: str
    });
  }
  function declaration2() {
    var pos = position2();
    var prop = match2(PROPERTY_REGEX);
    if (!prop) return;
    comment2();
    if (!match2(COLON_REGEX)) return error2("property missing ':'");
    var val = match2(VALUE_REGEX);
    var ret = pos({
      type: TYPE_DECLARATION,
      property: trim(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),
      value: val ? trim(val[0].replace(COMMENT_REGEX, EMPTY_STRING)) : EMPTY_STRING
    });
    match2(SEMICOLON_REGEX);
    return ret;
  }
  function declarations() {
    var decls = [];
    comments(decls);
    var decl;
    while (decl = declaration2()) {
      if (decl !== false) {
        decls.push(decl);
        comments(decls);
      }
    }
    return decls;
  }
  whitespace2();
  return declarations();
};
function trim(str) {
  return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;
}
var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(cjs, "__esModule", { value: true });
var _default = cjs.default = StyleToObject;
var inline_style_parser_1 = __importDefault(inlineStyleParser);
function StyleToObject(style, iterator) {
  var styleObject = null;
  if (!style || typeof style !== "string") {
    return styleObject;
  }
  var declarations = (0, inline_style_parser_1.default)(style);
  var hasIterator = typeof iterator === "function";
  declarations.forEach(function(declaration2) {
    if (declaration2.type !== "declaration") {
      return;
    }
    var property2 = declaration2.property, value = declaration2.value;
    if (hasIterator) {
      iterator(property2, value, declaration2);
    } else if (value) {
      styleObject = styleObject || {};
      styleObject[property2] = value;
    }
  });
  return styleObject;
}
const styleToObject = _default.default || _default;
const pointEnd = point$2("end");
const pointStart = point$2("start");
function point$2(type2) {
  return point2;
  function point2(node2) {
    const point3 = node2 && node2.position && node2.position[type2] || {};
    if (typeof point3.line === "number" && point3.line > 0 && typeof point3.column === "number" && point3.column > 0) {
      return {
        line: point3.line,
        column: point3.column,
        offset: typeof point3.offset === "number" && point3.offset > -1 ? point3.offset : void 0
      };
    }
  }
}
function position$1(node2) {
  const start2 = pointStart(node2);
  const end = pointEnd(node2);
  if (start2 && end) {
    return { start: start2, end };
  }
}
function stringifyPosition(value) {
  if (!value || typeof value !== "object") {
    return "";
  }
  if ("position" in value || "type" in value) {
    return position(value.position);
  }
  if ("start" in value || "end" in value) {
    return position(value);
  }
  if ("line" in value || "column" in value) {
    return point$1(value);
  }
  return "";
}
function point$1(point2) {
  return index(point2 && point2.line) + ":" + index(point2 && point2.column);
}
function position(pos) {
  return point$1(pos && pos.start) + "-" + point$1(pos && pos.end);
}
function index(value) {
  return value && typeof value === "number" ? value : 1;
}
class VFileMessage extends Error {
  /**
   * Create a message for `reason`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(causeOrReason, optionsOrParentOrPlace, origin2) {
    super();
    if (typeof optionsOrParentOrPlace === "string") {
      origin2 = optionsOrParentOrPlace;
      optionsOrParentOrPlace = void 0;
    }
    let reason = "";
    let options = {};
    let legacyCause = false;
    if (optionsOrParentOrPlace) {
      if ("line" in optionsOrParentOrPlace && "column" in optionsOrParentOrPlace) {
        options = { place: optionsOrParentOrPlace };
      } else if ("start" in optionsOrParentOrPlace && "end" in optionsOrParentOrPlace) {
        options = { place: optionsOrParentOrPlace };
      } else if ("type" in optionsOrParentOrPlace) {
        options = {
          ancestors: [optionsOrParentOrPlace],
          place: optionsOrParentOrPlace.position
        };
      } else {
        options = { ...optionsOrParentOrPlace };
      }
    }
    if (typeof causeOrReason === "string") {
      reason = causeOrReason;
    } else if (!options.cause && causeOrReason) {
      legacyCause = true;
      reason = causeOrReason.message;
      options.cause = causeOrReason;
    }
    if (!options.ruleId && !options.source && typeof origin2 === "string") {
      const index2 = origin2.indexOf(":");
      if (index2 === -1) {
        options.ruleId = origin2;
      } else {
        options.source = origin2.slice(0, index2);
        options.ruleId = origin2.slice(index2 + 1);
      }
    }
    if (!options.place && options.ancestors && options.ancestors) {
      const parent = options.ancestors[options.ancestors.length - 1];
      if (parent) {
        options.place = parent.position;
      }
    }
    const start2 = options.place && "start" in options.place ? options.place.start : options.place;
    this.ancestors = options.ancestors || void 0;
    this.cause = options.cause || void 0;
    this.column = start2 ? start2.column : void 0;
    this.fatal = void 0;
    this.file;
    this.message = reason;
    this.line = start2 ? start2.line : void 0;
    this.name = stringifyPosition(options.place) || "1:1";
    this.place = options.place || void 0;
    this.reason = this.message;
    this.ruleId = options.ruleId || void 0;
    this.source = options.source || void 0;
    this.stack = legacyCause && options.cause && typeof options.cause.stack === "string" ? options.cause.stack : "";
    this.actual;
    this.expected;
    this.note;
    this.url;
  }
}
VFileMessage.prototype.file = "";
VFileMessage.prototype.name = "";
VFileMessage.prototype.reason = "";
VFileMessage.prototype.message = "";
VFileMessage.prototype.stack = "";
VFileMessage.prototype.column = void 0;
VFileMessage.prototype.line = void 0;
VFileMessage.prototype.ancestors = void 0;
VFileMessage.prototype.cause = void 0;
VFileMessage.prototype.fatal = void 0;
VFileMessage.prototype.place = void 0;
VFileMessage.prototype.ruleId = void 0;
VFileMessage.prototype.source = void 0;
const own$3 = {}.hasOwnProperty;
const emptyMap = /* @__PURE__ */ new Map();
const cap = /[A-Z]/g;
const dashSomething = /-([a-z])/g;
const tableElements = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]);
const tableCellElement = /* @__PURE__ */ new Set(["td", "th"]);
const docs = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
function toJsxRuntime(tree, options) {
  if (!options || options.Fragment === void 0) {
    throw new TypeError("Expected `Fragment` in options");
  }
  const filePath = options.filePath || void 0;
  let create3;
  if (options.development) {
    if (typeof options.jsxDEV !== "function") {
      throw new TypeError(
        "Expected `jsxDEV` in options when `development: true`"
      );
    }
    create3 = developmentCreate(filePath, options.jsxDEV);
  } else {
    if (typeof options.jsx !== "function") {
      throw new TypeError("Expected `jsx` in production options");
    }
    if (typeof options.jsxs !== "function") {
      throw new TypeError("Expected `jsxs` in production options");
    }
    create3 = productionCreate(filePath, options.jsx, options.jsxs);
  }
  const state = {
    Fragment: options.Fragment,
    ancestors: [],
    components: options.components || {},
    create: create3,
    elementAttributeNameCase: options.elementAttributeNameCase || "react",
    evaluater: options.createEvaluater ? options.createEvaluater() : void 0,
    filePath,
    ignoreInvalidStyle: options.ignoreInvalidStyle || false,
    passKeys: options.passKeys !== false,
    passNode: options.passNode || false,
    schema: options.space === "svg" ? svg$2 : html$3,
    stylePropertyNameCase: options.stylePropertyNameCase || "dom",
    tableCellAlignToStyle: options.tableCellAlignToStyle !== false
  };
  const result = one(state, tree, void 0);
  if (result && typeof result !== "string") {
    return result;
  }
  return state.create(
    tree,
    state.Fragment,
    { children: result || void 0 },
    void 0
  );
}
function one(state, node2, key) {
  if (node2.type === "element") {
    return element(state, node2, key);
  }
  if (node2.type === "mdxFlowExpression" || node2.type === "mdxTextExpression") {
    return mdxExpression(state, node2);
  }
  if (node2.type === "mdxJsxFlowElement" || node2.type === "mdxJsxTextElement") {
    return mdxJsxElement(state, node2, key);
  }
  if (node2.type === "mdxjsEsm") {
    return mdxEsm(state, node2);
  }
  if (node2.type === "root") {
    return root$1(state, node2, key);
  }
  if (node2.type === "text") {
    return text$4(state, node2);
  }
}
function element(state, node2, key) {
  const parentSchema = state.schema;
  let schema = parentSchema;
  if (node2.tagName.toLowerCase() === "svg" && parentSchema.space === "html") {
    schema = svg$2;
    state.schema = schema;
  }
  state.ancestors.push(node2);
  const type2 = findComponentFromName(state, node2.tagName, false);
  const props = createElementProps(state, node2);
  let children = createChildren(state, node2);
  if (tableElements.has(node2.tagName)) {
    children = children.filter(function(child) {
      return typeof child === "string" ? !whitespace(child) : true;
    });
  }
  addNode(state, props, type2, node2);
  addChildren(props, children);
  state.ancestors.pop();
  state.schema = parentSchema;
  return state.create(node2, type2, props, key);
}
function mdxExpression(state, node2) {
  if (node2.data && node2.data.estree && state.evaluater) {
    const program = node2.data.estree;
    const expression = program.body[0];
    ok$1(expression.type === "ExpressionStatement");
    return (
      /** @type {Child | undefined} */
      state.evaluater.evaluateExpression(expression.expression)
    );
  }
  crashEstree(state, node2.position);
}
function mdxEsm(state, node2) {
  if (node2.data && node2.data.estree && state.evaluater) {
    return (
      /** @type {Child | undefined} */
      state.evaluater.evaluateProgram(node2.data.estree)
    );
  }
  crashEstree(state, node2.position);
}
function mdxJsxElement(state, node2, key) {
  const parentSchema = state.schema;
  let schema = parentSchema;
  if (node2.name === "svg" && parentSchema.space === "html") {
    schema = svg$2;
    state.schema = schema;
  }
  state.ancestors.push(node2);
  const type2 = node2.name === null ? state.Fragment : findComponentFromName(state, node2.name, true);
  const props = createJsxElementProps(state, node2);
  const children = createChildren(state, node2);
  addNode(state, props, type2, node2);
  addChildren(props, children);
  state.ancestors.pop();
  state.schema = parentSchema;
  return state.create(node2, type2, props, key);
}
function root$1(state, node2, key) {
  const props = {};
  addChildren(props, createChildren(state, node2));
  return state.create(node2, state.Fragment, props, key);
}
function text$4(_2, node2) {
  return node2.value;
}
function addNode(state, props, type2, node2) {
  if (typeof type2 !== "string" && type2 !== state.Fragment && state.passNode) {
    props.node = node2;
  }
}
function addChildren(props, children) {
  if (children.length > 0) {
    const value = children.length > 1 ? children : children[0];
    if (value) {
      props.children = value;
    }
  }
}
function productionCreate(_2, jsx4, jsxs3) {
  return create3;
  function create3(_3, type2, props, key) {
    const isStaticChildren = Array.isArray(props.children);
    const fn2 = isStaticChildren ? jsxs3 : jsx4;
    return key ? fn2(type2, props, key) : fn2(type2, props);
  }
}
function developmentCreate(filePath, jsxDEV) {
  return create3;
  function create3(node2, type2, props, key) {
    const isStaticChildren = Array.isArray(props.children);
    const point2 = pointStart(node2);
    return jsxDEV(
      type2,
      props,
      key,
      isStaticChildren,
      {
        columnNumber: point2 ? point2.column - 1 : void 0,
        fileName: filePath,
        lineNumber: point2 ? point2.line : void 0
      },
      void 0
    );
  }
}
function createElementProps(state, node2) {
  const props = {};
  let alignValue;
  let prop;
  for (prop in node2.properties) {
    if (prop !== "children" && own$3.call(node2.properties, prop)) {
      const result = createProperty(state, prop, node2.properties[prop]);
      if (result) {
        const [key, value] = result;
        if (state.tableCellAlignToStyle && key === "align" && typeof value === "string" && tableCellElement.has(node2.tagName)) {
          alignValue = value;
        } else {
          props[key] = value;
        }
      }
    }
  }
  if (alignValue) {
    const style = (
      /** @type {Style} */
      props.style || (props.style = {})
    );
    style[state.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = alignValue;
  }
  return props;
}
function createJsxElementProps(state, node2) {
  const props = {};
  for (const attribute of node2.attributes) {
    if (attribute.type === "mdxJsxExpressionAttribute") {
      if (attribute.data && attribute.data.estree && state.evaluater) {
        const program = attribute.data.estree;
        const expression = program.body[0];
        ok$1(expression.type === "ExpressionStatement");
        const objectExpression = expression.expression;
        ok$1(objectExpression.type === "ObjectExpression");
        const property2 = objectExpression.properties[0];
        ok$1(property2.type === "SpreadElement");
        Object.assign(
          props,
          state.evaluater.evaluateExpression(property2.argument)
        );
      } else {
        crashEstree(state, node2.position);
      }
    } else {
      const name2 = attribute.name;
      let value;
      if (attribute.value && typeof attribute.value === "object") {
        if (attribute.value.data && attribute.value.data.estree && state.evaluater) {
          const program = attribute.value.data.estree;
          const expression = program.body[0];
          ok$1(expression.type === "ExpressionStatement");
          value = state.evaluater.evaluateExpression(expression.expression);
        } else {
          crashEstree(state, node2.position);
        }
      } else {
        value = attribute.value === null ? true : attribute.value;
      }
      props[name2] = /** @type {Props[keyof Props]} */
      value;
    }
  }
  return props;
}
function createChildren(state, node2) {
  const children = [];
  let index2 = -1;
  const countsByName = state.passKeys ? /* @__PURE__ */ new Map() : emptyMap;
  while (++index2 < node2.children.length) {
    const child = node2.children[index2];
    let key;
    if (state.passKeys) {
      const name2 = child.type === "element" ? child.tagName : child.type === "mdxJsxFlowElement" || child.type === "mdxJsxTextElement" ? child.name : void 0;
      if (name2) {
        const count = countsByName.get(name2) || 0;
        key = name2 + "-" + count;
        countsByName.set(name2, count + 1);
      }
    }
    const result = one(state, child, key);
    if (result !== void 0) children.push(result);
  }
  return children;
}
function createProperty(state, prop, value) {
  const info = find(state.schema, prop);
  if (value === null || value === void 0 || typeof value === "number" && Number.isNaN(value)) {
    return;
  }
  if (Array.isArray(value)) {
    value = info.commaSeparated ? stringify$1(value) : stringify(value);
  }
  if (info.property === "style") {
    let styleObject = typeof value === "object" ? value : parseStyle(state, String(value));
    if (state.stylePropertyNameCase === "css") {
      styleObject = transformStylesToCssCasing(styleObject);
    }
    return ["style", styleObject];
  }
  return [
    state.elementAttributeNameCase === "react" && info.space ? hastToReact[info.property] || info.property : info.attribute,
    value
  ];
}
function parseStyle(state, value) {
  const result = {};
  try {
    styleToObject(value, replacer);
  } catch (error2) {
    if (!state.ignoreInvalidStyle) {
      const cause = (
        /** @type {Error} */
        error2
      );
      const message = new VFileMessage("Cannot parse `style` attribute", {
        ancestors: state.ancestors,
        cause,
        ruleId: "style",
        source: "hast-util-to-jsx-runtime"
      });
      message.file = state.filePath || void 0;
      message.url = docs + "#cannot-parse-style-attribute";
      throw message;
    }
  }
  return result;
  function replacer(name2, value2) {
    let key = name2;
    if (key.slice(0, 2) !== "--") {
      if (key.slice(0, 4) === "-ms-") key = "ms-" + key.slice(4);
      key = key.replace(dashSomething, toCamel);
    }
    result[key] = value2;
  }
}
function findComponentFromName(state, name$1, allowExpression) {
  let result;
  if (!allowExpression) {
    result = { type: "Literal", value: name$1 };
  } else if (name$1.includes(".")) {
    const identifiers = name$1.split(".");
    let index2 = -1;
    let node2;
    while (++index2 < identifiers.length) {
      const prop = name(identifiers[index2]) ? { type: "Identifier", name: identifiers[index2] } : { type: "Literal", value: identifiers[index2] };
      node2 = node2 ? {
        type: "MemberExpression",
        object: node2,
        property: prop,
        computed: Boolean(index2 && prop.type === "Literal"),
        optional: false
      } : prop;
    }
    result = node2;
  } else {
    result = name(name$1) && !/^[a-z]/.test(name$1) ? { type: "Identifier", name: name$1 } : { type: "Literal", value: name$1 };
  }
  if (result.type === "Literal") {
    const name2 = (
      /** @type {keyof JSX.IntrinsicElements} */
      result.value
    );
    return own$3.call(state.components, name2) ? state.components[name2] : name2;
  }
  if (state.evaluater) {
    return state.evaluater.evaluateExpression(result);
  }
  crashEstree(state);
}
function crashEstree(state, place) {
  const message = new VFileMessage(
    "Cannot handle MDX estrees without `createEvaluater`",
    {
      ancestors: state.ancestors,
      place,
      ruleId: "mdx-estree",
      source: "hast-util-to-jsx-runtime"
    }
  );
  message.file = state.filePath || void 0;
  message.url = docs + "#cannot-handle-mdx-estrees-without-createevaluater";
  throw message;
}
function transformStylesToCssCasing(domCasing) {
  const cssCasing = {};
  let from2;
  for (from2 in domCasing) {
    if (own$3.call(domCasing, from2)) {
      cssCasing[transformStyleToCssCasing(from2)] = domCasing[from2];
    }
  }
  return cssCasing;
}
function transformStyleToCssCasing(from2) {
  let to2 = from2.replace(cap, toDash);
  if (to2.slice(0, 3) === "ms-") to2 = "-" + to2;
  return to2;
}
function toCamel(_2, $1) {
  return $1.toUpperCase();
}
function toDash($0) {
  return "-" + $0.toLowerCase();
}
const urlAttributes = {
  action: ["form"],
  cite: ["blockquote", "del", "ins", "q"],
  data: ["object"],
  formAction: ["button", "input"],
  href: ["a", "area", "base", "link"],
  icon: ["menuitem"],
  itemId: null,
  manifest: ["html"],
  ping: ["a", "area"],
  poster: ["video"],
  src: [
    "audio",
    "embed",
    "iframe",
    "img",
    "input",
    "script",
    "source",
    "track",
    "video"
  ]
};
const content = {
  tokenize: initializeContent
};
function initializeContent(effects) {
  const contentStart = effects.attempt(this.parser.constructs.contentInitial, afterContentStartConstruct, paragraphInitial);
  let previous2;
  return contentStart;
  function afterContentStartConstruct(code2) {
    if (code2 === null) {
      effects.consume(code2);
      return;
    }
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return factorySpace(effects, contentStart, "linePrefix");
  }
  function paragraphInitial(code2) {
    effects.enter("paragraph");
    return lineStart(code2);
  }
  function lineStart(code2) {
    const token2 = effects.enter("chunkText", {
      contentType: "text",
      previous: previous2
    });
    if (previous2) {
      previous2.next = token2;
    }
    previous2 = token2;
    return data(code2);
  }
  function data(code2) {
    if (code2 === null) {
      effects.exit("chunkText");
      effects.exit("paragraph");
      effects.consume(code2);
      return;
    }
    if (markdownLineEnding(code2)) {
      effects.consume(code2);
      effects.exit("chunkText");
      return lineStart;
    }
    effects.consume(code2);
    return data;
  }
}
const document$2 = {
  tokenize: initializeDocument
};
const containerConstruct = {
  tokenize: tokenizeContainer
};
function initializeDocument(effects) {
  const self2 = this;
  const stack = [];
  let continued = 0;
  let childFlow;
  let childToken;
  let lineStartOffset;
  return start2;
  function start2(code2) {
    if (continued < stack.length) {
      const item = stack[continued];
      self2.containerState = item[1];
      return effects.attempt(item[0].continuation, documentContinue, checkNewContainers)(code2);
    }
    return checkNewContainers(code2);
  }
  function documentContinue(code2) {
    continued++;
    if (self2.containerState._closeFlow) {
      self2.containerState._closeFlow = void 0;
      if (childFlow) {
        closeFlow();
      }
      const indexBeforeExits = self2.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let point2;
      while (indexBeforeFlow--) {
        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {
          point2 = self2.events[indexBeforeFlow][1].end;
          break;
        }
      }
      exitContainers(continued);
      let index2 = indexBeforeExits;
      while (index2 < self2.events.length) {
        self2.events[index2][1].end = {
          ...point2
        };
        index2++;
      }
      splice(self2.events, indexBeforeFlow + 1, 0, self2.events.slice(indexBeforeExits));
      self2.events.length = index2;
      return checkNewContainers(code2);
    }
    return start2(code2);
  }
  function checkNewContainers(code2) {
    if (continued === stack.length) {
      if (!childFlow) {
        return documentContinued(code2);
      }
      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
        return flowStart(code2);
      }
      self2.interrupt = Boolean(childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack);
    }
    self2.containerState = {};
    return effects.check(containerConstruct, thereIsANewContainer, thereIsNoNewContainer)(code2);
  }
  function thereIsANewContainer(code2) {
    if (childFlow) closeFlow();
    exitContainers(continued);
    return documentContinued(code2);
  }
  function thereIsNoNewContainer(code2) {
    self2.parser.lazy[self2.now().line] = continued !== stack.length;
    lineStartOffset = self2.now().offset;
    return flowStart(code2);
  }
  function documentContinued(code2) {
    self2.containerState = {};
    return effects.attempt(containerConstruct, containerContinue, flowStart)(code2);
  }
  function containerContinue(code2) {
    continued++;
    stack.push([self2.currentConstruct, self2.containerState]);
    return documentContinued(code2);
  }
  function flowStart(code2) {
    if (code2 === null) {
      if (childFlow) closeFlow();
      exitContainers(0);
      effects.consume(code2);
      return;
    }
    childFlow = childFlow || self2.parser.flow(self2.now());
    effects.enter("chunkFlow", {
      _tokenizer: childFlow,
      contentType: "flow",
      previous: childToken
    });
    return flowContinue(code2);
  }
  function flowContinue(code2) {
    if (code2 === null) {
      writeToChild(effects.exit("chunkFlow"), true);
      exitContainers(0);
      effects.consume(code2);
      return;
    }
    if (markdownLineEnding(code2)) {
      effects.consume(code2);
      writeToChild(effects.exit("chunkFlow"));
      continued = 0;
      self2.interrupt = void 0;
      return start2;
    }
    effects.consume(code2);
    return flowContinue;
  }
  function writeToChild(token2, endOfFile) {
    const stream = self2.sliceStream(token2);
    if (endOfFile) stream.push(null);
    token2.previous = childToken;
    if (childToken) childToken.next = token2;
    childToken = token2;
    childFlow.defineSkip(token2.start);
    childFlow.write(stream);
    if (self2.parser.lazy[token2.start.line]) {
      let index2 = childFlow.events.length;
      while (index2--) {
        if (
          // The token starts before the line ending
          childFlow.events[index2][1].start.offset < lineStartOffset && // and either is not ended yet
          (!childFlow.events[index2][1].end || // or ends after it.
          childFlow.events[index2][1].end.offset > lineStartOffset)
        ) {
          return;
        }
      }
      const indexBeforeExits = self2.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let seen;
      let point2;
      while (indexBeforeFlow--) {
        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {
          if (seen) {
            point2 = self2.events[indexBeforeFlow][1].end;
            break;
          }
          seen = true;
        }
      }
      exitContainers(continued);
      index2 = indexBeforeExits;
      while (index2 < self2.events.length) {
        self2.events[index2][1].end = {
          ...point2
        };
        index2++;
      }
      splice(self2.events, indexBeforeFlow + 1, 0, self2.events.slice(indexBeforeExits));
      self2.events.length = index2;
    }
  }
  function exitContainers(size) {
    let index2 = stack.length;
    while (index2-- > size) {
      const entry = stack[index2];
      self2.containerState = entry[1];
      entry[0].exit.call(self2, effects);
    }
    stack.length = size;
  }
  function closeFlow() {
    childFlow.write([null]);
    childToken = void 0;
    childFlow = void 0;
    self2.containerState._closeFlow = void 0;
  }
}
function tokenizeContainer(effects, ok2, nok) {
  return factorySpace(effects, effects.attempt(this.parser.constructs.document, ok2, nok), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
}
const flow$1 = {
  tokenize: initializeFlow
};
function initializeFlow(effects) {
  const self2 = this;
  const initial = effects.attempt(
    // Try to parse a blank line.
    blankLine,
    atBlankEnding,
    // Try to parse initial flow (essentially, only code).
    effects.attempt(this.parser.constructs.flowInitial, afterConstruct, factorySpace(effects, effects.attempt(this.parser.constructs.flow, afterConstruct, effects.attempt(content$1, afterConstruct)), "linePrefix"))
  );
  return initial;
  function atBlankEnding(code2) {
    if (code2 === null) {
      effects.consume(code2);
      return;
    }
    effects.enter("lineEndingBlank");
    effects.consume(code2);
    effects.exit("lineEndingBlank");
    self2.currentConstruct = void 0;
    return initial;
  }
  function afterConstruct(code2) {
    if (code2 === null) {
      effects.consume(code2);
      return;
    }
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    self2.currentConstruct = void 0;
    return initial;
  }
}
const resolver = {
  resolveAll: createResolver()
};
const string$1 = initializeFactory("string");
const text$3 = initializeFactory("text");
function initializeFactory(field) {
  return {
    resolveAll: createResolver(field === "text" ? resolveAllLineSuffixes : void 0),
    tokenize: initializeText
  };
  function initializeText(effects) {
    const self2 = this;
    const constructs2 = this.parser.constructs[field];
    const text2 = effects.attempt(constructs2, start2, notText);
    return start2;
    function start2(code2) {
      return atBreak(code2) ? text2(code2) : notText(code2);
    }
    function notText(code2) {
      if (code2 === null) {
        effects.consume(code2);
        return;
      }
      effects.enter("data");
      effects.consume(code2);
      return data;
    }
    function data(code2) {
      if (atBreak(code2)) {
        effects.exit("data");
        return text2(code2);
      }
      effects.consume(code2);
      return data;
    }
    function atBreak(code2) {
      if (code2 === null) {
        return true;
      }
      const list2 = constructs2[code2];
      let index2 = -1;
      if (list2) {
        while (++index2 < list2.length) {
          const item = list2[index2];
          if (!item.previous || item.previous.call(self2, self2.previous)) {
            return true;
          }
        }
      }
      return false;
    }
  }
}
function createResolver(extraResolver) {
  return resolveAllText;
  function resolveAllText(events, context) {
    let index2 = -1;
    let enter;
    while (++index2 <= events.length) {
      if (enter === void 0) {
        if (events[index2] && events[index2][1].type === "data") {
          enter = index2;
          index2++;
        }
      } else if (!events[index2] || events[index2][1].type !== "data") {
        if (index2 !== enter + 2) {
          events[enter][1].end = events[index2 - 1][1].end;
          events.splice(enter + 2, index2 - enter - 2);
          index2 = enter + 2;
        }
        enter = void 0;
      }
    }
    return extraResolver ? extraResolver(events, context) : events;
  }
}
function resolveAllLineSuffixes(events, context) {
  let eventIndex = 0;
  while (++eventIndex <= events.length) {
    if ((eventIndex === events.length || events[eventIndex][1].type === "lineEnding") && events[eventIndex - 1][1].type === "data") {
      const data = events[eventIndex - 1][1];
      const chunks = context.sliceStream(data);
      let index2 = chunks.length;
      let bufferIndex = -1;
      let size = 0;
      let tabs;
      while (index2--) {
        const chunk = chunks[index2];
        if (typeof chunk === "string") {
          bufferIndex = chunk.length;
          while (chunk.charCodeAt(bufferIndex - 1) === 32) {
            size++;
            bufferIndex--;
          }
          if (bufferIndex) break;
          bufferIndex = -1;
        } else if (chunk === -2) {
          tabs = true;
          size++;
        } else if (chunk === -1) ;
        else {
          index2++;
          break;
        }
      }
      if (size) {
        const token2 = {
          type: eventIndex === events.length || tabs || size < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            _bufferIndex: index2 ? bufferIndex : data.start._bufferIndex + bufferIndex,
            _index: data.start._index + index2,
            line: data.end.line,
            column: data.end.column - size,
            offset: data.end.offset - size
          },
          end: {
            ...data.end
          }
        };
        data.end = {
          ...token2.start
        };
        if (data.start.offset === data.end.offset) {
          Object.assign(data, token2);
        } else {
          events.splice(eventIndex, 0, ["enter", token2, context], ["exit", token2, context]);
          eventIndex += 2;
        }
      }
      eventIndex++;
    }
  }
  return events;
}
const document$1 = {
  [42]: list$1,
  [43]: list$1,
  [45]: list$1,
  [48]: list$1,
  [49]: list$1,
  [50]: list$1,
  [51]: list$1,
  [52]: list$1,
  [53]: list$1,
  [54]: list$1,
  [55]: list$1,
  [56]: list$1,
  [57]: list$1,
  [62]: blockQuote
};
const contentInitial = {
  [91]: definition
};
const flowInitial = {
  [-2]: codeIndented,
  [-1]: codeIndented,
  [32]: codeIndented
};
const flow = {
  [35]: headingAtx,
  [42]: thematicBreak$1,
  [45]: [setextUnderline, thematicBreak$1],
  [60]: htmlFlow,
  [61]: setextUnderline,
  [95]: thematicBreak$1,
  [96]: codeFenced,
  [126]: codeFenced
};
const string = {
  [38]: characterReference,
  [92]: characterEscape
};
const text$2 = {
  [-5]: lineEnding,
  [-4]: lineEnding,
  [-3]: lineEnding,
  [33]: labelStartImage,
  [38]: characterReference,
  [42]: attention,
  [60]: [autolink, htmlText],
  [91]: labelStartLink,
  [92]: [hardBreakEscape, characterEscape],
  [93]: labelEnd,
  [95]: attention,
  [96]: codeText
};
const insideSpan = {
  null: [attention, resolver]
};
const attentionMarkers = {
  null: [42, 95]
};
const disable = {
  null: []
};
const defaultConstructs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers,
  contentInitial,
  disable,
  document: document$1,
  flow,
  flowInitial,
  insideSpan,
  string,
  text: text$2
}, Symbol.toStringTag, { value: "Module" }));
function createTokenizer(parser, initialize, from2) {
  let point2 = {
    _bufferIndex: -1,
    _index: 0,
    line: from2 && from2.line || 1,
    column: from2 && from2.column || 1,
    offset: from2 && from2.offset || 0
  };
  const columnStart = {};
  const resolveAllConstructs = [];
  let chunks = [];
  let stack = [];
  const effects = {
    attempt: constructFactory(onsuccessfulconstruct),
    check: constructFactory(onsuccessfulcheck),
    consume,
    enter,
    exit: exit2,
    interrupt: constructFactory(onsuccessfulcheck, {
      interrupt: true
    })
  };
  const context = {
    code: null,
    containerState: {},
    defineSkip,
    events: [],
    now: now2,
    parser,
    previous: null,
    sliceSerialize,
    sliceStream,
    write
  };
  let state = initialize.tokenize.call(context, effects);
  if (initialize.resolveAll) {
    resolveAllConstructs.push(initialize);
  }
  return context;
  function write(slice2) {
    chunks = push(chunks, slice2);
    main();
    if (chunks[chunks.length - 1] !== null) {
      return [];
    }
    addResult(initialize, 0);
    context.events = resolveAll(resolveAllConstructs, context.events, context);
    return context.events;
  }
  function sliceSerialize(token2, expandTabs) {
    return serializeChunks(sliceStream(token2), expandTabs);
  }
  function sliceStream(token2) {
    return sliceChunks(chunks, token2);
  }
  function now2() {
    const {
      _bufferIndex,
      _index,
      line: line2,
      column: column2,
      offset
    } = point2;
    return {
      _bufferIndex,
      _index,
      line: line2,
      column: column2,
      offset
    };
  }
  function defineSkip(value) {
    columnStart[value.line] = value.column;
    accountForPotentialSkip();
  }
  function main() {
    let chunkIndex;
    while (point2._index < chunks.length) {
      const chunk = chunks[point2._index];
      if (typeof chunk === "string") {
        chunkIndex = point2._index;
        if (point2._bufferIndex < 0) {
          point2._bufferIndex = 0;
        }
        while (point2._index === chunkIndex && point2._bufferIndex < chunk.length) {
          go(chunk.charCodeAt(point2._bufferIndex));
        }
      } else {
        go(chunk);
      }
    }
  }
  function go(code2) {
    state = state(code2);
  }
  function consume(code2) {
    if (markdownLineEnding(code2)) {
      point2.line++;
      point2.column = 1;
      point2.offset += code2 === -3 ? 2 : 1;
      accountForPotentialSkip();
    } else if (code2 !== -1) {
      point2.column++;
      point2.offset++;
    }
    if (point2._bufferIndex < 0) {
      point2._index++;
    } else {
      point2._bufferIndex++;
      if (point2._bufferIndex === // Points w/ non-negative `_bufferIndex` reference
      // strings.
      /** @type {string} */
      chunks[point2._index].length) {
        point2._bufferIndex = -1;
        point2._index++;
      }
    }
    context.previous = code2;
  }
  function enter(type2, fields) {
    const token2 = fields || {};
    token2.type = type2;
    token2.start = now2();
    context.events.push(["enter", token2, context]);
    stack.push(token2);
    return token2;
  }
  function exit2(type2) {
    const token2 = stack.pop();
    token2.end = now2();
    context.events.push(["exit", token2, context]);
    return token2;
  }
  function onsuccessfulconstruct(construct2, info) {
    addResult(construct2, info.from);
  }
  function onsuccessfulcheck(_2, info) {
    info.restore();
  }
  function constructFactory(onreturn, fields) {
    return hook;
    function hook(constructs2, returnState, bogusState) {
      let listOfConstructs;
      let constructIndex;
      let currentConstruct;
      let info;
      return Array.isArray(constructs2) ? (
        /* c8 ignore next 1 */
        handleListOfConstructs(constructs2)
      ) : "tokenize" in constructs2 ? (
        // Looks like a construct.
        handleListOfConstructs([
          /** @type {Construct} */
          constructs2
        ])
      ) : handleMapOfConstructs(constructs2);
      function handleMapOfConstructs(map2) {
        return start2;
        function start2(code2) {
          const left = code2 !== null && map2[code2];
          const all3 = code2 !== null && map2.null;
          const list2 = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(left) ? left : left ? [left] : [],
            ...Array.isArray(all3) ? all3 : all3 ? [all3] : []
          ];
          return handleListOfConstructs(list2)(code2);
        }
      }
      function handleListOfConstructs(list2) {
        listOfConstructs = list2;
        constructIndex = 0;
        if (list2.length === 0) {
          return bogusState;
        }
        return handleConstruct(list2[constructIndex]);
      }
      function handleConstruct(construct2) {
        return start2;
        function start2(code2) {
          info = store();
          currentConstruct = construct2;
          if (!construct2.partial) {
            context.currentConstruct = construct2;
          }
          if (construct2.name && context.parser.constructs.disable.null.includes(construct2.name)) {
            return nok();
          }
          return construct2.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a live binding, which is needed for `interrupt`.
            fields ? Object.assign(Object.create(context), fields) : context,
            effects,
            ok2,
            nok
          )(code2);
        }
      }
      function ok2(code2) {
        onreturn(currentConstruct, info);
        return returnState;
      }
      function nok(code2) {
        info.restore();
        if (++constructIndex < listOfConstructs.length) {
          return handleConstruct(listOfConstructs[constructIndex]);
        }
        return bogusState;
      }
    }
  }
  function addResult(construct2, from3) {
    if (construct2.resolveAll && !resolveAllConstructs.includes(construct2)) {
      resolveAllConstructs.push(construct2);
    }
    if (construct2.resolve) {
      splice(context.events, from3, context.events.length - from3, construct2.resolve(context.events.slice(from3), context));
    }
    if (construct2.resolveTo) {
      context.events = construct2.resolveTo(context.events, context);
    }
  }
  function store() {
    const startPoint = now2();
    const startPrevious = context.previous;
    const startCurrentConstruct = context.currentConstruct;
    const startEventsIndex = context.events.length;
    const startStack = Array.from(stack);
    return {
      from: startEventsIndex,
      restore
    };
    function restore() {
      point2 = startPoint;
      context.previous = startPrevious;
      context.currentConstruct = startCurrentConstruct;
      context.events.length = startEventsIndex;
      stack = startStack;
      accountForPotentialSkip();
    }
  }
  function accountForPotentialSkip() {
    if (point2.line in columnStart && point2.column < 2) {
      point2.column = columnStart[point2.line];
      point2.offset += columnStart[point2.line] - 1;
    }
  }
}
function sliceChunks(chunks, token2) {
  const startIndex = token2.start._index;
  const startBufferIndex = token2.start._bufferIndex;
  const endIndex = token2.end._index;
  const endBufferIndex = token2.end._bufferIndex;
  let view;
  if (startIndex === endIndex) {
    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
  } else {
    view = chunks.slice(startIndex, endIndex);
    if (startBufferIndex > -1) {
      const head = view[0];
      if (typeof head === "string") {
        view[0] = head.slice(startBufferIndex);
      } else {
        view.shift();
      }
    }
    if (endBufferIndex > 0) {
      view.push(chunks[endIndex].slice(0, endBufferIndex));
    }
  }
  return view;
}
function serializeChunks(chunks, expandTabs) {
  let index2 = -1;
  const result = [];
  let atTab;
  while (++index2 < chunks.length) {
    const chunk = chunks[index2];
    let value;
    if (typeof chunk === "string") {
      value = chunk;
    } else switch (chunk) {
      case -5: {
        value = "\r";
        break;
      }
      case -4: {
        value = "\n";
        break;
      }
      case -3: {
        value = "\r\n";
        break;
      }
      case -2: {
        value = expandTabs ? " " : "	";
        break;
      }
      case -1: {
        if (!expandTabs && atTab) continue;
        value = " ";
        break;
      }
      default: {
        value = String.fromCharCode(chunk);
      }
    }
    atTab = chunk === -2;
    result.push(value);
  }
  return result.join("");
}
function parse(options) {
  const settings = options || {};
  const constructs2 = (
    /** @type {FullNormalizedExtension} */
    combineExtensions([defaultConstructs, ...settings.extensions || []])
  );
  const parser = {
    constructs: constructs2,
    content: create3(content),
    defined: [],
    document: create3(document$2),
    flow: create3(flow$1),
    lazy: {},
    string: create3(string$1),
    text: create3(text$3)
  };
  return parser;
  function create3(initial) {
    return creator;
    function creator(from2) {
      return createTokenizer(parser, initial, from2);
    }
  }
}
function postprocess(events) {
  while (!subtokenize(events)) {
  }
  return events;
}
const search = /[\0\t\n\r]/g;
function preprocess() {
  let column2 = 1;
  let buffer2 = "";
  let start2 = true;
  let atCarriageReturn;
  return preprocessor;
  function preprocessor(value, encoding, end) {
    const chunks = [];
    let match2;
    let next2;
    let startPosition;
    let endPosition;
    let code2;
    value = buffer2 + (typeof value === "string" ? value.toString() : new TextDecoder(encoding || void 0).decode(value));
    startPosition = 0;
    buffer2 = "";
    if (start2) {
      if (value.charCodeAt(0) === 65279) {
        startPosition++;
      }
      start2 = void 0;
    }
    while (startPosition < value.length) {
      search.lastIndex = startPosition;
      match2 = search.exec(value);
      endPosition = match2 && match2.index !== void 0 ? match2.index : value.length;
      code2 = value.charCodeAt(endPosition);
      if (!match2) {
        buffer2 = value.slice(startPosition);
        break;
      }
      if (code2 === 10 && startPosition === endPosition && atCarriageReturn) {
        chunks.push(-3);
        atCarriageReturn = void 0;
      } else {
        if (atCarriageReturn) {
          chunks.push(-5);
          atCarriageReturn = void 0;
        }
        if (startPosition < endPosition) {
          chunks.push(value.slice(startPosition, endPosition));
          column2 += endPosition - startPosition;
        }
        switch (code2) {
          case 0: {
            chunks.push(65533);
            column2++;
            break;
          }
          case 9: {
            next2 = Math.ceil(column2 / 4) * 4;
            chunks.push(-2);
            while (column2++ < next2) chunks.push(-1);
            break;
          }
          case 10: {
            chunks.push(-4);
            column2 = 1;
            break;
          }
          default: {
            atCarriageReturn = true;
            column2 = 1;
          }
        }
      }
      startPosition = endPosition + 1;
    }
    if (end) {
      if (atCarriageReturn) chunks.push(-5);
      if (buffer2) chunks.push(buffer2);
      chunks.push(null);
    }
    return chunks;
  }
}
const own$2 = {}.hasOwnProperty;
function fromMarkdown(value, encoding, options) {
  if (typeof encoding !== "string") {
    options = encoding;
    encoding = void 0;
  }
  return compiler(options)(postprocess(parse(options).document().write(preprocess()(value, encoding, true))));
}
function compiler(options) {
  const config2 = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: opener(link2),
      autolinkProtocol: onenterdata,
      autolinkEmail: onenterdata,
      atxHeading: opener(heading2),
      blockQuote: opener(blockQuote2),
      characterEscape: onenterdata,
      characterReference: onenterdata,
      codeFenced: opener(codeFlow),
      codeFencedFenceInfo: buffer2,
      codeFencedFenceMeta: buffer2,
      codeIndented: opener(codeFlow, buffer2),
      codeText: opener(codeText2, buffer2),
      codeTextData: onenterdata,
      data: onenterdata,
      codeFlowValue: onenterdata,
      definition: opener(definition2),
      definitionDestinationString: buffer2,
      definitionLabelString: buffer2,
      definitionTitleString: buffer2,
      emphasis: opener(emphasis2),
      hardBreakEscape: opener(hardBreak2),
      hardBreakTrailing: opener(hardBreak2),
      htmlFlow: opener(html2, buffer2),
      htmlFlowData: onenterdata,
      htmlText: opener(html2, buffer2),
      htmlTextData: onenterdata,
      image: opener(image2),
      label: buffer2,
      link: opener(link2),
      listItem: opener(listItem2),
      listItemValue: onenterlistitemvalue,
      listOrdered: opener(list2, onenterlistordered),
      listUnordered: opener(list2),
      paragraph: opener(paragraph2),
      reference: onenterreference,
      referenceString: buffer2,
      resourceDestinationString: buffer2,
      resourceTitleString: buffer2,
      setextHeading: opener(heading2),
      strong: opener(strong2),
      thematicBreak: opener(thematicBreak2)
    },
    exit: {
      atxHeading: closer(),
      atxHeadingSequence: onexitatxheadingsequence,
      autolink: closer(),
      autolinkEmail: onexitautolinkemail,
      autolinkProtocol: onexitautolinkprotocol,
      blockQuote: closer(),
      characterEscapeValue: onexitdata,
      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
      characterReferenceValue: onexitcharacterreferencevalue,
      characterReference: onexitcharacterreference,
      codeFenced: closer(onexitcodefenced),
      codeFencedFence: onexitcodefencedfence,
      codeFencedFenceInfo: onexitcodefencedfenceinfo,
      codeFencedFenceMeta: onexitcodefencedfencemeta,
      codeFlowValue: onexitdata,
      codeIndented: closer(onexitcodeindented),
      codeText: closer(onexitcodetext),
      codeTextData: onexitdata,
      data: onexitdata,
      definition: closer(),
      definitionDestinationString: onexitdefinitiondestinationstring,
      definitionLabelString: onexitdefinitionlabelstring,
      definitionTitleString: onexitdefinitiontitlestring,
      emphasis: closer(),
      hardBreakEscape: closer(onexithardbreak),
      hardBreakTrailing: closer(onexithardbreak),
      htmlFlow: closer(onexithtmlflow),
      htmlFlowData: onexitdata,
      htmlText: closer(onexithtmltext),
      htmlTextData: onexitdata,
      image: closer(onexitimage),
      label: onexitlabel,
      labelText: onexitlabeltext,
      lineEnding: onexitlineending,
      link: closer(onexitlink),
      listItem: closer(),
      listOrdered: closer(),
      listUnordered: closer(),
      paragraph: closer(),
      referenceString: onexitreferencestring,
      resourceDestinationString: onexitresourcedestinationstring,
      resourceTitleString: onexitresourcetitlestring,
      resource: onexitresource,
      setextHeading: closer(onexitsetextheading),
      setextHeadingLineSequence: onexitsetextheadinglinesequence,
      setextHeadingText: onexitsetextheadingtext,
      strong: closer(),
      thematicBreak: closer()
    }
  };
  configure(config2, (options || {}).mdastExtensions || []);
  const data = {};
  return compile2;
  function compile2(events) {
    let tree = {
      type: "root",
      children: []
    };
    const context = {
      stack: [tree],
      tokenStack: [],
      config: config2,
      enter,
      exit: exit2,
      buffer: buffer2,
      resume,
      data
    };
    const listStack = [];
    let index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][1].type === "listOrdered" || events[index2][1].type === "listUnordered") {
        if (events[index2][0] === "enter") {
          listStack.push(index2);
        } else {
          const tail = listStack.pop();
          index2 = prepareList(events, tail, index2);
        }
      }
    }
    index2 = -1;
    while (++index2 < events.length) {
      const handler = config2[events[index2][0]];
      if (own$2.call(handler, events[index2][1].type)) {
        handler[events[index2][1].type].call(Object.assign({
          sliceSerialize: events[index2][2].sliceSerialize
        }, context), events[index2][1]);
      }
    }
    if (context.tokenStack.length > 0) {
      const tail = context.tokenStack[context.tokenStack.length - 1];
      const handler = tail[1] || defaultOnError;
      handler.call(context, void 0, tail[0]);
    }
    tree.position = {
      start: point(events.length > 0 ? events[0][1].start : {
        line: 1,
        column: 1,
        offset: 0
      }),
      end: point(events.length > 0 ? events[events.length - 2][1].end : {
        line: 1,
        column: 1,
        offset: 0
      })
    };
    index2 = -1;
    while (++index2 < config2.transforms.length) {
      tree = config2.transforms[index2](tree) || tree;
    }
    return tree;
  }
  function prepareList(events, start2, length2) {
    let index2 = start2 - 1;
    let containerBalance = -1;
    let listSpread = false;
    let listItem3;
    let lineIndex;
    let firstBlankLineIndex;
    let atMarker;
    while (++index2 <= length2) {
      const event = events[index2];
      switch (event[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          if (event[0] === "enter") {
            containerBalance++;
          } else {
            containerBalance--;
          }
          atMarker = void 0;
          break;
        }
        case "lineEndingBlank": {
          if (event[0] === "enter") {
            if (listItem3 && !atMarker && !containerBalance && !firstBlankLineIndex) {
              firstBlankLineIndex = index2;
            }
            atMarker = void 0;
          }
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace": {
          break;
        }
        default: {
          atMarker = void 0;
        }
      }
      if (!containerBalance && event[0] === "enter" && event[1].type === "listItemPrefix" || containerBalance === -1 && event[0] === "exit" && (event[1].type === "listUnordered" || event[1].type === "listOrdered")) {
        if (listItem3) {
          let tailIndex = index2;
          lineIndex = void 0;
          while (tailIndex--) {
            const tailEvent = events[tailIndex];
            if (tailEvent[1].type === "lineEnding" || tailEvent[1].type === "lineEndingBlank") {
              if (tailEvent[0] === "exit") continue;
              if (lineIndex) {
                events[lineIndex][1].type = "lineEndingBlank";
                listSpread = true;
              }
              tailEvent[1].type = "lineEnding";
              lineIndex = tailIndex;
            } else if (tailEvent[1].type === "linePrefix" || tailEvent[1].type === "blockQuotePrefix" || tailEvent[1].type === "blockQuotePrefixWhitespace" || tailEvent[1].type === "blockQuoteMarker" || tailEvent[1].type === "listItemIndent") ;
            else {
              break;
            }
          }
          if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
            listItem3._spread = true;
          }
          listItem3.end = Object.assign({}, lineIndex ? events[lineIndex][1].start : event[1].end);
          events.splice(lineIndex || index2, 0, ["exit", listItem3, event[2]]);
          index2++;
          length2++;
        }
        if (event[1].type === "listItemPrefix") {
          const item = {
            type: "listItem",
            _spread: false,
            start: Object.assign({}, event[1].start),
            // @ts-expect-error: well add `end` in a second.
            end: void 0
          };
          listItem3 = item;
          events.splice(index2, 0, ["enter", item, event[2]]);
          index2++;
          length2++;
          firstBlankLineIndex = void 0;
          atMarker = true;
        }
      }
    }
    events[start2][1]._spread = listSpread;
    return length2;
  }
  function opener(create3, and) {
    return open;
    function open(token2) {
      enter.call(this, create3(token2), token2);
      if (and) and.call(this, token2);
    }
  }
  function buffer2() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function enter(node2, token2, errorHandler) {
    const parent = this.stack[this.stack.length - 1];
    const siblings = parent.children;
    siblings.push(node2);
    this.stack.push(node2);
    this.tokenStack.push([token2, errorHandler || void 0]);
    node2.position = {
      start: point(token2.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function closer(and) {
    return close;
    function close(token2) {
      if (and) and.call(this, token2);
      exit2.call(this, token2);
    }
  }
  function exit2(token2, onExitError) {
    const node2 = this.stack.pop();
    const open = this.tokenStack.pop();
    if (!open) {
      throw new Error("Cannot close `" + token2.type + "` (" + stringifyPosition({
        start: token2.start,
        end: token2.end
      }) + "): its not open");
    } else if (open[0].type !== token2.type) {
      if (onExitError) {
        onExitError.call(this, token2, open[0]);
      } else {
        const handler = open[1] || defaultOnError;
        handler.call(this, token2, open[0]);
      }
    }
    node2.position.end = point(token2.end);
  }
  function resume() {
    return toString$1(this.stack.pop());
  }
  function onenterlistordered() {
    this.data.expectingFirstListItemValue = true;
  }
  function onenterlistitemvalue(token2) {
    if (this.data.expectingFirstListItemValue) {
      const ancestor = this.stack[this.stack.length - 2];
      ancestor.start = Number.parseInt(this.sliceSerialize(token2), 10);
      this.data.expectingFirstListItemValue = void 0;
    }
  }
  function onexitcodefencedfenceinfo() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.lang = data2;
  }
  function onexitcodefencedfencemeta() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.meta = data2;
  }
  function onexitcodefencedfence() {
    if (this.data.flowCodeInside) return;
    this.buffer();
    this.data.flowCodeInside = true;
  }
  function onexitcodefenced() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data2.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
    this.data.flowCodeInside = void 0;
  }
  function onexitcodeindented() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data2.replace(/(\r?\n|\r)$/g, "");
  }
  function onexitdefinitionlabelstring(token2) {
    const label = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.label = label;
    node2.identifier = normalizeIdentifier(this.sliceSerialize(token2)).toLowerCase();
  }
  function onexitdefinitiontitlestring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.title = data2;
  }
  function onexitdefinitiondestinationstring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.url = data2;
  }
  function onexitatxheadingsequence(token2) {
    const node2 = this.stack[this.stack.length - 1];
    if (!node2.depth) {
      const depth = this.sliceSerialize(token2).length;
      node2.depth = depth;
    }
  }
  function onexitsetextheadingtext() {
    this.data.setextHeadingSlurpLineEnding = true;
  }
  function onexitsetextheadinglinesequence(token2) {
    const node2 = this.stack[this.stack.length - 1];
    node2.depth = this.sliceSerialize(token2).codePointAt(0) === 61 ? 1 : 2;
  }
  function onexitsetextheading() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function onenterdata(token2) {
    const node2 = this.stack[this.stack.length - 1];
    const siblings = node2.children;
    let tail = siblings[siblings.length - 1];
    if (!tail || tail.type !== "text") {
      tail = text2();
      tail.position = {
        start: point(token2.start),
        // @ts-expect-error: well add `end` later.
        end: void 0
      };
      siblings.push(tail);
    }
    this.stack.push(tail);
  }
  function onexitdata(token2) {
    const tail = this.stack.pop();
    tail.value += this.sliceSerialize(token2);
    tail.position.end = point(token2.end);
  }
  function onexitlineending(token2) {
    const context = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const tail = context.children[context.children.length - 1];
      tail.position.end = point(token2.end);
      this.data.atHardBreak = void 0;
      return;
    }
    if (!this.data.setextHeadingSlurpLineEnding && config2.canContainEols.includes(context.type)) {
      onenterdata.call(this, token2);
      onexitdata.call(this, token2);
    }
  }
  function onexithardbreak() {
    this.data.atHardBreak = true;
  }
  function onexithtmlflow() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data2;
  }
  function onexithtmltext() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data2;
  }
  function onexitcodetext() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data2;
  }
  function onexitlink() {
    const node2 = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const referenceType = this.data.referenceType || "shortcut";
      node2.type += "Reference";
      node2.referenceType = referenceType;
      delete node2.url;
      delete node2.title;
    } else {
      delete node2.identifier;
      delete node2.label;
    }
    this.data.referenceType = void 0;
  }
  function onexitimage() {
    const node2 = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const referenceType = this.data.referenceType || "shortcut";
      node2.type += "Reference";
      node2.referenceType = referenceType;
      delete node2.url;
      delete node2.title;
    } else {
      delete node2.identifier;
      delete node2.label;
    }
    this.data.referenceType = void 0;
  }
  function onexitlabeltext(token2) {
    const string2 = this.sliceSerialize(token2);
    const ancestor = this.stack[this.stack.length - 2];
    ancestor.label = decodeString(string2);
    ancestor.identifier = normalizeIdentifier(string2).toLowerCase();
  }
  function onexitlabel() {
    const fragment = this.stack[this.stack.length - 1];
    const value = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    this.data.inReference = true;
    if (node2.type === "link") {
      const children = fragment.children;
      node2.children = children;
    } else {
      node2.alt = value;
    }
  }
  function onexitresourcedestinationstring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.url = data2;
  }
  function onexitresourcetitlestring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.title = data2;
  }
  function onexitresource() {
    this.data.inReference = void 0;
  }
  function onenterreference() {
    this.data.referenceType = "collapsed";
  }
  function onexitreferencestring(token2) {
    const label = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.label = label;
    node2.identifier = normalizeIdentifier(this.sliceSerialize(token2)).toLowerCase();
    this.data.referenceType = "full";
  }
  function onexitcharacterreferencemarker(token2) {
    this.data.characterReferenceType = token2.type;
  }
  function onexitcharacterreferencevalue(token2) {
    const data2 = this.sliceSerialize(token2);
    const type2 = this.data.characterReferenceType;
    let value;
    if (type2) {
      value = decodeNumericCharacterReference(data2, type2 === "characterReferenceMarkerNumeric" ? 10 : 16);
      this.data.characterReferenceType = void 0;
    } else {
      const result = decodeNamedCharacterReference(data2);
      value = result;
    }
    const tail = this.stack[this.stack.length - 1];
    tail.value += value;
  }
  function onexitcharacterreference(token2) {
    const tail = this.stack.pop();
    tail.position.end = point(token2.end);
  }
  function onexitautolinkprotocol(token2) {
    onexitdata.call(this, token2);
    const node2 = this.stack[this.stack.length - 1];
    node2.url = this.sliceSerialize(token2);
  }
  function onexitautolinkemail(token2) {
    onexitdata.call(this, token2);
    const node2 = this.stack[this.stack.length - 1];
    node2.url = "mailto:" + this.sliceSerialize(token2);
  }
  function blockQuote2() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function codeFlow() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function codeText2() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function definition2() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function emphasis2() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function heading2() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function hardBreak2() {
    return {
      type: "break"
    };
  }
  function html2() {
    return {
      type: "html",
      value: ""
    };
  }
  function image2() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function link2() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function list2(token2) {
    return {
      type: "list",
      ordered: token2.type === "listOrdered",
      start: null,
      spread: token2._spread,
      children: []
    };
  }
  function listItem2(token2) {
    return {
      type: "listItem",
      spread: token2._spread,
      checked: null,
      children: []
    };
  }
  function paragraph2() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function strong2() {
    return {
      type: "strong",
      children: []
    };
  }
  function text2() {
    return {
      type: "text",
      value: ""
    };
  }
  function thematicBreak2() {
    return {
      type: "thematicBreak"
    };
  }
}
function point(d2) {
  return {
    line: d2.line,
    column: d2.column,
    offset: d2.offset
  };
}
function configure(combined, extensions) {
  let index2 = -1;
  while (++index2 < extensions.length) {
    const value = extensions[index2];
    if (Array.isArray(value)) {
      configure(combined, value);
    } else {
      extension(combined, value);
    }
  }
}
function extension(combined, extension2) {
  let key;
  for (key in extension2) {
    if (own$2.call(extension2, key)) {
      switch (key) {
        case "canContainEols": {
          const right = extension2[key];
          if (right) {
            combined[key].push(...right);
          }
          break;
        }
        case "transforms": {
          const right = extension2[key];
          if (right) {
            combined[key].push(...right);
          }
          break;
        }
        case "enter":
        case "exit": {
          const right = extension2[key];
          if (right) {
            Object.assign(combined[key], right);
          }
          break;
        }
      }
    }
  }
}
function defaultOnError(left, right) {
  if (left) {
    throw new Error("Cannot close `" + left.type + "` (" + stringifyPosition({
      start: left.start,
      end: left.end
    }) + "): a different token (`" + right.type + "`, " + stringifyPosition({
      start: right.start,
      end: right.end
    }) + ") is open");
  } else {
    throw new Error("Cannot close document, a token (`" + right.type + "`, " + stringifyPosition({
      start: right.start,
      end: right.end
    }) + ") is still open");
  }
}
function remarkParse(options) {
  const self2 = this;
  self2.parser = parser;
  function parser(doc) {
    return fromMarkdown(doc, {
      ...self2.data("settings"),
      ...options,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: self2.data("micromarkExtensions") || [],
      mdastExtensions: self2.data("fromMarkdownExtensions") || []
    });
  }
}
function blockquote(state, node2) {
  const result = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: state.wrap(state.all(node2), true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function hardBreak(state, node2) {
  const result = { type: "element", tagName: "br", properties: {}, children: [] };
  state.patch(node2, result);
  return [state.applyData(node2, result), { type: "text", value: "\n" }];
}
function code(state, node2) {
  const value = node2.value ? node2.value + "\n" : "";
  const properties2 = {};
  if (node2.lang) {
    properties2.className = ["language-" + node2.lang];
  }
  let result = {
    type: "element",
    tagName: "code",
    properties: properties2,
    children: [{ type: "text", value }]
  };
  if (node2.meta) {
    result.data = { meta: node2.meta };
  }
  state.patch(node2, result);
  result = state.applyData(node2, result);
  result = { type: "element", tagName: "pre", properties: {}, children: [result] };
  state.patch(node2, result);
  return result;
}
function strikethrough(state, node2) {
  const result = {
    type: "element",
    tagName: "del",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function emphasis(state, node2) {
  const result = {
    type: "element",
    tagName: "em",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function footnoteReference(state, node2) {
  const clobberPrefix = typeof state.options.clobberPrefix === "string" ? state.options.clobberPrefix : "user-content-";
  const id2 = String(node2.identifier).toUpperCase();
  const safeId = normalizeUri(id2.toLowerCase());
  const index2 = state.footnoteOrder.indexOf(id2);
  let counter;
  let reuseCounter = state.footnoteCounts.get(id2);
  if (reuseCounter === void 0) {
    reuseCounter = 0;
    state.footnoteOrder.push(id2);
    counter = state.footnoteOrder.length;
  } else {
    counter = index2 + 1;
  }
  reuseCounter += 1;
  state.footnoteCounts.set(id2, reuseCounter);
  const link2 = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + clobberPrefix + "fn-" + safeId,
      id: clobberPrefix + "fnref-" + safeId + (reuseCounter > 1 ? "-" + reuseCounter : ""),
      dataFootnoteRef: true,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(counter) }]
  };
  state.patch(node2, link2);
  const sup = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [link2]
  };
  state.patch(node2, sup);
  return state.applyData(node2, sup);
}
function heading(state, node2) {
  const result = {
    type: "element",
    tagName: "h" + node2.depth,
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function html$2(state, node2) {
  if (state.options.allowDangerousHtml) {
    const result = { type: "raw", value: node2.value };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  return void 0;
}
function revert(state, node2) {
  const subtype = node2.referenceType;
  let suffix = "]";
  if (subtype === "collapsed") {
    suffix += "[]";
  } else if (subtype === "full") {
    suffix += "[" + (node2.label || node2.identifier) + "]";
  }
  if (node2.type === "imageReference") {
    return [{ type: "text", value: "![" + node2.alt + suffix }];
  }
  const contents = state.all(node2);
  const head = contents[0];
  if (head && head.type === "text") {
    head.value = "[" + head.value;
  } else {
    contents.unshift({ type: "text", value: "[" });
  }
  const tail = contents[contents.length - 1];
  if (tail && tail.type === "text") {
    tail.value += suffix;
  } else {
    contents.push({ type: "text", value: suffix });
  }
  return contents;
}
function imageReference(state, node2) {
  const id2 = String(node2.identifier).toUpperCase();
  const definition2 = state.definitionById.get(id2);
  if (!definition2) {
    return revert(state, node2);
  }
  const properties2 = { src: normalizeUri(definition2.url || ""), alt: node2.alt };
  if (definition2.title !== null && definition2.title !== void 0) {
    properties2.title = definition2.title;
  }
  const result = { type: "element", tagName: "img", properties: properties2, children: [] };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function image(state, node2) {
  const properties2 = { src: normalizeUri(node2.url) };
  if (node2.alt !== null && node2.alt !== void 0) {
    properties2.alt = node2.alt;
  }
  if (node2.title !== null && node2.title !== void 0) {
    properties2.title = node2.title;
  }
  const result = { type: "element", tagName: "img", properties: properties2, children: [] };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function inlineCode(state, node2) {
  const text2 = { type: "text", value: node2.value.replace(/\r?\n|\r/g, " ") };
  state.patch(node2, text2);
  const result = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [text2]
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function linkReference(state, node2) {
  const id2 = String(node2.identifier).toUpperCase();
  const definition2 = state.definitionById.get(id2);
  if (!definition2) {
    return revert(state, node2);
  }
  const properties2 = { href: normalizeUri(definition2.url || "") };
  if (definition2.title !== null && definition2.title !== void 0) {
    properties2.title = definition2.title;
  }
  const result = {
    type: "element",
    tagName: "a",
    properties: properties2,
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function link(state, node2) {
  const properties2 = { href: normalizeUri(node2.url) };
  if (node2.title !== null && node2.title !== void 0) {
    properties2.title = node2.title;
  }
  const result = {
    type: "element",
    tagName: "a",
    properties: properties2,
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function listItem(state, node2, parent) {
  const results = state.all(node2);
  const loose = parent ? listLoose(parent) : listItemLoose(node2);
  const properties2 = {};
  const children = [];
  if (typeof node2.checked === "boolean") {
    const head = results[0];
    let paragraph2;
    if (head && head.type === "element" && head.tagName === "p") {
      paragraph2 = head;
    } else {
      paragraph2 = { type: "element", tagName: "p", properties: {}, children: [] };
      results.unshift(paragraph2);
    }
    if (paragraph2.children.length > 0) {
      paragraph2.children.unshift({ type: "text", value: " " });
    }
    paragraph2.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: node2.checked, disabled: true },
      children: []
    });
    properties2.className = ["task-list-item"];
  }
  let index2 = -1;
  while (++index2 < results.length) {
    const child = results[index2];
    if (loose || index2 !== 0 || child.type !== "element" || child.tagName !== "p") {
      children.push({ type: "text", value: "\n" });
    }
    if (child.type === "element" && child.tagName === "p" && !loose) {
      children.push(...child.children);
    } else {
      children.push(child);
    }
  }
  const tail = results[results.length - 1];
  if (tail && (loose || tail.type !== "element" || tail.tagName !== "p")) {
    children.push({ type: "text", value: "\n" });
  }
  const result = { type: "element", tagName: "li", properties: properties2, children };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function listLoose(node2) {
  let loose = false;
  if (node2.type === "list") {
    loose = node2.spread || false;
    const children = node2.children;
    let index2 = -1;
    while (!loose && ++index2 < children.length) {
      loose = listItemLoose(children[index2]);
    }
  }
  return loose;
}
function listItemLoose(node2) {
  const spread2 = node2.spread;
  return spread2 === null || spread2 === void 0 ? node2.children.length > 1 : spread2;
}
function list(state, node2) {
  const properties2 = {};
  const results = state.all(node2);
  let index2 = -1;
  if (typeof node2.start === "number" && node2.start !== 1) {
    properties2.start = node2.start;
  }
  while (++index2 < results.length) {
    const child = results[index2];
    if (child.type === "element" && child.tagName === "li" && child.properties && Array.isArray(child.properties.className) && child.properties.className.includes("task-list-item")) {
      properties2.className = ["contains-task-list"];
      break;
    }
  }
  const result = {
    type: "element",
    tagName: node2.ordered ? "ol" : "ul",
    properties: properties2,
    children: state.wrap(results, true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function paragraph(state, node2) {
  const result = {
    type: "element",
    tagName: "p",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function root(state, node2) {
  const result = { type: "root", children: state.wrap(state.all(node2)) };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function strong(state, node2) {
  const result = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function table(state, node2) {
  const rows = state.all(node2);
  const firstRow = rows.shift();
  const tableContent = [];
  if (firstRow) {
    const head = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: state.wrap([firstRow], true)
    };
    state.patch(node2.children[0], head);
    tableContent.push(head);
  }
  if (rows.length > 0) {
    const body = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: state.wrap(rows, true)
    };
    const start2 = pointStart(node2.children[1]);
    const end = pointEnd(node2.children[node2.children.length - 1]);
    if (start2 && end) body.position = { start: start2, end };
    tableContent.push(body);
  }
  const result = {
    type: "element",
    tagName: "table",
    properties: {},
    children: state.wrap(tableContent, true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function tableRow(state, node2, parent) {
  const siblings = parent ? parent.children : void 0;
  const rowIndex = siblings ? siblings.indexOf(node2) : 1;
  const tagName = rowIndex === 0 ? "th" : "td";
  const align = parent && parent.type === "table" ? parent.align : void 0;
  const length2 = align ? align.length : node2.children.length;
  let cellIndex = -1;
  const cells = [];
  while (++cellIndex < length2) {
    const cell = node2.children[cellIndex];
    const properties2 = {};
    const alignValue = align ? align[cellIndex] : void 0;
    if (alignValue) {
      properties2.align = alignValue;
    }
    let result2 = { type: "element", tagName, properties: properties2, children: [] };
    if (cell) {
      result2.children = state.all(cell);
      state.patch(cell, result2);
      result2 = state.applyData(cell, result2);
    }
    cells.push(result2);
  }
  const result = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: state.wrap(cells, true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function tableCell(state, node2) {
  const result = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
const tab = 9;
const space = 32;
function trimLines(value) {
  const source = String(value);
  const search2 = /\r?\n|\r/g;
  let match2 = search2.exec(source);
  let last = 0;
  const lines = [];
  while (match2) {
    lines.push(
      trimLine(source.slice(last, match2.index), last > 0, true),
      match2[0]
    );
    last = match2.index + match2[0].length;
    match2 = search2.exec(source);
  }
  lines.push(trimLine(source.slice(last), last > 0, false));
  return lines.join("");
}
function trimLine(value, start2, end) {
  let startIndex = 0;
  let endIndex = value.length;
  if (start2) {
    let code2 = value.codePointAt(startIndex);
    while (code2 === tab || code2 === space) {
      startIndex++;
      code2 = value.codePointAt(startIndex);
    }
  }
  if (end) {
    let code2 = value.codePointAt(endIndex - 1);
    while (code2 === tab || code2 === space) {
      endIndex--;
      code2 = value.codePointAt(endIndex - 1);
    }
  }
  return endIndex > startIndex ? value.slice(startIndex, endIndex) : "";
}
function text$1(state, node2) {
  const result = { type: "text", value: trimLines(String(node2.value)) };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function thematicBreak(state, node2) {
  const result = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
const handlers = {
  blockquote,
  break: hardBreak,
  code,
  delete: strikethrough,
  emphasis,
  footnoteReference,
  heading,
  html: html$2,
  imageReference,
  image,
  inlineCode,
  linkReference,
  link,
  listItem,
  list,
  paragraph,
  // @ts-expect-error: root is different, but hard to type.
  root,
  strong,
  table,
  tableCell,
  tableRow,
  text: text$1,
  thematicBreak,
  toml: ignore,
  yaml: ignore,
  definition: ignore,
  footnoteDefinition: ignore
};
function ignore() {
  return void 0;
}
const VOID = -1;
const PRIMITIVE = 0;
const ARRAY = 1;
const OBJECT = 2;
const DATE = 3;
const REGEXP = 4;
const MAP = 5;
const SET = 6;
const ERROR = 7;
const BIGINT = 8;
const env = typeof self === "object" ? self : globalThis;
const deserializer = ($2, _2) => {
  const as2 = (out, index2) => {
    $2.set(index2, out);
    return out;
  };
  const unpair = (index2) => {
    if ($2.has(index2))
      return $2.get(index2);
    const [type2, value] = _2[index2];
    switch (type2) {
      case PRIMITIVE:
      case VOID:
        return as2(value, index2);
      case ARRAY: {
        const arr = as2([], index2);
        for (const index3 of value)
          arr.push(unpair(index3));
        return arr;
      }
      case OBJECT: {
        const object = as2({}, index2);
        for (const [key, index3] of value)
          object[unpair(key)] = unpair(index3);
        return object;
      }
      case DATE:
        return as2(new Date(value), index2);
      case REGEXP: {
        const { source, flags } = value;
        return as2(new RegExp(source, flags), index2);
      }
      case MAP: {
        const map2 = as2(/* @__PURE__ */ new Map(), index2);
        for (const [key, index3] of value)
          map2.set(unpair(key), unpair(index3));
        return map2;
      }
      case SET: {
        const set = as2(/* @__PURE__ */ new Set(), index2);
        for (const index3 of value)
          set.add(unpair(index3));
        return set;
      }
      case ERROR: {
        const { name: name2, message } = value;
        return as2(new env[name2](message), index2);
      }
      case BIGINT:
        return as2(BigInt(value), index2);
      case "BigInt":
        return as2(Object(BigInt(value)), index2);
    }
    return as2(new env[type2](value), index2);
  };
  return unpair;
};
const deserialize = (serialized) => deserializer(/* @__PURE__ */ new Map(), serialized)(0);
const EMPTY = "";
const { toString: toString2 } = {};
const { keys } = Object;
const typeOf = (value) => {
  const type2 = typeof value;
  if (type2 !== "object" || !value)
    return [PRIMITIVE, type2];
  const asString = toString2.call(value).slice(8, -1);
  switch (asString) {
    case "Array":
      return [ARRAY, EMPTY];
    case "Object":
      return [OBJECT, EMPTY];
    case "Date":
      return [DATE, EMPTY];
    case "RegExp":
      return [REGEXP, EMPTY];
    case "Map":
      return [MAP, EMPTY];
    case "Set":
      return [SET, EMPTY];
  }
  if (asString.includes("Array"))
    return [ARRAY, asString];
  if (asString.includes("Error"))
    return [ERROR, asString];
  return [OBJECT, asString];
};
const shouldSkip = ([TYPE2, type2]) => TYPE2 === PRIMITIVE && (type2 === "function" || type2 === "symbol");
const serializer = (strict, json, $2, _2) => {
  const as2 = (out, value) => {
    const index2 = _2.push(out) - 1;
    $2.set(value, index2);
    return index2;
  };
  const pair = (value) => {
    if ($2.has(value))
      return $2.get(value);
    let [TYPE2, type2] = typeOf(value);
    switch (TYPE2) {
      case PRIMITIVE: {
        let entry = value;
        switch (type2) {
          case "bigint":
            TYPE2 = BIGINT;
            entry = value.toString();
            break;
          case "function":
          case "symbol":
            if (strict)
              throw new TypeError("unable to serialize " + type2);
            entry = null;
            break;
          case "undefined":
            return as2([VOID], value);
        }
        return as2([TYPE2, entry], value);
      }
      case ARRAY: {
        if (type2)
          return as2([type2, [...value]], value);
        const arr = [];
        const index2 = as2([TYPE2, arr], value);
        for (const entry of value)
          arr.push(pair(entry));
        return index2;
      }
      case OBJECT: {
        if (type2) {
          switch (type2) {
            case "BigInt":
              return as2([type2, value.toString()], value);
            case "Boolean":
            case "Number":
            case "String":
              return as2([type2, value.valueOf()], value);
          }
        }
        if (json && "toJSON" in value)
          return pair(value.toJSON());
        const entries2 = [];
        const index2 = as2([TYPE2, entries2], value);
        for (const key of keys(value)) {
          if (strict || !shouldSkip(typeOf(value[key])))
            entries2.push([pair(key), pair(value[key])]);
        }
        return index2;
      }
      case DATE:
        return as2([TYPE2, value.toISOString()], value);
      case REGEXP: {
        const { source, flags } = value;
        return as2([TYPE2, { source, flags }], value);
      }
      case MAP: {
        const entries2 = [];
        const index2 = as2([TYPE2, entries2], value);
        for (const [key, entry] of value) {
          if (strict || !(shouldSkip(typeOf(key)) || shouldSkip(typeOf(entry))))
            entries2.push([pair(key), pair(entry)]);
        }
        return index2;
      }
      case SET: {
        const entries2 = [];
        const index2 = as2([TYPE2, entries2], value);
        for (const entry of value) {
          if (strict || !shouldSkip(typeOf(entry)))
            entries2.push(pair(entry));
        }
        return index2;
      }
    }
    const { message } = value;
    return as2([TYPE2, { name: type2, message }], value);
  };
  return pair;
};
const serialize = (value, { json, lossy } = {}) => {
  const _2 = [];
  return serializer(!(json || lossy), !!json, /* @__PURE__ */ new Map(), _2)(value), _2;
};
const structuredClone$1 = typeof structuredClone === "function" ? (
  /* c8 ignore start */
  (any, options) => options && ("json" in options || "lossy" in options) ? deserialize(serialize(any, options)) : structuredClone(any)
) : (any, options) => deserialize(serialize(any, options));
function defaultFootnoteBackContent(_2, rereferenceIndex) {
  const result = [{ type: "text", value: "" }];
  if (rereferenceIndex > 1) {
    result.push({
      type: "element",
      tagName: "sup",
      properties: {},
      children: [{ type: "text", value: String(rereferenceIndex) }]
    });
  }
  return result;
}
function defaultFootnoteBackLabel(referenceIndex, rereferenceIndex) {
  return "Back to reference " + (referenceIndex + 1) + (rereferenceIndex > 1 ? "-" + rereferenceIndex : "");
}
function footer(state) {
  const clobberPrefix = typeof state.options.clobberPrefix === "string" ? state.options.clobberPrefix : "user-content-";
  const footnoteBackContent = state.options.footnoteBackContent || defaultFootnoteBackContent;
  const footnoteBackLabel = state.options.footnoteBackLabel || defaultFootnoteBackLabel;
  const footnoteLabel = state.options.footnoteLabel || "Footnotes";
  const footnoteLabelTagName = state.options.footnoteLabelTagName || "h2";
  const footnoteLabelProperties = state.options.footnoteLabelProperties || {
    className: ["sr-only"]
  };
  const listItems = [];
  let referenceIndex = -1;
  while (++referenceIndex < state.footnoteOrder.length) {
    const definition2 = state.footnoteById.get(
      state.footnoteOrder[referenceIndex]
    );
    if (!definition2) {
      continue;
    }
    const content2 = state.all(definition2);
    const id2 = String(definition2.identifier).toUpperCase();
    const safeId = normalizeUri(id2.toLowerCase());
    let rereferenceIndex = 0;
    const backReferences = [];
    const counts = state.footnoteCounts.get(id2);
    while (counts !== void 0 && ++rereferenceIndex <= counts) {
      if (backReferences.length > 0) {
        backReferences.push({ type: "text", value: " " });
      }
      let children = typeof footnoteBackContent === "string" ? footnoteBackContent : footnoteBackContent(referenceIndex, rereferenceIndex);
      if (typeof children === "string") {
        children = { type: "text", value: children };
      }
      backReferences.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + clobberPrefix + "fnref-" + safeId + (rereferenceIndex > 1 ? "-" + rereferenceIndex : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof footnoteBackLabel === "string" ? footnoteBackLabel : footnoteBackLabel(referenceIndex, rereferenceIndex),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(children) ? children : [children]
      });
    }
    const tail = content2[content2.length - 1];
    if (tail && tail.type === "element" && tail.tagName === "p") {
      const tailTail = tail.children[tail.children.length - 1];
      if (tailTail && tailTail.type === "text") {
        tailTail.value += " ";
      } else {
        tail.children.push({ type: "text", value: " " });
      }
      tail.children.push(...backReferences);
    } else {
      content2.push(...backReferences);
    }
    const listItem2 = {
      type: "element",
      tagName: "li",
      properties: { id: clobberPrefix + "fn-" + safeId },
      children: state.wrap(content2, true)
    };
    state.patch(definition2, listItem2);
    listItems.push(listItem2);
  }
  if (listItems.length === 0) {
    return;
  }
  return {
    type: "element",
    tagName: "section",
    properties: { dataFootnotes: true, className: ["footnotes"] },
    children: [
      {
        type: "element",
        tagName: footnoteLabelTagName,
        properties: {
          ...structuredClone$1(footnoteLabelProperties),
          id: "footnote-label"
        },
        children: [{ type: "text", value: footnoteLabel }]
      },
      { type: "text", value: "\n" },
      {
        type: "element",
        tagName: "ol",
        properties: {},
        children: state.wrap(listItems, true)
      },
      { type: "text", value: "\n" }
    ]
  };
}
const own$1 = {}.hasOwnProperty;
const emptyOptions = {};
function createState(tree, options) {
  const settings = options || emptyOptions;
  const definitionById = /* @__PURE__ */ new Map();
  const footnoteById = /* @__PURE__ */ new Map();
  const footnoteCounts = /* @__PURE__ */ new Map();
  const handlers$1 = { ...handlers, ...settings.handlers };
  const state = {
    all: all3,
    applyData,
    definitionById,
    footnoteById,
    footnoteCounts,
    footnoteOrder: [],
    handlers: handlers$1,
    one: one2,
    options: settings,
    patch,
    wrap: wrap$1
  };
  visit(tree, function(node2) {
    if (node2.type === "definition" || node2.type === "footnoteDefinition") {
      const map2 = node2.type === "definition" ? definitionById : footnoteById;
      const id2 = String(node2.identifier).toUpperCase();
      if (!map2.has(id2)) {
        map2.set(id2, node2);
      }
    }
  });
  return state;
  function one2(node2, parent) {
    const type2 = node2.type;
    const handle2 = state.handlers[type2];
    if (own$1.call(state.handlers, type2) && handle2) {
      return handle2(state, node2, parent);
    }
    if (state.options.passThrough && state.options.passThrough.includes(type2)) {
      if ("children" in node2) {
        const { children, ...shallow } = node2;
        const result = structuredClone$1(shallow);
        result.children = state.all(node2);
        return result;
      }
      return structuredClone$1(node2);
    }
    const unknown = state.options.unknownHandler || defaultUnknownHandler;
    return unknown(state, node2, parent);
  }
  function all3(parent) {
    const values = [];
    if ("children" in parent) {
      const nodes = parent.children;
      let index2 = -1;
      while (++index2 < nodes.length) {
        const result = state.one(nodes[index2], parent);
        if (result) {
          if (index2 && nodes[index2 - 1].type === "break") {
            if (!Array.isArray(result) && result.type === "text") {
              result.value = trimMarkdownSpaceStart(result.value);
            }
            if (!Array.isArray(result) && result.type === "element") {
              const head = result.children[0];
              if (head && head.type === "text") {
                head.value = trimMarkdownSpaceStart(head.value);
              }
            }
          }
          if (Array.isArray(result)) {
            values.push(...result);
          } else {
            values.push(result);
          }
        }
      }
    }
    return values;
  }
}
function patch(from2, to2) {
  if (from2.position) to2.position = position$1(from2);
}
function applyData(from2, to2) {
  let result = to2;
  if (from2 && from2.data) {
    const hName = from2.data.hName;
    const hChildren = from2.data.hChildren;
    const hProperties = from2.data.hProperties;
    if (typeof hName === "string") {
      if (result.type === "element") {
        result.tagName = hName;
      } else {
        const children = "children" in result ? result.children : [result];
        result = { type: "element", tagName: hName, properties: {}, children };
      }
    }
    if (result.type === "element" && hProperties) {
      Object.assign(result.properties, structuredClone$1(hProperties));
    }
    if ("children" in result && result.children && hChildren !== null && hChildren !== void 0) {
      result.children = hChildren;
    }
  }
  return result;
}
function defaultUnknownHandler(state, node2) {
  const data = node2.data || {};
  const result = "value" in node2 && !(own$1.call(data, "hProperties") || own$1.call(data, "hChildren")) ? { type: "text", value: node2.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function wrap$1(nodes, loose) {
  const result = [];
  let index2 = -1;
  if (loose) {
    result.push({ type: "text", value: "\n" });
  }
  while (++index2 < nodes.length) {
    if (index2) result.push({ type: "text", value: "\n" });
    result.push(nodes[index2]);
  }
  if (loose && nodes.length > 0) {
    result.push({ type: "text", value: "\n" });
  }
  return result;
}
function trimMarkdownSpaceStart(value) {
  let index2 = 0;
  let code2 = value.charCodeAt(index2);
  while (code2 === 9 || code2 === 32) {
    index2++;
    code2 = value.charCodeAt(index2);
  }
  return value.slice(index2);
}
function toHast(tree, options) {
  const state = createState(tree, options);
  const node2 = state.one(tree, void 0);
  const foot = footer(state);
  const result = Array.isArray(node2) ? { type: "root", children: node2 } : node2 || { type: "root", children: [] };
  if (foot) {
    result.children.push({ type: "text", value: "\n" }, foot);
  }
  return result;
}
function remarkRehype(destination, options) {
  if (destination && "run" in destination) {
    return async function(tree, file) {
      const hastTree = (
        /** @type {HastRoot} */
        toHast(tree, { file, ...options })
      );
      await destination.run(hastTree, file);
    };
  }
  return function(tree, file) {
    return (
      /** @type {HastRoot} */
      toHast(tree, { file, ...destination || options })
    );
  };
}
function bail(error2) {
  if (error2) {
    throw error2;
  }
}
var hasOwn = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var defineProperty = Object.defineProperty;
var gOPD = Object.getOwnPropertyDescriptor;
var isArray = function isArray2(arr) {
  if (typeof Array.isArray === "function") {
    return Array.isArray(arr);
  }
  return toStr.call(arr) === "[object Array]";
};
var isPlainObject$1 = function isPlainObject(obj) {
  if (!obj || toStr.call(obj) !== "[object Object]") {
    return false;
  }
  var hasOwnConstructor = hasOwn.call(obj, "constructor");
  var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
  if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
    return false;
  }
  var key;
  for (key in obj) {
  }
  return typeof key === "undefined" || hasOwn.call(obj, key);
};
var setProperty = function setProperty2(target, options) {
  if (defineProperty && options.name === "__proto__") {
    defineProperty(target, options.name, {
      enumerable: true,
      configurable: true,
      value: options.newValue,
      writable: true
    });
  } else {
    target[options.name] = options.newValue;
  }
};
var getProperty = function getProperty2(obj, name2) {
  if (name2 === "__proto__") {
    if (!hasOwn.call(obj, name2)) {
      return void 0;
    } else if (gOPD) {
      return gOPD(obj, name2).value;
    }
  }
  return obj[name2];
};
var extend = function extend2() {
  var options, name2, src, copy2, copyIsArray, clone2;
  var target = arguments[0];
  var i = 1;
  var length2 = arguments.length;
  var deep = false;
  if (typeof target === "boolean") {
    deep = target;
    target = arguments[1] || {};
    i = 2;
  }
  if (target == null || typeof target !== "object" && typeof target !== "function") {
    target = {};
  }
  for (; i < length2; ++i) {
    options = arguments[i];
    if (options != null) {
      for (name2 in options) {
        src = getProperty(target, name2);
        copy2 = getProperty(options, name2);
        if (target !== copy2) {
          if (deep && copy2 && (isPlainObject$1(copy2) || (copyIsArray = isArray(copy2)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone2 = src && isArray(src) ? src : [];
            } else {
              clone2 = src && isPlainObject$1(src) ? src : {};
            }
            setProperty(target, { name: name2, newValue: extend2(deep, clone2, copy2) });
          } else if (typeof copy2 !== "undefined") {
            setProperty(target, { name: name2, newValue: copy2 });
          }
        }
      }
    }
  }
  return target;
};
const extend$1 = /* @__PURE__ */ getDefaultExportFromCjs(extend);
function isPlainObject2(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype2 = Object.getPrototypeOf(value);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}
function trough() {
  const fns = [];
  const pipeline = { run, use };
  return pipeline;
  function run(...values) {
    let middlewareIndex = -1;
    const callback = values.pop();
    if (typeof callback !== "function") {
      throw new TypeError("Expected function as last argument, not " + callback);
    }
    next2(null, ...values);
    function next2(error2, ...output) {
      const fn2 = fns[++middlewareIndex];
      let index2 = -1;
      if (error2) {
        callback(error2);
        return;
      }
      while (++index2 < values.length) {
        if (output[index2] === null || output[index2] === void 0) {
          output[index2] = values[index2];
        }
      }
      values = output;
      if (fn2) {
        wrap(fn2, next2)(...output);
      } else {
        callback(null, ...output);
      }
    }
  }
  function use(middelware) {
    if (typeof middelware !== "function") {
      throw new TypeError(
        "Expected `middelware` to be a function, not " + middelware
      );
    }
    fns.push(middelware);
    return pipeline;
  }
}
function wrap(middleware2, callback) {
  let called;
  return wrapped;
  function wrapped(...parameters) {
    const fnExpectsCallback = middleware2.length > parameters.length;
    let result;
    if (fnExpectsCallback) {
      parameters.push(done);
    }
    try {
      result = middleware2.apply(this, parameters);
    } catch (error2) {
      const exception = (
        /** @type {Error} */
        error2
      );
      if (fnExpectsCallback && called) {
        throw exception;
      }
      return done(exception);
    }
    if (!fnExpectsCallback) {
      if (result && result.then && typeof result.then === "function") {
        result.then(then, done);
      } else if (result instanceof Error) {
        done(result);
      } else {
        then(result);
      }
    }
  }
  function done(error2, ...output) {
    if (!called) {
      called = true;
      callback(error2, ...output);
    }
  }
  function then(value) {
    done(null, value);
  }
}
const minpath = { basename, dirname, extname, join, sep: "/" };
function basename(path2, extname2) {
  if (extname2 !== void 0 && typeof extname2 !== "string") {
    throw new TypeError('"ext" argument must be a string');
  }
  assertPath$1(path2);
  let start2 = 0;
  let end = -1;
  let index2 = path2.length;
  let seenNonSlash;
  if (extname2 === void 0 || extname2.length === 0 || extname2.length > path2.length) {
    while (index2--) {
      if (path2.codePointAt(index2) === 47) {
        if (seenNonSlash) {
          start2 = index2 + 1;
          break;
        }
      } else if (end < 0) {
        seenNonSlash = true;
        end = index2 + 1;
      }
    }
    return end < 0 ? "" : path2.slice(start2, end);
  }
  if (extname2 === path2) {
    return "";
  }
  let firstNonSlashEnd = -1;
  let extnameIndex = extname2.length - 1;
  while (index2--) {
    if (path2.codePointAt(index2) === 47) {
      if (seenNonSlash) {
        start2 = index2 + 1;
        break;
      }
    } else {
      if (firstNonSlashEnd < 0) {
        seenNonSlash = true;
        firstNonSlashEnd = index2 + 1;
      }
      if (extnameIndex > -1) {
        if (path2.codePointAt(index2) === extname2.codePointAt(extnameIndex--)) {
          if (extnameIndex < 0) {
            end = index2;
          }
        } else {
          extnameIndex = -1;
          end = firstNonSlashEnd;
        }
      }
    }
  }
  if (start2 === end) {
    end = firstNonSlashEnd;
  } else if (end < 0) {
    end = path2.length;
  }
  return path2.slice(start2, end);
}
function dirname(path2) {
  assertPath$1(path2);
  if (path2.length === 0) {
    return ".";
  }
  let end = -1;
  let index2 = path2.length;
  let unmatchedSlash;
  while (--index2) {
    if (path2.codePointAt(index2) === 47) {
      if (unmatchedSlash) {
        end = index2;
        break;
      }
    } else if (!unmatchedSlash) {
      unmatchedSlash = true;
    }
  }
  return end < 0 ? path2.codePointAt(0) === 47 ? "/" : "." : end === 1 && path2.codePointAt(0) === 47 ? "//" : path2.slice(0, end);
}
function extname(path2) {
  assertPath$1(path2);
  let index2 = path2.length;
  let end = -1;
  let startPart = 0;
  let startDot = -1;
  let preDotState = 0;
  let unmatchedSlash;
  while (index2--) {
    const code2 = path2.codePointAt(index2);
    if (code2 === 47) {
      if (unmatchedSlash) {
        startPart = index2 + 1;
        break;
      }
      continue;
    }
    if (end < 0) {
      unmatchedSlash = true;
      end = index2 + 1;
    }
    if (code2 === 46) {
      if (startDot < 0) {
        startDot = index2;
      } else if (preDotState !== 1) {
        preDotState = 1;
      }
    } else if (startDot > -1) {
      preDotState = -1;
    }
  }
  if (startDot < 0 || end < 0 || // We saw a non-dot character immediately before the dot.
  preDotState === 0 || // The (right-most) trimmed path component is exactly `..`.
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path2.slice(startDot, end);
}
function join(...segments) {
  let index2 = -1;
  let joined;
  while (++index2 < segments.length) {
    assertPath$1(segments[index2]);
    if (segments[index2]) {
      joined = joined === void 0 ? segments[index2] : joined + "/" + segments[index2];
    }
  }
  return joined === void 0 ? "." : normalize(joined);
}
function normalize(path2) {
  assertPath$1(path2);
  const absolute = path2.codePointAt(0) === 47;
  let value = normalizeString(path2, !absolute);
  if (value.length === 0 && !absolute) {
    value = ".";
  }
  if (value.length > 0 && path2.codePointAt(path2.length - 1) === 47) {
    value += "/";
  }
  return absolute ? "/" + value : value;
}
function normalizeString(path2, allowAboveRoot) {
  let result = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let index2 = -1;
  let code2;
  let lastSlashIndex;
  while (++index2 <= path2.length) {
    if (index2 < path2.length) {
      code2 = path2.codePointAt(index2);
    } else if (code2 === 47) {
      break;
    } else {
      code2 = 47;
    }
    if (code2 === 47) {
      if (lastSlash === index2 - 1 || dots === 1) ;
      else if (lastSlash !== index2 - 1 && dots === 2) {
        if (result.length < 2 || lastSegmentLength !== 2 || result.codePointAt(result.length - 1) !== 46 || result.codePointAt(result.length - 2) !== 46) {
          if (result.length > 2) {
            lastSlashIndex = result.lastIndexOf("/");
            if (lastSlashIndex !== result.length - 1) {
              if (lastSlashIndex < 0) {
                result = "";
                lastSegmentLength = 0;
              } else {
                result = result.slice(0, lastSlashIndex);
                lastSegmentLength = result.length - 1 - result.lastIndexOf("/");
              }
              lastSlash = index2;
              dots = 0;
              continue;
            }
          } else if (result.length > 0) {
            result = "";
            lastSegmentLength = 0;
            lastSlash = index2;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          result = result.length > 0 ? result + "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (result.length > 0) {
          result += "/" + path2.slice(lastSlash + 1, index2);
        } else {
          result = path2.slice(lastSlash + 1, index2);
        }
        lastSegmentLength = index2 - lastSlash - 1;
      }
      lastSlash = index2;
      dots = 0;
    } else if (code2 === 46 && dots > -1) {
      dots++;
    } else {
      dots = -1;
    }
  }
  return result;
}
function assertPath$1(path2) {
  if (typeof path2 !== "string") {
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(path2)
    );
  }
}
const minproc = { cwd };
function cwd() {
  return "/";
}
function isUrl(fileUrlOrPath) {
  return Boolean(
    fileUrlOrPath !== null && typeof fileUrlOrPath === "object" && "href" in fileUrlOrPath && fileUrlOrPath.href && "protocol" in fileUrlOrPath && fileUrlOrPath.protocol && // @ts-expect-error: indexing is fine.
    fileUrlOrPath.auth === void 0
  );
}
function urlToPath(path2) {
  if (typeof path2 === "string") {
    path2 = new URL(path2);
  } else if (!isUrl(path2)) {
    const error2 = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + path2 + "`"
    );
    error2.code = "ERR_INVALID_ARG_TYPE";
    throw error2;
  }
  if (path2.protocol !== "file:") {
    const error2 = new TypeError("The URL must be of scheme file");
    error2.code = "ERR_INVALID_URL_SCHEME";
    throw error2;
  }
  return getPathFromURLPosix(path2);
}
function getPathFromURLPosix(url) {
  if (url.hostname !== "") {
    const error2 = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    error2.code = "ERR_INVALID_FILE_URL_HOST";
    throw error2;
  }
  const pathname = url.pathname;
  let index2 = -1;
  while (++index2 < pathname.length) {
    if (pathname.codePointAt(index2) === 37 && pathname.codePointAt(index2 + 1) === 50) {
      const third = pathname.codePointAt(index2 + 2);
      if (third === 70 || third === 102) {
        const error2 = new TypeError(
          "File URL path must not include encoded / characters"
        );
        error2.code = "ERR_INVALID_FILE_URL_PATH";
        throw error2;
      }
    }
  }
  return decodeURIComponent(pathname);
}
const order = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class VFile {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array`  `{value: options}`
   * *   `URL`  `{path: options}`
   * *   `VFile`  shallow copies its data over to the new file
   * *   `object`  all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(value) {
    let options;
    if (!value) {
      options = {};
    } else if (isUrl(value)) {
      options = { path: value };
    } else if (typeof value === "string" || isUint8Array$1(value)) {
      options = { value };
    } else {
      options = value;
    }
    this.cwd = "cwd" in options ? "" : minproc.cwd();
    this.data = {};
    this.history = [];
    this.messages = [];
    this.value;
    this.map;
    this.result;
    this.stored;
    let index2 = -1;
    while (++index2 < order.length) {
      const field2 = order[index2];
      if (field2 in options && options[field2] !== void 0 && options[field2] !== null) {
        this[field2] = field2 === "history" ? [...options[field2]] : options[field2];
      }
    }
    let field;
    for (field in options) {
      if (!order.includes(field)) {
        this[field] = options[field];
      }
    }
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path === "string" ? minpath.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(basename2) {
    assertNonEmpty(basename2, "basename");
    assertPart(basename2, "basename");
    this.path = minpath.join(this.dirname || "", basename2);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path === "string" ? minpath.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(dirname2) {
    assertPath(this.basename, "dirname");
    this.path = minpath.join(dirname2 || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path === "string" ? minpath.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(extname2) {
    assertPart(extname2, "extname");
    assertPath(this.dirname, "extname");
    if (extname2) {
      if (extname2.codePointAt(0) !== 46) {
        throw new Error("`extname` must start with `.`");
      }
      if (extname2.includes(".", 1)) {
        throw new Error("`extname` cannot contain multiple dots");
      }
    }
    this.path = minpath.join(this.dirname, this.stem + (extname2 || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(path2) {
    if (isUrl(path2)) {
      path2 = urlToPath(path2);
    }
    assertNonEmpty(path2, "path");
    if (this.path !== path2) {
      this.history.push(path2);
    }
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path === "string" ? minpath.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(stem) {
    assertNonEmpty(stem, "stem");
    assertPart(stem, "stem");
    this.path = minpath.join(this.dirname || "", stem + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(causeOrReason, optionsOrParentOrPlace, origin2) {
    const message = this.message(causeOrReason, optionsOrParentOrPlace, origin2);
    message.fatal = true;
    throw message;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(causeOrReason, optionsOrParentOrPlace, origin2) {
    const message = this.message(causeOrReason, optionsOrParentOrPlace, origin2);
    message.fatal = void 0;
    return message;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(causeOrReason, optionsOrParentOrPlace, origin2) {
    const message = new VFileMessage(
      // @ts-expect-error: the overloads are fine.
      causeOrReason,
      optionsOrParentOrPlace,
      origin2
    );
    if (this.path) {
      message.name = this.path + ":" + message.name;
      message.file = this.path;
    }
    message.fatal = false;
    this.messages.push(message);
    return message;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when its a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(encoding) {
    if (this.value === void 0) {
      return "";
    }
    if (typeof this.value === "string") {
      return this.value;
    }
    const decoder = new TextDecoder(encoding || void 0);
    return decoder.decode(this.value);
  }
}
function assertPart(part, name2) {
  if (part && part.includes(minpath.sep)) {
    throw new Error(
      "`" + name2 + "` cannot be a path: did not expect `" + minpath.sep + "`"
    );
  }
}
function assertNonEmpty(part, name2) {
  if (!part) {
    throw new Error("`" + name2 + "` cannot be empty");
  }
}
function assertPath(path2, name2) {
  if (!path2) {
    throw new Error("Setting `" + name2 + "` requires `path` to be set too");
  }
}
function isUint8Array$1(value) {
  return Boolean(
    value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
  );
}
const CallableInstance = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  function(property2) {
    const self2 = this;
    const constr = self2.constructor;
    const proto = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      constr.prototype
    );
    const value = proto[property2];
    const apply2 = function() {
      return value.apply(apply2, arguments);
    };
    Object.setPrototypeOf(apply2, proto);
    return apply2;
  }
);
const own = {}.hasOwnProperty;
class Processor extends CallableInstance {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy");
    this.Compiler = void 0;
    this.Parser = void 0;
    this.attachers = [];
    this.compiler = void 0;
    this.freezeIndex = -1;
    this.frozen = void 0;
    this.namespace = {};
    this.parser = void 0;
    this.transformers = trough();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@linkcode Processor}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const destination = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new Processor()
    );
    let index2 = -1;
    while (++index2 < this.attachers.length) {
      const attacher = this.attachers[index2];
      destination.use(...attacher);
    }
    destination.data(extend$1(true, {}, this.namespace));
    return destination;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > **Note**: to register custom data in TypeScript, augment the
   * > {@linkcode Data} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(key, value) {
    if (typeof key === "string") {
      if (arguments.length === 2) {
        assertUnfrozen("data", this.frozen);
        this.namespace[key] = value;
        return this;
      }
      return own.call(this.namespace, key) && this.namespace[key] || void 0;
    }
    if (key) {
      assertUnfrozen("data", this.frozen);
      this.namespace = key;
      return this;
    }
    return this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * Its possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen) {
      return this;
    }
    const self2 = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    while (++this.freezeIndex < this.attachers.length) {
      const [attacher, ...options] = this.attachers[this.freezeIndex];
      if (options[0] === false) {
        continue;
      }
      if (options[0] === true) {
        options[0] = void 0;
      }
      const transformer = attacher.call(self2, ...options);
      if (typeof transformer === "function") {
        this.transformers.use(transformer);
      }
    }
    this.frozen = true;
    this.freezeIndex = Number.POSITIVE_INFINITY;
    return this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(file) {
    this.freeze();
    const realFile = vfile(file);
    const parser = this.parser || this.Parser;
    assertParser("parse", parser);
    return parser(String(realFile), realFile);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(file, done) {
    const self2 = this;
    this.freeze();
    assertParser("process", this.parser || this.Parser);
    assertCompiler("process", this.compiler || this.Compiler);
    return done ? executor(void 0, done) : new Promise(executor);
    function executor(resolve2, reject) {
      const realFile = vfile(file);
      const parseTree = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        self2.parse(realFile)
      );
      self2.run(parseTree, realFile, function(error2, tree, file2) {
        if (error2 || !tree || !file2) {
          return realDone(error2);
        }
        const compileTree = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          tree
        );
        const compileResult = self2.stringify(compileTree, file2);
        if (looksLikeAValue(compileResult)) {
          file2.value = compileResult;
        } else {
          file2.result = compileResult;
        }
        realDone(
          error2,
          /** @type {VFileWithOutput<CompileResult>} */
          file2
        );
      });
      function realDone(error2, file2) {
        if (error2 || !file2) {
          reject(error2);
        } else if (resolve2) {
          resolve2(file2);
        } else {
          done(void 0, file2);
        }
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(file) {
    let complete = false;
    let result;
    this.freeze();
    assertParser("processSync", this.parser || this.Parser);
    assertCompiler("processSync", this.compiler || this.Compiler);
    this.process(file, realDone);
    assertDone("processSync", "process", complete);
    return result;
    function realDone(error2, file2) {
      complete = true;
      bail(error2);
      result = file2;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(tree, file, done) {
    assertNode(tree);
    this.freeze();
    const transformers = this.transformers;
    if (!done && typeof file === "function") {
      done = file;
      file = void 0;
    }
    return done ? executor(void 0, done) : new Promise(executor);
    function executor(resolve2, reject) {
      const realFile = vfile(file);
      transformers.run(tree, realFile, realDone);
      function realDone(error2, outputTree, file2) {
        const resultingTree = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          outputTree || tree
        );
        if (error2) {
          reject(error2);
        } else if (resolve2) {
          resolve2(resultingTree);
        } else {
          done(void 0, resultingTree, file2);
        }
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(tree, file) {
    let complete = false;
    let result;
    this.run(tree, file, realDone);
    assertDone("runSync", "run", complete);
    return result;
    function realDone(error2, tree2) {
      bail(error2);
      result = tree2;
      complete = true;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(tree, file) {
    this.freeze();
    const realFile = vfile(file);
    const compiler2 = this.compiler || this.Compiler;
    assertCompiler("stringify", compiler2);
    assertNode(tree);
    return compiler2(tree, realFile);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(value, ...parameters) {
    const attachers = this.attachers;
    const namespace = this.namespace;
    assertUnfrozen("use", this.frozen);
    if (value === null || value === void 0) ;
    else if (typeof value === "function") {
      addPlugin(value, parameters);
    } else if (typeof value === "object") {
      if (Array.isArray(value)) {
        addList(value);
      } else {
        addPreset(value);
      }
    } else {
      throw new TypeError("Expected usable value, not `" + value + "`");
    }
    return this;
    function add(value2) {
      if (typeof value2 === "function") {
        addPlugin(value2, []);
      } else if (typeof value2 === "object") {
        if (Array.isArray(value2)) {
          const [plugin, ...parameters2] = (
            /** @type {PluginTuple<Array<unknown>>} */
            value2
          );
          addPlugin(plugin, parameters2);
        } else {
          addPreset(value2);
        }
      } else {
        throw new TypeError("Expected usable value, not `" + value2 + "`");
      }
    }
    function addPreset(result) {
      if (!("plugins" in result) && !("settings" in result)) {
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      }
      addList(result.plugins);
      if (result.settings) {
        namespace.settings = extend$1(true, namespace.settings, result.settings);
      }
    }
    function addList(plugins) {
      let index2 = -1;
      if (plugins === null || plugins === void 0) ;
      else if (Array.isArray(plugins)) {
        while (++index2 < plugins.length) {
          const thing = plugins[index2];
          add(thing);
        }
      } else {
        throw new TypeError("Expected a list of plugins, not `" + plugins + "`");
      }
    }
    function addPlugin(plugin, parameters2) {
      let index2 = -1;
      let entryIndex = -1;
      while (++index2 < attachers.length) {
        if (attachers[index2][0] === plugin) {
          entryIndex = index2;
          break;
        }
      }
      if (entryIndex === -1) {
        attachers.push([plugin, ...parameters2]);
      } else if (parameters2.length > 0) {
        let [primary, ...rest] = parameters2;
        const currentPrimary = attachers[entryIndex][1];
        if (isPlainObject2(currentPrimary) && isPlainObject2(primary)) {
          primary = extend$1(true, currentPrimary, primary);
        }
        attachers[entryIndex] = [plugin, primary, ...rest];
      }
    }
  }
}
const unified = new Processor().freeze();
function assertParser(name2, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name2 + "` without `parser`");
  }
}
function assertCompiler(name2, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name2 + "` without `compiler`");
  }
}
function assertUnfrozen(name2, frozen) {
  if (frozen) {
    throw new Error(
      "Cannot call `" + name2 + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
  }
}
function assertNode(node2) {
  if (!isPlainObject2(node2) || typeof node2.type !== "string") {
    throw new TypeError("Expected node, got `" + node2 + "`");
  }
}
function assertDone(name2, asyncName, complete) {
  if (!complete) {
    throw new Error(
      "`" + name2 + "` finished async. Use `" + asyncName + "` instead"
    );
  }
}
function vfile(value) {
  return looksLikeAVFile(value) ? value : new VFile(value);
}
function looksLikeAVFile(value) {
  return Boolean(
    value && typeof value === "object" && "message" in value && "messages" in value
  );
}
function looksLikeAValue(value) {
  return typeof value === "string" || isUint8Array(value);
}
function isUint8Array(value) {
  return Boolean(
    value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
  );
}
const changelog = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md";
const emptyPlugins = [];
const emptyRemarkRehypeOptions = { allowDangerousHtml: true };
const safeProtocol = /^(https?|ircs?|mailto|xmpp)$/i;
const deprecations = [
  { from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
  { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" },
  {
    from: "allowNode",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowElement"
  },
  {
    from: "allowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowedElements"
  },
  {
    from: "disallowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "disallowedElements"
  },
  { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
  { from: "includeElementIndex", id: "#remove-includeelementindex" },
  {
    from: "includeNodeIndex",
    id: "change-includenodeindex-to-includeelementindex"
  },
  { from: "linkTarget", id: "remove-linktarget" },
  { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" },
  { from: "rawSourcePos", id: "#remove-rawsourcepos" },
  { from: "renderers", id: "change-renderers-to-components", to: "components" },
  { from: "source", id: "change-source-to-children", to: "children" },
  { from: "sourcePos", id: "#remove-sourcepos" },
  { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" },
  { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }
];
function Markdown(options) {
  const allowedElements = options.allowedElements;
  const allowElement = options.allowElement;
  const children = options.children || "";
  const className = options.className;
  const components = options.components;
  const disallowedElements = options.disallowedElements;
  const rehypePlugins = options.rehypePlugins || emptyPlugins;
  const remarkPlugins = options.remarkPlugins || emptyPlugins;
  const remarkRehypeOptions = options.remarkRehypeOptions ? { ...options.remarkRehypeOptions, ...emptyRemarkRehypeOptions } : emptyRemarkRehypeOptions;
  const skipHtml = options.skipHtml;
  const unwrapDisallowed = options.unwrapDisallowed;
  const urlTransform = options.urlTransform || defaultUrlTransform;
  const processor = unified().use(remarkParse).use(remarkPlugins).use(remarkRehype, remarkRehypeOptions).use(rehypePlugins);
  const file = new VFile();
  if (typeof children === "string") {
    file.value = children;
  }
  for (const deprecation of deprecations) {
    if (Object.hasOwn(options, deprecation.from)) {
      unreachable(
        "Unexpected `" + deprecation.from + "` prop, " + (deprecation.to ? "use `" + deprecation.to + "` instead" : "remove it") + " (see <" + changelog + "#" + deprecation.id + "> for more info)"
      );
    }
  }
  const mdastTree = processor.parse(file);
  let hastTree = processor.runSync(mdastTree, file);
  if (className) {
    hastTree = {
      type: "element",
      tagName: "div",
      properties: { className },
      // Assume no doctypes.
      children: (
        /** @type {Array<ElementContent>} */
        hastTree.type === "root" ? hastTree.children : [hastTree]
      )
    };
  }
  visit(hastTree, transform);
  return toJsxRuntime(hastTree, {
    Fragment: g$3,
    components,
    ignoreInvalidStyle: true,
    jsx: u$2,
    jsxs: u$2,
    passKeys: true,
    passNode: true
  });
  function transform(node2, index2, parent) {
    if (node2.type === "raw" && parent && typeof index2 === "number") {
      if (skipHtml) {
        parent.children.splice(index2, 1);
      } else {
        parent.children[index2] = { type: "text", value: node2.value };
      }
      return index2;
    }
    if (node2.type === "element") {
      let key;
      for (key in urlAttributes) {
        if (Object.hasOwn(urlAttributes, key) && Object.hasOwn(node2.properties, key)) {
          const value = node2.properties[key];
          const test2 = urlAttributes[key];
          if (test2 === null || test2.includes(node2.tagName)) {
            node2.properties[key] = urlTransform(String(value || ""), key, node2);
          }
        }
      }
    }
    if (node2.type === "element") {
      let remove = allowedElements ? !allowedElements.includes(node2.tagName) : disallowedElements ? disallowedElements.includes(node2.tagName) : false;
      if (!remove && allowElement && typeof index2 === "number") {
        remove = !allowElement(node2, index2, parent);
      }
      if (remove && parent && typeof index2 === "number") {
        if (unwrapDisallowed && node2.children) {
          parent.children.splice(index2, 1, ...node2.children);
        } else {
          parent.children.splice(index2, 1);
        }
        return index2;
      }
    }
  }
}
function defaultUrlTransform(value) {
  const colon = value.indexOf(":");
  const questionMark = value.indexOf("?");
  const numberSign = value.indexOf("#");
  const slash = value.indexOf("/");
  if (
    // If there is no protocol, its relative.
    colon < 0 || // If the first colon is after a `?`, `#`, or `/`, its not a protocol.
    slash > -1 && colon > slash || questionMark > -1 && colon > questionMark || numberSign > -1 && colon > numberSign || // It is a protocol, it should be allowed.
    safeProtocol.test(value.slice(0, colon))
  ) {
    return value;
  }
  return "";
}
var updateQueue = makeQueue();
var raf = (fn2) => schedule(fn2, updateQueue);
var writeQueue = makeQueue();
raf.write = (fn2) => schedule(fn2, writeQueue);
var onStartQueue = makeQueue();
raf.onStart = (fn2) => schedule(fn2, onStartQueue);
var onFrameQueue = makeQueue();
raf.onFrame = (fn2) => schedule(fn2, onFrameQueue);
var onFinishQueue = makeQueue();
raf.onFinish = (fn2) => schedule(fn2, onFinishQueue);
var timeouts = [];
raf.setTimeout = (handler, ms2) => {
  const time = raf.now() + ms2;
  const cancel = () => {
    const i = timeouts.findIndex((t2) => t2.cancel == cancel);
    if (~i)
      timeouts.splice(i, 1);
    pendingCount -= ~i ? 1 : 0;
  };
  const timeout = { time, handler, cancel };
  timeouts.splice(findTimeout(time), 0, timeout);
  pendingCount += 1;
  start();
  return timeout;
};
var findTimeout = (time) => ~(~timeouts.findIndex((t2) => t2.time > time) || ~timeouts.length);
raf.cancel = (fn2) => {
  onStartQueue.delete(fn2);
  onFrameQueue.delete(fn2);
  onFinishQueue.delete(fn2);
  updateQueue.delete(fn2);
  writeQueue.delete(fn2);
};
raf.sync = (fn2) => {
  sync = true;
  raf.batchedUpdates(fn2);
  sync = false;
};
raf.throttle = (fn2) => {
  let lastArgs;
  function queuedFn() {
    try {
      fn2(...lastArgs);
    } finally {
      lastArgs = null;
    }
  }
  function throttled(...args) {
    lastArgs = args;
    raf.onStart(queuedFn);
  }
  throttled.handler = fn2;
  throttled.cancel = () => {
    onStartQueue.delete(queuedFn);
    lastArgs = null;
  };
  return throttled;
};
var nativeRaf = typeof window != "undefined" ? window.requestAnimationFrame : (
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  () => {
  }
);
raf.use = (impl) => nativeRaf = impl;
raf.now = typeof performance != "undefined" ? () => performance.now() : Date.now;
raf.batchedUpdates = (fn2) => fn2();
raf.catch = console.error;
raf.frameLoop = "always";
raf.advance = () => {
  if (raf.frameLoop !== "demand") {
    console.warn(
      "Cannot call the manual advancement of rafz whilst frameLoop is not set as demand"
    );
  } else {
    update();
  }
};
var ts = -1;
var pendingCount = 0;
var sync = false;
function schedule(fn2, queue) {
  if (sync) {
    queue.delete(fn2);
    fn2(0);
  } else {
    queue.add(fn2);
    start();
  }
}
function start() {
  if (ts < 0) {
    ts = 0;
    if (raf.frameLoop !== "demand") {
      nativeRaf(loop);
    }
  }
}
function stop() {
  ts = -1;
}
function loop() {
  if (~ts) {
    nativeRaf(loop);
    raf.batchedUpdates(update);
  }
}
function update() {
  const prevTs = ts;
  ts = raf.now();
  const count = findTimeout(ts);
  if (count) {
    eachSafely(timeouts.splice(0, count), (t2) => t2.handler());
    pendingCount -= count;
  }
  if (!pendingCount) {
    stop();
    return;
  }
  onStartQueue.flush();
  updateQueue.flush(prevTs ? Math.min(64, ts - prevTs) : 16.667);
  onFrameQueue.flush();
  writeQueue.flush();
  onFinishQueue.flush();
}
function makeQueue() {
  let next2 = /* @__PURE__ */ new Set();
  let current = next2;
  return {
    add(fn2) {
      pendingCount += current == next2 && !next2.has(fn2) ? 1 : 0;
      next2.add(fn2);
    },
    delete(fn2) {
      pendingCount -= current == next2 && next2.has(fn2) ? 1 : 0;
      return next2.delete(fn2);
    },
    flush(arg) {
      if (current.size) {
        next2 = /* @__PURE__ */ new Set();
        pendingCount -= current.size;
        eachSafely(current, (fn2) => fn2(arg) && next2.add(fn2));
        pendingCount += next2.size;
        current = next2;
      }
    }
  };
}
function eachSafely(values, each2) {
  values.forEach((value) => {
    try {
      each2(value);
    } catch (e2) {
      raf.catch(e2);
    }
  });
}
var __defProp2 = Object.defineProperty;
var __export = (target, all3) => {
  for (var name2 in all3)
    __defProp2(target, name2, { get: all3[name2], enumerable: true });
};
var globals_exports = {};
__export(globals_exports, {
  assign: () => assign,
  colors: () => colors,
  createStringInterpolator: () => createStringInterpolator,
  skipAnimation: () => skipAnimation,
  to: () => to,
  willAdvance: () => willAdvance
});
function noop() {
}
var defineHidden = (obj, key, value) => Object.defineProperty(obj, key, { value, writable: true, configurable: true });
var is = {
  arr: Array.isArray,
  obj: (a2) => !!a2 && a2.constructor.name === "Object",
  fun: (a2) => typeof a2 === "function",
  str: (a2) => typeof a2 === "string",
  num: (a2) => typeof a2 === "number",
  und: (a2) => a2 === void 0
};
function isEqual(a2, b2) {
  if (is.arr(a2)) {
    if (!is.arr(b2) || a2.length !== b2.length)
      return false;
    for (let i = 0; i < a2.length; i++) {
      if (a2[i] !== b2[i])
        return false;
    }
    return true;
  }
  return a2 === b2;
}
var each = (obj, fn2) => obj.forEach(fn2);
function eachProp(obj, fn2, ctx2) {
  if (is.arr(obj)) {
    for (let i = 0; i < obj.length; i++) {
      fn2.call(ctx2, obj[i], `${i}`);
    }
    return;
  }
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      fn2.call(ctx2, obj[key], key);
    }
  }
}
var toArray = (a2) => is.und(a2) ? [] : is.arr(a2) ? a2 : [a2];
function flush(queue, iterator) {
  if (queue.size) {
    const items2 = Array.from(queue);
    queue.clear();
    each(items2, iterator);
  }
}
var flushCalls = (queue, ...args) => flush(queue, (fn2) => fn2(...args));
var isSSR = () => typeof window === "undefined" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent);
var createStringInterpolator;
var to;
var colors = null;
var skipAnimation = false;
var willAdvance = noop;
var assign = (globals) => {
  if (globals.to)
    to = globals.to;
  if (globals.now)
    raf.now = globals.now;
  if (globals.colors !== void 0)
    colors = globals.colors;
  if (globals.skipAnimation != null)
    skipAnimation = globals.skipAnimation;
  if (globals.createStringInterpolator)
    createStringInterpolator = globals.createStringInterpolator;
  if (globals.requestAnimationFrame)
    raf.use(globals.requestAnimationFrame);
  if (globals.batchedUpdates)
    raf.batchedUpdates = globals.batchedUpdates;
  if (globals.willAdvance)
    willAdvance = globals.willAdvance;
  if (globals.frameLoop)
    raf.frameLoop = globals.frameLoop;
};
var startQueue = /* @__PURE__ */ new Set();
var currentFrame = [];
var prevFrame = [];
var priority = 0;
var frameLoop = {
  get idle() {
    return !startQueue.size && !currentFrame.length;
  },
  /** Advance the given animation on every frame until idle. */
  start(animation) {
    if (priority > animation.priority) {
      startQueue.add(animation);
      raf.onStart(flushStartQueue);
    } else {
      startSafely(animation);
      raf(advance);
    }
  },
  /** Advance all animations by the given time. */
  advance,
  /** Call this when an animation's priority changes. */
  sort(animation) {
    if (priority) {
      raf.onFrame(() => frameLoop.sort(animation));
    } else {
      const prevIndex = currentFrame.indexOf(animation);
      if (~prevIndex) {
        currentFrame.splice(prevIndex, 1);
        startUnsafely(animation);
      }
    }
  },
  /**
   * Clear all animations. For testing purposes.
   *
   *  Never call this from within the frameloop.
   */
  clear() {
    currentFrame = [];
    startQueue.clear();
  }
};
function flushStartQueue() {
  startQueue.forEach(startSafely);
  startQueue.clear();
  raf(advance);
}
function startSafely(animation) {
  if (!currentFrame.includes(animation))
    startUnsafely(animation);
}
function startUnsafely(animation) {
  currentFrame.splice(
    findIndex(currentFrame, (other) => other.priority > animation.priority),
    0,
    animation
  );
}
function advance(dt2) {
  const nextFrame = prevFrame;
  for (let i = 0; i < currentFrame.length; i++) {
    const animation = currentFrame[i];
    priority = animation.priority;
    if (!animation.idle) {
      willAdvance(animation);
      animation.advance(dt2);
      if (!animation.idle) {
        nextFrame.push(animation);
      }
    }
  }
  priority = 0;
  prevFrame = currentFrame;
  prevFrame.length = 0;
  currentFrame = nextFrame;
  return currentFrame.length > 0;
}
function findIndex(arr, test2) {
  const index2 = arr.findIndex(test2);
  return index2 < 0 ? arr.length : index2;
}
var clamp = (min, max, v2) => Math.min(Math.max(v2, min), max);
var colors2 = {
  transparent: 0,
  aliceblue: 4042850303,
  antiquewhite: 4209760255,
  aqua: 16777215,
  aquamarine: 2147472639,
  azure: 4043309055,
  beige: 4126530815,
  bisque: 4293182719,
  black: 255,
  blanchedalmond: 4293643775,
  blue: 65535,
  blueviolet: 2318131967,
  brown: 2771004159,
  burlywood: 3736635391,
  burntsienna: 3934150143,
  cadetblue: 1604231423,
  chartreuse: 2147418367,
  chocolate: 3530104575,
  coral: 4286533887,
  cornflowerblue: 1687547391,
  cornsilk: 4294499583,
  crimson: 3692313855,
  cyan: 16777215,
  darkblue: 35839,
  darkcyan: 9145343,
  darkgoldenrod: 3095792639,
  darkgray: 2846468607,
  darkgreen: 6553855,
  darkgrey: 2846468607,
  darkkhaki: 3182914559,
  darkmagenta: 2332068863,
  darkolivegreen: 1433087999,
  darkorange: 4287365375,
  darkorchid: 2570243327,
  darkred: 2332033279,
  darksalmon: 3918953215,
  darkseagreen: 2411499519,
  darkslateblue: 1211993087,
  darkslategray: 793726975,
  darkslategrey: 793726975,
  darkturquoise: 13554175,
  darkviolet: 2483082239,
  deeppink: 4279538687,
  deepskyblue: 12582911,
  dimgray: 1768516095,
  dimgrey: 1768516095,
  dodgerblue: 512819199,
  firebrick: 2988581631,
  floralwhite: 4294635775,
  forestgreen: 579543807,
  fuchsia: 4278255615,
  gainsboro: 3705462015,
  ghostwhite: 4177068031,
  gold: 4292280575,
  goldenrod: 3668254975,
  gray: 2155905279,
  green: 8388863,
  greenyellow: 2919182335,
  grey: 2155905279,
  honeydew: 4043305215,
  hotpink: 4285117695,
  indianred: 3445382399,
  indigo: 1258324735,
  ivory: 4294963455,
  khaki: 4041641215,
  lavender: 3873897215,
  lavenderblush: 4293981695,
  lawngreen: 2096890111,
  lemonchiffon: 4294626815,
  lightblue: 2916673279,
  lightcoral: 4034953471,
  lightcyan: 3774873599,
  lightgoldenrodyellow: 4210742015,
  lightgray: 3553874943,
  lightgreen: 2431553791,
  lightgrey: 3553874943,
  lightpink: 4290167295,
  lightsalmon: 4288707327,
  lightseagreen: 548580095,
  lightskyblue: 2278488831,
  lightslategray: 2005441023,
  lightslategrey: 2005441023,
  lightsteelblue: 2965692159,
  lightyellow: 4294959359,
  lime: 16711935,
  limegreen: 852308735,
  linen: 4210091775,
  magenta: 4278255615,
  maroon: 2147483903,
  mediumaquamarine: 1724754687,
  mediumblue: 52735,
  mediumorchid: 3126187007,
  mediumpurple: 2473647103,
  mediumseagreen: 1018393087,
  mediumslateblue: 2070474495,
  mediumspringgreen: 16423679,
  mediumturquoise: 1221709055,
  mediumvioletred: 3340076543,
  midnightblue: 421097727,
  mintcream: 4127193855,
  mistyrose: 4293190143,
  moccasin: 4293178879,
  navajowhite: 4292783615,
  navy: 33023,
  oldlace: 4260751103,
  olive: 2155872511,
  olivedrab: 1804477439,
  orange: 4289003775,
  orangered: 4282712319,
  orchid: 3664828159,
  palegoldenrod: 4008225535,
  palegreen: 2566625535,
  paleturquoise: 2951671551,
  palevioletred: 3681588223,
  papayawhip: 4293907967,
  peachpuff: 4292524543,
  peru: 3448061951,
  pink: 4290825215,
  plum: 3718307327,
  powderblue: 2967529215,
  purple: 2147516671,
  rebeccapurple: 1714657791,
  red: 4278190335,
  rosybrown: 3163525119,
  royalblue: 1097458175,
  saddlebrown: 2336560127,
  salmon: 4202722047,
  sandybrown: 4104413439,
  seagreen: 780883967,
  seashell: 4294307583,
  sienna: 2689740287,
  silver: 3233857791,
  skyblue: 2278484991,
  slateblue: 1784335871,
  slategray: 1887473919,
  slategrey: 1887473919,
  snow: 4294638335,
  springgreen: 16744447,
  steelblue: 1182971135,
  tan: 3535047935,
  teal: 8421631,
  thistle: 3636451583,
  tomato: 4284696575,
  turquoise: 1088475391,
  violet: 4001558271,
  wheat: 4125012991,
  white: 4294967295,
  whitesmoke: 4126537215,
  yellow: 4294902015,
  yellowgreen: 2597139199
};
var NUMBER = "[-+]?\\d*\\.?\\d+";
var PERCENTAGE = NUMBER + "%";
function call(...parts) {
  return "\\(\\s*(" + parts.join(")\\s*,\\s*(") + ")\\s*\\)";
}
var rgb = new RegExp("rgb" + call(NUMBER, NUMBER, NUMBER));
var rgba = new RegExp("rgba" + call(NUMBER, NUMBER, NUMBER, NUMBER));
var hsl = new RegExp("hsl" + call(NUMBER, PERCENTAGE, PERCENTAGE));
var hsla = new RegExp(
  "hsla" + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER)
);
var hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
var hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
var hex6 = /^#([0-9a-fA-F]{6})$/;
var hex8 = /^#([0-9a-fA-F]{8})$/;
function normalizeColor(color2) {
  let match2;
  if (typeof color2 === "number") {
    return color2 >>> 0 === color2 && color2 >= 0 && color2 <= 4294967295 ? color2 : null;
  }
  if (match2 = hex6.exec(color2))
    return parseInt(match2[1] + "ff", 16) >>> 0;
  if (colors && colors[color2] !== void 0) {
    return colors[color2];
  }
  if (match2 = rgb.exec(color2)) {
    return (parse255(match2[1]) << 24 | // r
    parse255(match2[2]) << 16 | // g
    parse255(match2[3]) << 8 | // b
    255) >>> // a
    0;
  }
  if (match2 = rgba.exec(color2)) {
    return (parse255(match2[1]) << 24 | // r
    parse255(match2[2]) << 16 | // g
    parse255(match2[3]) << 8 | // b
    parse1(match2[4])) >>> // a
    0;
  }
  if (match2 = hex3.exec(color2)) {
    return parseInt(
      match2[1] + match2[1] + // r
      match2[2] + match2[2] + // g
      match2[3] + match2[3] + // b
      "ff",
      // a
      16
    ) >>> 0;
  }
  if (match2 = hex8.exec(color2))
    return parseInt(match2[1], 16) >>> 0;
  if (match2 = hex4.exec(color2)) {
    return parseInt(
      match2[1] + match2[1] + // r
      match2[2] + match2[2] + // g
      match2[3] + match2[3] + // b
      match2[4] + match2[4],
      // a
      16
    ) >>> 0;
  }
  if (match2 = hsl.exec(color2)) {
    return (hslToRgb(
      parse360(match2[1]),
      // h
      parsePercentage(match2[2]),
      // s
      parsePercentage(match2[3])
      // l
    ) | 255) >>> // a
    0;
  }
  if (match2 = hsla.exec(color2)) {
    return (hslToRgb(
      parse360(match2[1]),
      // h
      parsePercentage(match2[2]),
      // s
      parsePercentage(match2[3])
      // l
    ) | parse1(match2[4])) >>> // a
    0;
  }
  return null;
}
function hue2rgb(p2, q2, t2) {
  if (t2 < 0)
    t2 += 1;
  if (t2 > 1)
    t2 -= 1;
  if (t2 < 1 / 6)
    return p2 + (q2 - p2) * 6 * t2;
  if (t2 < 1 / 2)
    return q2;
  if (t2 < 2 / 3)
    return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
  return p2;
}
function hslToRgb(h2, s2, l2) {
  const q2 = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
  const p2 = 2 * l2 - q2;
  const r2 = hue2rgb(p2, q2, h2 + 1 / 3);
  const g2 = hue2rgb(p2, q2, h2);
  const b2 = hue2rgb(p2, q2, h2 - 1 / 3);
  return Math.round(r2 * 255) << 24 | Math.round(g2 * 255) << 16 | Math.round(b2 * 255) << 8;
}
function parse255(str) {
  const int = parseInt(str, 10);
  if (int < 0)
    return 0;
  if (int > 255)
    return 255;
  return int;
}
function parse360(str) {
  const int = parseFloat(str);
  return (int % 360 + 360) % 360 / 360;
}
function parse1(str) {
  const num = parseFloat(str);
  if (num < 0)
    return 0;
  if (num > 1)
    return 255;
  return Math.round(num * 255);
}
function parsePercentage(str) {
  const int = parseFloat(str);
  if (int < 0)
    return 0;
  if (int > 100)
    return 1;
  return int / 100;
}
function colorToRgba(input) {
  let int32Color = normalizeColor(input);
  if (int32Color === null)
    return input;
  int32Color = int32Color || 0;
  const r2 = (int32Color & 4278190080) >>> 24;
  const g2 = (int32Color & 16711680) >>> 16;
  const b2 = (int32Color & 65280) >>> 8;
  const a2 = (int32Color & 255) / 255;
  return `rgba(${r2}, ${g2}, ${b2}, ${a2})`;
}
var createInterpolator = (range, output, extrapolate) => {
  if (is.fun(range)) {
    return range;
  }
  if (is.arr(range)) {
    return createInterpolator({
      range,
      output,
      extrapolate
    });
  }
  if (is.str(range.output[0])) {
    return createStringInterpolator(range);
  }
  const config2 = range;
  const outputRange = config2.output;
  const inputRange = config2.range || [0, 1];
  const extrapolateLeft = config2.extrapolateLeft || config2.extrapolate || "extend";
  const extrapolateRight = config2.extrapolateRight || config2.extrapolate || "extend";
  const easing = config2.easing || ((t2) => t2);
  return (input) => {
    const range2 = findRange(input, inputRange);
    return interpolate(
      input,
      inputRange[range2],
      inputRange[range2 + 1],
      outputRange[range2],
      outputRange[range2 + 1],
      easing,
      extrapolateLeft,
      extrapolateRight,
      config2.map
    );
  };
};
function interpolate(input, inputMin, inputMax, outputMin, outputMax, easing, extrapolateLeft, extrapolateRight, map2) {
  let result = map2 ? map2(input) : input;
  if (result < inputMin) {
    if (extrapolateLeft === "identity")
      return result;
    else if (extrapolateLeft === "clamp")
      result = inputMin;
  }
  if (result > inputMax) {
    if (extrapolateRight === "identity")
      return result;
    else if (extrapolateRight === "clamp")
      result = inputMax;
  }
  if (outputMin === outputMax)
    return outputMin;
  if (inputMin === inputMax)
    return input <= inputMin ? outputMin : outputMax;
  if (inputMin === -Infinity)
    result = -result;
  else if (inputMax === Infinity)
    result = result - inputMin;
  else
    result = (result - inputMin) / (inputMax - inputMin);
  result = easing(result);
  if (outputMin === -Infinity)
    result = -result;
  else if (outputMax === Infinity)
    result = result + outputMin;
  else
    result = result * (outputMax - outputMin) + outputMin;
  return result;
}
function findRange(input, inputRange) {
  for (var i = 1; i < inputRange.length - 1; ++i)
    if (inputRange[i] >= input)
      break;
  return i - 1;
}
var steps = (steps2, direction = "end") => (progress2) => {
  progress2 = direction === "end" ? Math.min(progress2, 0.999) : Math.max(progress2, 1e-3);
  const expanded = progress2 * steps2;
  const rounded = direction === "end" ? Math.floor(expanded) : Math.ceil(expanded);
  return clamp(0, 1, rounded / steps2);
};
var c1 = 1.70158;
var c2 = c1 * 1.525;
var c3 = c1 + 1;
var c4 = 2 * Math.PI / 3;
var c5 = 2 * Math.PI / 4.5;
var bounceOut = (x2) => {
  const n1 = 7.5625;
  const d1 = 2.75;
  if (x2 < 1 / d1) {
    return n1 * x2 * x2;
  } else if (x2 < 2 / d1) {
    return n1 * (x2 -= 1.5 / d1) * x2 + 0.75;
  } else if (x2 < 2.5 / d1) {
    return n1 * (x2 -= 2.25 / d1) * x2 + 0.9375;
  } else {
    return n1 * (x2 -= 2.625 / d1) * x2 + 0.984375;
  }
};
var easings = {
  linear: (x2) => x2,
  easeInQuad: (x2) => x2 * x2,
  easeOutQuad: (x2) => 1 - (1 - x2) * (1 - x2),
  easeInOutQuad: (x2) => x2 < 0.5 ? 2 * x2 * x2 : 1 - Math.pow(-2 * x2 + 2, 2) / 2,
  easeInCubic: (x2) => x2 * x2 * x2,
  easeOutCubic: (x2) => 1 - Math.pow(1 - x2, 3),
  easeInOutCubic: (x2) => x2 < 0.5 ? 4 * x2 * x2 * x2 : 1 - Math.pow(-2 * x2 + 2, 3) / 2,
  easeInQuart: (x2) => x2 * x2 * x2 * x2,
  easeOutQuart: (x2) => 1 - Math.pow(1 - x2, 4),
  easeInOutQuart: (x2) => x2 < 0.5 ? 8 * x2 * x2 * x2 * x2 : 1 - Math.pow(-2 * x2 + 2, 4) / 2,
  easeInQuint: (x2) => x2 * x2 * x2 * x2 * x2,
  easeOutQuint: (x2) => 1 - Math.pow(1 - x2, 5),
  easeInOutQuint: (x2) => x2 < 0.5 ? 16 * x2 * x2 * x2 * x2 * x2 : 1 - Math.pow(-2 * x2 + 2, 5) / 2,
  easeInSine: (x2) => 1 - Math.cos(x2 * Math.PI / 2),
  easeOutSine: (x2) => Math.sin(x2 * Math.PI / 2),
  easeInOutSine: (x2) => -(Math.cos(Math.PI * x2) - 1) / 2,
  easeInExpo: (x2) => x2 === 0 ? 0 : Math.pow(2, 10 * x2 - 10),
  easeOutExpo: (x2) => x2 === 1 ? 1 : 1 - Math.pow(2, -10 * x2),
  easeInOutExpo: (x2) => x2 === 0 ? 0 : x2 === 1 ? 1 : x2 < 0.5 ? Math.pow(2, 20 * x2 - 10) / 2 : (2 - Math.pow(2, -20 * x2 + 10)) / 2,
  easeInCirc: (x2) => 1 - Math.sqrt(1 - Math.pow(x2, 2)),
  easeOutCirc: (x2) => Math.sqrt(1 - Math.pow(x2 - 1, 2)),
  easeInOutCirc: (x2) => x2 < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * x2, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * x2 + 2, 2)) + 1) / 2,
  easeInBack: (x2) => c3 * x2 * x2 * x2 - c1 * x2 * x2,
  easeOutBack: (x2) => 1 + c3 * Math.pow(x2 - 1, 3) + c1 * Math.pow(x2 - 1, 2),
  easeInOutBack: (x2) => x2 < 0.5 ? Math.pow(2 * x2, 2) * ((c2 + 1) * 2 * x2 - c2) / 2 : (Math.pow(2 * x2 - 2, 2) * ((c2 + 1) * (x2 * 2 - 2) + c2) + 2) / 2,
  easeInElastic: (x2) => x2 === 0 ? 0 : x2 === 1 ? 1 : -Math.pow(2, 10 * x2 - 10) * Math.sin((x2 * 10 - 10.75) * c4),
  easeOutElastic: (x2) => x2 === 0 ? 0 : x2 === 1 ? 1 : Math.pow(2, -10 * x2) * Math.sin((x2 * 10 - 0.75) * c4) + 1,
  easeInOutElastic: (x2) => x2 === 0 ? 0 : x2 === 1 ? 1 : x2 < 0.5 ? -(Math.pow(2, 20 * x2 - 10) * Math.sin((20 * x2 - 11.125) * c5)) / 2 : Math.pow(2, -20 * x2 + 10) * Math.sin((20 * x2 - 11.125) * c5) / 2 + 1,
  easeInBounce: (x2) => 1 - bounceOut(1 - x2),
  easeOutBounce: bounceOut,
  easeInOutBounce: (x2) => x2 < 0.5 ? (1 - bounceOut(1 - 2 * x2)) / 2 : (1 + bounceOut(2 * x2 - 1)) / 2,
  steps
};
var $get = Symbol.for("FluidValue.get");
var $observers = Symbol.for("FluidValue.observers");
var hasFluidValue = (arg) => Boolean(arg && arg[$get]);
var getFluidValue = (arg) => arg && arg[$get] ? arg[$get]() : arg;
var getFluidObservers = (target) => target[$observers] || null;
function callFluidObserver(observer2, event) {
  if (observer2.eventObserved) {
    observer2.eventObserved(event);
  } else {
    observer2(event);
  }
}
function callFluidObservers(target, event) {
  const observers = target[$observers];
  if (observers) {
    observers.forEach((observer2) => {
      callFluidObserver(observer2, event);
    });
  }
}
var FluidValue = class {
  constructor(get2) {
    if (!get2 && !(get2 = this.get)) {
      throw Error("Unknown getter");
    }
    setFluidGetter(this, get2);
  }
};
var setFluidGetter = (target, get2) => setHidden(target, $get, get2);
function addFluidObserver(target, observer2) {
  if (target[$get]) {
    let observers = target[$observers];
    if (!observers) {
      setHidden(target, $observers, observers = /* @__PURE__ */ new Set());
    }
    if (!observers.has(observer2)) {
      observers.add(observer2);
      if (target.observerAdded) {
        target.observerAdded(observers.size, observer2);
      }
    }
  }
  return observer2;
}
function removeFluidObserver(target, observer2) {
  const observers = target[$observers];
  if (observers && observers.has(observer2)) {
    const count = observers.size - 1;
    if (count) {
      observers.delete(observer2);
    } else {
      target[$observers] = null;
    }
    if (target.observerRemoved) {
      target.observerRemoved(count, observer2);
    }
  }
}
var setHidden = (target, key, value) => Object.defineProperty(target, key, {
  value,
  writable: true,
  configurable: true
});
var numberRegex = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
var colorRegex = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi;
var unitRegex = new RegExp(`(${numberRegex.source})(%|[a-z]+)`, "i");
var rgbaRegex = /rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi;
var cssVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
var variableToRgba = (input) => {
  const [token2, fallback] = parseCSSVariable(input);
  if (!token2 || isSSR()) {
    return input;
  }
  const value = window.getComputedStyle(document.documentElement).getPropertyValue(token2);
  if (value) {
    return value.trim();
  } else if (fallback && fallback.startsWith("--")) {
    const value2 = window.getComputedStyle(document.documentElement).getPropertyValue(fallback);
    if (value2) {
      return value2;
    } else {
      return input;
    }
  } else if (fallback && cssVariableRegex.test(fallback)) {
    return variableToRgba(fallback);
  } else if (fallback) {
    return fallback;
  }
  return input;
};
var parseCSSVariable = (current) => {
  const match2 = cssVariableRegex.exec(current);
  if (!match2)
    return [,];
  const [, token2, fallback] = match2;
  return [token2, fallback];
};
var namedColorRegex;
var rgbaRound = (_2, p1, p2, p3, p4) => `rgba(${Math.round(p1)}, ${Math.round(p2)}, ${Math.round(p3)}, ${p4})`;
var createStringInterpolator2 = (config2) => {
  if (!namedColorRegex)
    namedColorRegex = colors ? (
      // match color names, ignore partial matches
      new RegExp(`(${Object.keys(colors).join("|")})(?!\\w)`, "g")
    ) : (
      // never match
      /^\b$/
    );
  const output = config2.output.map((value) => {
    return getFluidValue(value).replace(cssVariableRegex, variableToRgba).replace(colorRegex, colorToRgba).replace(namedColorRegex, colorToRgba);
  });
  const keyframes2 = output.map((value) => value.match(numberRegex).map(Number));
  const outputRanges = keyframes2[0].map(
    (_2, i) => keyframes2.map((values) => {
      if (!(i in values)) {
        throw Error('The arity of each "output" value must be equal');
      }
      return values[i];
    })
  );
  const interpolators = outputRanges.map(
    (output2) => createInterpolator({ ...config2, output: output2 })
  );
  return (input) => {
    var _a3;
    const missingUnit = !unitRegex.test(output[0]) && ((_a3 = output.find((value) => unitRegex.test(value))) == null ? void 0 : _a3.replace(numberRegex, ""));
    let i = 0;
    return output[0].replace(
      numberRegex,
      () => `${interpolators[i++](input)}${missingUnit || ""}`
    ).replace(rgbaRegex, rgbaRound);
  };
};
var prefix = "react-spring: ";
var once = (fn2) => {
  const func = fn2;
  let called = false;
  if (typeof func != "function") {
    throw new TypeError(`${prefix}once requires a function parameter`);
  }
  return (...args) => {
    if (!called) {
      func(...args);
      called = true;
    }
  };
};
var warnInterpolate = once(console.warn);
function deprecateInterpolate() {
  warnInterpolate(
    `${prefix}The "interpolate" function is deprecated in v9 (use "to" instead)`
  );
}
var warnDirectCall = once(console.warn);
function deprecateDirectCall() {
  warnDirectCall(
    `${prefix}Directly calling start instead of using the api object is deprecated in v9 (use ".start" instead), this will be removed in later 0.X.0 versions`
  );
}
function isAnimatedString(value) {
  return is.str(value) && (value[0] == "#" || /\d/.test(value) || // Do not identify a CSS variable as an AnimatedString if its SSR
  !isSSR() && cssVariableRegex.test(value) || value in (colors || {}));
}
var useIsomorphicLayoutEffect = isSSR() ? _ : A$2;
var useIsMounted = () => {
  const isMounted = F$1(false);
  useIsomorphicLayoutEffect(() => {
    isMounted.current = true;
    return () => {
      isMounted.current = false;
    };
  }, []);
  return isMounted;
};
function useForceUpdate() {
  const update2 = p$1()[1];
  const isMounted = useIsMounted();
  return () => {
    if (isMounted.current) {
      update2(Math.random());
    }
  };
}
function useMemoOne(getResult, inputs) {
  const [initial] = p$1(
    () => ({
      inputs,
      result: getResult()
    })
  );
  const committed = F$1();
  const prevCache = committed.current;
  let cache = prevCache;
  if (cache) {
    const useCache = Boolean(
      cache.inputs && areInputsEqual(inputs, cache.inputs)
    );
    if (!useCache) {
      cache = {
        inputs,
        result: getResult()
      };
    }
  } else {
    cache = initial;
  }
  _(() => {
    committed.current = cache;
    if (prevCache == initial) {
      initial.inputs = initial.result = void 0;
    }
  }, [cache]);
  return cache.result;
}
function areInputsEqual(next2, prev2) {
  if (next2.length !== prev2.length) {
    return false;
  }
  for (let i = 0; i < next2.length; i++) {
    if (next2[i] !== prev2[i]) {
      return false;
    }
  }
  return true;
}
var useOnce = (effect) => _(effect, emptyDeps);
var emptyDeps = [];
function usePrev(value) {
  const prevRef = F$1();
  _(() => {
    prevRef.current = value;
  });
  return prevRef.current;
}
var $node = Symbol.for("Animated:node");
var isAnimated = (value) => !!value && value[$node] === value;
var getAnimated = (owner) => owner && owner[$node];
var setAnimated = (owner, node2) => defineHidden(owner, $node, node2);
var getPayload = (owner) => owner && owner[$node] && owner[$node].getPayload();
var Animated = class {
  constructor() {
    setAnimated(this, this);
  }
  /** Get every `AnimatedValue` used by this node. */
  getPayload() {
    return this.payload || [];
  }
};
var AnimatedValue = class extends Animated {
  constructor(_value) {
    super();
    this._value = _value;
    this.done = true;
    this.durationProgress = 0;
    if (is.num(this._value)) {
      this.lastPosition = this._value;
    }
  }
  /** @internal */
  static create(value) {
    return new AnimatedValue(value);
  }
  getPayload() {
    return [this];
  }
  getValue() {
    return this._value;
  }
  setValue(value, step) {
    if (is.num(value)) {
      this.lastPosition = value;
      if (step) {
        value = Math.round(value / step) * step;
        if (this.done) {
          this.lastPosition = value;
        }
      }
    }
    if (this._value === value) {
      return false;
    }
    this._value = value;
    return true;
  }
  reset() {
    const { done } = this;
    this.done = false;
    if (is.num(this._value)) {
      this.elapsedTime = 0;
      this.durationProgress = 0;
      this.lastPosition = this._value;
      if (done)
        this.lastVelocity = null;
      this.v0 = null;
    }
  }
};
var AnimatedString = class extends AnimatedValue {
  constructor(value) {
    super(0);
    this._string = null;
    this._toString = createInterpolator({
      output: [value, value]
    });
  }
  /** @internal */
  static create(value) {
    return new AnimatedString(value);
  }
  getValue() {
    const value = this._string;
    return value == null ? this._string = this._toString(this._value) : value;
  }
  setValue(value) {
    if (is.str(value)) {
      if (value == this._string) {
        return false;
      }
      this._string = value;
      this._value = 1;
    } else if (super.setValue(value)) {
      this._string = null;
    } else {
      return false;
    }
    return true;
  }
  reset(goal) {
    if (goal) {
      this._toString = createInterpolator({
        output: [this.getValue(), goal]
      });
    }
    this._value = 0;
    super.reset();
  }
};
var TreeContext = { dependencies: null };
var AnimatedObject = class extends Animated {
  constructor(source) {
    super();
    this.source = source;
    this.setValue(source);
  }
  getValue(animated2) {
    const values = {};
    eachProp(this.source, (source, key) => {
      if (isAnimated(source)) {
        values[key] = source.getValue(animated2);
      } else if (hasFluidValue(source)) {
        values[key] = getFluidValue(source);
      } else if (!animated2) {
        values[key] = source;
      }
    });
    return values;
  }
  /** Replace the raw object data */
  setValue(source) {
    this.source = source;
    this.payload = this._makePayload(source);
  }
  reset() {
    if (this.payload) {
      each(this.payload, (node2) => node2.reset());
    }
  }
  /** Create a payload set. */
  _makePayload(source) {
    if (source) {
      const payload = /* @__PURE__ */ new Set();
      eachProp(source, this._addToPayload, payload);
      return Array.from(payload);
    }
  }
  /** Add to a payload set. */
  _addToPayload(source) {
    if (TreeContext.dependencies && hasFluidValue(source)) {
      TreeContext.dependencies.add(source);
    }
    const payload = getPayload(source);
    if (payload) {
      each(payload, (node2) => this.add(node2));
    }
  }
};
var AnimatedArray = class extends AnimatedObject {
  constructor(source) {
    super(source);
  }
  /** @internal */
  static create(source) {
    return new AnimatedArray(source);
  }
  getValue() {
    return this.source.map((node2) => node2.getValue());
  }
  setValue(source) {
    const payload = this.getPayload();
    if (source.length == payload.length) {
      return payload.map((node2, i) => node2.setValue(source[i])).some(Boolean);
    }
    super.setValue(source.map(makeAnimated));
    return true;
  }
};
function makeAnimated(value) {
  const nodeType = isAnimatedString(value) ? AnimatedString : AnimatedValue;
  return nodeType.create(value);
}
function getAnimatedType(value) {
  const parentNode = getAnimated(value);
  return parentNode ? parentNode.constructor : is.arr(value) ? AnimatedArray : isAnimatedString(value) ? AnimatedString : AnimatedValue;
}
var withAnimated = (Component, host2) => {
  const hasInstance = (
    // Function components must use "forwardRef" to avoid being
    // re-rendered on every animation frame.
    !is.fun(Component) || Component.prototype && Component.prototype.isReactComponent
  );
  return N((givenProps, givenRef) => {
    const instanceRef = F$1(null);
    const ref2 = hasInstance && // eslint-disable-next-line react-hooks/rules-of-hooks
    x$2(
      (value) => {
        instanceRef.current = updateRef(givenRef, value);
      },
      [givenRef]
    );
    const [props, deps] = getAnimatedState(givenProps, host2);
    const forceUpdate = useForceUpdate();
    const callback = () => {
      const instance = instanceRef.current;
      if (hasInstance && !instance) {
        return;
      }
      const didUpdate = instance ? host2.applyAnimatedValues(instance, props.getValue(true)) : false;
      if (didUpdate === false) {
        forceUpdate();
      }
    };
    const observer = new PropsObserver(callback, deps);
    const observerRef = F$1();
    useIsomorphicLayoutEffect(() => {
      observerRef.current = observer;
      each(deps, (dep) => addFluidObserver(dep, observer));
      return () => {
        if (observerRef.current) {
          each(
            observerRef.current.deps,
            (dep) => removeFluidObserver(dep, observerRef.current)
          );
          raf.cancel(observerRef.current.update);
        }
      };
    });
    _(callback, []);
    useOnce(() => () => {
      const observer2 = observerRef.current;
      each(observer2.deps, (dep) => removeFluidObserver(dep, observer2));
    });
    const usedProps = host2.getComponentProps(props.getValue());
    return /* @__PURE__ */ y$3(Component, { ...usedProps, ref: ref2 });
  });
};
var PropsObserver = class {
  constructor(update2, deps) {
    this.update = update2;
    this.deps = deps;
  }
  eventObserved(event) {
    if (event.type == "change") {
      raf.write(this.update);
    }
  }
};
function getAnimatedState(props, host2) {
  const dependencies2 = /* @__PURE__ */ new Set();
  TreeContext.dependencies = dependencies2;
  if (props.style)
    props = {
      ...props,
      style: host2.createAnimatedStyle(props.style)
    };
  props = new AnimatedObject(props);
  TreeContext.dependencies = null;
  return [props, dependencies2];
}
function updateRef(ref2, value) {
  if (ref2) {
    if (is.fun(ref2))
      ref2(value);
    else
      ref2.current = value;
  }
  return value;
}
var cacheKey = Symbol.for("AnimatedComponent");
var createHost = (components, {
  applyAnimatedValues: applyAnimatedValues2 = () => false,
  createAnimatedStyle = (style) => new AnimatedObject(style),
  getComponentProps = (props) => props
} = {}) => {
  const hostConfig = {
    applyAnimatedValues: applyAnimatedValues2,
    createAnimatedStyle,
    getComponentProps
  };
  const animated2 = (Component) => {
    const displayName = getDisplayName(Component) || "Anonymous";
    if (is.str(Component)) {
      Component = animated2[Component] || (animated2[Component] = withAnimated(Component, hostConfig));
    } else {
      Component = Component[cacheKey] || (Component[cacheKey] = withAnimated(Component, hostConfig));
    }
    Component.displayName = `Animated(${displayName})`;
    return Component;
  };
  eachProp(components, (Component, key) => {
    if (is.arr(components)) {
      key = getDisplayName(Component);
    }
    animated2[key] = animated2(Component);
  });
  return {
    animated: animated2
  };
};
var getDisplayName = (arg) => is.str(arg) ? arg : arg && is.str(arg.displayName) ? arg.displayName : is.fun(arg) && arg.name || null;
function callProp(value, ...args) {
  return is.fun(value) ? value(...args) : value;
}
var matchProp = (value, key) => value === true || !!(key && value && (is.fun(value) ? value(key) : toArray(value).includes(key)));
var resolveProp = (prop, key) => is.obj(prop) ? key && prop[key] : prop;
var getDefaultProp = (props, key) => props.default === true ? props[key] : props.default ? props.default[key] : void 0;
var noopTransform = (value) => value;
var getDefaultProps = (props, transform = noopTransform) => {
  let keys2 = DEFAULT_PROPS;
  if (props.default && props.default !== true) {
    props = props.default;
    keys2 = Object.keys(props);
  }
  const defaults2 = {};
  for (const key of keys2) {
    const value = transform(props[key], key);
    if (!is.und(value)) {
      defaults2[key] = value;
    }
  }
  return defaults2;
};
var DEFAULT_PROPS = [
  "config",
  "onProps",
  "onStart",
  "onChange",
  "onPause",
  "onResume",
  "onRest"
];
var RESERVED_PROPS = {
  config: 1,
  from: 1,
  to: 1,
  ref: 1,
  loop: 1,
  reset: 1,
  pause: 1,
  cancel: 1,
  reverse: 1,
  immediate: 1,
  default: 1,
  delay: 1,
  onProps: 1,
  onStart: 1,
  onChange: 1,
  onPause: 1,
  onResume: 1,
  onRest: 1,
  onResolve: 1,
  // Transition props
  items: 1,
  trail: 1,
  sort: 1,
  expires: 1,
  initial: 1,
  enter: 1,
  update: 1,
  leave: 1,
  children: 1,
  onDestroyed: 1,
  // Internal props
  keys: 1,
  callId: 1,
  parentId: 1
};
function getForwardProps(props) {
  const forward = {};
  let count = 0;
  eachProp(props, (value, prop) => {
    if (!RESERVED_PROPS[prop]) {
      forward[prop] = value;
      count++;
    }
  });
  if (count) {
    return forward;
  }
}
function inferTo(props) {
  const to2 = getForwardProps(props);
  if (to2) {
    const out = { to: to2 };
    eachProp(props, (val, key) => key in to2 || (out[key] = val));
    return out;
  }
  return { ...props };
}
function computeGoal(value) {
  value = getFluidValue(value);
  return is.arr(value) ? value.map(computeGoal) : isAnimatedString(value) ? globals_exports.createStringInterpolator({
    range: [0, 1],
    output: [value, value]
  })(1) : value;
}
function hasProps(props) {
  for (const _2 in props)
    return true;
  return false;
}
function isAsyncTo(to2) {
  return is.fun(to2) || is.arr(to2) && is.obj(to2[0]);
}
function detachRefs(ctrl, ref2) {
  var _a3;
  (_a3 = ctrl.ref) == null ? void 0 : _a3.delete(ctrl);
  ref2 == null ? void 0 : ref2.delete(ctrl);
}
function replaceRef(ctrl, ref2) {
  var _a3;
  if (ref2 && ctrl.ref !== ref2) {
    (_a3 = ctrl.ref) == null ? void 0 : _a3.delete(ctrl);
    ref2.add(ctrl);
    ctrl.ref = ref2;
  }
}
var config = {
  default: { tension: 170, friction: 26 },
  gentle: { tension: 120, friction: 14 },
  wobbly: { tension: 180, friction: 12 },
  stiff: { tension: 210, friction: 20 },
  slow: { tension: 280, friction: 60 },
  molasses: { tension: 280, friction: 120 }
};
var defaults = {
  ...config.default,
  mass: 1,
  damping: 1,
  easing: easings.linear,
  clamp: false
};
var AnimationConfig = class {
  constructor() {
    this.velocity = 0;
    Object.assign(this, defaults);
  }
};
function mergeConfig(config2, newConfig, defaultConfig) {
  if (defaultConfig) {
    defaultConfig = { ...defaultConfig };
    sanitizeConfig(defaultConfig, newConfig);
    newConfig = { ...defaultConfig, ...newConfig };
  }
  sanitizeConfig(config2, newConfig);
  Object.assign(config2, newConfig);
  for (const key in defaults) {
    if (config2[key] == null) {
      config2[key] = defaults[key];
    }
  }
  let { frequency, damping } = config2;
  const { mass } = config2;
  if (!is.und(frequency)) {
    if (frequency < 0.01)
      frequency = 0.01;
    if (damping < 0)
      damping = 0;
    config2.tension = Math.pow(2 * Math.PI / frequency, 2) * mass;
    config2.friction = 4 * Math.PI * damping * mass / frequency;
  }
  return config2;
}
function sanitizeConfig(config2, props) {
  if (!is.und(props.decay)) {
    config2.duration = void 0;
  } else {
    const isTensionConfig = !is.und(props.tension) || !is.und(props.friction);
    if (isTensionConfig || !is.und(props.frequency) || !is.und(props.damping) || !is.und(props.mass)) {
      config2.duration = void 0;
      config2.decay = void 0;
    }
    if (isTensionConfig) {
      config2.frequency = void 0;
    }
  }
}
var emptyArray = [];
var Animation = class {
  constructor() {
    this.changed = false;
    this.values = emptyArray;
    this.toValues = null;
    this.fromValues = emptyArray;
    this.config = new AnimationConfig();
    this.immediate = false;
  }
};
function scheduleProps(callId, { key, props, defaultProps, state, actions }) {
  return new Promise((resolve2, reject) => {
    let delay;
    let timeout;
    let cancel = matchProp(props.cancel ?? (defaultProps == null ? void 0 : defaultProps.cancel), key);
    if (cancel) {
      onStart();
    } else {
      if (!is.und(props.pause)) {
        state.paused = matchProp(props.pause, key);
      }
      let pause = defaultProps == null ? void 0 : defaultProps.pause;
      if (pause !== true) {
        pause = state.paused || matchProp(pause, key);
      }
      delay = callProp(props.delay || 0, key);
      if (pause) {
        state.resumeQueue.add(onResume);
        actions.pause();
      } else {
        actions.resume();
        onResume();
      }
    }
    function onPause() {
      state.resumeQueue.add(onResume);
      state.timeouts.delete(timeout);
      timeout.cancel();
      delay = timeout.time - raf.now();
    }
    function onResume() {
      if (delay > 0 && !globals_exports.skipAnimation) {
        state.delayed = true;
        timeout = raf.setTimeout(onStart, delay);
        state.pauseQueue.add(onPause);
        state.timeouts.add(timeout);
      } else {
        onStart();
      }
    }
    function onStart() {
      if (state.delayed) {
        state.delayed = false;
      }
      state.pauseQueue.delete(onPause);
      state.timeouts.delete(timeout);
      if (callId <= (state.cancelId || 0)) {
        cancel = true;
      }
      try {
        actions.start({ ...props, callId, cancel }, resolve2);
      } catch (err) {
        reject(err);
      }
    }
  });
}
var getCombinedResult = (target, results) => results.length == 1 ? results[0] : results.some((result) => result.cancelled) ? getCancelledResult(target.get()) : results.every((result) => result.noop) ? getNoopResult(target.get()) : getFinishedResult(
  target.get(),
  results.every((result) => result.finished)
);
var getNoopResult = (value) => ({
  value,
  noop: true,
  finished: true,
  cancelled: false
});
var getFinishedResult = (value, finished, cancelled = false) => ({
  value,
  finished,
  cancelled
});
var getCancelledResult = (value) => ({
  value,
  cancelled: true,
  finished: false
});
function runAsync(to2, props, state, target) {
  const { callId, parentId, onRest } = props;
  const { asyncTo: prevTo, promise: prevPromise } = state;
  if (!parentId && to2 === prevTo && !props.reset) {
    return prevPromise;
  }
  return state.promise = (async () => {
    state.asyncId = callId;
    state.asyncTo = to2;
    const defaultProps = getDefaultProps(
      props,
      (value, key) => (
        // The `onRest` prop is only called when the `runAsync` promise is resolved.
        key === "onRest" ? void 0 : value
      )
    );
    let preventBail;
    let bail2;
    const bailPromise = new Promise(
      (resolve2, reject) => (preventBail = resolve2, bail2 = reject)
    );
    const bailIfEnded = (bailSignal) => {
      const bailResult = (
        // The `cancel` prop or `stop` method was used.
        callId <= (state.cancelId || 0) && getCancelledResult(target) || // The async `to` prop was replaced.
        callId !== state.asyncId && getFinishedResult(target, false)
      );
      if (bailResult) {
        bailSignal.result = bailResult;
        bail2(bailSignal);
        throw bailSignal;
      }
    };
    const animate = (arg1, arg2) => {
      const bailSignal = new BailSignal();
      const skipAnimationSignal = new SkipAnimationSignal();
      return (async () => {
        if (globals_exports.skipAnimation) {
          stopAsync(state);
          skipAnimationSignal.result = getFinishedResult(target, false);
          bail2(skipAnimationSignal);
          throw skipAnimationSignal;
        }
        bailIfEnded(bailSignal);
        const props2 = is.obj(arg1) ? { ...arg1 } : { ...arg2, to: arg1 };
        props2.parentId = callId;
        eachProp(defaultProps, (value, key) => {
          if (is.und(props2[key])) {
            props2[key] = value;
          }
        });
        const result2 = await target.start(props2);
        bailIfEnded(bailSignal);
        if (state.paused) {
          await new Promise((resume) => {
            state.resumeQueue.add(resume);
          });
        }
        return result2;
      })();
    };
    let result;
    if (globals_exports.skipAnimation) {
      stopAsync(state);
      return getFinishedResult(target, false);
    }
    try {
      let animating;
      if (is.arr(to2)) {
        animating = (async (queue) => {
          for (const props2 of queue) {
            await animate(props2);
          }
        })(to2);
      } else {
        animating = Promise.resolve(to2(animate, target.stop.bind(target)));
      }
      await Promise.all([animating.then(preventBail), bailPromise]);
      result = getFinishedResult(target.get(), true, false);
    } catch (err) {
      if (err instanceof BailSignal) {
        result = err.result;
      } else if (err instanceof SkipAnimationSignal) {
        result = err.result;
      } else {
        throw err;
      }
    } finally {
      if (callId == state.asyncId) {
        state.asyncId = parentId;
        state.asyncTo = parentId ? prevTo : void 0;
        state.promise = parentId ? prevPromise : void 0;
      }
    }
    if (is.fun(onRest)) {
      raf.batchedUpdates(() => {
        onRest(result, target, target.item);
      });
    }
    return result;
  })();
}
function stopAsync(state, cancelId) {
  flush(state.timeouts, (t2) => t2.cancel());
  state.pauseQueue.clear();
  state.resumeQueue.clear();
  state.asyncId = state.asyncTo = state.promise = void 0;
  if (cancelId)
    state.cancelId = cancelId;
}
var BailSignal = class extends Error {
  constructor() {
    super(
      "An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise."
    );
  }
};
var SkipAnimationSignal = class extends Error {
  constructor() {
    super("SkipAnimationSignal");
  }
};
var isFrameValue = (value) => value instanceof FrameValue;
var nextId = 1;
var FrameValue = class extends FluidValue {
  constructor() {
    super(...arguments);
    this.id = nextId++;
    this._priority = 0;
  }
  get priority() {
    return this._priority;
  }
  set priority(priority2) {
    if (this._priority != priority2) {
      this._priority = priority2;
      this._onPriorityChange(priority2);
    }
  }
  /** Get the current value */
  get() {
    const node2 = getAnimated(this);
    return node2 && node2.getValue();
  }
  /** Create a spring that maps our value to another value */
  to(...args) {
    return globals_exports.to(this, args);
  }
  /** @deprecated Use the `to` method instead. */
  interpolate(...args) {
    deprecateInterpolate();
    return globals_exports.to(this, args);
  }
  toJSON() {
    return this.get();
  }
  observerAdded(count) {
    if (count == 1)
      this._attach();
  }
  observerRemoved(count) {
    if (count == 0)
      this._detach();
  }
  /** Called when the first child is added. */
  _attach() {
  }
  /** Called when the last child is removed. */
  _detach() {
  }
  /** Tell our children about our new value */
  _onChange(value, idle = false) {
    callFluidObservers(this, {
      type: "change",
      parent: this,
      value,
      idle
    });
  }
  /** Tell our children about our new priority */
  _onPriorityChange(priority2) {
    if (!this.idle) {
      frameLoop.sort(this);
    }
    callFluidObservers(this, {
      type: "priority",
      parent: this,
      priority: priority2
    });
  }
};
var $P = Symbol.for("SpringPhase");
var HAS_ANIMATED = 1;
var IS_ANIMATING = 2;
var IS_PAUSED = 4;
var hasAnimated = (target) => (target[$P] & HAS_ANIMATED) > 0;
var isAnimating = (target) => (target[$P] & IS_ANIMATING) > 0;
var isPaused = (target) => (target[$P] & IS_PAUSED) > 0;
var setActiveBit = (target, active) => active ? target[$P] |= IS_ANIMATING | HAS_ANIMATED : target[$P] &= ~IS_ANIMATING;
var setPausedBit = (target, paused) => paused ? target[$P] |= IS_PAUSED : target[$P] &= ~IS_PAUSED;
var SpringValue = class extends FrameValue {
  constructor(arg1, arg2) {
    super();
    this.animation = new Animation();
    this.defaultProps = {};
    this._state = {
      paused: false,
      delayed: false,
      pauseQueue: /* @__PURE__ */ new Set(),
      resumeQueue: /* @__PURE__ */ new Set(),
      timeouts: /* @__PURE__ */ new Set()
    };
    this._pendingCalls = /* @__PURE__ */ new Set();
    this._lastCallId = 0;
    this._lastToId = 0;
    this._memoizedDuration = 0;
    if (!is.und(arg1) || !is.und(arg2)) {
      const props = is.obj(arg1) ? { ...arg1 } : { ...arg2, from: arg1 };
      if (is.und(props.default)) {
        props.default = true;
      }
      this.start(props);
    }
  }
  /** Equals true when not advancing on each frame. */
  get idle() {
    return !(isAnimating(this) || this._state.asyncTo) || isPaused(this);
  }
  get goal() {
    return getFluidValue(this.animation.to);
  }
  get velocity() {
    const node2 = getAnimated(this);
    return node2 instanceof AnimatedValue ? node2.lastVelocity || 0 : node2.getPayload().map((node22) => node22.lastVelocity || 0);
  }
  /**
   * When true, this value has been animated at least once.
   */
  get hasAnimated() {
    return hasAnimated(this);
  }
  /**
   * When true, this value has an unfinished animation,
   * which is either active or paused.
   */
  get isAnimating() {
    return isAnimating(this);
  }
  /**
   * When true, all current and future animations are paused.
   */
  get isPaused() {
    return isPaused(this);
  }
  /**
   *
   *
   */
  get isDelayed() {
    return this._state.delayed;
  }
  /** Advance the current animation by a number of milliseconds */
  advance(dt2) {
    let idle = true;
    let changed = false;
    const anim = this.animation;
    let { toValues } = anim;
    const { config: config2 } = anim;
    const payload = getPayload(anim.to);
    if (!payload && hasFluidValue(anim.to)) {
      toValues = toArray(getFluidValue(anim.to));
    }
    anim.values.forEach((node22, i) => {
      if (node22.done)
        return;
      const to2 = (
        // Animated strings always go from 0 to 1.
        node22.constructor == AnimatedString ? 1 : payload ? payload[i].lastPosition : toValues[i]
      );
      let finished = anim.immediate;
      let position2 = to2;
      if (!finished) {
        position2 = node22.lastPosition;
        if (config2.tension <= 0) {
          node22.done = true;
          return;
        }
        let elapsed = node22.elapsedTime += dt2;
        const from2 = anim.fromValues[i];
        const v0 = node22.v0 != null ? node22.v0 : node22.v0 = is.arr(config2.velocity) ? config2.velocity[i] : config2.velocity;
        let velocity;
        const precision = config2.precision || (from2 == to2 ? 5e-3 : Math.min(1, Math.abs(to2 - from2) * 1e-3));
        if (!is.und(config2.duration)) {
          let p2 = 1;
          if (config2.duration > 0) {
            if (this._memoizedDuration !== config2.duration) {
              this._memoizedDuration = config2.duration;
              if (node22.durationProgress > 0) {
                node22.elapsedTime = config2.duration * node22.durationProgress;
                elapsed = node22.elapsedTime += dt2;
              }
            }
            p2 = (config2.progress || 0) + elapsed / this._memoizedDuration;
            p2 = p2 > 1 ? 1 : p2 < 0 ? 0 : p2;
            node22.durationProgress = p2;
          }
          position2 = from2 + config2.easing(p2) * (to2 - from2);
          velocity = (position2 - node22.lastPosition) / dt2;
          finished = p2 == 1;
        } else if (config2.decay) {
          const decay = config2.decay === true ? 0.998 : config2.decay;
          const e2 = Math.exp(-(1 - decay) * elapsed);
          position2 = from2 + v0 / (1 - decay) * (1 - e2);
          finished = Math.abs(node22.lastPosition - position2) <= precision;
          velocity = v0 * e2;
        } else {
          velocity = node22.lastVelocity == null ? v0 : node22.lastVelocity;
          const restVelocity = config2.restVelocity || precision / 10;
          const bounceFactor = config2.clamp ? 0 : config2.bounce;
          const canBounce = !is.und(bounceFactor);
          const isGrowing = from2 == to2 ? node22.v0 > 0 : from2 < to2;
          let isMoving;
          let isBouncing = false;
          const step = 1;
          const numSteps = Math.ceil(dt2 / step);
          for (let n2 = 0; n2 < numSteps; ++n2) {
            isMoving = Math.abs(velocity) > restVelocity;
            if (!isMoving) {
              finished = Math.abs(to2 - position2) <= precision;
              if (finished) {
                break;
              }
            }
            if (canBounce) {
              isBouncing = position2 == to2 || position2 > to2 == isGrowing;
              if (isBouncing) {
                velocity = -velocity * bounceFactor;
                position2 = to2;
              }
            }
            const springForce = -config2.tension * 1e-6 * (position2 - to2);
            const dampingForce = -config2.friction * 1e-3 * velocity;
            const acceleration = (springForce + dampingForce) / config2.mass;
            velocity = velocity + acceleration * step;
            position2 = position2 + velocity * step;
          }
        }
        node22.lastVelocity = velocity;
        if (Number.isNaN(position2)) {
          console.warn(`Got NaN while animating:`, this);
          finished = true;
        }
      }
      if (payload && !payload[i].done) {
        finished = false;
      }
      if (finished) {
        node22.done = true;
      } else {
        idle = false;
      }
      if (node22.setValue(position2, config2.round)) {
        changed = true;
      }
    });
    const node2 = getAnimated(this);
    const currVal = node2.getValue();
    if (idle) {
      const finalVal = getFluidValue(anim.to);
      if ((currVal !== finalVal || changed) && !config2.decay) {
        node2.setValue(finalVal);
        this._onChange(finalVal);
      } else if (changed && config2.decay) {
        this._onChange(currVal);
      }
      this._stop();
    } else if (changed) {
      this._onChange(currVal);
    }
  }
  /** Set the current value, while stopping the current animation */
  set(value) {
    raf.batchedUpdates(() => {
      this._stop();
      this._focus(value);
      this._set(value);
    });
    return this;
  }
  /**
   * Freeze the active animation in time, as well as any updates merged
   * before `resume` is called.
   */
  pause() {
    this._update({ pause: true });
  }
  /** Resume the animation if paused. */
  resume() {
    this._update({ pause: false });
  }
  /** Skip to the end of the current animation. */
  finish() {
    if (isAnimating(this)) {
      const { to: to2, config: config2 } = this.animation;
      raf.batchedUpdates(() => {
        this._onStart();
        if (!config2.decay) {
          this._set(to2, false);
        }
        this._stop();
      });
    }
    return this;
  }
  /** Push props into the pending queue. */
  update(props) {
    const queue = this.queue || (this.queue = []);
    queue.push(props);
    return this;
  }
  start(to2, arg2) {
    let queue;
    if (!is.und(to2)) {
      queue = [is.obj(to2) ? to2 : { ...arg2, to: to2 }];
    } else {
      queue = this.queue || [];
      this.queue = [];
    }
    return Promise.all(
      queue.map((props) => {
        const up = this._update(props);
        return up;
      })
    ).then((results) => getCombinedResult(this, results));
  }
  /**
   * Stop the current animation, and cancel any delayed updates.
   *
   * Pass `true` to call `onRest` with `cancelled: true`.
   */
  stop(cancel) {
    const { to: to2 } = this.animation;
    this._focus(this.get());
    stopAsync(this._state, cancel && this._lastCallId);
    raf.batchedUpdates(() => this._stop(to2, cancel));
    return this;
  }
  /** Restart the animation. */
  reset() {
    this._update({ reset: true });
  }
  /** @internal */
  eventObserved(event) {
    if (event.type == "change") {
      this._start();
    } else if (event.type == "priority") {
      this.priority = event.priority + 1;
    }
  }
  /**
   * Parse the `to` and `from` range from the given `props` object.
   *
   * This also ensures the initial value is available to animated components
   * during the render phase.
   */
  _prepareNode(props) {
    const key = this.key || "";
    let { to: to2, from: from2 } = props;
    to2 = is.obj(to2) ? to2[key] : to2;
    if (to2 == null || isAsyncTo(to2)) {
      to2 = void 0;
    }
    from2 = is.obj(from2) ? from2[key] : from2;
    if (from2 == null) {
      from2 = void 0;
    }
    const range = { to: to2, from: from2 };
    if (!hasAnimated(this)) {
      if (props.reverse)
        [to2, from2] = [from2, to2];
      from2 = getFluidValue(from2);
      if (!is.und(from2)) {
        this._set(from2);
      } else if (!getAnimated(this)) {
        this._set(to2);
      }
    }
    return range;
  }
  /** Every update is processed by this method before merging. */
  _update({ ...props }, isLoop) {
    const { key, defaultProps } = this;
    if (props.default)
      Object.assign(
        defaultProps,
        getDefaultProps(
          props,
          (value, prop) => /^on/.test(prop) ? resolveProp(value, key) : value
        )
      );
    mergeActiveFn(this, props, "onProps");
    sendEvent(this, "onProps", props, this);
    const range = this._prepareNode(props);
    if (Object.isFrozen(this)) {
      throw Error(
        "Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?"
      );
    }
    const state = this._state;
    return scheduleProps(++this._lastCallId, {
      key,
      props,
      defaultProps,
      state,
      actions: {
        pause: () => {
          if (!isPaused(this)) {
            setPausedBit(this, true);
            flushCalls(state.pauseQueue);
            sendEvent(
              this,
              "onPause",
              getFinishedResult(this, checkFinished(this, this.animation.to)),
              this
            );
          }
        },
        resume: () => {
          if (isPaused(this)) {
            setPausedBit(this, false);
            if (isAnimating(this)) {
              this._resume();
            }
            flushCalls(state.resumeQueue);
            sendEvent(
              this,
              "onResume",
              getFinishedResult(this, checkFinished(this, this.animation.to)),
              this
            );
          }
        },
        start: this._merge.bind(this, range)
      }
    }).then((result) => {
      if (props.loop && result.finished && !(isLoop && result.noop)) {
        const nextProps = createLoopUpdate(props);
        if (nextProps) {
          return this._update(nextProps, true);
        }
      }
      return result;
    });
  }
  /** Merge props into the current animation */
  _merge(range, props, resolve2) {
    if (props.cancel) {
      this.stop(true);
      return resolve2(getCancelledResult(this));
    }
    const hasToProp = !is.und(range.to);
    const hasFromProp = !is.und(range.from);
    if (hasToProp || hasFromProp) {
      if (props.callId > this._lastToId) {
        this._lastToId = props.callId;
      } else {
        return resolve2(getCancelledResult(this));
      }
    }
    const { key, defaultProps, animation: anim } = this;
    const { to: prevTo, from: prevFrom } = anim;
    let { to: to2 = prevTo, from: from2 = prevFrom } = range;
    if (hasFromProp && !hasToProp && (!props.default || is.und(to2))) {
      to2 = from2;
    }
    if (props.reverse)
      [to2, from2] = [from2, to2];
    const hasFromChanged = !isEqual(from2, prevFrom);
    if (hasFromChanged) {
      anim.from = from2;
    }
    from2 = getFluidValue(from2);
    const hasToChanged = !isEqual(to2, prevTo);
    if (hasToChanged) {
      this._focus(to2);
    }
    const hasAsyncTo = isAsyncTo(props.to);
    const { config: config2 } = anim;
    const { decay, velocity } = config2;
    if (hasToProp || hasFromProp) {
      config2.velocity = 0;
    }
    if (props.config && !hasAsyncTo) {
      mergeConfig(
        config2,
        callProp(props.config, key),
        // Avoid calling the same "config" prop twice.
        props.config !== defaultProps.config ? callProp(defaultProps.config, key) : void 0
      );
    }
    let node2 = getAnimated(this);
    if (!node2 || is.und(to2)) {
      return resolve2(getFinishedResult(this, true));
    }
    const reset = (
      // When `reset` is undefined, the `from` prop implies `reset: true`,
      // except for declarative updates. When `reset` is defined, there
      // must exist a value to animate from.
      is.und(props.reset) ? hasFromProp && !props.default : !is.und(from2) && matchProp(props.reset, key)
    );
    const value = reset ? from2 : this.get();
    const goal = computeGoal(to2);
    const isAnimatable = is.num(goal) || is.arr(goal) || isAnimatedString(goal);
    const immediate = !hasAsyncTo && (!isAnimatable || matchProp(defaultProps.immediate || props.immediate, key));
    if (hasToChanged) {
      const nodeType = getAnimatedType(to2);
      if (nodeType !== node2.constructor) {
        if (immediate) {
          node2 = this._set(goal);
        } else
          throw Error(
            `Cannot animate between ${node2.constructor.name} and ${nodeType.name}, as the "to" prop suggests`
          );
      }
    }
    const goalType = node2.constructor;
    let started = hasFluidValue(to2);
    let finished = false;
    if (!started) {
      const hasValueChanged = reset || !hasAnimated(this) && hasFromChanged;
      if (hasToChanged || hasValueChanged) {
        finished = isEqual(computeGoal(value), goal);
        started = !finished;
      }
      if (!isEqual(anim.immediate, immediate) && !immediate || !isEqual(config2.decay, decay) || !isEqual(config2.velocity, velocity)) {
        started = true;
      }
    }
    if (finished && isAnimating(this)) {
      if (anim.changed && !reset) {
        started = true;
      } else if (!started) {
        this._stop(prevTo);
      }
    }
    if (!hasAsyncTo) {
      if (started || hasFluidValue(prevTo)) {
        anim.values = node2.getPayload();
        anim.toValues = hasFluidValue(to2) ? null : goalType == AnimatedString ? [1] : toArray(goal);
      }
      if (anim.immediate != immediate) {
        anim.immediate = immediate;
        if (!immediate && !reset) {
          this._set(prevTo);
        }
      }
      if (started) {
        const { onRest } = anim;
        each(ACTIVE_EVENTS, (type2) => mergeActiveFn(this, props, type2));
        const result = getFinishedResult(this, checkFinished(this, prevTo));
        flushCalls(this._pendingCalls, result);
        this._pendingCalls.add(resolve2);
        if (anim.changed)
          raf.batchedUpdates(() => {
            var _a3;
            anim.changed = !reset;
            onRest == null ? void 0 : onRest(result, this);
            if (reset) {
              callProp(defaultProps.onRest, result);
            } else {
              (_a3 = anim.onStart) == null ? void 0 : _a3.call(anim, result, this);
            }
          });
      }
    }
    if (reset) {
      this._set(value);
    }
    if (hasAsyncTo) {
      resolve2(runAsync(props.to, props, this._state, this));
    } else if (started) {
      this._start();
    } else if (isAnimating(this) && !hasToChanged) {
      this._pendingCalls.add(resolve2);
    } else {
      resolve2(getNoopResult(value));
    }
  }
  /** Update the `animation.to` value, which might be a `FluidValue` */
  _focus(value) {
    const anim = this.animation;
    if (value !== anim.to) {
      if (getFluidObservers(this)) {
        this._detach();
      }
      anim.to = value;
      if (getFluidObservers(this)) {
        this._attach();
      }
    }
  }
  _attach() {
    let priority2 = 0;
    const { to: to2 } = this.animation;
    if (hasFluidValue(to2)) {
      addFluidObserver(to2, this);
      if (isFrameValue(to2)) {
        priority2 = to2.priority + 1;
      }
    }
    this.priority = priority2;
  }
  _detach() {
    const { to: to2 } = this.animation;
    if (hasFluidValue(to2)) {
      removeFluidObserver(to2, this);
    }
  }
  /**
   * Update the current value from outside the frameloop,
   * and return the `Animated` node.
   */
  _set(arg, idle = true) {
    const value = getFluidValue(arg);
    if (!is.und(value)) {
      const oldNode = getAnimated(this);
      if (!oldNode || !isEqual(value, oldNode.getValue())) {
        const nodeType = getAnimatedType(value);
        if (!oldNode || oldNode.constructor != nodeType) {
          setAnimated(this, nodeType.create(value));
        } else {
          oldNode.setValue(value);
        }
        if (oldNode) {
          raf.batchedUpdates(() => {
            this._onChange(value, idle);
          });
        }
      }
    }
    return getAnimated(this);
  }
  _onStart() {
    const anim = this.animation;
    if (!anim.changed) {
      anim.changed = true;
      sendEvent(
        this,
        "onStart",
        getFinishedResult(this, checkFinished(this, anim.to)),
        this
      );
    }
  }
  _onChange(value, idle) {
    if (!idle) {
      this._onStart();
      callProp(this.animation.onChange, value, this);
    }
    callProp(this.defaultProps.onChange, value, this);
    super._onChange(value, idle);
  }
  // This method resets the animation state (even if already animating) to
  // ensure the latest from/to range is used, and it also ensures this spring
  // is added to the frameloop.
  _start() {
    const anim = this.animation;
    getAnimated(this).reset(getFluidValue(anim.to));
    if (!anim.immediate) {
      anim.fromValues = anim.values.map((node2) => node2.lastPosition);
    }
    if (!isAnimating(this)) {
      setActiveBit(this, true);
      if (!isPaused(this)) {
        this._resume();
      }
    }
  }
  _resume() {
    if (globals_exports.skipAnimation) {
      this.finish();
    } else {
      frameLoop.start(this);
    }
  }
  /**
   * Exit the frameloop and notify `onRest` listeners.
   *
   * Always wrap `_stop` calls with `batchedUpdates`.
   */
  _stop(goal, cancel) {
    if (isAnimating(this)) {
      setActiveBit(this, false);
      const anim = this.animation;
      each(anim.values, (node2) => {
        node2.done = true;
      });
      if (anim.toValues) {
        anim.onChange = anim.onPause = anim.onResume = void 0;
      }
      callFluidObservers(this, {
        type: "idle",
        parent: this
      });
      const result = cancel ? getCancelledResult(this.get()) : getFinishedResult(this.get(), checkFinished(this, goal ?? anim.to));
      flushCalls(this._pendingCalls, result);
      if (anim.changed) {
        anim.changed = false;
        sendEvent(this, "onRest", result, this);
      }
    }
  }
};
function checkFinished(target, to2) {
  const goal = computeGoal(to2);
  const value = computeGoal(target.get());
  return isEqual(value, goal);
}
function createLoopUpdate(props, loop2 = props.loop, to2 = props.to) {
  const loopRet = callProp(loop2);
  if (loopRet) {
    const overrides = loopRet !== true && inferTo(loopRet);
    const reverse = (overrides || props).reverse;
    const reset = !overrides || overrides.reset;
    return createUpdate({
      ...props,
      loop: loop2,
      // Avoid updating default props when looping.
      default: false,
      // Never loop the `pause` prop.
      pause: void 0,
      // For the "reverse" prop to loop as expected, the "to" prop
      // must be undefined. The "reverse" prop is ignored when the
      // "to" prop is an array or function.
      to: !reverse || isAsyncTo(to2) ? to2 : void 0,
      // Ignore the "from" prop except on reset.
      from: reset ? props.from : void 0,
      reset,
      // The "loop" prop can return a "useSpring" props object to
      // override any of the original props.
      ...overrides
    });
  }
}
function createUpdate(props) {
  const { to: to2, from: from2 } = props = inferTo(props);
  const keys2 = /* @__PURE__ */ new Set();
  if (is.obj(to2))
    findDefined(to2, keys2);
  if (is.obj(from2))
    findDefined(from2, keys2);
  props.keys = keys2.size ? Array.from(keys2) : null;
  return props;
}
function declareUpdate(props) {
  const update2 = createUpdate(props);
  if (is.und(update2.default)) {
    update2.default = getDefaultProps(update2);
  }
  return update2;
}
function findDefined(values, keys2) {
  eachProp(values, (value, key) => value != null && keys2.add(key));
}
var ACTIVE_EVENTS = [
  "onStart",
  "onRest",
  "onChange",
  "onPause",
  "onResume"
];
function mergeActiveFn(target, props, type2) {
  target.animation[type2] = props[type2] !== getDefaultProp(props, type2) ? resolveProp(props[type2], target.key) : void 0;
}
function sendEvent(target, type2, ...args) {
  var _a3, _b2, _c2, _d2;
  (_b2 = (_a3 = target.animation)[type2]) == null ? void 0 : _b2.call(_a3, ...args);
  (_d2 = (_c2 = target.defaultProps)[type2]) == null ? void 0 : _d2.call(_c2, ...args);
}
var BATCHED_EVENTS = ["onStart", "onChange", "onRest"];
var nextId2 = 1;
var Controller = class {
  constructor(props, flush3) {
    this.id = nextId2++;
    this.springs = {};
    this.queue = [];
    this._lastAsyncId = 0;
    this._active = /* @__PURE__ */ new Set();
    this._changed = /* @__PURE__ */ new Set();
    this._started = false;
    this._state = {
      paused: false,
      pauseQueue: /* @__PURE__ */ new Set(),
      resumeQueue: /* @__PURE__ */ new Set(),
      timeouts: /* @__PURE__ */ new Set()
    };
    this._events = {
      onStart: /* @__PURE__ */ new Map(),
      onChange: /* @__PURE__ */ new Map(),
      onRest: /* @__PURE__ */ new Map()
    };
    this._onFrame = this._onFrame.bind(this);
    if (flush3) {
      this._flush = flush3;
    }
    if (props) {
      this.start({ default: true, ...props });
    }
  }
  /**
   * Equals `true` when no spring values are in the frameloop, and
   * no async animation is currently active.
   */
  get idle() {
    return !this._state.asyncTo && Object.values(this.springs).every((spring) => {
      return spring.idle && !spring.isDelayed && !spring.isPaused;
    });
  }
  get item() {
    return this._item;
  }
  set item(item) {
    this._item = item;
  }
  /** Get the current values of our springs */
  get() {
    const values = {};
    this.each((spring, key) => values[key] = spring.get());
    return values;
  }
  /** Set the current values without animating. */
  set(values) {
    for (const key in values) {
      const value = values[key];
      if (!is.und(value)) {
        this.springs[key].set(value);
      }
    }
  }
  /** Push an update onto the queue of each value. */
  update(props) {
    if (props) {
      this.queue.push(createUpdate(props));
    }
    return this;
  }
  /**
   * Start the queued animations for every spring, and resolve the returned
   * promise once all queued animations have finished or been cancelled.
   *
   * When you pass a queue (instead of nothing), that queue is used instead of
   * the queued animations added with the `update` method, which are left alone.
   */
  start(props) {
    let { queue } = this;
    if (props) {
      queue = toArray(props).map(createUpdate);
    } else {
      this.queue = [];
    }
    if (this._flush) {
      return this._flush(this, queue);
    }
    prepareKeys(this, queue);
    return flushUpdateQueue(this, queue);
  }
  /** @internal */
  stop(arg, keys2) {
    if (arg !== !!arg) {
      keys2 = arg;
    }
    if (keys2) {
      const springs = this.springs;
      each(toArray(keys2), (key) => springs[key].stop(!!arg));
    } else {
      stopAsync(this._state, this._lastAsyncId);
      this.each((spring) => spring.stop(!!arg));
    }
    return this;
  }
  /** Freeze the active animation in time */
  pause(keys2) {
    if (is.und(keys2)) {
      this.start({ pause: true });
    } else {
      const springs = this.springs;
      each(toArray(keys2), (key) => springs[key].pause());
    }
    return this;
  }
  /** Resume the animation if paused. */
  resume(keys2) {
    if (is.und(keys2)) {
      this.start({ pause: false });
    } else {
      const springs = this.springs;
      each(toArray(keys2), (key) => springs[key].resume());
    }
    return this;
  }
  /** Call a function once per spring value */
  each(iterator) {
    eachProp(this.springs, iterator);
  }
  /** @internal Called at the end of every animation frame */
  _onFrame() {
    const { onStart, onChange, onRest } = this._events;
    const active = this._active.size > 0;
    const changed = this._changed.size > 0;
    if (active && !this._started || changed && !this._started) {
      this._started = true;
      flush(onStart, ([onStart2, result]) => {
        result.value = this.get();
        onStart2(result, this, this._item);
      });
    }
    const idle = !active && this._started;
    const values = changed || idle && onRest.size ? this.get() : null;
    if (changed && onChange.size) {
      flush(onChange, ([onChange2, result]) => {
        result.value = values;
        onChange2(result, this, this._item);
      });
    }
    if (idle) {
      this._started = false;
      flush(onRest, ([onRest2, result]) => {
        result.value = values;
        onRest2(result, this, this._item);
      });
    }
  }
  /** @internal */
  eventObserved(event) {
    if (event.type == "change") {
      this._changed.add(event.parent);
      if (!event.idle) {
        this._active.add(event.parent);
      }
    } else if (event.type == "idle") {
      this._active.delete(event.parent);
    } else
      return;
    raf.onFrame(this._onFrame);
  }
};
function flushUpdateQueue(ctrl, queue) {
  return Promise.all(queue.map((props) => flushUpdate(ctrl, props))).then(
    (results) => getCombinedResult(ctrl, results)
  );
}
async function flushUpdate(ctrl, props, isLoop) {
  const { keys: keys2, to: to2, from: from2, loop: loop2, onRest, onResolve } = props;
  const defaults2 = is.obj(props.default) && props.default;
  if (loop2) {
    props.loop = false;
  }
  if (to2 === false)
    props.to = null;
  if (from2 === false)
    props.from = null;
  const asyncTo = is.arr(to2) || is.fun(to2) ? to2 : void 0;
  if (asyncTo) {
    props.to = void 0;
    props.onRest = void 0;
    if (defaults2) {
      defaults2.onRest = void 0;
    }
  } else {
    each(BATCHED_EVENTS, (key) => {
      const handler = props[key];
      if (is.fun(handler)) {
        const queue = ctrl["_events"][key];
        props[key] = ({ finished, cancelled }) => {
          const result2 = queue.get(handler);
          if (result2) {
            if (!finished)
              result2.finished = false;
            if (cancelled)
              result2.cancelled = true;
          } else {
            queue.set(handler, {
              value: null,
              finished: finished || false,
              cancelled: cancelled || false
            });
          }
        };
        if (defaults2) {
          defaults2[key] = props[key];
        }
      }
    });
  }
  const state = ctrl["_state"];
  if (props.pause === !state.paused) {
    state.paused = props.pause;
    flushCalls(props.pause ? state.pauseQueue : state.resumeQueue);
  } else if (state.paused) {
    props.pause = true;
  }
  const promises = (keys2 || Object.keys(ctrl.springs)).map(
    (key) => ctrl.springs[key].start(props)
  );
  const cancel = props.cancel === true || getDefaultProp(props, "cancel") === true;
  if (asyncTo || cancel && state.asyncId) {
    promises.push(
      scheduleProps(++ctrl["_lastAsyncId"], {
        props,
        state,
        actions: {
          pause: noop,
          resume: noop,
          start(props2, resolve2) {
            if (cancel) {
              stopAsync(state, ctrl["_lastAsyncId"]);
              resolve2(getCancelledResult(ctrl));
            } else {
              props2.onRest = onRest;
              resolve2(
                runAsync(
                  asyncTo,
                  props2,
                  state,
                  ctrl
                )
              );
            }
          }
        }
      })
    );
  }
  if (state.paused) {
    await new Promise((resume) => {
      state.resumeQueue.add(resume);
    });
  }
  const result = getCombinedResult(ctrl, await Promise.all(promises));
  if (loop2 && result.finished && !(isLoop && result.noop)) {
    const nextProps = createLoopUpdate(props, loop2, to2);
    if (nextProps) {
      prepareKeys(ctrl, [nextProps]);
      return flushUpdate(ctrl, nextProps, true);
    }
  }
  if (onResolve) {
    raf.batchedUpdates(() => onResolve(result, ctrl, ctrl.item));
  }
  return result;
}
function getSprings(ctrl, props) {
  const springs = { ...ctrl.springs };
  if (props) {
    each(toArray(props), (props2) => {
      if (is.und(props2.keys)) {
        props2 = createUpdate(props2);
      }
      if (!is.obj(props2.to)) {
        props2 = { ...props2, to: void 0 };
      }
      prepareSprings(springs, props2, (key) => {
        return createSpring(key);
      });
    });
  }
  setSprings(ctrl, springs);
  return springs;
}
function setSprings(ctrl, springs) {
  eachProp(springs, (spring, key) => {
    if (!ctrl.springs[key]) {
      ctrl.springs[key] = spring;
      addFluidObserver(spring, ctrl);
    }
  });
}
function createSpring(key, observer) {
  const spring = new SpringValue();
  spring.key = key;
  if (observer) {
    addFluidObserver(spring, observer);
  }
  return spring;
}
function prepareSprings(springs, props, create3) {
  if (props.keys) {
    each(props.keys, (key) => {
      const spring = springs[key] || (springs[key] = create3(key));
      spring["_prepareNode"](props);
    });
  }
}
function prepareKeys(ctrl, queue) {
  each(queue, (props) => {
    prepareSprings(ctrl.springs, props, (key) => {
      return createSpring(key, ctrl);
    });
  });
}
var SpringContext = ({
  children,
  ...props
}) => {
  const inherited = P$1(ctx);
  const pause = props.pause || !!inherited.pause, immediate = props.immediate || !!inherited.immediate;
  props = useMemoOne(() => ({ pause, immediate }), [pause, immediate]);
  const { Provider: Provider2 } = ctx;
  return /* @__PURE__ */ y$3(Provider2, { value: props }, children);
};
var ctx = makeContext(SpringContext, {});
SpringContext.Provider = ctx.Provider;
SpringContext.Consumer = ctx.Consumer;
function makeContext(target, init) {
  Object.assign(target, E$2(init));
  target.Provider._context = target;
  target.Consumer._context = target;
  return target;
}
var SpringRef = () => {
  const current = [];
  const SpringRef2 = function(props) {
    deprecateDirectCall();
    const results = [];
    each(current, (ctrl, i) => {
      if (is.und(props)) {
        results.push(ctrl.start());
      } else {
        const update2 = _getProps(props, ctrl, i);
        if (update2) {
          results.push(ctrl.start(update2));
        }
      }
    });
    return results;
  };
  SpringRef2.current = current;
  SpringRef2.add = function(ctrl) {
    if (!current.includes(ctrl)) {
      current.push(ctrl);
    }
  };
  SpringRef2.delete = function(ctrl) {
    const i = current.indexOf(ctrl);
    if (~i)
      current.splice(i, 1);
  };
  SpringRef2.pause = function() {
    each(current, (ctrl) => ctrl.pause(...arguments));
    return this;
  };
  SpringRef2.resume = function() {
    each(current, (ctrl) => ctrl.resume(...arguments));
    return this;
  };
  SpringRef2.set = function(values) {
    each(current, (ctrl, i) => {
      const update2 = is.fun(values) ? values(i, ctrl) : values;
      if (update2) {
        ctrl.set(update2);
      }
    });
  };
  SpringRef2.start = function(props) {
    const results = [];
    each(current, (ctrl, i) => {
      if (is.und(props)) {
        results.push(ctrl.start());
      } else {
        const update2 = this._getProps(props, ctrl, i);
        if (update2) {
          results.push(ctrl.start(update2));
        }
      }
    });
    return results;
  };
  SpringRef2.stop = function() {
    each(current, (ctrl) => ctrl.stop(...arguments));
    return this;
  };
  SpringRef2.update = function(props) {
    each(current, (ctrl, i) => ctrl.update(this._getProps(props, ctrl, i)));
    return this;
  };
  const _getProps = function(arg, ctrl, index2) {
    return is.fun(arg) ? arg(index2, ctrl) : arg;
  };
  SpringRef2._getProps = _getProps;
  return SpringRef2;
};
function useSprings(length2, props, deps) {
  const propsFn = is.fun(props) && props;
  if (propsFn && !deps)
    deps = [];
  const ref2 = q$2(
    () => propsFn || arguments.length == 3 ? SpringRef() : void 0,
    []
  );
  const layoutId = F$1(0);
  const forceUpdate = useForceUpdate();
  const state = q$2(
    () => ({
      ctrls: [],
      queue: [],
      flush(ctrl, updates2) {
        const springs2 = getSprings(ctrl, updates2);
        const canFlushSync = layoutId.current > 0 && !state.queue.length && !Object.keys(springs2).some((key) => !ctrl.springs[key]);
        return canFlushSync ? flushUpdateQueue(ctrl, updates2) : new Promise((resolve2) => {
          setSprings(ctrl, springs2);
          state.queue.push(() => {
            resolve2(flushUpdateQueue(ctrl, updates2));
          });
          forceUpdate();
        });
      }
    }),
    []
  );
  const ctrls = F$1([...state.ctrls]);
  const updates = [];
  const prevLength = usePrev(length2) || 0;
  q$2(() => {
    each(ctrls.current.slice(length2, prevLength), (ctrl) => {
      detachRefs(ctrl, ref2);
      ctrl.stop(true);
    });
    ctrls.current.length = length2;
    declareUpdates(prevLength, length2);
  }, [length2]);
  q$2(() => {
    declareUpdates(0, Math.min(prevLength, length2));
  }, deps);
  function declareUpdates(startIndex, endIndex) {
    for (let i = startIndex; i < endIndex; i++) {
      const ctrl = ctrls.current[i] || (ctrls.current[i] = new Controller(null, state.flush));
      const update2 = propsFn ? propsFn(i, ctrl) : props[i];
      if (update2) {
        updates[i] = declareUpdate(update2);
      }
    }
  }
  const springs = ctrls.current.map((ctrl, i) => getSprings(ctrl, updates[i]));
  const context = P$1(SpringContext);
  const prevContext = usePrev(context);
  const hasContext = context !== prevContext && hasProps(context);
  useIsomorphicLayoutEffect(() => {
    layoutId.current++;
    state.ctrls = ctrls.current;
    const { queue } = state;
    if (queue.length) {
      state.queue = [];
      each(queue, (cb) => cb());
    }
    each(ctrls.current, (ctrl, i) => {
      ref2 == null ? void 0 : ref2.add(ctrl);
      if (hasContext) {
        ctrl.start({ default: context });
      }
      const update2 = updates[i];
      if (update2) {
        replaceRef(ctrl, update2.ref);
        if (ctrl.ref) {
          ctrl.queue.push(update2);
        } else {
          ctrl.start(update2);
        }
      }
    });
  });
  useOnce(() => () => {
    each(state.ctrls, (ctrl) => ctrl.stop(true));
  });
  const values = springs.map((x2) => ({ ...x2 }));
  return ref2 ? [values, ref2] : values;
}
function useSpring(props, deps) {
  const isFn = is.fun(props);
  const [[values], ref2] = useSprings(
    1,
    isFn ? props : [props],
    isFn ? deps || [] : deps
  );
  return isFn || arguments.length == 2 ? [values, ref2] : values;
}
var Interpolation = class extends FrameValue {
  constructor(source, args) {
    super();
    this.source = source;
    this.idle = true;
    this._active = /* @__PURE__ */ new Set();
    this.calc = createInterpolator(...args);
    const value = this._get();
    const nodeType = getAnimatedType(value);
    setAnimated(this, nodeType.create(value));
  }
  advance(_dt) {
    const value = this._get();
    const oldValue = this.get();
    if (!isEqual(value, oldValue)) {
      getAnimated(this).setValue(value);
      this._onChange(value, this.idle);
    }
    if (!this.idle && checkIdle(this._active)) {
      becomeIdle(this);
    }
  }
  _get() {
    const inputs = is.arr(this.source) ? this.source.map(getFluidValue) : toArray(getFluidValue(this.source));
    return this.calc(...inputs);
  }
  _start() {
    if (this.idle && !checkIdle(this._active)) {
      this.idle = false;
      each(getPayload(this), (node2) => {
        node2.done = false;
      });
      if (globals_exports.skipAnimation) {
        raf.batchedUpdates(() => this.advance());
        becomeIdle(this);
      } else {
        frameLoop.start(this);
      }
    }
  }
  // Observe our sources only when we're observed.
  _attach() {
    let priority2 = 1;
    each(toArray(this.source), (source) => {
      if (hasFluidValue(source)) {
        addFluidObserver(source, this);
      }
      if (isFrameValue(source)) {
        if (!source.idle) {
          this._active.add(source);
        }
        priority2 = Math.max(priority2, source.priority + 1);
      }
    });
    this.priority = priority2;
    this._start();
  }
  // Stop observing our sources once we have no observers.
  _detach() {
    each(toArray(this.source), (source) => {
      if (hasFluidValue(source)) {
        removeFluidObserver(source, this);
      }
    });
    this._active.clear();
    becomeIdle(this);
  }
  /** @internal */
  eventObserved(event) {
    if (event.type == "change") {
      if (event.idle) {
        this.advance();
      } else {
        this._active.add(event.parent);
        this._start();
      }
    } else if (event.type == "idle") {
      this._active.delete(event.parent);
    } else if (event.type == "priority") {
      this.priority = toArray(this.source).reduce(
        (highest, parent) => Math.max(highest, (isFrameValue(parent) ? parent.priority : 0) + 1),
        0
      );
    }
  }
};
function isIdle(source) {
  return source.idle !== false;
}
function checkIdle(active) {
  return !active.size || Array.from(active).every(isIdle);
}
function becomeIdle(self2) {
  if (!self2.idle) {
    self2.idle = true;
    each(getPayload(self2), (node2) => {
      node2.done = true;
    });
    callFluidObservers(self2, {
      type: "idle",
      parent: self2
    });
  }
}
globals_exports.assign({
  createStringInterpolator: createStringInterpolator2,
  to: (source, args) => new Interpolation(source, args)
});
var isCustomPropRE = /^--/;
function dangerousStyleValue(name2, value) {
  if (value == null || typeof value === "boolean" || value === "")
    return "";
  if (typeof value === "number" && value !== 0 && !isCustomPropRE.test(name2) && !(isUnitlessNumber.hasOwnProperty(name2) && isUnitlessNumber[name2]))
    return value + "px";
  return ("" + value).trim();
}
var attributeCache = {};
function applyAnimatedValues(instance, props) {
  if (!instance.nodeType || !instance.setAttribute) {
    return false;
  }
  const isFilterElement = instance.nodeName === "filter" || instance.parentNode && instance.parentNode.nodeName === "filter";
  const {
    className,
    style,
    children,
    scrollTop,
    scrollLeft,
    viewBox,
    ...attributes
  } = props;
  const values = Object.values(attributes);
  const names2 = Object.keys(attributes).map(
    (name2) => isFilterElement || instance.hasAttribute(name2) ? name2 : attributeCache[name2] || (attributeCache[name2] = name2.replace(
      /([A-Z])/g,
      // Attributes are written in dash case
      (n2) => "-" + n2.toLowerCase()
    ))
  );
  if (children !== void 0) {
    instance.textContent = children;
  }
  for (const name2 in style) {
    if (style.hasOwnProperty(name2)) {
      const value = dangerousStyleValue(name2, style[name2]);
      if (isCustomPropRE.test(name2)) {
        instance.style.setProperty(name2, value);
      } else {
        instance.style[name2] = value;
      }
    }
  }
  names2.forEach((name2, i) => {
    instance.setAttribute(name2, values[i]);
  });
  if (className !== void 0) {
    instance.className = className;
  }
  if (scrollTop !== void 0) {
    instance.scrollTop = scrollTop;
  }
  if (scrollLeft !== void 0) {
    instance.scrollLeft = scrollLeft;
  }
  if (viewBox !== void 0) {
    instance.setAttribute("viewBox", viewBox);
  }
}
var isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};
var prefixKey = (prefix2, key) => prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
var prefixes = ["Webkit", "Ms", "Moz", "O"];
isUnitlessNumber = Object.keys(isUnitlessNumber).reduce((acc, prop) => {
  prefixes.forEach((prefix2) => acc[prefixKey(prefix2, prop)] = acc[prop]);
  return acc;
}, isUnitlessNumber);
var domTransforms = /^(matrix|translate|scale|rotate|skew)/;
var pxTransforms = /^(translate)/;
var degTransforms = /^(rotate|skew)/;
var addUnit = (value, unit) => is.num(value) && value !== 0 ? value + unit : value;
var isValueIdentity = (value, id2) => is.arr(value) ? value.every((v2) => isValueIdentity(v2, id2)) : is.num(value) ? value === id2 : parseFloat(value) === id2;
var AnimatedStyle = class extends AnimatedObject {
  constructor({ x: x2, y: y2, z: z2, ...style }) {
    const inputs = [];
    const transforms = [];
    if (x2 || y2 || z2) {
      inputs.push([x2 || 0, y2 || 0, z2 || 0]);
      transforms.push((xyz) => [
        `translate3d(${xyz.map((v2) => addUnit(v2, "px")).join(",")})`,
        // prettier-ignore
        isValueIdentity(xyz, 0)
      ]);
    }
    eachProp(style, (value, key) => {
      if (key === "transform") {
        inputs.push([value || ""]);
        transforms.push((transform) => [transform, transform === ""]);
      } else if (domTransforms.test(key)) {
        delete style[key];
        if (is.und(value))
          return;
        const unit = pxTransforms.test(key) ? "px" : degTransforms.test(key) ? "deg" : "";
        inputs.push(toArray(value));
        transforms.push(
          key === "rotate3d" ? ([x22, y22, z22, deg]) => [
            `rotate3d(${x22},${y22},${z22},${addUnit(deg, unit)})`,
            isValueIdentity(deg, 0)
          ] : (input) => [
            `${key}(${input.map((v2) => addUnit(v2, unit)).join(",")})`,
            isValueIdentity(input, key.startsWith("scale") ? 1 : 0)
          ]
        );
      }
    });
    if (inputs.length) {
      style.transform = new FluidTransform(inputs, transforms);
    }
    super(style);
  }
};
var FluidTransform = class extends FluidValue {
  constructor(inputs, transforms) {
    super();
    this.inputs = inputs;
    this.transforms = transforms;
    this._value = null;
  }
  get() {
    return this._value || (this._value = this._get());
  }
  _get() {
    let transform = "";
    let identity2 = true;
    each(this.inputs, (input, i) => {
      const arg1 = getFluidValue(input[0]);
      const [t2, id2] = this.transforms[i](
        is.arr(arg1) ? arg1 : input.map(getFluidValue)
      );
      transform += " " + t2;
      identity2 = identity2 && id2;
    });
    return identity2 ? "none" : transform;
  }
  // Start observing our inputs once we have an observer.
  observerAdded(count) {
    if (count == 1)
      each(
        this.inputs,
        (input) => each(
          input,
          (value) => hasFluidValue(value) && addFluidObserver(value, this)
        )
      );
  }
  // Stop observing our inputs once we have no observers.
  observerRemoved(count) {
    if (count == 0)
      each(
        this.inputs,
        (input) => each(
          input,
          (value) => hasFluidValue(value) && removeFluidObserver(value, this)
        )
      );
  }
  eventObserved(event) {
    if (event.type == "change") {
      this._value = null;
    }
    callFluidObservers(this, event);
  }
};
var primitives = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
];
globals_exports.assign({
  batchedUpdates: pn,
  createStringInterpolator: createStringInterpolator2,
  colors: colors2
});
var host = createHost(primitives, {
  applyAnimatedValues,
  createAnimatedStyle: (style) => new AnimatedStyle(style),
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getComponentProps: ({ scrollTop, scrollLeft, ...props }) => props
});
var animated = host.animated;
const getProductKey = ({
  apiKey: apiKey2,
  id: id2
}) => {
  return ["product", { apiKey: apiKey2, id: id2 ?? "" }];
};
const useGetProduct = ({
  apiKey: apiKey2,
  id: id2,
  locale: locale2,
  countryCode: countryCode2,
  onSuccess,
  onError
}) => {
  const key = getProductKey({ apiKey: apiKey2, id: id2 });
  const onMutationSuccess = (data) => {
    onSuccess == null ? void 0 : onSuccess(data);
  };
  return useQuery(
    key,
    async () => getProduct({
      apiKey: apiKey2,
      id: id2,
      locale: locale2,
      countryCode: countryCode2
    }),
    {
      onSuccess: onMutationSuccess,
      onError
    }
  );
};
const useSaveAnswerQualificationQuestion = ({
  onSuccess,
  onError
} = {}) => {
  const onMutationError = (error2) => {
    onError == null ? void 0 : onError(error2);
  };
  return useMutation(
    async ({
      apiKey: apiKey2,
      aiMessageId,
      answer,
      userId: userId2,
      language: language2,
      locale: locale2,
      countryCode: countryCode2,
      sessionId
    }) => saveAnswerQualificationQuestion({
      apiKey: apiKey2,
      aiMessageId,
      answer,
      userId: userId2,
      sessionId,
      language: language2,
      locale: locale2,
      countryCode: countryCode2
    }),
    {
      onSuccess,
      onError: onMutationError
    }
  );
};
const useSendFeedback = ({
  onSuccess,
  onError
} = {}) => {
  const onMutationSuccess = () => {
    if (onSuccess) {
      onSuccess();
    }
  };
  const onMutationError = () => {
    if (onError) {
      onError();
    }
  };
  return useMutation(
    async ({
      apiKey: apiKey2,
      value,
      sessionId,
      messageId,
      userId: userId2
    }) => sendFeedback({ apiKey: apiKey2, value, userId: userId2, sessionId, messageId }),
    {
      onSuccess: onMutationSuccess,
      onError: onMutationError
    }
  );
};
const getDiagnosticPictureUrlKey = ({
  apiKey: apiKey2,
  userId: userId2
}) => {
  return ["diagnostic-picture-url", { apiKey: apiKey2, userId: userId2 }];
};
const useGetDiagnosticPictureUrl = ({
  apiKey: apiKey2,
  userId: userId2,
  sessionId,
  language: language2,
  locale: locale2,
  countryCode: countryCode2,
  onSuccess,
  onError
}) => {
  const key = getDiagnosticPictureUrlKey({ apiKey: apiKey2, userId: userId2 });
  const onMutationSuccess = (data) => {
    onSuccess == null ? void 0 : onSuccess(data);
  };
  return useQuery(
    key,
    async () => getDiagnosticPictureUrl({
      apiKey: apiKey2,
      userId: userId2,
      sessionId,
      language: language2,
      locale: locale2,
      countryCode: countryCode2
    }),
    {
      onSuccess: onMutationSuccess,
      onError
    }
  );
};
const useUploadPicture = ({
  onSuccess
} = {}) => {
  const onMutationSuccess = (data, variables) => {
    if (onSuccess) {
      onSuccess(data, variables);
    }
  };
  return useMutation(
    async ({ path: path2, file, fields }) => uploadPicture({
      path: path2,
      file,
      fields
    }),
    {
      onSuccess: onMutationSuccess
    }
  );
};
const Feedbacks = ({
  messageId
}) => {
  const { apiKey: apiKey2, userId: userId2, getSessionId } = useAssistantMessages();
  const { isWriting, isLoadingToWrite, displayFeedbacks } = useAssistantState();
  const sendFeedback2 = useSendFeedback();
  const [clicked, setClicked] = p$1(false);
  const [animationTriggered, setAnimationTriggered] = p$1(false);
  const [hideFeedback, setHideFeedback] = p$1(true);
  const handleFeedback = (value) => {
    sendFeedback2.mutate({
      messageId,
      apiKey: apiKey2,
      value,
      sessionId: getSessionId(),
      userId: userId2
    });
    setClicked(true);
  };
  const feedbackAnimation = useSpring({
    opacity: clicked ? 0 : animationTriggered ? 1 : 0,
    config: {
      duration: 500
    },
    delay: animationTriggered ? 800 : 0,
    onRest: () => {
      if (clicked) {
        setHideFeedback(true);
      }
    }
  });
  _(() => {
    if (displayFeedbacks === true) {
      setHideFeedback(false);
      setAnimationTriggered(true);
    }
  }, [displayFeedbacks]);
  if (isWriting === true || isLoadingToWrite === true || hideFeedback)
    return /* @__PURE__ */ jsx2(Fragment, {});
  return /* @__PURE__ */ jsxs(
    animated.div,
    {
      style: feedbackAnimation,
      css: css({
        display: "flex",
        alignItem: "center",
        gap: spacings.xs
      }),
      children: [
        /* @__PURE__ */ jsx2(
          Button,
          {
            variant: "secondary",
            size: "sm",
            iconLeft: /* @__PURE__ */ jsx2(ThumbUpIcon, {}),
            labelCss: css({
              fontSize: `${theme.typography.body3.fontSize}px`
            }),
            onClick: () => handleFeedback(1),
            children: /* @__PURE__ */ jsx2(MemoizedFormattedMessage, { id: "useful" })
          }
        ),
        /* @__PURE__ */ jsx2(
          Button,
          {
            variant: "secondary",
            size: "sm",
            iconLeft: /* @__PURE__ */ jsx2(ThumbDownIcon, {}),
            onClick: () => handleFeedback(0),
            labelCss: css({
              fontSize: `${theme.typography.body3.fontSize}px`
            }),
            children: /* @__PURE__ */ jsx2(MemoizedFormattedMessage, { id: "useless" })
          }
        )
      ]
    }
  );
};
const AssistantChatShoppingMessageWrapper = ({
  children,
  customCss
}) => /* @__PURE__ */ jsx2(
  "div",
  {
    css: [
      css({
        position: "relative",
        alignSelf: "flex-start",
        display: "flex",
        gap: spacings.md,
        flexDirection: "column",
        width: "100%",
        overflow: "hidden"
      }),
      customCss
    ],
    children
  }
);
const AssistantText = ({
  children,
  customCss
}) => /* @__PURE__ */ jsx2(
  "pre",
  {
    css: [
      css({
        margin: 0,
        whiteSpace: "normal",
        flex: 1,
        lineHeight: theme.typography.body2.lineHeight,
        padding: 0,
        background: "unset",
        gap: spacings.xs
      }),
      customCss
    ],
    children: /* @__PURE__ */ jsx2(
      Typography,
      {
        variant: "md-paragraph",
        color: theme.palette.classic.black,
        customCss: css({
          width: "100%",
          lineHeight: theme.typography.body2.lineHeight,
          fontSize: `${theme.typography.h3.fontSize}px`,
          display: "flex",
          flexDirection: "column",
          gap: spacings.sm,
          [`@media screen and (max-width: ${TABLET_BP})`]: {
            fontSize: `${theme.typography.body2.fontSize}px`
          }
        }),
        children
      }
    )
  }
);
const DialogOrOrganizationIcon = ({
  size,
  rounded
}) => {
  const { config: config2 } = useDialogConfig();
  if ((config2 == null ? void 0 : config2.bookmarkLogoUrl) !== void 0) {
    return /* @__PURE__ */ jsx2(
      "img",
      {
        css: css({
          width: `${size}px`,
          minWidth: `${size}px`,
          height: `${size}px`,
          borderRadius: rounded === true ? "50%" : theme.borderRadius.md
        }),
        src: config2.bookmarkLogoUrl,
        alt: "organization-logo"
      }
    );
  }
  return /* @__PURE__ */ jsx2(
    "div",
    {
      css: css({
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        borderRadius: rounded === true ? "50%" : theme.borderRadius.md,
        width: `${size}px`,
        minWidth: `${size}px`,
        height: `${size}px`,
        background: theme.palette.classic.black
      }),
      children: /* @__PURE__ */ jsx2(
        DialogIconBlank,
        {
          color: theme.palette.classic.white,
          customCss: css({
            width: `20px`,
            height: `20px`,
            background: "black",
            borderRadius: rounded === true ? "50%" : theme.borderRadius.md
          })
        }
      )
    }
  );
};
const SKELETON_MOBILE_COUNT = 2;
const SKELETON_DESKTOP_COUNT = 3;
const RecommendationSkeleton = () => {
  const isMobile = useIsMobile({ size: MEDIUM_MOBILE_NUMBER });
  return /* @__PURE__ */ jsx2(
    "div",
    {
      css: css({
        position: "relative",
        display: "flex",
        width: "100%",
        gap: spacings.md,
        justifyContent: "center"
      }),
      children: Array(isMobile ? SKELETON_MOBILE_COUNT : SKELETON_DESKTOP_COUNT).fill(void 0).map((_2, index2) => /* @__PURE__ */ jsxs(
        "div",
        {
          css: css({
            display: "flex",
            flexDirection: "column",
            alignItems: "flex-start",
            width: "145px",
            height: "100%",
            gap: spacings.md
          }),
          children: [
            /* @__PURE__ */ jsx2(
              "div",
              {
                css: [
                  skeletonAnimationStyle,
                  css({
                    width: "100%",
                    height: "145px",
                    "&:empty": { display: "block" }
                  })
                ]
              }
            ),
            /* @__PURE__ */ jsxs(
              "div",
              {
                css: css({
                  width: "100%",
                  height: "40px",
                  display: "flex",
                  flexDirection: "column",
                  gap: spacings.xs
                }),
                children: [
                  /* @__PURE__ */ jsx2(
                    "div",
                    {
                      css: [
                        skeletonAnimationStyle,
                        css({
                          width: "80%",
                          height: "18px",
                          "&:empty": { display: "block" }
                        })
                      ]
                    }
                  ),
                  /* @__PURE__ */ jsx2(
                    "div",
                    {
                      css: [
                        skeletonAnimationStyle,
                        css({
                          width: "30%",
                          height: "18px",
                          "&:empty": { display: "block" }
                        })
                      ]
                    }
                  )
                ]
              }
            )
          ]
        },
        index2
      ))
    }
  );
};
const ProductImage = ({
  url,
  width,
  height,
  customCss,
  children,
  withBorder = true
}) => {
  return /* @__PURE__ */ jsx2(
    "div",
    {
      css: [
        css({
          width: width !== void 0 ? `${width}px` : "100%",
          height: height !== void 0 ? `${height}px` : "100%",
          background: `url("${url}")`,
          backgroundPosition: "center",
          backgroundRepeat: "no-repeat",
          backgroundSize: "contain",
          borderRadius: theme.borderRadius.lg,
          border: withBorder ? `1px solid #F4F0F4` : "unset",
          "&:empty": {
            display: "block"
          }
        }),
        customCss
      ],
      children
    }
  );
};
const buildTranslatedTitle = (product, selectedVariant, onlySimpleTitle) => {
  var _a3, _b2, _c2;
  const productTranslatedTitle = (_a3 = product.translations) == null ? void 0 : _a3.find(
    (translation) => translation.key === "title"
  );
  if (onlySimpleTitle === true) {
    return product.title;
  }
  if (productTranslatedTitle === void 0) {
    const defaultTitle = ((_b2 = selectedVariant == null ? void 0 : selectedVariant.displayName) == null ? void 0 : _b2.match(/Default Title/g)) !== null ? product.title : selectedVariant.displayName;
    return defaultTitle;
  }
  let formattedTitle = productTranslatedTitle.value;
  const selectedOptionsValues = (_c2 = selectedVariant == null ? void 0 : selectedVariant.selectedOptions) == null ? void 0 : _c2.filter((opt) => opt.name !== "Title").map((option) => option.value);
  selectedOptionsValues == null ? void 0 : selectedOptionsValues.forEach((originalValue, index2) => {
    var _a4;
    const currentOptionField = `option${index2 + 1}`;
    const translatedValue = (_a4 = selectedVariant == null ? void 0 : selectedVariant.translations) == null ? void 0 : _a4.find(
      (translation) => translation.key === currentOptionField
    );
    formattedTitle += `${index2 === 0 ? " - " : " / "} ${translatedValue !== void 0 ? translatedValue.value : originalValue}`;
  });
  return formattedTitle;
};
const isZeroPrice = (price) => {
  return price === "0.00" || price === "0.0" || price === "0";
};
const ProductMainInformations = ({
  enableLightColor = false,
  onlySimpleTitle = false,
  priceFirst = false,
  product,
  selectedVariantId,
  customTitleStyle
}) => {
  const { countryCode: countryCode2, languageIsoCode: languageIsoCode2 } = useLocalization();
  const selectedVariant = product.variants.find(
    (variant) => formatProductVariantId(variant.id) === selectedVariantId
  ) ?? product.variants[0];
  const priceFormatted = priceFormatter(
    selectedVariant == null ? void 0 : selectedVariant.price,
    selectedVariant == null ? void 0 : selectedVariant.currencyCode,
    `${languageIsoCode2}-${countryCode2}`
  );
  const compareAtPriceFormatted = isZeroPrice(selectedVariant == null ? void 0 : selectedVariant.compareAtPrice) ? void 0 : priceFormatter(
    selectedVariant == null ? void 0 : selectedVariant.compareAtPrice,
    selectedVariant == null ? void 0 : selectedVariant.currencyCode,
    `${languageIsoCode2}-${countryCode2}`
  );
  const title2 = buildTranslatedTitle(product, selectedVariant, onlySimpleTitle);
  const price = /* @__PURE__ */ jsxs("div", { css: css({ display: "flex", gap: spacings.md, fontWeight: 400 }), children: [
    compareAtPriceFormatted !== void 0 && compareAtPriceFormatted !== priceFormatted && /* @__PURE__ */ jsx2(
      Typography,
      {
        customCss: css({ textDecoration: "line-through" }),
        variant: "xs-xs",
        color: enableLightColor ? theme.palette.classic.white : theme.palette.grey400,
        children: compareAtPriceFormatted
      }
    ),
    /* @__PURE__ */ jsx2(
      Typography,
      {
        variant: "xs-xs",
        color: enableLightColor ? theme.palette.classic.white : theme.palette.grey600,
        customCss: css({ fontWeight: 400 }),
        children: priceFormatted
      }
    )
  ] });
  if (priceFirst) {
    return /* @__PURE__ */ jsxs(
      "div",
      {
        css: css({
          display: "flex",
          flexDirection: "column"
        }),
        children: [
          price,
          /* @__PURE__ */ jsx2(
            Typography,
            {
              variant: "xs-lg",
              customCss: customTitleStyle,
              color: enableLightColor ? theme.palette.classic.white : theme.palette.classic.black,
              children: title2
            }
          )
        ]
      }
    );
  }
  return /* @__PURE__ */ jsxs(
    "div",
    {
      css: css({
        display: "flex",
        flexDirection: "column"
      }),
      children: [
        /* @__PURE__ */ jsx2(
          Typography,
          {
            variant: "xs-lg",
            customCss: customTitleStyle,
            color: enableLightColor ? theme.palette.classic.white : theme.palette.classic.black,
            children: title2
          }
        ),
        price
      ]
    }
  );
};
const getOptionsValue = (currentSelectedOptions, field) => {
  const selectedOption = currentSelectedOptions.find(
    ({ name: name2 }) => name2 === field
  );
  return (selectedOption == null ? void 0 : selectedOption.value) ?? "";
};
const getVariantId = (currentSelectedOptions, variants) => {
  const variantFound = variants.find((variant) => {
    if (variant.selectedOptions !== void 0) {
      const isSelectedVariant = variant.selectedOptions.every((option) => {
        const currentOption = currentSelectedOptions.find(
          (currentSelectedOption) => currentSelectedOption.name === option.name
        );
        return currentOption !== void 0 && option.value === currentOption.value;
      });
      return isSelectedVariant;
    }
    return false;
  });
  return variantFound == null ? void 0 : variantFound.id;
};
const getDefaultSelectedOptions = (currentVariantId, variants) => {
  const variant = variants.find(
    ({ id: id2 }) => formatProductVariantId(id2) === currentVariantId
  ) ?? variants[0];
  return (variant == null ? void 0 : variant.selectedOptions) ?? [];
};
const VariantSelection = ({
  enableCompactMode = false,
  options,
  selectedVariantId,
  variants,
  onChangeVariantId
}) => {
  const [currentSelectedOptions, setCurrentSelectedOptions] = p$1(getDefaultSelectedOptions(selectedVariantId, variants));
  const optionsSorted = options.sort(
    (optA, optB) => optA.position - optB.position
  );
  const handleVariantChange = (field, value) => {
    const newCurrentSelectedOptions = [...currentSelectedOptions];
    const selectedOptionIndex = newCurrentSelectedOptions.findIndex(
      (opt) => opt.name === field
    );
    newCurrentSelectedOptions.splice(selectedOptionIndex, 1);
    newCurrentSelectedOptions.push({ name: field, value });
    setCurrentSelectedOptions(newCurrentSelectedOptions);
    const newVariantId = getVariantId(newCurrentSelectedOptions, variants);
    onChangeVariantId(formatProductVariantId(newVariantId ?? ""));
  };
  const outOfStockVariants = variants.filter(
    (variant) => variant.inventoryQuantity === 0
  );
  return /* @__PURE__ */ jsx2(
    "div",
    {
      css: css({ display: "flex", flexDirection: "column", gap: spacings.md }),
      children: optionsSorted.map((option) => {
        const opts = option.values.map((value) => ({ label: value, value })).filter((opt) => {
          if (options.length > 1) return true;
          const outOfStockOption = outOfStockVariants.find(
            (variant) => {
              var _a3;
              return Boolean(
                (_a3 = variant.selectedOptions) == null ? void 0 : _a3.find(
                  (selectedOption) => selectedOption.value === opt.value
                )
              );
            }
          );
          return outOfStockOption === void 0;
        });
        if (opts.length === 1) return /* @__PURE__ */ jsx2(Fragment, {});
        return /* @__PURE__ */ jsx2(
          ClassicSelect,
          {
            enableCompactMode,
            options: opts,
            name: option.name,
            id: option.name,
            selectedValue: getOptionsValue(currentSelectedOptions, option.name),
            onChange: (value) => handleVariantChange(option.name, value)
          },
          option.id
        );
      })
    }
  );
};
const RECOMMENDATION_DESKTOP_SIZE = 167;
const RECOMMENDATION_MOBILE_SIZE = 143;
const RECOMMENDATION_MOBILE_SMALL_SIZE = 130;
const useProductCardAddToCart = (selectedVariantId) => {
  const { handleAddToCart } = useAssistantMessages();
  const [isCheckedIcon, setIsCheckedIcon] = p$1(false);
  const { config: config2 } = useDialogConfig();
  const onAddToCart = async (event) => {
    event.stopPropagation();
    setIsCheckedIcon(true);
    setTimeout(() => {
      setIsCheckedIcon(false);
    }, 2e3);
    if (selectedVariantId !== void 0) {
      await handleAddToCart(selectedVariantId);
    }
  };
  const icons = {
    [AddToCartIcons.BAG]: /* @__PURE__ */ u$2(ShoppingBagIcon, { color: theme.palette.classic.black }),
    [AddToCartIcons.CART]: /* @__PURE__ */ u$2(ShoppingCartIcon, { color: theme.palette.classic.black })
  };
  const shoppingIcon = (config2 == null ? void 0 : config2.addToCartIcon) !== void 0 ? icons[config2.addToCartIcon] : icons[AddToCartIcons.CART];
  return {
    onAddToCart,
    icon: isCheckedIcon ? /* @__PURE__ */ u$2(CheckIcon, { color: theme.palette.classic.black }) : shoppingIcon
  };
};
const ProductCard = ({
  product,
  selectedVariantId,
  hasMultipleRecommendation = false
}) => {
  var _a3, _b2, _c2;
  const isMobile = useIsMobile({ size: MEDIUM_MOBILE_NUMBER });
  const [currentSelectedVariantId, setCurrentSelectedVariantId] = p$1(
    formatProductVariantId(
      selectedVariantId ?? product.variants[0].id
    )
  );
  const { openRecommendationDrawer } = useRecommendationDrawer();
  const { onAddToCart, icon } = useProductCardAddToCart(
    currentSelectedVariantId
  );
  const handleChangeVariantId = (newVariantIdSelected) => {
    if (newVariantIdSelected === void 0) return;
    setCurrentSelectedVariantId(formatProductVariantId(newVariantIdSelected));
  };
  const variantSelected = product.variants.find(
    (variant) => formatProductVariantId(variant.id) === formatProductVariantId(currentSelectedVariantId)
  );
  const handleProductClick = () => {
    openRecommendationDrawer(
      product,
      currentSelectedVariantId,
      variantSelected == null ? void 0 : variantSelected.title
    );
  };
  const selectedImage = ((_a3 = variantSelected == null ? void 0 : variantSelected.image) == null ? void 0 : _a3.url) ?? ((_b2 = product.featuredImage) == null ? void 0 : _b2.url) ?? "";
  const recommendationSize = hasMultipleRecommendation ? RECOMMENDATION_MOBILE_SMALL_SIZE : RECOMMENDATION_MOBILE_SIZE;
  const recommendationSizeStyle = `${recommendationSize}px`;
  return /* @__PURE__ */ jsxs(
    "div",
    {
      css: css({
        display: "flex",
        flexDirection: "column",
        alignSelf: "center",
        width: "100%",
        height: "100%",
        maxWidth: `${RECOMMENDATION_DESKTOP_SIZE}px`,
        maxHeight: `${RECOMMENDATION_DESKTOP_SIZE}px`,
        borderRadius: theme.borderRadius.lgx,
        justifyContent: "space-between",
        border: `1px solid ${theme.palette.grey100}`,
        background: theme.palette.classic.white,
        overflow: "hidden",
        [`@media screen and (max-width: ${MEDIUM_MOBILE_BP})`]: {
          maxWidth: recommendationSizeStyle,
          maxHeight: recommendationSizeStyle
        }
      }),
      children: [
        /* @__PURE__ */ jsx2(
          DivClickable,
          {
            customCss: css({
              position: "relative",
              cursor: "pointer",
              display: "flex",
              flexDirection: "column",
              alignSelf: "center",
              width: `${RECOMMENDATION_DESKTOP_SIZE}px`,
              height: `${RECOMMENDATION_DESKTOP_SIZE}px`,
              minHeight: `${RECOMMENDATION_DESKTOP_SIZE}px`,
              [`@media screen and (max-width: ${MEDIUM_MOBILE_BP})`]: {
                height: recommendationSizeStyle,
                minHeight: recommendationSizeStyle,
                maxWidth: recommendationSizeStyle
              }
            }),
            onClick: handleProductClick,
            children: /* @__PURE__ */ jsxs(Fragment, { children: [
              /* @__PURE__ */ jsx2(
                "div",
                {
                  id: "mask",
                  css: css({
                    "&:empty": {
                      display: "block"
                    },
                    position: "absolute",
                    top: 0,
                    left: 0,
                    width: "100%",
                    height: "100%",
                    background: "rgb(0 0 0 / 16%)",
                    zIndex: theme.zIndex.low
                  })
                }
              ),
              /* @__PURE__ */ jsx2(
                Button,
                {
                  disabled: (variantSelected == null ? void 0 : variantSelected.inventoryQuantity) === 0 || ((_c2 = product.variants[0]) == null ? void 0 : _c2.inventoryQuantity) === 0,
                  customCss: css({
                    zIndex: theme.zIndex.low + 2,
                    position: "absolute",
                    background: theme.palette.classic.white,
                    top: spacings.md,
                    right: spacings.md,
                    width: "40px",
                    minWidth: "40px",
                    height: "40px",
                    borderRadius: "100%",
                    border: `1px solid ${theme.palette.grey200}`
                  }),
                  variant: "blank",
                  iconLeft: icon,
                  onClick: onAddToCart
                }
              ),
              /* @__PURE__ */ jsx2(
                "div",
                {
                  css: css({
                    position: "absolute",
                    bottom: 0,
                    left: 0,
                    padding: spacings.md,
                    zIndex: theme.zIndex.low + 1
                  }),
                  children: /* @__PURE__ */ jsx2(
                    ProductMainInformations,
                    {
                      enableLightColor: true,
                      onlySimpleTitle: true,
                      priceFirst: true,
                      product,
                      selectedVariantId: currentSelectedVariantId
                    }
                  )
                }
              ),
              /* @__PURE__ */ jsx2(
                ProductImage,
                {
                  url: selectedImage,
                  width: isMobile ? recommendationSize : RECOMMENDATION_DESKTOP_SIZE,
                  height: isMobile ? recommendationSize : RECOMMENDATION_DESKTOP_SIZE,
                  customCss: css({
                    position: "absolute",
                    height: "100%",
                    left: 0,
                    top: 0,
                    zIndex: theme.zIndex.default,
                    margin: "0 auto",
                    borderRadius: "unset",
                    minWidth: "unset"
                  }),
                  withBorder: false
                }
              )
            ] })
          }
        ),
        product.totalVariants > 1 && /* @__PURE__ */ jsx2("div", { css: css({ padding: spacings.md, width: "100%" }), children: /* @__PURE__ */ jsx2(
          VariantSelection,
          {
            enableCompactMode: true,
            options: product.options ?? [],
            variants: product.variants,
            selectedVariantId: currentSelectedVariantId,
            onChangeVariantId: handleChangeVariantId
          }
        ) })
      ]
    }
  );
};
const MODAL_CUSTOM_EVENT = "enableDialogAssistantEvent";
const PRODUCT_QUESTION = "PRODUCT_QUESTION";
const GENERIC_QUESTION = "GENERIC_QUESTION";
const START_DIAGNOSTIC = "START_DIAGNOSTIC";
const modalEvents = [
  PRODUCT_QUESTION,
  GENERIC_QUESTION,
  START_DIAGNOSTIC
];
const isModalEvent = (event) => {
  const evt = event;
  if (evt.detail === void 0 || evt.detail === null || Object.keys(evt.detail).length === 0)
    return false;
  const detail = evt.detail;
  return modalEvents.includes(detail.type);
};
const isProductQuestionEvent = (event) => {
  return event.detail.type === PRODUCT_QUESTION;
};
const isStartDiagnosticEvent = (event) => {
  return event.detail.type === START_DIAGNOSTIC;
};
const isProductQuestionAnswerEvent = (event) => {
  return (
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    event.detail.type === PRODUCT_QUESTION && event.detail.payload.answer !== void 0
  );
};
const isGenericQuestionEvent = (event) => {
  return (
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    event.detail.type === GENERIC_QUESTION
  );
};
const useModalEvent = ({
  onEvent
}) => {
  const handleModalCustomEvent = x$2(
    (event) => {
      if (!isModalEvent(event)) return;
      onEvent(event);
    },
    [onEvent]
  );
  _(() => {
    window.addEventListener(MODAL_CUSTOM_EVENT, handleModalCustomEvent);
    return () => {
      window.removeEventListener(MODAL_CUSTOM_EVENT, handleModalCustomEvent);
    };
  }, [handleModalCustomEvent]);
};
const ModalStateContext = E$2({
  modalState: HIDDEN_STATE,
  setModalState: () => console.error("Modal state context is not well initialized"),
  modalHasBeenSeen: false,
  setModalHasBeenSeen: () => console.error("Modal state context is not well initialized")
});
const useModalState = () => P$1(ModalStateContext);
const initBookmarkHasBeenSeen = (existingValue) => {
  if (existingValue === void 0) {
    return {
      modalHasBeenSeen: false,
      expiry: Date.now() + 1e3 * 60 * 30
      // 30 minutes from now in milliseconds
    };
  }
  const isExpired = existingValue.expiry < Date.now();
  if (isExpired) {
    return {
      modalHasBeenSeen: false,
      expiry: Date.now() + 1e3 * 60 * 30
      // 30 minutes from now in milliseconds
    };
  }
  return existingValue;
};
const useModalHasBeenSeen = () => {
  const dialogLocalStorage = useLocalStorage();
  const [displayBookmarkInfo, setBookmarkInfo] = p$1(
    initBookmarkHasBeenSeen(dialogLocalStorage.storedValue.displayBookmarkInfo)
  );
  const setModalHasBeenSeen = x$2(() => {
    const valueWithExpiry = {
      modalHasBeenSeen: true,
      expiry: Date.now() + 1e3 * 60 * 30
      // 30 minutes from now in milliseconds
    };
    setBookmarkInfo(valueWithExpiry);
    dialogLocalStorage.dispatch({
      type: "modalHasBeenSeen",
      payload: valueWithExpiry
    });
  }, [dialogLocalStorage]);
  return [displayBookmarkInfo, setModalHasBeenSeen];
};
const ModalStateProvider = ({
  children
}) => {
  const [displayBookmarkInfo, setModalHasBeenSeen] = useModalHasBeenSeen();
  const [modalState, setModalState] = p$1(
    displayBookmarkInfo.modalHasBeenSeen ? BOOKMARK_STATE : HIDDEN_STATE
  );
  const contextValue = q$2(() => {
    return {
      modalState,
      setModalState,
      modalHasBeenSeen: displayBookmarkInfo.modalHasBeenSeen,
      setModalHasBeenSeen
    };
  }, [modalState, displayBookmarkInfo, setModalHasBeenSeen]);
  return /* @__PURE__ */ u$2(ModalStateContext.Provider, { value: contextValue, children });
};
const isValidLocation = (modalConfig) => {
  const path2 = document.location.pathname;
  const regex = new RegExp(modalConfig.location ?? ".*");
  return path2.match(regex) !== null;
};
const useModalTrigger = ({
  modalConfigs,
  onModalStateChange
}) => {
  const isDisplayed = F$1(false);
  const isScrolling = F$1(false);
  const scrollTimeout = F$1();
  const stopScrollingTimeout = F$1();
  const { modalHasBeenSeen } = useModalState();
  const handleScrollEvent = x$2(
    (modalConfig) => {
      return () => {
        if (!isScrolling.current) {
          isScrolling.current = true;
          scrollTimeout.current = setTimeout(() => {
            if (!isValidLocation(modalConfig) || isDisplayed.current) return;
            const newState = modalHasBeenSeen ? BOOKMARK_STATE : MODAL_STATE;
            isDisplayed.current = true;
            onModalStateChange(newState, modalConfig);
          }, modalConfig.duration);
        }
        clearTimeout(stopScrollingTimeout.current);
        stopScrollingTimeout.current = setTimeout(() => {
          isScrolling.current = false;
          clearTimeout(scrollTimeout.current);
        }, 200);
      };
    },
    [onModalStateChange, modalHasBeenSeen]
  );
  const handleOnLoadEvent = x$2(
    (modalConfig) => {
      return () => {
        if (!isValidLocation(modalConfig) || isDisplayed.current) return;
        const newState = modalHasBeenSeen ? BOOKMARK_STATE : MODAL_STATE;
        setTimeout(() => {
          isDisplayed.current = true;
          onModalStateChange(newState, modalConfig);
        }, modalConfig.duration);
      };
    },
    [isDisplayed, onModalStateChange, modalHasBeenSeen]
  );
  const handleInstantEvent = x$2(
    (modalConfig) => {
      if (isDisplayed.current || !isValidLocation(modalConfig)) return;
      const newState = modalHasBeenSeen ? BOOKMARK_STATE : MODAL_STATE;
      isDisplayed.current = true;
      setTimeout(() => {
        onModalStateChange(newState, modalConfig);
      }, modalConfig.duration);
    },
    [onModalStateChange, modalHasBeenSeen]
  );
  const subscribeEvents = x$2(
    (modalConfig) => {
      modalConfig.events.forEach((event) => {
        switch (event) {
          case INSTANT_EVENT:
            handleInstantEvent(modalConfig);
            break;
          case SCROLL_EVENT:
            window.addEventListener(event, handleScrollEvent(modalConfig));
            break;
          case ON_LOAD_EVENT:
            handleOnLoadEvent(modalConfig)();
            break;
        }
      });
    },
    [handleInstantEvent, handleOnLoadEvent, handleScrollEvent]
  );
  const cleanEvents = x$2(
    (modalConfig) => {
      modalConfig.events.forEach((event) => {
        switch (event) {
          case INSTANT_EVENT:
            break;
          case SCROLL_EVENT:
            window.removeEventListener(event, handleScrollEvent(modalConfig));
            break;
        }
      });
    },
    [handleScrollEvent]
  );
  _(() => {
    if (modalConfigs === void 0) return;
    modalConfigs.forEach((modalConfig) => subscribeEvents(modalConfig));
    return () => {
      modalConfigs.forEach((modalConfig) => cleanEvents(modalConfig));
    };
  }, [cleanEvents, modalConfigs, subscribeEvents]);
};
const Recommendation = ({
  recommendation,
  hasMultipleRecommendation
}) => {
  var _a3;
  const { productId } = useCurrentProductId();
  const localization = useLocalization();
  const { apiKey: apiKey2 } = useAssistantMessages();
  const getProductQuery = useGetProduct({
    apiKey: apiKey2,
    id: productId,
    locale: localization.languageIsoCode,
    countryCode: localization.countryCode
  });
  if (recommendation.id === ((_a3 = getProductQuery.data) == null ? void 0 : _a3.id) && !hasMultipleRecommendation) {
    return /* @__PURE__ */ jsx2(Fragment, {});
  }
  const mobileSize = hasMultipleRecommendation ? `${RECOMMENDATION_MOBILE_SMALL_SIZE}px` : `${RECOMMENDATION_MOBILE_SIZE}px`;
  return /* @__PURE__ */ jsx2(
    "div",
    {
      css: css({
        display: "flex",
        flexDirection: "column",
        gap: spacings.sm,
        flex: "0 0 40%",
        maxWidth: `${RECOMMENDATION_DESKTOP_SIZE}px`,
        maxHeight: `${RECOMMENDATION_DESKTOP_SIZE}px`,
        width: "100%",
        height: "100%",
        [`@media screen and (max-width: ${MEDIUM_MOBILE_BP})`]: {
          maxWidth: mobileSize,
          maxHeight: mobileSize
        }
      }),
      children: /* @__PURE__ */ jsx2(
        ProductCard,
        {
          product: recommendation,
          hasMultipleRecommendation
        }
      )
    }
  );
};
const Recommendations = ({
  recommendations
}) => {
  if (recommendations === void 0) return /* @__PURE__ */ jsx2(Fragment, {});
  return /* @__PURE__ */ jsx2(
    ScrollContainer,
    {
      scrollType: "percentage",
      marginSideButton: getSmallSpacingNumber(2),
      blurWidth: 50,
      children: recommendations.map((recommendation, index2) => {
        var _a3;
        return /* @__PURE__ */ jsx2(
          Recommendation,
          {
            recommendation,
            hasMultipleRecommendation: recommendations.length > 1
          },
          `recommendation-${index2.toString()}-${(_a3 = recommendation.variants[0]) == null ? void 0 : _a3.id}`
        );
      })
    }
  );
};
const RecommendationWrapper = ({
  isLoading,
  recommendations
}) => {
  const { isFeatureDisabled } = useDialogConfig();
  if (isFeatureDisabled(Features.RECOMMENDATIONS)) {
    return /* @__PURE__ */ u$2(g$3, {});
  }
  if (isLoading) {
    return /* @__PURE__ */ u$2(RecommendationSkeleton, {});
  }
  return /* @__PURE__ */ u$2(Recommendations, { recommendations });
};
const defaultAnswerItemStyle$1 = (theme2) => css({
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  minWidth: "62px",
  padding: `${spacings.sm} ${spacings.lg}`,
  borderRadius: theme2.borderRadius.xxxl,
  cursor: "pointer",
  background: theme2.palette.custom.primaryColor
});
const QualificationAnswers = ({
  savedAnswers,
  theme: theme2
}) => {
  return /* @__PURE__ */ jsxs(
    "div",
    {
      css: css({ display: "flex", flexDirection: "column", gap: spacings.md }),
      children: [
        /* @__PURE__ */ jsx2(Typography, { variant: "base-md", children: /* @__PURE__ */ jsx2(MemoizedFormattedMessage, { id: "answers", defaultMessage: "Answers" }) }),
        /* @__PURE__ */ jsx2(
          "div",
          {
            css: css({
              display: "flex",
              gap: spacings.sm,
              flexWrap: "wrap"
            }),
            children: savedAnswers == null ? void 0 : savedAnswers.map((answerItem) => /* @__PURE__ */ jsx2("div", { css: defaultAnswerItemStyle$1(theme2), children: /* @__PURE__ */ jsx2(
              Typography,
              {
                variant: "lg-paragraph",
                color: theme2.palette.custom.ctaTextColor,
                children: answerItem
              }
            ) }, answerItem))
          }
        )
      ]
    }
  );
};
const QualificationAnswersThemed = withTheme(QualificationAnswers);
const defaultAnswerItemStyle = (theme2) => css({
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  minWidth: "62px",
  padding: `${spacings.sm} ${spacings.lg}`,
  borderRadius: theme2.borderRadius.xxxl,
  border: `1px solid ${theme2.palette.classic.black}`,
  cursor: "pointer",
  "&:hover": {
    background: theme2.palette.grey100
  }
});
const QualificationQuestion = ({
  qualificationQuestion,
  addAnswer,
  theme: theme2
}) => {
  const { question, answers, messageId } = qualificationQuestion;
  const focusTextArea = () => {
    const textAreaElement = document.getElementById("dialog-ai-input");
    textAreaElement == null ? void 0 : textAreaElement.focus();
  };
  return /* @__PURE__ */ jsxs(
    "div",
    {
      css: css({ display: "flex", flexDirection: "column", gap: spacings.md }),
      children: [
        /* @__PURE__ */ jsx2(Typography, { variant: "base-md", children: question }),
        /* @__PURE__ */ jsxs(
          "div",
          {
            css: css({
              display: "flex",
              gap: spacings.sm,
              [`@media screen and (max-width: ${MEDIUM_MOBILE_BP})`]: {
                flexDirection: "column"
              }
            }),
            children: [
              answers.map((answerItem) => /* @__PURE__ */ jsx2(
                DivClickable,
                {
                  onClick: () => addAnswer(answerItem, messageId),
                  customCss: defaultAnswerItemStyle(theme2),
                  children: /* @__PURE__ */ jsx2(Typography, { variant: "lg-paragraph", children: answerItem })
                },
                answerItem
              )),
              answers.length > 0 && /* @__PURE__ */ jsx2(
                DivClickable,
                {
                  onClick: focusTextArea,
                  customCss: defaultAnswerItemStyle(theme2),
                  children: /* @__PURE__ */ jsx2(PlusIcon, { color: theme2.palette.classic.black })
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ jsx2("div", { css: css({ display: "flex", justifyContent: "flex-end" }), children: /* @__PURE__ */ jsx2(
          Button,
          {
            variant: "secondary",
            size: "md",
            iconRight: /* @__PURE__ */ jsx2(ArrowRightIcon, {}),
            onClick: () => addAnswer(SKIP_ANSWER, messageId),
            children: /* @__PURE__ */ jsx2(MemoizedFormattedMessage, { id: "skipAnswer" })
          }
        ) })
      ]
    }
  );
};
const QualificationQuestionThemed = withTheme(QualificationQuestion);
const QualificationSkeleton = () => {
  return /* @__PURE__ */ jsxs(
    "div",
    {
      css: css({
        position: "relative",
        display: "flex",
        flexDirection: "column",
        gap: spacings.md,
        width: "100%"
      }),
      children: [
        /* @__PURE__ */ jsx2(
          "div",
          {
            css: [
              skeletonAnimationStyle,
              css({
                width: "80%",
                height: "28px",
                borderRadius: "32px",
                "&:empty": {
                  display: "inline-block"
                }
              })
            ]
          }
        ),
        /* @__PURE__ */ jsx2("div", { css: [css({ display: "flex", gap: spacings.sm })], children: Array(3).fill(null).map((_2, index2) => /* @__PURE__ */ jsx2(
          "div",
          {
            css: [
              skeletonAnimationStyle,
              css({
                width: "100px",
                height: "36px",
                padding: `${spacings.sm} ${spacings.lg}`,
                borderRadius: theme.borderRadius.xxxl,
                "&:empty": {
                  display: "inline-block"
                }
              })
            ]
          },
          index2
        )) })
      ]
    }
  );
};
const QualificationQuestions = ({
  qualificationQuestions,
  recommendations,
  savedAnswers,
  currentMessageId
}) => {
  const [questionHasChanged, setQuestionHasChanged] = p$1(false);
  const lastQuestion = qualificationQuestions[qualificationQuestions.length - 1];
  const { apiKey: apiKey2, userId: userId2, getSessionId, updateExistingMessage, messages } = useAssistantMessages();
  const { isSearchingForQualificationQuestion } = useAssistantState();
  const saveAnswer = useSaveAnswerQualificationQuestion();
  const localization = useLocalization();
  _(() => {
    setQuestionHasChanged(true);
  }, [lastQuestion, qualificationQuestions]);
  const addAnswer = async (answer, messageId) => {
    if (lastQuestion === void 0) return;
    setQuestionHasChanged(false);
    if (answer !== SKIP_ANSWER) {
      updateExistingMessage(lastQuestion.messageId, {
        savedAnswers: [...savedAnswers ?? [], answer]
      });
    }
    await saveAnswer.mutateAsync({
      sessionId: getSessionId(),
      userId: userId2,
      apiKey: apiKey2,
      aiMessageId: messageId,
      answer,
      language: localization.language,
      locale: localization.languageIsoCode,
      countryCode: localization.countryCode
    });
  };
  const lastMessage = messages[messages.length - 1];
  const qualificationsIsActive = (lastMessage == null ? void 0 : lastMessage.messageId) === currentMessageId;
  return /* @__PURE__ */ jsxs(
    "div",
    {
      css: css({ display: "flex", flexDirection: "column", gap: spacings.md }),
      children: [
        savedAnswers !== void 0 && savedAnswers.length > 0 && /* @__PURE__ */ jsx2(QualificationAnswersThemed, { savedAnswers }),
        isSearchingForQualificationQuestion === false && lastQuestion !== void 0 && qualificationsIsActive && recommendations === void 0 && questionHasChanged ? /* @__PURE__ */ jsx2(
          QualificationQuestionThemed,
          {
            qualificationQuestion: lastQuestion,
            addAnswer
          }
        ) : /* @__PURE__ */ jsx2(Fragment, {}),
        (isSearchingForQualificationQuestion === true && qualificationsIsActive || !questionHasChanged && qualificationsIsActive) && /* @__PURE__ */ jsx2(QualificationSkeleton, {})
      ]
    }
  );
};
const removeTags = (text2) => {
  return text2.replace(/<strong>|<\/strong>/g, "");
};
const fadeIn = keyframes`
   0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
`;
const commonMarkdownComponent = {
  h1: "h1",
  h2: "h2",
  h3: "h3",
  h4: "h4",
  h5: "h5",
  a: ({ href, children }) => /* @__PURE__ */ jsx2("a", { href, target: "_blank", rel: "noopener noreferrer", children }),
  ol: (props) => {
    return /* @__PURE__ */ jsx2(
      "ol",
      {
        css: css({
          gap: spacings.sm
        }),
        children: props.children
      }
    );
  },
  li: (props) => {
    return /* @__PURE__ */ jsx2(
      "li",
      {
        css: css({
          position: "relative"
        }),
        children: props.children
      }
    );
  },
  ul: (props) => {
    return /* @__PURE__ */ jsx2(
      "ul",
      {
        css: css({
          gap: spacings.sm
        }),
        children: props.children
      }
    );
  }
};
const AssistantMessage = ({
  message,
  isLastMessage,
  theme: theme2,
  children,
  childrenWithMargin = true
}) => {
  const { isFeatureDisabled } = useDialogConfig();
  const { isLookingForRecommendations, messageId: messageIdState } = useAssistantState();
  const sentencesFormatted = (message == null ? void 0 : message.messageBySentences) ?? [];
  const joinedSentences = sentencesFormatted.join("");
  if (message === void 0) return /* @__PURE__ */ jsx2(Fragment, {});
  const {
    output,
    recommendations,
    qualifications,
    savedAnswers,
    done,
    messageId
  } = message;
  return /* @__PURE__ */ jsxs(AssistantChatShoppingMessageWrapper, { children: [
    /* @__PURE__ */ jsxs(FlexBox, { direction: "column", gap: "md", children: [
      /* @__PURE__ */ jsxs(
        "div",
        {
          className: "dialog-message",
          "data-message-id": messageId,
          css: css({
            display: "flex",
            alignItems: "flex-start",
            gap: spacings.lg
          }),
          children: [
            /* @__PURE__ */ jsx2(
              "div",
              {
                css: css({
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "center",
                  width: "32px",
                  height: "32px",
                  borderRadius: "100%",
                  opacity: done === true ? 1 : 0,
                  animation: `${fadeIn} 2s forwards cubic-bezier(0.22, 0.61, 0.36, 1)`
                }),
                children: /* @__PURE__ */ jsx2(DialogOrOrganizationIcon, { size: 32, rounded: true })
              }
            ),
            /* @__PURE__ */ jsxs(
              "div",
              {
                css: css({
                  display: "flex",
                  flexDirection: "column",
                  gap: spacings.md,
                  overflow: "hidden"
                }),
                children: [
                  /* @__PURE__ */ jsx2(
                    AssistantText,
                    {
                      customCss: css({
                        marginTop: "5px",
                        "*": {
                          opacity: done === true ? 1 : 0,
                          animation: done !== true ? `${fadeIn} 2s forwards cubic-bezier(0.22, 0.61, 0.36, 1)` : "none",
                          fontSize: `${theme2.typography.h3.fontSize}px`,
                          lineHeight: theme2.typography.body2.lineHeight,
                          textAlign: "left",
                          [`@media screen and (max-width: ${MEDIUM_MOBILE_BP})`]: {
                            fontSize: `${theme2.typography.body2.fontSize}px`
                          }
                        },
                        h1: {
                          margin: `${spacings.sm} 0`
                        },
                        h2: {
                          margin: `${spacings.xs} 0`
                        },
                        h3: {
                          margin: "0"
                        },
                        h4: {
                          margin: "0"
                        },
                        h5: {
                          margin: "0"
                        },
                        "ul, ol": {
                          padding: "revert"
                        },
                        "p, ul, li, ol": {
                          margin: 0
                        },
                        "li > p": {
                          display: "inline"
                        },
                        p: {
                          overflowY: "hidden"
                        },
                        ol: {
                          margin: `${spacings.xs} 0`,
                          counterReset: "item"
                        },
                        "ol > li": {
                          counterIncrement: "item"
                        },
                        "ol > li::marker": {
                          content: `counters(item, '.') '. '`
                        },
                        "ol ol": {
                          counterReset: "item"
                        },
                        ul: {
                          listStyleType: "disc"
                        },
                        "ul ul": {
                          listStyleType: "circle"
                        },
                        "ul ul ul": {
                          listStyleType: "square"
                        },
                        strong: {
                          color: theme2.highlightProductName ? theme2.palette.custom.primaryColor : "inherit"
                        }
                      }),
                      children: /* @__PURE__ */ jsx2(
                        Markdown,
                        {
                          components: commonMarkdownComponent,
                          remarkPlugins: [remarkGfm],
                          children: removeTags(done === true ? output : joinedSentences)
                        }
                      )
                    }
                  ),
                  childrenWithMargin ? children : null,
                  isLastMessage === true && !isFeatureDisabled(Features.FEEDBACKS) && /* @__PURE__ */ jsx2(Feedbacks, { messageId: message.messageId })
                ]
              }
            )
          ]
        }
      ),
      childrenWithMargin ? null : children
    ] }),
    qualifications !== void 0 ? /* @__PURE__ */ jsx2(
      QualificationQuestions,
      {
        currentMessageId: messageId,
        qualificationQuestions: qualifications,
        recommendations,
        savedAnswers
      }
    ) : /* @__PURE__ */ jsx2(Fragment, {}),
    isLastMessage === true ? /* @__PURE__ */ jsx2(
      RecommendationWrapper,
      {
        isLoading: isLookingForRecommendations === true && messageIdState === messageId,
        recommendations
      }
    ) : /* @__PURE__ */ jsx2(Fragment, {})
  ] });
};
const AssistantMessageThemed = withTheme(AssistantMessage);
const parseMessage = (message) => {
  const matchContextTags = /<ProductPage>.*?<\/ProductPage>/s;
  const matchLegacyPattern = /question asked on the page of the product:.*?:/;
  const matchUserQueryTags = /<userQuery>(.*?)<\/userQuery>/s;
  return message.replace(matchContextTags, "").replace(matchUserQueryTags, "$1").replace(matchLegacyPattern, "").trim();
};
const HumanMessage = ({
  message,
  pictureUrl,
  theme: theme2
}) => {
  const isMobile = useIsMobile({ size: TABLET_BP_NUMBER });
  const messageContentParse = parseMessage(message);
  if (pictureUrl !== void 0) {
    return /* @__PURE__ */ jsx2(
      "div",
      {
        css: css({
          borderRadius: theme2.borderRadius.xl,
          alignSelf: "flex-end",
          width: isMobile ? "170px" : "240px",
          height: isMobile ? "170px" : "240px",
          backgroundSize: "cover",
          backgroundRepeat: "no-repeat",
          backgroundPosition: "center",
          backgroundImage: `url(${pictureUrl})`,
          "&:empty": { display: "block" }
        })
      }
    );
  }
  return /* @__PURE__ */ jsx2(
    Typography,
    {
      variant: "base-reg",
      customCss: [
        css({
          padding: `${spacings.md} ${spacings.lg}`,
          background: theme2.palette.custom.primaryColor,
          borderRadius: theme2.borderRadius.xxl,
          width: "fit-content",
          maxWidth: "400px",
          alignSelf: "flex-end",
          fontWeight: theme2.typography.body1.fontWeight,
          fontSize: `${theme2.typography.h3.fontSize}px`,
          lineHeight: theme2.typography.body2.lineHeight,
          [`@media screen and (max-width: ${MEDIUM_MOBILE_BP})`]: {
            maxWidth: "250px",
            fontSize: `${theme2.typography.body2.fontSize}px`,
            padding: `${spacings.sm} ${spacings.md}`
          }
        })
      ],
      color: theme2.palette.custom.ctaTextColor,
      children: messageContentParse
    }
  );
};
const HumanMessageThemed = withTheme(HumanMessage);
/*! @license DOMPurify 3.2.3 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.3/LICENSE */
const {
  entries,
  setPrototypeOf,
  isFrozen,
  getPrototypeOf,
  getOwnPropertyDescriptor
} = Object;
let {
  freeze,
  seal,
  create: create2
} = Object;
let {
  apply,
  construct
} = typeof Reflect !== "undefined" && Reflect;
if (!freeze) {
  freeze = function freeze2(x2) {
    return x2;
  };
}
if (!seal) {
  seal = function seal2(x2) {
    return x2;
  };
}
if (!apply) {
  apply = function apply2(fun, thisValue, args) {
    return fun.apply(thisValue, args);
  };
}
if (!construct) {
  construct = function construct2(Func, args) {
    return new Func(...args);
  };
}
const arrayForEach = unapply(Array.prototype.forEach);
const arrayPop = unapply(Array.prototype.pop);
const arrayPush = unapply(Array.prototype.push);
const stringToLowerCase = unapply(String.prototype.toLowerCase);
const stringToString = unapply(String.prototype.toString);
const stringMatch = unapply(String.prototype.match);
const stringReplace = unapply(String.prototype.replace);
const stringIndexOf = unapply(String.prototype.indexOf);
const stringTrim = unapply(String.prototype.trim);
const objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty);
const regExpTest = unapply(RegExp.prototype.test);
const typeErrorCreate = unconstruct(TypeError);
function unapply(func) {
  return function(thisArg) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return apply(func, thisArg, args);
  };
}
function unconstruct(func) {
  return function() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return construct(func, args);
  };
}
function addToSet(set, array) {
  let transformCaseFunc = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : stringToLowerCase;
  if (setPrototypeOf) {
    setPrototypeOf(set, null);
  }
  let l2 = array.length;
  while (l2--) {
    let element2 = array[l2];
    if (typeof element2 === "string") {
      const lcElement = transformCaseFunc(element2);
      if (lcElement !== element2) {
        if (!isFrozen(array)) {
          array[l2] = lcElement;
        }
        element2 = lcElement;
      }
    }
    set[element2] = true;
  }
  return set;
}
function cleanArray(array) {
  for (let index2 = 0; index2 < array.length; index2++) {
    const isPropertyExist = objectHasOwnProperty(array, index2);
    if (!isPropertyExist) {
      array[index2] = null;
    }
  }
  return array;
}
function clone(object) {
  const newObject = create2(null);
  for (const [property2, value] of entries(object)) {
    const isPropertyExist = objectHasOwnProperty(object, property2);
    if (isPropertyExist) {
      if (Array.isArray(value)) {
        newObject[property2] = cleanArray(value);
      } else if (value && typeof value === "object" && value.constructor === Object) {
        newObject[property2] = clone(value);
      } else {
        newObject[property2] = value;
      }
    }
  }
  return newObject;
}
function lookupGetter(object, prop) {
  while (object !== null) {
    const desc = getOwnPropertyDescriptor(object, prop);
    if (desc) {
      if (desc.get) {
        return unapply(desc.get);
      }
      if (typeof desc.value === "function") {
        return unapply(desc.value);
      }
    }
    object = getPrototypeOf(object);
  }
  function fallbackValue() {
    return null;
  }
  return fallbackValue;
}
const html$1 = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
const svg$1 = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
const svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
const svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
const mathMl$1 = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]);
const mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
const text = freeze(["#text"]);
const html = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]);
const svg = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
const mathMl = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
const xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
const MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
const ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
const TMPLIT_EXPR = seal(/\$\{[\w\W]*}/gm);
const DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]+$/);
const ARIA_ATTR = seal(/^aria-[\-\w]+$/);
const IS_ALLOWED_URI = seal(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
);
const IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
const ATTR_WHITESPACE = seal(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
);
const DOCTYPE_NAME = seal(/^html$/i);
const CUSTOM_ELEMENT = seal(/^[a-z][.\w]*(-[.\w]+)+$/i);
var EXPRESSIONS = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ARIA_ATTR,
  ATTR_WHITESPACE,
  CUSTOM_ELEMENT,
  DATA_ATTR,
  DOCTYPE_NAME,
  ERB_EXPR,
  IS_ALLOWED_URI,
  IS_SCRIPT_OR_DATA,
  MUSTACHE_EXPR,
  TMPLIT_EXPR
});
const NODE_TYPE = {
  element: 1,
  attribute: 2,
  text: 3,
  cdataSection: 4,
  entityReference: 5,
  // Deprecated
  entityNode: 6,
  // Deprecated
  progressingInstruction: 7,
  comment: 8,
  document: 9,
  documentType: 10,
  documentFragment: 11,
  notation: 12
  // Deprecated
};
const getGlobal = function getGlobal2() {
  return typeof window === "undefined" ? null : window;
};
const _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes, purifyHostElement) {
  if (typeof trustedTypes !== "object" || typeof trustedTypes.createPolicy !== "function") {
    return null;
  }
  let suffix = null;
  const ATTR_NAME = "data-tt-policy-suffix";
  if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {
    suffix = purifyHostElement.getAttribute(ATTR_NAME);
  }
  const policyName = "dompurify" + (suffix ? "#" + suffix : "");
  try {
    return trustedTypes.createPolicy(policyName, {
      createHTML(html2) {
        return html2;
      },
      createScriptURL(scriptUrl) {
        return scriptUrl;
      }
    });
  } catch (_2) {
    console.warn("TrustedTypes policy " + policyName + " could not be created.");
    return null;
  }
};
const _createHooksMap = function _createHooksMap2() {
  return {
    afterSanitizeAttributes: [],
    afterSanitizeElements: [],
    afterSanitizeShadowDOM: [],
    beforeSanitizeAttributes: [],
    beforeSanitizeElements: [],
    beforeSanitizeShadowDOM: [],
    uponSanitizeAttribute: [],
    uponSanitizeElement: [],
    uponSanitizeShadowNode: []
  };
};
function createDOMPurify() {
  let window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
  const DOMPurify = (root2) => createDOMPurify(root2);
  DOMPurify.version = "3.2.3";
  DOMPurify.removed = [];
  if (!window2 || !window2.document || window2.document.nodeType !== NODE_TYPE.document) {
    DOMPurify.isSupported = false;
    return DOMPurify;
  }
  let {
    document: document2
  } = window2;
  const originalDocument = document2;
  const currentScript = originalDocument.currentScript;
  const {
    DocumentFragment,
    HTMLTemplateElement,
    Node,
    Element: Element2,
    NodeFilter,
    NamedNodeMap = window2.NamedNodeMap || window2.MozNamedAttrMap,
    HTMLFormElement,
    DOMParser,
    trustedTypes
  } = window2;
  const ElementPrototype = Element2.prototype;
  const cloneNode = lookupGetter(ElementPrototype, "cloneNode");
  const remove = lookupGetter(ElementPrototype, "remove");
  const getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
  const getChildNodes = lookupGetter(ElementPrototype, "childNodes");
  const getParentNode = lookupGetter(ElementPrototype, "parentNode");
  if (typeof HTMLTemplateElement === "function") {
    const template = document2.createElement("template");
    if (template.content && template.content.ownerDocument) {
      document2 = template.content.ownerDocument;
    }
  }
  let trustedTypesPolicy;
  let emptyHTML = "";
  const {
    implementation,
    createNodeIterator,
    createDocumentFragment,
    getElementsByTagName
  } = document2;
  const {
    importNode
  } = originalDocument;
  let hooks = _createHooksMap();
  DOMPurify.isSupported = typeof entries === "function" && typeof getParentNode === "function" && implementation && implementation.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: MUSTACHE_EXPR2,
    ERB_EXPR: ERB_EXPR2,
    TMPLIT_EXPR: TMPLIT_EXPR2,
    DATA_ATTR: DATA_ATTR2,
    ARIA_ATTR: ARIA_ATTR2,
    IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA2,
    ATTR_WHITESPACE: ATTR_WHITESPACE2,
    CUSTOM_ELEMENT: CUSTOM_ELEMENT2
  } = EXPRESSIONS;
  let {
    IS_ALLOWED_URI: IS_ALLOWED_URI$1
  } = EXPRESSIONS;
  let ALLOWED_TAGS = null;
  const DEFAULT_ALLOWED_TAGS = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text]);
  let ALLOWED_ATTR = null;
  const DEFAULT_ALLOWED_ATTR = addToSet({}, [...html, ...svg, ...mathMl, ...xml]);
  let CUSTOM_ELEMENT_HANDLING = Object.seal(create2(null, {
    tagNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    attributeNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: false
    }
  }));
  let FORBID_TAGS = null;
  let FORBID_ATTR = null;
  let ALLOW_ARIA_ATTR = true;
  let ALLOW_DATA_ATTR = true;
  let ALLOW_UNKNOWN_PROTOCOLS = false;
  let ALLOW_SELF_CLOSE_IN_ATTR = true;
  let SAFE_FOR_TEMPLATES = false;
  let SAFE_FOR_XML = true;
  let WHOLE_DOCUMENT = false;
  let SET_CONFIG = false;
  let FORCE_BODY = false;
  let RETURN_DOM = false;
  let RETURN_DOM_FRAGMENT = false;
  let RETURN_TRUSTED_TYPE = false;
  let SANITIZE_DOM = true;
  let SANITIZE_NAMED_PROPS = false;
  const SANITIZE_NAMED_PROPS_PREFIX = "user-content-";
  let KEEP_CONTENT = true;
  let IN_PLACE = false;
  let USE_PROFILES = {};
  let FORBID_CONTENTS = null;
  const DEFAULT_FORBID_CONTENTS = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let DATA_URI_TAGS = null;
  const DEFAULT_DATA_URI_TAGS = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
  let URI_SAFE_ATTRIBUTES = null;
  const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]);
  const MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
  const SVG_NAMESPACE = "http://www.w3.org/2000/svg";
  const HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
  let NAMESPACE = HTML_NAMESPACE;
  let IS_EMPTY_INPUT = false;
  let ALLOWED_NAMESPACES = null;
  const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
  let MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]);
  let HTML_INTEGRATION_POINTS = addToSet({}, ["annotation-xml"]);
  const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ["title", "style", "font", "a", "script"]);
  let PARSER_MEDIA_TYPE = null;
  const SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"];
  const DEFAULT_PARSER_MEDIA_TYPE = "text/html";
  let transformCaseFunc = null;
  let CONFIG = null;
  const formElement = document2.createElement("form");
  const isRegexOrFunction = function isRegexOrFunction2(testValue) {
    return testValue instanceof RegExp || testValue instanceof Function;
  };
  const _parseConfig = function _parseConfig2() {
    let cfg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (CONFIG && CONFIG === cfg) {
      return;
    }
    if (!cfg || typeof cfg !== "object") {
      cfg = {};
    }
    cfg = clone(cfg);
    PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes
    SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? DEFAULT_PARSER_MEDIA_TYPE : cfg.PARSER_MEDIA_TYPE;
    transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? stringToString : stringToLowerCase;
    ALLOWED_TAGS = objectHasOwnProperty(cfg, "ALLOWED_TAGS") ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
    ALLOWED_ATTR = objectHasOwnProperty(cfg, "ALLOWED_ATTR") ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
    ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, "ALLOWED_NAMESPACES") ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
    URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, "ADD_URI_SAFE_ATTR") ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES;
    DATA_URI_TAGS = objectHasOwnProperty(cfg, "ADD_DATA_URI_TAGS") ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS;
    FORBID_CONTENTS = objectHasOwnProperty(cfg, "FORBID_CONTENTS") ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
    FORBID_TAGS = objectHasOwnProperty(cfg, "FORBID_TAGS") ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};
    FORBID_ATTR = objectHasOwnProperty(cfg, "FORBID_ATTR") ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};
    USE_PROFILES = objectHasOwnProperty(cfg, "USE_PROFILES") ? cfg.USE_PROFILES : false;
    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
    ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false;
    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
    SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false;
    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
    RETURN_DOM = cfg.RETURN_DOM || false;
    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
    FORCE_BODY = cfg.FORCE_BODY || false;
    SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
    SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false;
    KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
    IN_PLACE = cfg.IN_PLACE || false;
    IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;
    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
    MATHML_TEXT_INTEGRATION_POINTS = cfg.MATHML_TEXT_INTEGRATION_POINTS || MATHML_TEXT_INTEGRATION_POINTS;
    HTML_INTEGRATION_POINTS = cfg.HTML_INTEGRATION_POINTS || HTML_INTEGRATION_POINTS;
    CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === "boolean") {
      CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
    }
    if (SAFE_FOR_TEMPLATES) {
      ALLOW_DATA_ATTR = false;
    }
    if (RETURN_DOM_FRAGMENT) {
      RETURN_DOM = true;
    }
    if (USE_PROFILES) {
      ALLOWED_TAGS = addToSet({}, text);
      ALLOWED_ATTR = [];
      if (USE_PROFILES.html === true) {
        addToSet(ALLOWED_TAGS, html$1);
        addToSet(ALLOWED_ATTR, html);
      }
      if (USE_PROFILES.svg === true) {
        addToSet(ALLOWED_TAGS, svg$1);
        addToSet(ALLOWED_ATTR, svg);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.svgFilters === true) {
        addToSet(ALLOWED_TAGS, svgFilters);
        addToSet(ALLOWED_ATTR, svg);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.mathMl === true) {
        addToSet(ALLOWED_TAGS, mathMl$1);
        addToSet(ALLOWED_ATTR, mathMl);
        addToSet(ALLOWED_ATTR, xml);
      }
    }
    if (cfg.ADD_TAGS) {
      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
        ALLOWED_TAGS = clone(ALLOWED_TAGS);
      }
      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
    }
    if (cfg.ADD_ATTR) {
      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
        ALLOWED_ATTR = clone(ALLOWED_ATTR);
      }
      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
    }
    if (cfg.ADD_URI_SAFE_ATTR) {
      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
    }
    if (cfg.FORBID_CONTENTS) {
      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
        FORBID_CONTENTS = clone(FORBID_CONTENTS);
      }
      addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
    }
    if (KEEP_CONTENT) {
      ALLOWED_TAGS["#text"] = true;
    }
    if (WHOLE_DOCUMENT) {
      addToSet(ALLOWED_TAGS, ["html", "head", "body"]);
    }
    if (ALLOWED_TAGS.table) {
      addToSet(ALLOWED_TAGS, ["tbody"]);
      delete FORBID_TAGS.tbody;
    }
    if (cfg.TRUSTED_TYPES_POLICY) {
      if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== "function") {
        throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
      }
      if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== "function") {
        throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
      }
      trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;
      emptyHTML = trustedTypesPolicy.createHTML("");
    } else {
      if (trustedTypesPolicy === void 0) {
        trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);
      }
      if (trustedTypesPolicy !== null && typeof emptyHTML === "string") {
        emptyHTML = trustedTypesPolicy.createHTML("");
      }
    }
    if (freeze) {
      freeze(cfg);
    }
    CONFIG = cfg;
  };
  const ALL_SVG_TAGS = addToSet({}, [...svg$1, ...svgFilters, ...svgDisallowed]);
  const ALL_MATHML_TAGS = addToSet({}, [...mathMl$1, ...mathMlDisallowed]);
  const _checkValidNamespace = function _checkValidNamespace2(element2) {
    let parent = getParentNode(element2);
    if (!parent || !parent.tagName) {
      parent = {
        namespaceURI: NAMESPACE,
        tagName: "template"
      };
    }
    const tagName = stringToLowerCase(element2.tagName);
    const parentTagName = stringToLowerCase(parent.tagName);
    if (!ALLOWED_NAMESPACES[element2.namespaceURI]) {
      return false;
    }
    if (element2.namespaceURI === SVG_NAMESPACE) {
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === "svg";
      }
      if (parent.namespaceURI === MATHML_NAMESPACE) {
        return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
      }
      return Boolean(ALL_SVG_TAGS[tagName]);
    }
    if (element2.namespaceURI === MATHML_NAMESPACE) {
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === "math";
      }
      if (parent.namespaceURI === SVG_NAMESPACE) {
        return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
      }
      return Boolean(ALL_MATHML_TAGS[tagName]);
    }
    if (element2.namespaceURI === HTML_NAMESPACE) {
      if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
    }
    if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && ALLOWED_NAMESPACES[element2.namespaceURI]) {
      return true;
    }
    return false;
  };
  const _forceRemove = function _forceRemove2(node2) {
    arrayPush(DOMPurify.removed, {
      element: node2
    });
    try {
      getParentNode(node2).removeChild(node2);
    } catch (_2) {
      remove(node2);
    }
  };
  const _removeAttribute = function _removeAttribute2(name2, element2) {
    try {
      arrayPush(DOMPurify.removed, {
        attribute: element2.getAttributeNode(name2),
        from: element2
      });
    } catch (_2) {
      arrayPush(DOMPurify.removed, {
        attribute: null,
        from: element2
      });
    }
    element2.removeAttribute(name2);
    if (name2 === "is") {
      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
        try {
          _forceRemove(element2);
        } catch (_2) {
        }
      } else {
        try {
          element2.setAttribute(name2, "");
        } catch (_2) {
        }
      }
    }
  };
  const _initDocument = function _initDocument2(dirty) {
    let doc = null;
    let leadingWhitespace = null;
    if (FORCE_BODY) {
      dirty = "<remove></remove>" + dirty;
    } else {
      const matches = stringMatch(dirty, /^[\r\n\t ]+/);
      leadingWhitespace = matches && matches[0];
    }
    if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && NAMESPACE === HTML_NAMESPACE) {
      dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>";
    }
    const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
    if (NAMESPACE === HTML_NAMESPACE) {
      try {
        doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
      } catch (_2) {
      }
    }
    if (!doc || !doc.documentElement) {
      doc = implementation.createDocument(NAMESPACE, "template", null);
      try {
        doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
      } catch (_2) {
      }
    }
    const body = doc.body || doc.documentElement;
    if (dirty && leadingWhitespace) {
      body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null);
    }
    if (NAMESPACE === HTML_NAMESPACE) {
      return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? "html" : "body")[0];
    }
    return WHOLE_DOCUMENT ? doc.documentElement : body;
  };
  const _createNodeIterator = function _createNodeIterator2(root2) {
    return createNodeIterator.call(
      root2.ownerDocument || root2,
      root2,
      // eslint-disable-next-line no-bitwise
      NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION,
      null
    );
  };
  const _isClobbered = function _isClobbered2(element2) {
    return element2 instanceof HTMLFormElement && (typeof element2.nodeName !== "string" || typeof element2.textContent !== "string" || typeof element2.removeChild !== "function" || !(element2.attributes instanceof NamedNodeMap) || typeof element2.removeAttribute !== "function" || typeof element2.setAttribute !== "function" || typeof element2.namespaceURI !== "string" || typeof element2.insertBefore !== "function" || typeof element2.hasChildNodes !== "function");
  };
  const _isNode = function _isNode2(value) {
    return typeof Node === "function" && value instanceof Node;
  };
  function _executeHooks(hooks2, currentNode, data) {
    arrayForEach(hooks2, (hook) => {
      hook.call(DOMPurify, currentNode, data, CONFIG);
    });
  }
  const _sanitizeElements = function _sanitizeElements2(currentNode) {
    let content2 = null;
    _executeHooks(hooks.beforeSanitizeElements, currentNode, null);
    if (_isClobbered(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    const tagName = transformCaseFunc(currentNode.nodeName);
    _executeHooks(hooks.uponSanitizeElement, currentNode, {
      tagName,
      allowedTags: ALLOWED_TAGS
    });
    if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
      _forceRemove(currentNode);
      return true;
    }
    if (currentNode.nodeType === NODE_TYPE.progressingInstruction) {
      _forceRemove(currentNode);
      return true;
    }
    if (SAFE_FOR_XML && currentNode.nodeType === NODE_TYPE.comment && regExpTest(/<[/\w]/g, currentNode.data)) {
      _forceRemove(currentNode);
      return true;
    }
    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
      if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) {
          return false;
        }
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) {
          return false;
        }
      }
      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
        const parentNode = getParentNode(currentNode) || currentNode.parentNode;
        const childNodes = getChildNodes(currentNode) || currentNode.childNodes;
        if (childNodes && parentNode) {
          const childCount = childNodes.length;
          for (let i = childCount - 1; i >= 0; --i) {
            const childClone = cloneNode(childNodes[i], true);
            childClone.__removalCount = (currentNode.__removalCount || 0) + 1;
            parentNode.insertBefore(childClone, getNextSibling(currentNode));
          }
        }
      }
      _forceRemove(currentNode);
      return true;
    }
    if (currentNode instanceof Element2 && !_checkValidNamespace(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    if ((tagName === "noscript" || tagName === "noembed" || tagName === "noframes") && regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }
    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text) {
      content2 = currentNode.textContent;
      arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
        content2 = stringReplace(content2, expr, " ");
      });
      if (currentNode.textContent !== content2) {
        arrayPush(DOMPurify.removed, {
          element: currentNode.cloneNode()
        });
        currentNode.textContent = content2;
      }
    }
    _executeHooks(hooks.afterSanitizeElements, currentNode, null);
    return false;
  };
  const _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value) {
    if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value in document2 || value in formElement)) {
      return false;
    }
    if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR2, lcName)) ;
    else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR2, lcName)) ;
    else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
      if (
        // First condition does a very basic check if a) it's basically a valid custom element tagname AND
        // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
        // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
        _isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || // Alternative, second condition checks if it's an `is`-attribute, AND
        // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
        lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))
      ) ;
      else {
        return false;
      }
    } else if (URI_SAFE_ATTRIBUTES[lcName]) ;
    else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE2, ""))) ;
    else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value, "data:") === 0 && DATA_URI_TAGS[lcTag]) ;
    else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA2, stringReplace(value, ATTR_WHITESPACE2, ""))) ;
    else if (value) {
      return false;
    } else ;
    return true;
  };
  const _isBasicCustomElement = function _isBasicCustomElement2(tagName) {
    return tagName !== "annotation-xml" && stringMatch(tagName, CUSTOM_ELEMENT2);
  };
  const _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
    _executeHooks(hooks.beforeSanitizeAttributes, currentNode, null);
    const {
      attributes
    } = currentNode;
    if (!attributes || _isClobbered(currentNode)) {
      return;
    }
    const hookEvent = {
      attrName: "",
      attrValue: "",
      keepAttr: true,
      allowedAttributes: ALLOWED_ATTR,
      forceKeepAttr: void 0
    };
    let l2 = attributes.length;
    while (l2--) {
      const attr = attributes[l2];
      const {
        name: name2,
        namespaceURI,
        value: attrValue
      } = attr;
      const lcName = transformCaseFunc(name2);
      let value = name2 === "value" ? attrValue : stringTrim(attrValue);
      hookEvent.attrName = lcName;
      hookEvent.attrValue = value;
      hookEvent.keepAttr = true;
      hookEvent.forceKeepAttr = void 0;
      _executeHooks(hooks.uponSanitizeAttribute, currentNode, hookEvent);
      value = hookEvent.attrValue;
      if (SANITIZE_NAMED_PROPS && (lcName === "id" || lcName === "name")) {
        _removeAttribute(name2, currentNode);
        value = SANITIZE_NAMED_PROPS_PREFIX + value;
      }
      if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\/(style|title)/i, value)) {
        _removeAttribute(name2, currentNode);
        continue;
      }
      if (hookEvent.forceKeepAttr) {
        continue;
      }
      _removeAttribute(name2, currentNode);
      if (!hookEvent.keepAttr) {
        continue;
      }
      if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
        _removeAttribute(name2, currentNode);
        continue;
      }
      if (SAFE_FOR_TEMPLATES) {
        arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
          value = stringReplace(value, expr, " ");
        });
      }
      const lcTag = transformCaseFunc(currentNode.nodeName);
      if (!_isValidAttribute(lcTag, lcName, value)) {
        continue;
      }
      if (trustedTypesPolicy && typeof trustedTypes === "object" && typeof trustedTypes.getAttributeType === "function") {
        if (namespaceURI) ;
        else {
          switch (trustedTypes.getAttributeType(lcTag, lcName)) {
            case "TrustedHTML": {
              value = trustedTypesPolicy.createHTML(value);
              break;
            }
            case "TrustedScriptURL": {
              value = trustedTypesPolicy.createScriptURL(value);
              break;
            }
          }
        }
      }
      try {
        if (namespaceURI) {
          currentNode.setAttributeNS(namespaceURI, name2, value);
        } else {
          currentNode.setAttribute(name2, value);
        }
        if (_isClobbered(currentNode)) {
          _forceRemove(currentNode);
        } else {
          arrayPop(DOMPurify.removed);
        }
      } catch (_2) {
      }
    }
    _executeHooks(hooks.afterSanitizeAttributes, currentNode, null);
  };
  const _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
    let shadowNode = null;
    const shadowIterator = _createNodeIterator(fragment);
    _executeHooks(hooks.beforeSanitizeShadowDOM, fragment, null);
    while (shadowNode = shadowIterator.nextNode()) {
      _executeHooks(hooks.uponSanitizeShadowNode, shadowNode, null);
      _sanitizeElements(shadowNode);
      _sanitizeAttributes(shadowNode);
      if (shadowNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM2(shadowNode.content);
      }
    }
    _executeHooks(hooks.afterSanitizeShadowDOM, fragment, null);
  };
  DOMPurify.sanitize = function(dirty) {
    let cfg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let body = null;
    let importedNode = null;
    let currentNode = null;
    let returnNode = null;
    IS_EMPTY_INPUT = !dirty;
    if (IS_EMPTY_INPUT) {
      dirty = "<!-->";
    }
    if (typeof dirty !== "string" && !_isNode(dirty)) {
      if (typeof dirty.toString === "function") {
        dirty = dirty.toString();
        if (typeof dirty !== "string") {
          throw typeErrorCreate("dirty is not a string, aborting");
        }
      } else {
        throw typeErrorCreate("toString is not a function");
      }
    }
    if (!DOMPurify.isSupported) {
      return dirty;
    }
    if (!SET_CONFIG) {
      _parseConfig(cfg);
    }
    DOMPurify.removed = [];
    if (typeof dirty === "string") {
      IN_PLACE = false;
    }
    if (IN_PLACE) {
      if (dirty.nodeName) {
        const tagName = transformCaseFunc(dirty.nodeName);
        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
          throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
        }
      }
    } else if (dirty instanceof Node) {
      body = _initDocument("<!---->");
      importedNode = body.ownerDocument.importNode(dirty, true);
      if (importedNode.nodeType === NODE_TYPE.element && importedNode.nodeName === "BODY") {
        body = importedNode;
      } else if (importedNode.nodeName === "HTML") {
        body = importedNode;
      } else {
        body.appendChild(importedNode);
      }
    } else {
      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes
      dirty.indexOf("<") === -1) {
        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
      }
      body = _initDocument(dirty);
      if (!body) {
        return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
      }
    }
    if (body && FORCE_BODY) {
      _forceRemove(body.firstChild);
    }
    const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);
    while (currentNode = nodeIterator.nextNode()) {
      _sanitizeElements(currentNode);
      _sanitizeAttributes(currentNode);
      if (currentNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(currentNode.content);
      }
    }
    if (IN_PLACE) {
      return dirty;
    }
    if (RETURN_DOM) {
      if (RETURN_DOM_FRAGMENT) {
        returnNode = createDocumentFragment.call(body.ownerDocument);
        while (body.firstChild) {
          returnNode.appendChild(body.firstChild);
        }
      } else {
        returnNode = body;
      }
      if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {
        returnNode = importNode.call(originalDocument, returnNode, true);
      }
      return returnNode;
    }
    let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
    if (WHOLE_DOCUMENT && ALLOWED_TAGS["!doctype"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
      serializedHTML = "<!DOCTYPE " + body.ownerDocument.doctype.name + ">\n" + serializedHTML;
    }
    if (SAFE_FOR_TEMPLATES) {
      arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
        serializedHTML = stringReplace(serializedHTML, expr, " ");
      });
    }
    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
  };
  DOMPurify.setConfig = function() {
    let cfg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _parseConfig(cfg);
    SET_CONFIG = true;
  };
  DOMPurify.clearConfig = function() {
    CONFIG = null;
    SET_CONFIG = false;
  };
  DOMPurify.isValidAttribute = function(tag, attr, value) {
    if (!CONFIG) {
      _parseConfig({});
    }
    const lcTag = transformCaseFunc(tag);
    const lcName = transformCaseFunc(attr);
    return _isValidAttribute(lcTag, lcName, value);
  };
  DOMPurify.addHook = function(entryPoint, hookFunction) {
    if (typeof hookFunction !== "function") {
      return;
    }
    arrayPush(hooks[entryPoint], hookFunction);
  };
  DOMPurify.removeHook = function(entryPoint) {
    return arrayPop(hooks[entryPoint]);
  };
  DOMPurify.removeHooks = function(entryPoint) {
    hooks[entryPoint] = [];
  };
  DOMPurify.removeAllHooks = function() {
    hooks = _createHooksMap();
  };
  return DOMPurify;
}
var purify = createDOMPurify();
const ProductAdditionnalInformations = ({
  recommendation
}) => {
  const { descriptionHtml } = recommendation;
  const sanitizedDescriptionHtml = purify.sanitize(descriptionHtml ?? "");
  return /* @__PURE__ */ jsxs(
    "div",
    {
      css: css({
        display: "flex",
        flexDirection: "column",
        gap: spacings.sm
      }),
      children: [
        /* @__PURE__ */ jsx2(Typography, { variant: "xs-lg", children: /* @__PURE__ */ jsx2(MemoizedFormattedMessage, { id: "description" }) }),
        /* @__PURE__ */ jsx2(
          "pre",
          {
            css: {
              whiteSpace: "normal",
              padding: 0,
              margin: 0,
              background: "unset"
            },
            children: /* @__PURE__ */ jsx2(Typography, { variant: "sm-paragraph", enableDangerousInnerHTML: true, children: sanitizedDescriptionHtml })
          }
        )
      ]
    }
  );
};
const ErrorMessage$1 = ({
  errorMessage
}) => {
  if (errorMessage === void 0) return /* @__PURE__ */ u$2(g$3, {});
  return /* @__PURE__ */ u$2(
    Typography,
    {
      variant: "sm-md",
      customCss: css({
        position: "absolute",
        left: "14px",
        bottom: "-22px",
        color: theme.palette.red600,
        marginTop: spacings.sm,
        display: "block"
      }),
      children: errorMessage
    }
  );
};
const arrowStyle = css({
  position: "absolute",
  right: "0",
  bottom: spacings.sm,
  padding: 0,
  "&:disabled": {
    background: "transparent",
    "svg > path": {
      stroke: theme.palette.classic.white
    },
    span: {
      color: theme.palette.classic.white,
      cursor: "not-allowed"
    }
  },
  "&:hover, &:focus": {
    background: "unset"
  }
});
const sendIconContainerStyle = (theme2, disabled) => css({
  position: "absolute",
  top: "-2px",
  right: spacings.sm,
  backgroundColor: disabled === true ? theme2.palette.grey200 : theme2.palette.custom.primaryColor,
  width: "40px",
  height: "40px",
  borderRadius: "100%",
  display: "flex",
  justifyContent: "center",
  alignItems: "center"
});
const SendIconMessage = ({
  disabled,
  isLoading,
  theme: theme2,
  sendMessage
}) => {
  return /* @__PURE__ */ jsx2(
    Button,
    {
      disabled: isLoading || disabled,
      onClick: sendMessage,
      customCss: arrowStyle,
      variant: "blank",
      iconLeft: /* @__PURE__ */ jsx2("div", { css: sendIconContainerStyle(theme2, disabled), children: /* @__PURE__ */ jsx2(
        ArrowUpIcon,
        {
          color: disabled === true || isLoading ? theme2.palette.classic.white : theme2.palette.custom.ctaTextColor
        }
      ) })
    }
  );
};
const SendIconMessageThemed = withTheme(SendIconMessage);
const isValidMessage = (message, isQualification) => {
  const countWords = message.split(" ").length;
  if (isQualification === true) {
    return countWords <= MAX_WORDS_PER_ANSWER && message.length <= MAX_CHARACTERS_PER_ANSWER;
  }
  return countWords <= MAX_WORDS_PER_QUESTION && message.length <= MAX_CHARACTERS_PER_QUESTION;
};
const getErrorMessage = (message, isQualification) => {
  const isValid = isValidMessage(message, isQualification);
  if (isValid) return;
  if (isQualification === true) {
    return `The answer is too long (max ${MAX_WORDS_PER_ANSWER} words)`;
  }
  return `The question is too long (max ${MAX_WORDS_PER_QUESTION} words)`;
};
const isTooLongQuestionError = (error2) => {
  var _a3;
  const knownError = (_a3 = error2.response) == null ? void 0 : _a3.data;
  return knownError !== void 0 && (knownError.errorType === ANSWER_TOO_LONG || knownError.errorType === QUESTION_TOO_LONG);
};
const defaultInputStyle = (theme2, hasMultiline) => css({
  border: "unset",
  boxShadow: "unset",
  borderRadius: hasMultiline ? theme2.borderRadius.xxl : "50px",
  margin: "0 auto",
  background: theme2.palette.grey100,
  minHeight: "51px",
  height: "51px",
  color: theme2.palette.classic.black,
  paddingRight: getSmallSpacing(13),
  paddingLeft: spacings.lg,
  transition: "linear border-radius 0.25s",
  lineHeight: hasMultiline ? "20px" : "31px",
  [`@media screen and (max-width: ${TABLET_BP})`]: {
    fontSize: "14px"
  },
  "&:placeholder": {
    color: theme2.palette.grey600,
    fontWeight: theme2.typography.body1.fontWeight,
    lineHeight: "31px"
  },
  "&:hover": {
    border: "unset",
    borderRadius: hasMultiline ? theme2.borderRadius.xxl : "50px"
  },
  "&:focus, &:disabled": {
    border: `1px solid ${theme2.palette.classic.black}`,
    boxShadow: "unset",
    borderRadius: hasMultiline ? theme2.borderRadius.xxl : "50px"
  },
  "&:disabled": {
    cursor: "not-allowed",
    opacity: 0.3,
    border: "unset"
  }
});
const defaultContainerStyle$1 = (theme2, hasMultiline) => css({
  position: "relative",
  margin: "0 auto",
  transition: "linear border-radius 0.5s",
  borderRadius: hasMultiline ? theme2.borderRadius.xxl : "50px",
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  width: "100%",
  minWidth: "180px",
  minHeight: "51px",
  background: theme2.palette.grey100
});
const AssistantChatShoppingSendMessages = ({
  placeholder = "Ask anything",
  onSendMessage,
  customInputStyle,
  enableSendMessageOnBlur = false,
  disabled = false,
  isLoading = false,
  theme: theme2
}) => {
  const {
    apiKey: apiKey2,
    userId: userId2,
    getSessionId,
    updateExistingMessage,
    messages,
    conversationLimitIsReached
  } = useAssistantMessages();
  const { modalState } = useModalState();
  const isMobile = window.innerWidth < TABLET_BP_NUMBER;
  const { isQualifying, updateAssistantState } = useAssistantState();
  const textAreaRef = F$1(null);
  const intl = useIntl();
  const [message, setMessage] = p$1("");
  const lock = F$1(false);
  const [error2, setError] = p$1(void 0);
  const localization = useLocalization();
  const postHog = usePostHog();
  const saveAnswer = useSaveAnswerQualificationQuestion({
    onError: (err) => {
      if (err.response !== void 0 && isTooLongQuestionError(err)) {
        setError(err.response.data.message);
      }
    }
  });
  const prepareSendMessage = () => {
    if (message === "" || lock.current || disabled || isLoading) return;
    lock.current = true;
    setMessage("");
    if (isQualifying === true) {
      const lastMessage = messages[messages.length - 1];
      if (lastMessage === void 0) return;
      updateAssistantState({ isSearchingForQualificationQuestion: true });
      saveAnswer.mutate({
        sessionId: getSessionId(),
        userId: userId2,
        apiKey: apiKey2,
        aiMessageId: lastMessage.messageId,
        answer: message,
        language: localization.language,
        locale: localization.languageIsoCode,
        countryCode: localization.countryCode
      });
      updateExistingMessage(lastMessage.messageId, {
        savedAnswers: [...lastMessage.savedAnswers ?? [], message]
      });
      return;
    }
    postHog.capture(TRACKING_EVENTS.USER_SENT_CUSTOM_MESSAGE, {
      message
    });
    onSendMessage == null ? void 0 : onSendMessage(message);
  };
  _(() => {
    if (!isLoading) {
      lock.current = false;
    }
  }, [isLoading]);
  const hasMultiline = textAreaRef.current !== null && textAreaRef.current.clientHeight > 51;
  const errorText = getErrorMessage(message, isQualifying === true);
  const hasError = errorText !== void 0 || error2 !== void 0;
  const disableDynamicHeight = modalState === MODAL_STATE && isMobile;
  return /* @__PURE__ */ jsx2("div", { css: defaultContainerStyle$1(theme2, hasMultiline), children: /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx2(ErrorMessage$1, { errorMessage: errorText ?? error2 }),
    /* @__PURE__ */ jsx2(
      Textarea,
      {
        disabled: conversationLimitIsReached || isLoading,
        ref: textAreaRef,
        id: "dialog-ai-input",
        name: "dialog-ai-input",
        enableDynamicHeight: disableDynamicHeight ? false : true,
        onBlur: () => {
          if (!enableSendMessageOnBlur || hasError) return;
          prepareSendMessage();
        },
        onKeyDown: (event) => {
          if (event.key === "Enter" && !hasError) {
            event.preventDefault();
            prepareSendMessage();
          }
        },
        onChange: (evt) => setMessage(evt.target.value),
        value: message,
        textAreaCustomCss: [
          defaultInputStyle(theme2, hasMultiline),
          customInputStyle ?? css({}),
          disableDynamicHeight ? css({
            whiteSpace: "nowrap",
            paddingRight: "35px",
            overflow: "auto"
          }) : css({}),
          css({
            "@supports (-webkit-touch-callout: none)": {
              fontSize: "16px"
            }
          })
        ],
        placeholder: isQualifying === true ? intl.formatMessage({ id: "customAnswer" }) : placeholder
      }
    ),
    /* @__PURE__ */ jsx2(
      SendIconMessageThemed,
      {
        disabled: hasError || conversationLimitIsReached || isLoading || message === "",
        isLoading,
        sendMessage: prepareSendMessage
      }
    )
  ] }) });
};
const AssistantChatShoppingSendMessagesThemed = withTheme(
  AssistantChatShoppingSendMessages
);
const IDLE_STATE = "IDLE";
const LOADING_STATE = "LOADING";
const ADDED_STATE = "ADDED";
const FAKE_DURATION_BEFORE_ADDED_STATE = 1e3;
const DURATION_BEFORE_RESET = 1500;
const DURATION_BETWEEN_STATE = 500;
const getAnimationStyle$1 = (state) => {
  switch (state) {
    case IDLE_STATE:
    default:
      return {
        top: "0%",
        config: { duration: DURATION_BETWEEN_STATE }
      };
    case LOADING_STATE:
      return {
        top: "-100%",
        config: { duration: DURATION_BETWEEN_STATE }
      };
    case ADDED_STATE:
      return {
        top: "-200%",
        config: { duration: DURATION_BETWEEN_STATE }
      };
  }
};
const AddToCartButton = ({
  theme: theme2,
  addToCart: addToCart2,
  outOfStock,
  customCss
}) => {
  const { isFeatureDisabled } = useDialogConfig();
  const [currentState, setCurrentState] = p$1(IDLE_STATE);
  const animationProps = useSpring(getAnimationStyle$1(currentState));
  const handleAddToCart = async (event) => {
    event.stopPropagation();
    setCurrentState(LOADING_STATE);
    await (addToCart2 == null ? void 0 : addToCart2());
    if ("monster_refresh" in window && window.monster_refresh !== void 0 && typeof window.monster_refresh === "function") {
      await window.monster_refresh(false);
    }
    setTimeout(() => {
      setCurrentState(ADDED_STATE);
    }, FAKE_DURATION_BEFORE_ADDED_STATE);
  };
  _(() => {
    if (currentState === ADDED_STATE) {
      setTimeout(() => {
        setCurrentState(IDLE_STATE);
      }, DURATION_BEFORE_RESET);
    }
  }, [currentState]);
  if (isFeatureDisabled(Features.ADD_TO_CART)) {
    return /* @__PURE__ */ jsx2(Fragment, {});
  }
  return /* @__PURE__ */ jsx2(
    Button,
    {
      disabled: outOfStock,
      onClick: (event) => handleAddToCart(event),
      labelCss: css({
        height: "100%",
        display: "flex",
        alignItems: "center",
        width: "100%",
        justifyContent: "center",
        fontSize: theme2.typography.body3.fontSize,
        color: theme2.palette.classic.white
      }),
      customCss: [
        theme2.palette.custom.ctaBorderType === "straight" ? css({
          borderRadius: 0
        }) : css({}),
        css({
          overflow: "hidden",
          width: "100%",
          position: "relative",
          textTransform: theme2.capitalizeCtas ? "uppercase" : "none",
          backgroundColor: theme2.palette.classic.black,
          "&:hover": {
            backgroundColor: theme2.palette.classic.black
          }
        }),
        customCss ?? css({})
      ],
      children: /* @__PURE__ */ jsxs(
        animated.div,
        {
          css: css({
            position: "absolute",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            width: "100%",
            gap: spacings.xs,
            height: "100%",
            top: 0
          }),
          style: animationProps,
          children: [
            /* @__PURE__ */ jsx2(
              "div",
              {
                css: css({
                  display: "flex",
                  alignItems: "center",
                  position: "absolute",
                  gap: spacings.sm,
                  height: "100%",
                  color: theme2.palette.classic.white,
                  top: 0
                }),
                children: outOfStock ? /* @__PURE__ */ jsx2(MemoizedFormattedMessage, { id: "outOfStock" }) : /* @__PURE__ */ jsx2(MemoizedFormattedMessage, { id: "addToCart" })
              }
            ),
            /* @__PURE__ */ jsx2(
              "div",
              {
                css: css({
                  display: "flex",
                  alignItems: "center",
                  position: "absolute",
                  height: "100%",
                  top: "100%"
                }),
                children: /* @__PURE__ */ jsx2(
                  SpinnerIcon,
                  {
                    color: theme2.palette.classic.white,
                    customCss: infiniteRotationStyle()
                  }
                )
              }
            ),
            /* @__PURE__ */ jsxs(
              "div",
              {
                css: css({
                  display: "flex",
                  alignItems: "center",
                  position: "absolute",
                  height: "100%",
                  top: "200%",
                  gap: spacings.sm
                }),
                children: [
                  /* @__PURE__ */ jsx2(CircleCheckIcon, { color: theme2.palette.classic.white }),
                  /* @__PURE__ */ jsx2(MemoizedFormattedMessage, { id: "productAdded" })
                ]
              }
            )
          ]
        }
      )
    }
  );
};
const AddToCartButtonThemed = withTheme(AddToCartButton);
const AskSpecificInformations = ({
  askSomethingOnProduct,
  suggestions,
  theme: theme2,
  containerStyle,
  description: description2,
  assistantName,
  inputPlaceholder
}) => {
  const intl = useIntl();
  if (suggestions === void 0 || suggestions.length === 0) return /* @__PURE__ */ jsx2(Fragment, {});
  return /* @__PURE__ */ jsxs(
    "div",
    {
      css: [
        css({
          display: "flex",
          flexDirection: "column",
          gap: spacings.xl
        }),
        containerStyle
      ],
      children: [
        /* @__PURE__ */ jsxs(
          "div",
          {
            css: css({
              display: "flex",
              alignItems: "flex-start",
              flexDirection: "column"
            }),
            children: [
              /* @__PURE__ */ jsx2(
                Typography,
                {
                  variant: "xs-base",
                  color: theme2.palette.grey550,
                  customCss: css({ textTransform: "uppercase" }),
                  children: assistantName ?? /* @__PURE__ */ jsx2(MemoizedFormattedMessage, { id: "titleAssistantModal" })
                }
              ),
              /* @__PURE__ */ jsx2(Typography, { variant: "md-paragraph", children: description2 ?? /* @__PURE__ */ jsx2(MemoizedFormattedMessage, { id: "descriptionAssistantModal" }) })
            ]
          }
        ),
        /* @__PURE__ */ jsxs(
          "div",
          {
            css: css({
              display: "flex",
              gap: spacings.xxl,
              flexDirection: "column"
            }),
            children: [
              /* @__PURE__ */ jsx2(
                "div",
                {
                  css: css({
                    display: "flex",
                    flexDirection: "column",
                    gap: spacings.md
                  }),
                  children: suggestions.slice(0, 2).map((suggestion, index2) => /* @__PURE__ */ jsx2(
                    SuggestionThemed,
                    {
                      title: suggestion.question,
                      onSelect: (question) => askSomethingOnProduct(question, suggestion.answer)
                    },
                    `suggestion-${suggestion.question}-${index2}`
                  ))
                }
              ),
              /* @__PURE__ */ jsx2(
                AssistantChatShoppingSendMessagesThemed,
                {
                  placeholder: inputPlaceholder ?? intl.formatMessage({ id: "askAnything" }),
                  enableSendMessageOnBlur: true,
                  onSendMessage: askSomethingOnProduct
                }
              )
            ]
          }
        )
      ]
    }
  );
};
const AskSpecificInformationsThemed = withTheme(AskSpecificInformations);
const getProductPageQuestionsKey = ({
  apiKey: apiKey2,
  pagePath,
  locale: locale2,
  productId
}) => {
  return ["product-page-questions", { apiKey: apiKey2, pagePath, locale: locale2, productId }];
};
const useGetProductPageQuestions = ({
  apiKey: apiKey2,
  pagePath,
  locale: locale2,
  productId,
  onSuccess,
  onError
}) => {
  const key = getProductPageQuestionsKey({
    apiKey: apiKey2,
    productId,
    locale: locale2,
    pagePath
  });
  return useQuery(
    key,
    async () => getProductPageQuestions({
      pagePath,
      apiKey: apiKey2,
      locale: locale2,
      productId: formatProductId(productId)
    }),
    {
      onSuccess,
      onError
    }
  );
};
const isLegacyProductQuestions = (productQuestions) => Array.isArray(productQuestions);
const ProductDetails = ({
  recommendation,
  askSomethingOnProduct
}) => {
  var _a3, _b2, _c2;
  const isMobile = useIsMobile({ size: MEDIUM_MOBILE_NUMBER });
  const { apiKey: apiKey2, handleAddToCart } = useAssistantMessages();
  const { languageIsoCode: languageIsoCode2 } = useLocalization();
  const [productQuestions, setProductQuestions] = p$1();
  const [selectedVariantId, setSelectedVariantId] = p$1(
    formatProductVariantId(
      recommendation.selectedVariantId ?? ((_a3 = recommendation.product.variants[0]) == null ? void 0 : _a3.id) ?? ""
    )
  );
  const { handle: handle2 } = recommendation.product;
  useGetProductPageQuestions({
    apiKey: apiKey2,
    locale: languageIsoCode2,
    pagePath: handle2,
    productId: recommendation.product.id,
    onSuccess: (data) => {
      if (isLegacyProductQuestions(data)) {
        setProductQuestions({
          questions: data
        });
        return;
      }
      if (!Array.isArray(data)) {
        setProductQuestions(data);
      }
      return;
    }
  });
  const handleChangeVariantId = (newVariantIdSelected) => {
    if (newVariantIdSelected === void 0) return;
    setSelectedVariantId(formatProductVariantId(newVariantIdSelected));
  };
  const navigateToProduct = () => {
    window.open(`${window.location.origin}/products/${handle2}`, "_blank");
  };
  const selectedVariant = recommendation.product.variants.find(
    (variant) => formatProductVariantId(variant.id) === selectedVariantId
  );
  const imageSize = isMobile ? RECOMMENDATION_MOBILE_SIZE : RECOMMENDATION_DESKTOP_SIZE;
  return /* @__PURE__ */ jsxs(
    "div",
    {
      css: css({ display: "flex", flexDirection: "column", gap: spacings.md }),
      children: [
        /* @__PURE__ */ jsx2(
          ProductImage,
          {
            width: imageSize,
            height: imageSize,
            url: ((_b2 = selectedVariant == null ? void 0 : selectedVariant.image) == null ? void 0 : _b2.url) ?? ((_c2 = recommendation.product.featuredImage) == null ? void 0 : _c2.url) ?? "",
            customCss: css({
              margin: "0 auto",
              border: `1px solid #F4F0F4`
            })
          }
        ),
        /* @__PURE__ */ jsxs(
          "div",
          {
            css: css({
              display: "flex",
              flexDirection: "column",
              gap: spacings.xxl
            }),
            children: [
              /* @__PURE__ */ jsx2(
                ProductMainInformations,
                {
                  product: recommendation.product,
                  selectedVariantId
                }
              ),
              recommendation.product.variants.length > 1 && recommendation.product.options !== void 0 && /* @__PURE__ */ jsx2(
                VariantSelection,
                {
                  options: recommendation.product.options,
                  variants: recommendation.product.variants,
                  selectedVariantId,
                  onChangeVariantId: handleChangeVariantId
                }
              ),
              /* @__PURE__ */ jsx2(
                AddToCartButtonThemed,
                {
                  addToCart: () => handleAddToCart(selectedVariantId),
                  outOfStock: (selectedVariant == null ? void 0 : selectedVariant.inventoryQuantity) === 0
                }
              ),
              /* @__PURE__ */ jsx2(
                AskSpecificInformationsThemed,
                {
                  description: productQuestions == null ? void 0 : productQuestions.description,
                  assistantName: productQuestions == null ? void 0 : productQuestions.assistantName,
                  suggestions: productQuestions == null ? void 0 : productQuestions.questions,
                  askSomethingOnProduct,
                  containerStyle: css({ gap: spacings.xl })
                }
              ),
              /* @__PURE__ */ jsx2(
                ProductAdditionnalInformations,
                {
                  recommendation: recommendation.product
                }
              ),
              /* @__PURE__ */ jsx2(
                Button,
                {
                  variant: "secondary",
                  iconLeft: /* @__PURE__ */ jsx2(LinkIcon, {}),
                  onClick: navigateToProduct,
                  children: /* @__PURE__ */ jsx2(MemoizedFormattedMessage, { id: "seeProductOrigin" })
                }
              )
            ]
          }
        )
      ]
    }
  );
};
const RecommendationDrawer = ({
  open,
  onClose,
  recommendation,
  backButtonText,
  askSomethingOnProduct
}) => {
  if (recommendation === void 0) return /* @__PURE__ */ jsx2(Fragment, {});
  const handleQuestionProduct = (question, answer) => {
    askSomethingOnProduct(question, answer);
    onClose();
  };
  return /* @__PURE__ */ jsxs(
    Drawer,
    {
      display: open,
      onClose,
      id: "dialog-drawer",
      customDrawerStyle: css({
        top: 0,
        margin: 0,
        padding: `${spacings.lg} ${spacings.xxxl}`,
        height: "100%",
        borderRadius: 0,
        right: 0,
        width: "620px",
        zIndex: theme.zIndex.highest,
        [`@media screen and (max-width: ${TABLET_BP})`]: {
          width: "100%",
          padding: `${spacings.lg} ${spacings.xxxl}`
        }
      }),
      children: [
        /* @__PURE__ */ jsx2(
          Button,
          {
            enableCleanIconOnlyStyle: true,
            iconLeft: /* @__PURE__ */ jsx2(CarretLeftIcon, { customCss: css({ width: "24px", height: "24px" }) }),
            onClick: onClose,
            customCss: css({
              alignSelf: "flex-start"
            }),
            children: /* @__PURE__ */ jsx2(Typography, { variant: "lg-lg", children: backButtonText })
          }
        ),
        /* @__PURE__ */ jsx2(
          "div",
          {
            css: [
              assistantChatShoppingContainerStyle,
              css({
                overflowY: "auto",
                overflowX: "hidden",
                width: "100%",
                "&::-webkit-scrollbar": {
                  display: "none"
                },
                msOverflowStyle: "none",
                scrollbarWidth: "none"
              })
            ],
            children: /* @__PURE__ */ jsx2(
              ProductDetails,
              {
                recommendation,
                askSomethingOnProduct: handleQuestionProduct
              }
            )
          }
        )
      ]
    }
  );
};
const QuestionProductCard = ({
  product,
  selectedVariantId,
  onProductClick
}) => {
  var _a3, _b2;
  const productCardRef = F$1(null);
  const { containerInformations, setupAdditionalContainerInformations } = useContainerWatcher();
  const variantSelected = product.variants.find(
    (variant) => selectedVariantId !== void 0 && formatProductVariantId(variant.id) === formatProductVariantId(selectedVariantId)
  );
  const { onAddToCart, icon } = useProductCardAddToCart(selectedVariantId);
  const selectedImage = ((_a3 = variantSelected == null ? void 0 : variantSelected.image) == null ? void 0 : _a3.url) ?? ((_b2 = product.featuredImage) == null ? void 0 : _b2.url) ?? "";
  _(() => {
    if (productCardRef.current === null) return;
    setupAdditionalContainerInformations(productCardRef.current);
  }, [productCardRef, setupAdditionalContainerInformations]);
  return /* @__PURE__ */ jsxs(
    DivClickable,
    {
      ref: productCardRef,
      onClick: () => onProductClick == null ? void 0 : onProductClick(),
      customCss: css({
        display: "flex",
        gap: spacings.lg,
        width: (containerInformations == null ? void 0 : containerInformations.width) ?? "100%",
        padding: `${spacings.md} ${spacings.lg}`,
        border: `1px solid ${theme.palette.grey100}`,
        cursor: "pointer",
        position: "fixed",
        top: (containerInformations == null ? void 0 : containerInformations.top) ?? 0,
        zIndex: theme.zIndex.high,
        background: theme.palette.classic.white,
        boxShadow: theme.shadow.lg,
        borderRadius: theme.borderRadius.xl
      }),
      children: [
        /* @__PURE__ */ jsx2(
          ProductImage,
          {
            url: selectedImage,
            withBorder: false,
            height: 72,
            width: 72
          }
        ),
        /* @__PURE__ */ jsxs(
          "div",
          {
            css: css({
              display: "flex",
              flexDirection: "row",
              gap: spacings.xxl,
              width: "100%",
              justifyContent: "space-between"
            }),
            children: [
              /* @__PURE__ */ jsx2(
                ProductMainInformations,
                {
                  product,
                  selectedVariantId,
                  customTitleStyle: css({
                    fontSize: `${theme.typography.h3.fontSize}px`,
                    fontWeight: 500,
                    lineHeight: theme.typography.body2.lineHeight,
                    [`@media screen and (max-width: ${MEDIUM_MOBILE_BP})`]: {
                      fontSize: `${theme.typography.body2.fontSize}px`
                    }
                  })
                }
              ),
              /* @__PURE__ */ jsx2(
                Button,
                {
                  variant: "blank",
                  size: "sm",
                  iconLeft: icon,
                  onClick: onAddToCart,
                  customCss: css({
                    width: "40px",
                    minWidth: "40px",
                    height: "40px",
                    borderRadius: "100%",
                    border: `1px solid ${theme.palette.grey200}`
                  })
                }
              )
            ]
          }
        )
      ]
    }
  );
};
const QuestionProductDetails = ({
  selectedProductId,
  selectedVariantId
}) => {
  const localization = useLocalization();
  const { apiKey: apiKey2 } = useAssistantMessages();
  const { setDisplayRecommendationDrawer, setSelectedRecommendation } = useRecommendationDrawer();
  const { productId } = useCurrentProductId();
  const getProductQuery = useGetProduct({
    apiKey: apiKey2,
    id: selectedProductId ?? productId,
    locale: localization.languageIsoCode,
    countryCode: localization.countryCode
  });
  if (!getProductQuery.isSuccess) {
    return /* @__PURE__ */ jsx2(PageLoader, {});
  }
  const product = getProductQuery.data;
  const openProductDetails = () => {
    setSelectedRecommendation({
      product,
      selectedVariantId
    });
    setDisplayRecommendationDrawer(true);
  };
  return /* @__PURE__ */ jsx2(
    QuestionProductCard,
    {
      product,
      selectedVariantId,
      onProductClick: openProductDetails
    }
  );
};
const ProductQuestionMessage = ({
  message
}) => {
  if (message === void 0) return /* @__PURE__ */ jsx2(Fragment, {});
  const { output, selectedProduct } = message;
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    selectedProduct !== void 0 && /* @__PURE__ */ jsx2(
      QuestionProductDetails,
      {
        selectedProductId: getRawProductId(selectedProduct.id),
        selectedVariantId: getRawProductId(
          selectedProduct.selectedVariantId ?? ""
        )
      }
    ),
    /* @__PURE__ */ jsx2(HumanMessageThemed, { message: output })
  ] });
};
const AssistantChatShoppingMessage = ({
  message,
  isLastMessage
}) => {
  const { isFeatureDisabled } = useDialogConfig();
  const { displayDiagnostic } = useAssistantState();
  if (message === void 0) return /* @__PURE__ */ jsx2(Fragment, {});
  const { output, senderId, pictureUrl } = message;
  const isHuman = senderId === "human";
  const isProductQuestionMessage = senderId === "questionMessage";
  if (isHuman) {
    return /* @__PURE__ */ jsx2(HumanMessageThemed, { message: output, pictureUrl });
  }
  if (isProductQuestionMessage) {
    if (isFeatureDisabled(Features.PRODUCT_CARD) || displayDiagnostic === true) {
      return /* @__PURE__ */ jsx2(Fragment, {});
    }
    return /* @__PURE__ */ jsx2(ProductQuestionMessage, { message });
  }
  return /* @__PURE__ */ jsx2(AssistantMessageThemed, { message, isLastMessage });
};
const ConversationLimitReachedMessageError = () => {
  return /* @__PURE__ */ jsx2(AssistantChatShoppingMessageWrapper, { children: /* @__PURE__ */ jsxs(
    "div",
    {
      css: css({
        display: "flex",
        gap: spacings.sm,
        alignItems: "center",
        background: theme.palette.red100,
        padding: `${spacings.sm} ${spacings.md}`,
        borderRadius: theme.borderRadius.md
      }),
      children: [
        /* @__PURE__ */ jsx2(InformationCircleIcon, { color: theme.palette.red600 }),
        /* @__PURE__ */ jsx2(Typography, { variant: "sm-md", children: /* @__PURE__ */ jsx2(MemoizedFormattedMessage, { id: "errors.conversationLimitReached" }) })
      ]
    }
  ) });
};
const BackButton = ({
  onBack,
  theme: theme2
}) => {
  return /* @__PURE__ */ jsx2(
    Button,
    {
      onClick: onBack,
      variant: "blank",
      enableCleanIconOnlyStyle: true,
      iconLeft: /* @__PURE__ */ jsx2(ArrowLeftIcon, { color: theme2.palette.custom.primaryColor }),
      customCss: css({
        position: "absolute",
        top: spacings.md,
        left: spacings.md
      })
    }
  );
};
const BackButtonThemed = withTheme(BackButton);
const takePictureMobileStyle$1 = css({
  position: "absolute",
  bottom: spacings.xxl,
  touchAction: "manipulation"
});
const takePictureDesktopStyle$1 = css({
  position: "absolute",
  bottom: spacings.lg,
  zIndex: theme.zIndex.highest
});
const buttonStyle = (theme2) => css({
  backgroundColor: theme2.palette.custom.primaryColor,
  border: "unset",
  transition: "all 0.2s ease-in-out",
  "&:hover": {
    transform: "scale(1.03)",
    backgroundColor: theme2.palette.custom.primaryColor
  }
});
const ValidateButton = ({
  onValidate,
  onRetry,
  theme: theme2
}) => {
  const isMobile = useIsMobile({ size: TABLET_BP_NUMBER });
  return /* @__PURE__ */ jsxs(
    FlexBox,
    {
      justify: "center",
      align: "center",
      gap: "md",
      customCss: isMobile ? takePictureMobileStyle$1 : takePictureDesktopStyle$1,
      children: [
        /* @__PURE__ */ jsx2(
          Button,
          {
            variant: "secondary",
            onClick: onRetry,
            customCss: buttonStyle(theme2),
            iconLeft: /* @__PURE__ */ jsx2(CrossIcon, { color: theme2.palette.custom.ctaTextColor })
          }
        ),
        /* @__PURE__ */ jsx2(
          Button,
          {
            variant: "secondary",
            onClick: onValidate,
            customCss: buttonStyle(theme2),
            iconLeft: /* @__PURE__ */ jsx2(CheckIcon, { color: theme2.palette.custom.ctaTextColor })
          }
        )
      ]
    }
  );
};
const ValidateButtonThemed = withTheme(ValidateButton);
const mobileCameraStyle = css({
  position: "fixed",
  top: 0,
  left: 0,
  width: "100%",
  height: "100%",
  zIndex: theme.zIndex.highest,
  touchAction: "manipulation",
  background: theme.palette.classic.black
});
const desktopCameraStyle = css({
  position: "relative",
  width: "100%",
  height: "100%",
  minHeight: "300px",
  borderRadius: theme.borderRadius.xl,
  background: theme.palette.classic.black,
  overflow: "auto"
});
const videoStyle = css({
  objectFit: "cover",
  height: "100%"
});
const CapturedCamera = ({
  isMobile,
  hideCameraScreen,
  showCameraScreen,
  submitPicture,
  capturedImage
}) => {
  return /* @__PURE__ */ jsxs(
    FlexBox,
    {
      customCss: isMobile ? mobileCameraStyle : desktopCameraStyle,
      justify: "center",
      align: "center",
      children: [
        /* @__PURE__ */ jsx2(
          "div",
          {
            css: css({
              width: "100%",
              height: "100%",
              minHeight: "300px",
              backgroundSize: "cover",
              backgroundRepeat: "no-repeat",
              backgroundPosition: "center",
              backgroundImage: `url(${capturedImage})`,
              "&:empty": { display: "block" }
            })
          }
        ),
        isMobile && /* @__PURE__ */ jsx2(BackButtonThemed, { onBack: hideCameraScreen }),
        /* @__PURE__ */ jsx2(
          ValidateButtonThemed,
          {
            onValidate: submitPicture,
            onRetry: showCameraScreen
          }
        )
      ]
    }
  );
};
const ErrorCamera = ({
  isMobile,
  hideCameraScreen
}) => {
  return /* @__PURE__ */ jsxs(
    FlexBox,
    {
      customCss: isMobile ? mobileCameraStyle : desktopCameraStyle,
      justify: "center",
      align: "center",
      children: [
        /* @__PURE__ */ jsx2(
          "div",
          {
            css: [
              css({
                position: "absolute",
                top: 0,
                left: 0,
                height: "100%",
                width: "100%",
                "&:empty": { display: "block" }
              })
            ]
          }
        ),
        isMobile && /* @__PURE__ */ jsx2(BackButtonThemed, { onBack: hideCameraScreen }),
        /* @__PURE__ */ jsx2(
          Typography,
          {
            variant: "sm-reg",
            color: theme.palette.classic.white,
            customCss: css({
              position: "absolute",
              top: "calc(50% - 10px)"
            }),
            children: /* @__PURE__ */ jsx2(MemoizedFormattedMessage, { id: "diagnostic.allowCameraAccess" })
          }
        )
      ]
    }
  );
};
const HiddenCamera = ({
  showCameraScreen,
  handlePictureUpload
}) => {
  return /* @__PURE__ */ jsxs(
    ScrollContainer,
    {
      scrollType: "full",
      customContainerStyle: css({
        display: "flex",
        justifyContent: "flex-start",
        whiteSpace: "nowrap",
        padding: `0 ${spacings.xs}`
      }),
      children: [
        /* @__PURE__ */ jsx2(
          Button,
          {
            size: "md",
            iconLeft: /* @__PURE__ */ jsx2(CameraIcon, {}),
            variant: "secondary",
            onClick: showCameraScreen,
            children: /* @__PURE__ */ jsx2(MemoizedFormattedMessage, { id: "diagnostic.takePicture" })
          }
        ),
        /* @__PURE__ */ jsx2(
          Button,
          {
            customCss: css({ position: "relative" }),
            size: "md",
            iconLeft: /* @__PURE__ */ jsx2(UploadIcon, {}),
            variant: "secondary",
            children: /* @__PURE__ */ jsxs(Fragment, { children: [
              /* @__PURE__ */ jsx2(MemoizedFormattedMessage, { id: "diagnostic.uploadPicture" }),
              /* @__PURE__ */ jsx2(
                "input",
                {
                  onChange: handlePictureUpload,
                  id: "diagnostic-picture-upload",
                  type: "file",
                  accept: "image/png, image/jpeg",
                  css: css({
                    opacity: 0,
                    position: "absolute",
                    height: "100%",
                    width: "100%",
                    top: 0,
                    left: 0,
                    cursor: "pointer"
                  })
                }
              )
            ] })
          }
        )
      ]
    }
  );
};
const takePictureMobileStyle = css({
  position: "absolute",
  bottom: spacings.xxl,
  touchAction: "manipulation"
});
const takePictureDesktopStyle = css({
  position: "absolute",
  bottom: spacings.lg,
  zIndex: theme.zIndex.highest
});
const TakePictureButton = ({
  onTakePicture,
  theme: theme2
}) => {
  const isMobile = useIsMobile({ size: TABLET_BP_NUMBER });
  return /* @__PURE__ */ jsx2(
    Button,
    {
      onClick: onTakePicture,
      customCss: [
        isMobile ? takePictureMobileStyle : takePictureDesktopStyle,
        css({
          borderRadius: "100%",
          background: theme2.palette.custom.primaryColor,
          width: "64px",
          height: "64px",
          userSelect: "none",
          "&:hover": {
            background: theme2.palette.custom.primaryColor
          }
        })
      ],
      children: /* @__PURE__ */ jsx2(
        "div",
        {
          css: css({
            width: "56px",
            height: "56px",
            border: `2px solid ${theme2.palette.custom.ctaTextColor}`,
            borderRadius: "100%",
            "&:empty": {
              display: "block"
            }
          })
        }
      )
    }
  );
};
const TakePictureButtonThemed = withTheme(TakePictureButton);
var CameraStates = /* @__PURE__ */ ((CameraStates2) => {
  CameraStates2["HIDDEN"] = "hidden";
  CameraStates2["SHOWING"] = "showing";
  CameraStates2["ERROR"] = "error";
  CameraStates2["CAPTURED"] = "captured";
  CameraStates2["UPLOADING"] = "uploading";
  CameraStates2["UPLOADED"] = "uploaded";
  return CameraStates2;
})(CameraStates || {});
const ShowCamera = ({
  isMobile,
  onChangeCameraState,
  onCapturedImage
}) => {
  const canvasRef = F$1(null);
  const videoRef = F$1(null);
  const [isVideoLoaded, setIsVideoLoaded] = p$1(false);
  const startCamera = x$2(async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ video: true });
      if (videoRef.current) {
        videoRef.current.srcObject = stream;
        videoRef.current.onloadeddata = () => {
          setIsVideoLoaded(true);
        };
      }
      onChangeCameraState(CameraStates.SHOWING);
    } catch (error2) {
      console.error("Error accessing the camera:", error2);
      onChangeCameraState(CameraStates.ERROR);
    }
  }, [videoRef, setIsVideoLoaded, onChangeCameraState]);
  const takePicture = x$2(() => {
    if (videoRef.current === null || canvasRef.current === null) return;
    const canvas = canvasRef.current;
    const video = videoRef.current;
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    const context = canvas.getContext("2d");
    if (context === null) return;
    context.translate(canvas.width, 0);
    context.scale(-1, 1);
    context.drawImage(video, 0, 0, canvas.width, canvas.height);
    context.save();
    const imageDataUrl = canvas.toDataURL("image/png");
    onCapturedImage(imageDataUrl);
    onChangeCameraState(CameraStates.CAPTURED);
  }, [canvasRef, videoRef, onCapturedImage, onChangeCameraState]);
  const stopCamera = x$2(() => {
    if (videoRef.current === null) return;
    const stream = videoRef.current.srcObject;
    if (stream === null) return;
    const tracks = stream.getTracks();
    tracks.forEach((track) => {
      track.stop();
    });
    videoRef.current.srcObject = null;
    setIsVideoLoaded(false);
  }, [videoRef]);
  _(() => {
    void startCamera();
    return () => {
      stopCamera();
    };
  }, [startCamera, stopCamera]);
  return /* @__PURE__ */ jsxs(
    FlexBox,
    {
      customCss: isMobile ? mobileCameraStyle : desktopCameraStyle,
      justify: "center",
      align: "center",
      children: [
        /* @__PURE__ */ jsx2(
          "video",
          {
            ref: videoRef,
            autoPlay: true,
            playsInline: true,
            css: [videoStyle, !isMobile && css({ width: "100%" })],
            children: /* @__PURE__ */ jsx2("track", { kind: "captions" })
          }
        ),
        /* @__PURE__ */ jsx2("canvas", { ref: canvasRef, style: { display: "none" } }),
        !isVideoLoaded && /* @__PURE__ */ jsx2(
          Typography,
          {
            variant: "sm-reg",
            color: theme.palette.classic.white,
            customCss: css({
              position: "absolute"
            }),
            children: /* @__PURE__ */ jsx2(MemoizedFormattedMessage, { id: "diagnostic.loading" })
          }
        ),
        /* @__PURE__ */ jsx2(
          BackButtonThemed,
          {
            onBack: () => onChangeCameraState(CameraStates.HIDDEN)
          }
        ),
        /* @__PURE__ */ jsx2(TakePictureButtonThemed, { onTakePicture: takePicture })
      ]
    }
  );
};
const UploadedCamera = ({
  isMobile,
  capturedImage
}) => {
  return /* @__PURE__ */ jsx2(
    "div",
    {
      css: css({
        borderRadius: theme.borderRadius.xl,
        alignSelf: "flex-end",
        width: isMobile ? "170px" : "240px",
        height: isMobile ? "170px" : "240px",
        backgroundSize: "cover",
        backgroundRepeat: "no-repeat",
        backgroundPosition: "center",
        backgroundImage: `url(${capturedImage})`,
        "&:empty": { display: "block" }
      })
    }
  );
};
const dataURLToFile = (dataUrl, filename) => {
  var _a3;
  const arr = dataUrl.split(",");
  const firstElement = arr[0];
  const secondElement = arr[1];
  if (firstElement === void 0 || secondElement === void 0) {
    throw new Error("Invalid data URL");
  }
  const mime = (_a3 = firstElement.match(/:(.*?);/)) == null ? void 0 : _a3[1];
  if (mime === void 0) {
    console.error("Invalid data URL");
  }
  const bstr = atob(secondElement);
  let n2 = bstr.length;
  const u8arr = new Uint8Array(n2);
  while (n2--) {
    u8arr[n2] = bstr.charCodeAt(n2);
  }
  return new File([u8arr], filename, { type: mime });
};
const getBase64FromFile = (file) => {
  return new Promise((resolve2, reject) => {
    const fileReader = new FileReader();
    fileReader.readAsDataURL(file);
    fileReader.onload = () => {
      const result = fileReader.result;
      const readableByApi = result.split(",").pop();
      resolve2({ readableByApi, readableByImg: result });
    };
    fileReader.onerror = () => {
      reject(new Error("Error reading file"));
    };
  });
};
const handleFileRead = async (event) => {
  const target = event.target;
  if (target.files !== null) {
    const file = target.files[0];
    if (file) {
      const { readableByApi, readableByImg } = await getBase64FromFile(file);
      return {
        file,
        base64: readableByApi,
        readableByImg
      };
    }
  }
  return void 0;
};
const ErrorMessage = ({
  retryLastMessage
}) => {
  return /* @__PURE__ */ jsx2(AssistantChatShoppingMessageWrapper, { children: /* @__PURE__ */ jsx2(
    Button,
    {
      onClick: retryLastMessage,
      enableCleanIconOnlyStyle: true,
      labelCss: css({
        color: theme.palette.red400,
        "&:hover": { color: theme.palette.red400 }
      }),
      variant: "blank",
      iconLeft: /* @__PURE__ */ jsx2(
        RefreshIcon,
        {
          color: theme.palette.red400,
          customCss: css({ width: "16px", height: "16px" })
        }
      ),
      children: /* @__PURE__ */ jsx2(MemoizedFormattedMessage, { id: "errors.internalError" })
    }
  ) });
};
const getPictureUrlByContentType = (pictureUrl, contentType) => {
  if (contentType === "image/png") {
    return pictureUrl.pngUploadUrl;
  }
  return pictureUrl.jpgUploadUrl;
};
const DiagnosticCamera = () => {
  const { activateWebSocket: activateWebSocket2 } = P$1(WebSocketContext);
  const { updateAssistantState, hasError } = useAssistantState();
  const { language: language2, languageIsoCode: languageIsoCode2, countryCode: countryCode2 } = useLocalization();
  const { apiKey: apiKey2, userId: userId2, getSessionId } = useAssistantMessages();
  const { data: diagnosticPictureUrlResponse } = useGetDiagnosticPictureUrl({
    sessionId: getSessionId(),
    language: language2,
    locale: languageIsoCode2,
    countryCode: countryCode2,
    apiKey: apiKey2,
    userId: userId2
  });
  const { mutate: uploadPicture2 } = useUploadPicture();
  const [cameraState, setCameraState] = p$1(
    CameraStates.HIDDEN
  );
  const isMobile = useIsMobile({ size: TABLET_BP_NUMBER });
  const [capturedImage, setCapturedImage] = p$1();
  const submitPicture = () => {
    if (capturedImage === void 0 || diagnosticPictureUrlResponse === void 0)
      return;
    const file = dataURLToFile(capturedImage, "diagnostic.png");
    const pictureUrl = getPictureUrlByContentType(
      diagnosticPictureUrlResponse,
      file.type
    );
    uploadPicture2({
      path: pictureUrl.url,
      file,
      fields: pictureUrl.fields
    });
    showUploadedPictureScreen();
    activateWebSocket2();
    updateAssistantState({
      isLoadingToWrite: true,
      isRunningDiagnostic: true,
      displayCustomDiagnosticLoader: true
    });
  };
  const handlePictureUpload = async (event) => {
    const data = await handleFileRead(event);
    if ((data == null ? void 0 : data.file) === void 0) return;
    setCapturedImage(data.readableByImg);
    setCameraState(CameraStates.CAPTURED);
  };
  const retryLastMessage = () => {
    updateAssistantState({
      hasError: false,
      isLoadingToWrite: false
    });
    hideCameraScreen();
  };
  const hideCameraScreen = () => {
    setCameraState(CameraStates.HIDDEN);
  };
  const showCameraScreen = () => setCameraState(CameraStates.SHOWING);
  const showUploadedPictureScreen = () => {
    setCameraState(CameraStates.UPLOADED);
  };
  if (hasError === true) {
    return /* @__PURE__ */ jsx2(ErrorMessage, { retryLastMessage });
  }
  switch (cameraState) {
    case CameraStates.SHOWING:
      return /* @__PURE__ */ jsx2(
        ShowCamera,
        {
          isMobile,
          onChangeCameraState: setCameraState,
          onCapturedImage: setCapturedImage
        }
      );
    case CameraStates.ERROR:
      return /* @__PURE__ */ jsx2(ErrorCamera, { isMobile, hideCameraScreen });
    case CameraStates.CAPTURED:
      return /* @__PURE__ */ jsx2(
        CapturedCamera,
        {
          isMobile,
          hideCameraScreen,
          showCameraScreen,
          submitPicture,
          capturedImage: capturedImage ?? ""
        }
      );
    case CameraStates.UPLOADED:
      return /* @__PURE__ */ jsx2(
        UploadedCamera,
        {
          isMobile,
          capturedImage: capturedImage ?? ""
        }
      );
    case CameraStates.HIDDEN:
    default:
      return /* @__PURE__ */ jsx2(
        HiddenCamera,
        {
          showCameraScreen,
          handlePictureUpload
        }
      );
  }
};
const Diagnostic = () => {
  const intl = useIntl();
  const defaultMessage = intl.formatMessage({
    id: "diagnostic.defaultMessage"
  });
  const isMobile = useIsMobile({ size: SMALL_MOBILE_NUMBER });
  return /* @__PURE__ */ u$2(
    FlexBox,
    {
      direction: "column",
      gap: "md",
      customCss: css({ marginTop: spacings.lg, overflow: "hidden" }),
      children: /* @__PURE__ */ u$2(
        AssistantMessageThemed,
        {
          childrenWithMargin: !isMobile,
          message: {
            messageId: "diagnostic-message",
            senderId: "ai",
            output: defaultMessage,
            done: true
          },
          children: /* @__PURE__ */ u$2(DiagnosticCamera, {})
        }
      )
    }
  );
};
const textStyle = css({
  display: "flex",
  gap: spacings.xs,
  alignItems: "center"
});
const DiagnosticLoader = () => {
  const intl = useIntl();
  const [stepDone, setStepDone] = p$1(0);
  const animationTexts = [
    intl.formatMessage({ id: "animations.uploadingPicture" }),
    intl.formatMessage({ id: "animations.analyzingPicture" }),
    intl.formatMessage({ id: "animations.createDiagnostic" })
  ];
  _(() => {
    const interval = setInterval(() => {
      setStepDone((prev2) => prev2 + 1);
    }, 2e3);
    return () => {
      clearInterval(interval);
      setStepDone(0);
    };
  }, []);
  const [bubbleAnimation] = useSpring(
    () => ({
      from: { transform: "scale(0.4)" },
      to: { transform: "scale(1)" },
      loop: { reverse: true },
      delay: 700,
      config: { duration: 700 }
    }),
    []
  );
  return /* @__PURE__ */ jsxs(FlexBox, { gap: "lg", align: "flex-start", children: [
    /* @__PURE__ */ jsx2(
      animated.div,
      {
        style: bubbleAnimation,
        css: css({
          width: "32px",
          height: "32px",
          borderRadius: "100%",
          background: theme.palette.grey200,
          "&:empty": {
            display: "block"
          }
        })
      }
    ),
    /* @__PURE__ */ jsxs(FlexBox, { gap: "xs", direction: "column", children: [
      /* @__PURE__ */ jsx2(
        Typography,
        {
          variant: "sm-reg",
          color: theme.palette.grey400,
          customCss: textStyle,
          children: /* @__PURE__ */ jsxs(Fragment, { children: [
            animationTexts[0],
            " ",
            stepDone >= 1 ? /* @__PURE__ */ jsx2(CheckIcon, { color: theme.palette.grey400 }) : /* @__PURE__ */ jsx2(Fragment, {})
          ] })
        }
      ),
      /* @__PURE__ */ jsx2(
        Typography,
        {
          variant: "sm-reg",
          color: theme.palette.grey400,
          customCss: textStyle,
          children: /* @__PURE__ */ jsxs(Fragment, { children: [
            animationTexts[1],
            " ",
            stepDone >= 2 ? /* @__PURE__ */ jsx2(CheckIcon, { color: theme.palette.grey400 }) : /* @__PURE__ */ jsx2(Fragment, {})
          ] })
        }
      ),
      /* @__PURE__ */ jsx2(
        Typography,
        {
          variant: "sm-reg",
          color: theme.palette.grey400,
          customCss: textStyle,
          children: /* @__PURE__ */ jsxs(Fragment, { children: [
            animationTexts[2],
            " ",
            stepDone >= 3 ? /* @__PURE__ */ jsx2(CheckIcon, { color: theme.palette.grey400 }) : /* @__PURE__ */ jsx2(Fragment, {})
          ] })
        }
      )
    ] })
  ] });
};
const EmptyMessage = () => {
  return /* @__PURE__ */ jsx2(
    "div",
    {
      css: css({
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center",
        height: "100%",
        background: theme.palette.classic.white,
        border: `1px solid ${theme.palette.grey100}`,
        borderRadius: theme.borderRadius.xl,
        padding: `${spacings.md} ${spacings.lg}`,
        boxShadow: theme.shadow.lg
      }),
      children: /* @__PURE__ */ jsx2(Typography, { variant: "sm-md", color: theme.palette.grey600, children: /* @__PURE__ */ jsx2(MemoizedFormattedMessage, { id: "conversationEmpty" }) })
    }
  );
};
const TRANSLATE_Y = 24;
const MOBILE_TRANSLATE_Y = 20;
const getStyle = (index2, maxIndex, isMobile) => {
  if (index2 === maxIndex) {
    return {
      from: {
        transform: `translateY(${-index2 * (isMobile ? MOBILE_TRANSLATE_Y : TRANSLATE_Y)}px)`
      },
      to: {
        transform: `translateY(0px)`
      }
    };
  }
  return {
    from: {
      transform: `translateY(${-index2 * (isMobile ? MOBILE_TRANSLATE_Y : TRANSLATE_Y)}px)`
    },
    to: {
      transform: `translateY(${(-index2 - 1) * (isMobile ? MOBILE_TRANSLATE_Y : TRANSLATE_Y)}px)`
    }
  };
};
const WritingLoader = () => {
  const isMobile = useIsMobile({ size: MEDIUM_MOBILE_NUMBER });
  const intl = useIntl();
  const [textIndex, setTextIndex] = p$1(0);
  const animationTexts = [
    intl.formatMessage({ id: "animations.thinking" }),
    intl.formatMessage({ id: "animations.indexing" }),
    intl.formatMessage({ id: "animations.finding" })
  ];
  const [bubbleAnimation] = useSpring(
    () => ({
      from: { transform: "scale(0.4)" },
      to: { transform: "scale(1)" },
      loop: { reverse: true },
      delay: 700,
      config: { duration: 700 }
    }),
    []
  );
  const [textAnimation] = useSpring(
    () => ({
      ...getStyle(textIndex, animationTexts.length - 1, isMobile),
      config: { tension: 100, friction: 20 },
      delay: 2e3,
      onRest: () => {
        if (textIndex === animationTexts.length - 1) {
          setTextIndex(0);
          return;
        }
        setTextIndex((prevIndex) => prevIndex + 1);
      }
    }),
    [textIndex]
  );
  const typographyVariant = isMobile ? "sm-md" : "base-reg";
  return /* @__PURE__ */ jsxs(
    "div",
    {
      css: css({
        position: "relative",
        display: "flex",
        gap: spacings.lg,
        alignItems: "center",
        width: "100%",
        overflow: "hidden",
        height: "32px",
        minHeight: "32px"
      }),
      children: [
        /* @__PURE__ */ jsx2(
          animated.div,
          {
            style: bubbleAnimation,
            css: css({
              width: "32px",
              height: "32px",
              borderRadius: "100%",
              background: theme.palette.grey200,
              "&:empty": {
                display: "block"
              }
            })
          }
        ),
        /* @__PURE__ */ jsx2(
          "div",
          {
            css: css({ overflow: "hidden", height: isMobile ? "19px" : "29px" }),
            children: /* @__PURE__ */ jsxs(
              animated.div,
              {
                style: textAnimation,
                css: css({
                  height: "100%",
                  display: "flex",
                  flexDirection: "column",
                  transform: "translateY(-2px)"
                }),
                children: [
                  /* @__PURE__ */ jsx2(Typography, { variant: typographyVariant, color: theme.palette.grey400, children: animationTexts[0] }),
                  /* @__PURE__ */ jsx2(Typography, { variant: typographyVariant, color: theme.palette.grey400, children: animationTexts[1] }),
                  /* @__PURE__ */ jsx2(Typography, { variant: typographyVariant, color: theme.palette.grey400, children: animationTexts[2] })
                ]
              }
            )
          }
        )
      ]
    }
  );
};
const AssistantChatShoppingMessages = ({
  messages,
  assistantIsWriting,
  assistantIsLoading,
  assistantHasError,
  retryLastMessage,
  conversationLimitIsReached
}) => {
  const messageEndContainerRef = F$1(null);
  const { modalHasBeenSeen } = useModalState();
  const { displayDiagnostic, displayCustomDiagnosticLoader } = useAssistantState();
  _(() => {
    scrollToBottom({
      containerRef: messageEndContainerRef.current,
      scrollBehavior: "auto"
    });
  }, [messages]);
  return /* @__PURE__ */ jsxs(
    "div",
    {
      css: css({
        display: "flex",
        flexDirection: "column",
        scrollBehavior: "smooth"
      }),
      children: [
        /* @__PURE__ */ jsxs(
          "div",
          {
            css: css({
              display: "flex",
              flexDirection: "column",
              gap: spacings.lg,
              [`@media screen and (max-width: ${MEDIUM_MOBILE_BP})`]: {
                gap: spacings.sm
              }
            }),
            children: [
              displayDiagnostic === true && /* @__PURE__ */ jsx2(Diagnostic, {}),
              messages.map((message, index2) => {
                return /* @__PURE__ */ jsx2(
                  AssistantChatShoppingMessage,
                  {
                    message,
                    isLastMessage: index2 === messages.length - 1
                  },
                  message.messageId
                );
              }),
              messages.length === 0 && modalHasBeenSeen && displayDiagnostic === false && /* @__PURE__ */ jsx2(EmptyMessage, {}),
              assistantHasError && /* @__PURE__ */ jsx2(ErrorMessage, { retryLastMessage }),
              conversationLimitIsReached && /* @__PURE__ */ jsx2(ConversationLimitReachedMessageError, {}),
              assistantIsLoading && !assistantIsWriting && !assistantHasError && (displayDiagnostic === true && displayCustomDiagnosticLoader === true ? /* @__PURE__ */ jsx2(DiagnosticLoader, {}) : /* @__PURE__ */ jsx2(WritingLoader, {}))
            ]
          }
        ),
        /* @__PURE__ */ jsx2(
          "div",
          {
            ref: messageEndContainerRef,
            css: css({ "&:empty": { display: "block" } })
          }
        )
      ]
    }
  );
};
const PRODUCT_QUESTION_HEIGHT = 100;
const LoadPreviousMessagesButton = ({
  onClick,
  loading
}) => {
  return /* @__PURE__ */ jsx2(
    Button,
    {
      variant: "blank",
      loading,
      onClick,
      labelCss: css({
        color: theme.palette.grey400,
        fontSize: theme.typography.body3.fontSize,
        fontWeight: theme.typography.body3.fontWeight
      }),
      customCss: css({
        margin: "0 auto",
        padding: `0 ${spacings.lg}`,
        borderRadius: theme.borderRadius.lg,
        cursor: "pointer",
        width: "fit-content",
        height: "auto",
        fontSize: theme.typography.body3.fontSize,
        "&:hover": {
          span: {
            color: theme.palette.grey600
          },
          background: theme.palette.classic.white,
          border: `1px solid ${theme.palette.grey150}`
        },
        [`@media screen and (max-width: ${TABLET_BP})`]: {
          fontSize: "10px"
        }
      }),
      children: /* @__PURE__ */ jsx2(MemoizedFormattedMessage, { id: "loadPreviousMessages" })
    }
  );
};
const AssistantChatMessagesWrapper = ({
  enableHistory = false
}) => {
  const intl = useIntl();
  const { isFeatureDisabled } = useDialogConfig();
  const { additionalContainerInformations } = useContainerWatcher();
  const { isWriting, isLoadingToWrite, displayDiagnostic } = useAssistantState();
  const {
    messages,
    assistantHasError,
    retryLastMessage,
    conversationLimitIsReached,
    askSomethingOnProduct,
    setMessages,
    apiKey: apiKey2,
    userId: userId2
  } = useAssistantMessages();
  const [previousMessagesLoaded, setPreviousMessagesLoaded] = p$1(false);
  const {
    refetch,
    isLoading: isLoadingHistory,
    data
  } = useGetMessagesAI({
    apiKey: apiKey2,
    userId: userId2,
    enabled: enableHistory
  });
  const processPreviousMessages = x$2(
    (messagesHistory) => {
      if (displayDiagnostic === true) return;
      const previousMessages = messagesHistory.map((msg) => ({
        output: parseAiMessage(msg.text),
        senderId: msg.type,
        messageId: msg.messageId,
        pictureUrl: msg.pictureUrl,
        done: true
      }));
      setMessages((currentMessages) => {
        const limitIndex = previousMessages.findIndex(
          (message) => {
            var _a3;
            return message.messageId === ((_a3 = currentMessages[0]) == null ? void 0 : _a3.messageId);
          }
        );
        if (limitIndex === -1) {
          return [...previousMessages, ...currentMessages];
        }
        return [...previousMessages.slice(0, limitIndex), ...currentMessages];
      });
      setPreviousMessagesLoaded(true);
    },
    [setMessages, displayDiagnostic]
  );
  _(() => {
    if (data && !previousMessagesLoaded) {
      processPreviousMessages(data);
    }
  }, [data, previousMessagesLoaded, processPreviousMessages]);
  const loadPreviousMessages = x$2(async () => {
    const { data: messagesHistory } = await refetch();
    if (messagesHistory === void 0) return;
    processPreviousMessages(messagesHistory);
  }, [refetch, processPreviousMessages]);
  const {
    selectedRecommendation,
    displayRecommendationDrawer,
    setDisplayRecommendationDrawer
  } = useRecommendationDrawer();
  const hasProductQuestion = messages.find(
    (msg) => msg.senderId === "questionMessage"
  );
  const onCloseRecommendationDrawer = x$2(() => {
    setDisplayRecommendationDrawer(false);
  }, [setDisplayRecommendationDrawer]);
  const askProduct = x$2(
    (question, answer) => {
      askSomethingOnProduct({
        question,
        product: selectedRecommendation == null ? void 0 : selectedRecommendation.product,
        answer
      });
    },
    [askSomethingOnProduct, selectedRecommendation]
  );
  const handleLoadPreviousMessages = async () => {
    setPreviousMessagesLoaded(true);
    await loadPreviousMessages();
  };
  const productCardBlocHeight = (additionalContainerInformations == null ? void 0 : additionalContainerInformations.height) ?? PRODUCT_QUESTION_HEIGHT;
  return /* @__PURE__ */ jsxs(
    "div",
    {
      css: css({
        display: "flex",
        flexDirection: "column",
        gap: spacings.lg,
        position: "relative",
        width: "100%",
        paddingBottom: getSmallSpacing(8),
        paddingTop: hasProductQuestion && !isFeatureDisabled(Features.PRODUCT_CARD) ? `calc(${spacings.lg} + ${productCardBlocHeight}px)` : "0",
        [`@media screen and (max-width: ${TABLET_BP})`]: {
          paddingBottom: getSmallSpacing(4)
        }
      }),
      children: [
        !previousMessagesLoaded && displayDiagnostic === false && /* @__PURE__ */ jsx2(
          LoadPreviousMessagesButton,
          {
            onClick: handleLoadPreviousMessages,
            loading: isLoadingHistory
          }
        ),
        /* @__PURE__ */ jsx2(
          AssistantChatShoppingMessages,
          {
            messages,
            conversationLimitIsReached,
            assistantIsWriting: isWriting === true,
            assistantIsLoading: isLoadingToWrite === true,
            assistantHasError,
            retryLastMessage
          }
        ),
        /* @__PURE__ */ jsx2(
          RecommendationDrawer,
          {
            open: displayRecommendationDrawer,
            onClose: onCloseRecommendationDrawer,
            recommendation: selectedRecommendation,
            askSomethingOnProduct: askProduct,
            backButtonText: intl.formatMessage({ id: "info" })
          }
        )
      ]
    }
  );
};
const AssistantChatShopping = ({
  onClose,
  displayPoweredByDialog
}) => {
  var _a3, _b2, _c2;
  const messagesContainerRef = F$1(null);
  const intl = useIntl();
  const { isWriting, isLoadingToWrite, isSearchingForQualificationQuestion } = useAssistantState();
  const { messages, sendMessage, apiKey: apiKey2 } = useAssistantMessages();
  const { languageIsoCode: languageIsoCode2 } = useLocalization();
  const config2 = useGetDialogConfig({ apiKey: apiKey2, locale: languageIsoCode2 });
  const lastMessage = messages[messages.length - 1];
  const isLoading = isLoadingToWrite === true || isWriting === true || isSearchingForQualificationQuestion;
  return /* @__PURE__ */ jsxs(
    "div",
    {
      css: [
        assistantChatShoppingContainerStyle,
        css({
          width: "100%"
        })
      ],
      children: [
        /* @__PURE__ */ jsx2(
          "div",
          {
            css: css({
              display: "flex",
              justifyContent: "center",
              alignItems: "center",
              flexDirection: "column",
              gap: spacings.md,
              [`@media screen and (max-width: ${MEDIUM_MOBILE_BP})`]: {
                padding: `${spacings.lg} 0 ${spacings.md} 0`
              }
            }),
            children: /* @__PURE__ */ jsx2(
              AssistantChatShoppingHeader,
              {
                title: intl.formatMessage({ id: "assist" }),
                description: intl.formatMessage({ id: "descriptionAssistantModal" }),
                onClose
              }
            )
          }
        ),
        /* @__PURE__ */ jsx2(ContainerWatcherProvider, { containerRef: messagesContainerRef, watchScroll: true, children: /* @__PURE__ */ jsx2(
          "div",
          {
            ref: messagesContainerRef,
            css: css({
              width: "100%",
              display: "flex",
              flexDirection: "column",
              justifyContent: "space-between",
              flex: 1,
              overflowY: "auto",
              overflowX: "hidden",
              "&::-webkit-scrollbar": {
                display: "none"
              },
              "-ms-overflow-style": "none",
              "scrollbar-width": "none"
            }),
            children: /* @__PURE__ */ jsx2(
              AssistantChatMessagesWrapper,
              {
                enableHistory: apiKey2 === "a00906a2-0f3e-4be6-94fa-d1aa08f50bb5"
              }
            )
          }
        ) }),
        /* @__PURE__ */ jsxs(
          "div",
          {
            css: css({
              display: "flex",
              flexDirection: "column",
              gap: spacings.md,
              [`@media screen and (max-width: ${TABLET_BP})`]: {
                gap: spacings.sm
              }
            }),
            children: [
              isLoading === false && /* @__PURE__ */ jsx2(
                Suggestions,
                {
                  suggestions: lastMessage == null ? void 0 : lastMessage.suggestions,
                  sendMessage
                },
                `suggestions-container-${((_a3 = lastMessage == null ? void 0 : lastMessage.suggestions) == null ? void 0 : _a3.length) ?? 0}`
              ),
              /* @__PURE__ */ jsx2(
                AssistantChatShoppingSendMessagesThemed,
                {
                  placeholder: intl.formatMessage({ id: "askAnything" }),
                  onSendMessage: sendMessage,
                  isLoading
                }
              ),
              /* @__PURE__ */ jsxs(
                "div",
                {
                  css: css({
                    display: "flex",
                    gap: spacings.xs,
                    alignItems: "center",
                    justifyContent: "center"
                  }),
                  children: [
                    /* @__PURE__ */ jsx2(
                      Typography,
                      {
                        variant: "xs-md",
                        color: theme.palette.grey400,
                        customCss: css({ fontSize: "10px" }),
                        children: /* @__PURE__ */ jsx2(
                          MemoizedFormattedMessage,
                          {
                            id: ((_b2 = config2.data) == null ? void 0 : _b2.disclaimerName) !== void 0 && config2.data.disclaimerName !== "" ? "customDisclaimer" : "defaultDisclaimer",
                            values: {
                              disclaimerName: (_c2 = config2.data) == null ? void 0 : _c2.disclaimerName
                            }
                          }
                        )
                      }
                    ),
                    displayPoweredByDialog ? /* @__PURE__ */ jsxs(Fragment, { children: [
                      /* @__PURE__ */ jsx2(
                        "div",
                        {
                          css: css({
                            width: "4px",
                            height: "4px",
                            borderRadius: "100%",
                            background: theme.palette.grey400,
                            "&:empty": {
                              display: "block"
                            }
                          })
                        }
                      ),
                      /* @__PURE__ */ jsx2(PoweredByDialog, {})
                    ] }) : /* @__PURE__ */ jsx2(Fragment, {})
                  ]
                }
              )
            ]
          }
        )
      ]
    }
  );
};
const AssitantChatShoppingDrawer = ({
  onClose,
  displayPoweredByDialog
}) => {
  const closeDrawer = () => {
    onClose();
  };
  return /* @__PURE__ */ jsx2(
    "div",
    {
      css: css({
        width: "620px",
        height: "100dvh",
        background: theme.palette.classic.white,
        padding: spacings.xxxl,
        boxShadow: theme.shadow.lg
      }),
      children: /* @__PURE__ */ jsx2(
        AssistantChatShopping,
        {
          onClose: closeDrawer,
          displayPoweredByDialog
        }
      )
    }
  );
};
const defaultContainerStyle = css({
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  boxSizing: "border-box",
  padding: `${spacings.sm} ${spacings.xxl} ${spacings.sm}`,
  width: "100%",
  height: "100%",
  backgroundColor: "white",
  overflow: "hidden",
  "@media screen and (max-width: 768px)": {
    padding: `${spacings.sm} ${spacings.lg} ${spacings.sm}`
  }
});
const AssistantShopping = ({
  isDesktop,
  onClose
}) => {
  var _a3;
  const postHog = usePostHog();
  const { messages, userId: userId2, getSessionId } = useAssistantMessages();
  const { config: dialogConfig, error: error2 } = useDialogConfig();
  const { dispatch, storedValue } = useLocalStorage();
  const localStorage2 = useLocalStorage();
  const hasStartedConversation = F$1(
    (_a3 = localStorage2.storedValue.session) == null ? void 0 : _a3.hasStartedConversation
  );
  _(() => {
    if (error2) {
      onClose();
    }
  }, [error2, onClose]);
  const onStartConversation = x$2(() => {
    hasStartedConversation.current = true;
    dispatch({ type: "startedConversation" });
    if ((dialogConfig == null ? void 0 : dialogConfig.initialAssistantMessage) !== void 0 && !storedValue.hasSeenInitialMessage) {
      dispatch({ type: "initialMessageSeen" });
    }
    if (window.gtag !== void 0) {
      window.gtag("event", "dialog_session", {
        dialogId: userId2
      });
    }
    postHog.capture(TRACKING_EVENTS.START_ASSISTANT_CONVERSATION, {
      userId: userId2,
      sessionId: getSessionId()
    });
  }, [postHog, userId2, getSessionId, dispatch, dialogConfig, storedValue]);
  _(() => {
    var _a4;
    if ((messages.length === 1 || messages.length === 2 && ((_a4 = messages[0]) == null ? void 0 : _a4.messageId) === "initialMessage") && hasStartedConversation.current !== true) {
      void onStartConversation();
    }
  }, [messages.length, onStartConversation, messages]);
  const displayPoweredByDialog = (dialogConfig == null ? void 0 : dialogConfig.displayPoweredByDialog) ?? false;
  if (isDesktop) {
    return /* @__PURE__ */ jsx2(
      AssitantChatShoppingDrawer,
      {
        onClose,
        displayPoweredByDialog
      }
    );
  }
  return /* @__PURE__ */ jsx2("div", { css: defaultContainerStyle, children: /* @__PURE__ */ jsx2(
    AssistantChatShopping,
    {
      onClose,
      displayPoweredByDialog
    }
  ) });
};
const AssistantModalContent = ({
  askSomethingOnProduct,
  suggestions,
  assistantName,
  description: description2,
  inputPlaceholder,
  theme: theme$1
}) => {
  return /* @__PURE__ */ jsx2(
    "div",
    {
      css: css({
        height: "100%",
        padding: `${spacings.xl} ${getSmallSpacing(6)} ${getSmallSpacing(8)}`,
        borderTopLeftRadius: theme$1 == null ? void 0 : theme$1.borderRadius.xxl,
        borderTopRightRadius: theme$1 == null ? void 0 : theme$1.borderRadius.xxl,
        background: (theme$1 == null ? void 0 : theme$1.palette.custom.backgroundColor) ?? theme.palette.classic.white,
        [`@media screen and (max-width: ${TABLET_BP})`]: {
          padding: `${spacings.xl} ${spacings.xl} ${getSmallSpacing(8)}`
        }
      }),
      children: /* @__PURE__ */ jsx2(
        AskSpecificInformationsThemed,
        {
          assistantName,
          askSomethingOnProduct,
          suggestions,
          description: description2,
          inputPlaceholder
        }
      )
    }
  );
};
const AssistantModalContentThemed = withTheme(AssistantModalContent);
const modalMaxHeight = "400px";
const commonContainerStyle = {
  alignItems: "center",
  justifyContent: "center",
  boxSizing: "border-box",
  position: "fixed",
  zIndex: theme.zIndex.highest,
  height: "100%"
};
const hiddenContainerStyle = (isDesktop) => css({
  ...commonContainerStyle,
  bottom: 0,
  left: isDesktop ? getSmallSpacing(8) : 0,
  right: 0,
  zIndex: theme.zIndex.highest,
  width: isDesktop ? "400px" : "100%",
  maxHeight: isDesktop ? modalMaxHeight : `100dvh`,
  height: "100%",
  overflow: "unset",
  display: "flex"
});
const closedContainerStyle = () => css({
  display: "none"
});
const bookmarkContainerStyle = () => css({
  ...commonContainerStyle,
  right: 0,
  top: "30% !important",
  zIndex: theme.zIndex.highest,
  maxHeight: "64px",
  width: "64px",
  height: "64px !important",
  overflow: "unset",
  display: "flex",
  background: "transparent"
});
const modalContainerStyle = (isDesktop) => css({
  ...commonContainerStyle,
  bottom: 0,
  left: isDesktop ? getSmallSpacing(8) : 0,
  right: 0,
  zIndex: theme.zIndex.highest,
  width: isDesktop ? "400px" : "100%",
  maxHeight: isDesktop ? modalMaxHeight : `100dvh`,
  overflow: isDesktop ? "unset" : "hidden",
  display: "flex",
  borderRadius: theme.borderRadius.lg
});
const chatContainerStyle = () => css({
  ...commonContainerStyle,
  bottom: 0,
  left: 0,
  right: 0,
  zIndex: theme.zIndex.highest,
  width: "100%",
  maxHeight: `100dvh`,
  overflow: "hidden",
  display: "flex",
  borderRadius: "unset"
});
const maskStyle = css({
  position: "fixed",
  bottom: 0,
  left: 0,
  right: 0,
  opacity: "0.2",
  background: theme.palette.classic.black,
  zIndex: theme.zIndex.lowest,
  width: "100%",
  height: "100%",
  overflow: "hidden",
  cursor: "unset",
  "&:empty": {
    display: "block"
  }
});
const commonModalStyle = {
  width: "inherit",
  position: "fixed",
  bottom: 0,
  zIndex: theme.zIndex.low,
  background: theme.palette.classic.white,
  borderTopLeftRadius: theme.borderRadius.xxl,
  borderTopRightRadius: theme.borderRadius.xxl,
  boxShadow: "0px 4px 44px 0px rgba(0, 0, 0, 0.25)"
};
const defaultAnimationStyle = css({
  ...commonModalStyle
});
const chatAnimationStyle = (isDesktop) => css({
  ...commonModalStyle,
  height: "100%",
  width: isDesktop ? "unset" : "100%",
  maxHeight: "100%"
});
const modalAnimationStyle = () => css({
  ...commonModalStyle,
  height: "auto"
});
const bookmarkAnimationStyle = () => css({
  position: "absolute",
  zIndex: theme.zIndex.low,
  background: theme.palette.classic.white,
  boxShadow: theme.shadow.lg,
  height: "100%",
  transform: "translateX(100%)",
  borderBottomLeftRadius: theme.borderRadius.xl,
  borderTopLeftRadius: theme.borderRadius.xl,
  border: `1px solid ${theme.palette.grey100}`,
  overflow: "hidden"
});
const getDisplayAnimation = (state, isDesktop) => {
  switch (state) {
    case BOOKMARK_STATE:
      return {
        from: { transform: "translateX(100%)" },
        to: { transform: "translateX(0%)" }
      };
    case MODAL_STATE:
    default:
      return {
        from: { maxHeight: "0" },
        to: { maxHeight: modalMaxHeight }
      };
    case CHAT_STATE:
      return {
        from: {
          ...isDesktop ? {
            right: "-100%"
          } : {}
        },
        to: {
          maxHeight: "100%",
          ...isDesktop ? {
            right: "0%"
          } : {}
        }
      };
    case HIDDEN_STATE:
    case CLOSED_STATE:
      return {
        to: { maxHeight: "0" }
      };
  }
};
const getContainerStyle = (isDesktop, modalState) => {
  switch (modalState) {
    case BOOKMARK_STATE:
      return bookmarkContainerStyle();
    case MODAL_STATE:
      return modalContainerStyle(isDesktop);
    case CHAT_STATE:
      return chatContainerStyle();
    case HIDDEN_STATE:
      return hiddenContainerStyle(isDesktop);
    case CLOSED_STATE:
      return closedContainerStyle();
    default:
      return css({});
  }
};
const getAnimationStyle = (isDesktop, modalState) => {
  switch (modalState) {
    case BOOKMARK_STATE:
      return bookmarkAnimationStyle();
    case MODAL_STATE:
      return modalAnimationStyle();
    case CHAT_STATE:
      return chatAnimationStyle(isDesktop);
    default:
      return defaultAnimationStyle;
  }
};
const AssistantViewer = ({
  children,
  onClose
}) => {
  const { modalState, setModalState } = useModalState();
  const isDesktop = window.innerWidth > TABLET_BP_NUMBER;
  const displayAnimation = getDisplayAnimation(modalState, isDesktop);
  const props = useSpring({
    ...displayAnimation,
    onResolve: () => {
      if (modalState === HIDDEN_STATE) {
        setModalState(CLOSED_STATE);
      }
    }
  });
  const containerStyle = getContainerStyle(isDesktop, modalState);
  const animationStyle = getAnimationStyle(isDesktop, modalState);
  const enableMask = modalState === MODAL_STATE && !isDesktop || modalState === CHAT_STATE;
  return /* @__PURE__ */ jsxs(
    "div",
    {
      id: "dialog-ai-container",
      "data-modal-state": modalState,
      css: containerStyle,
      children: [
        enableMask ? /* @__PURE__ */ jsx2(DivClickable, { customCss: maskStyle, onClick: () => onClose == null ? void 0 : onClose() }) : /* @__PURE__ */ jsx2(Fragment, {}),
        /* @__PURE__ */ jsx2(animated.div, { style: props, css: animationStyle, children })
      ]
    }
  );
};
AssistantViewer.Modal = ({
  children,
  modalState
}) => {
  if (modalState !== MODAL_STATE) return /* @__PURE__ */ jsx2(Fragment, {});
  return /* @__PURE__ */ jsx2(Fragment, { children });
};
AssistantViewer.Chat = ({
  children,
  modalState
}) => {
  if (modalState !== CHAT_STATE) return /* @__PURE__ */ jsx2(Fragment, {});
  return /* @__PURE__ */ jsx2(Fragment, { children });
};
AssistantViewer.Bookmark = ({
  children,
  modalState
}) => {
  if (modalState !== BOOKMARK_STATE) return /* @__PURE__ */ jsx2(Fragment, {});
  return /* @__PURE__ */ jsx2(Fragment, { children });
};
const AssistantModal = ({
  suggestions,
  description: description2,
  assistantName,
  inputPlaceholder,
  modalState,
  setModalState
}) => {
  const { sendMessage, closeAssistant, openAssistant } = useAssistantMessages();
  const { setModalHasBeenSeen, modalHasBeenSeen } = useModalState();
  const { isLoading } = useDialogConfig();
  const isDesktop = window.innerWidth > TABLET_BP_NUMBER;
  const posthog = usePostHog();
  const onClose = () => {
    if (modalState === MODAL_STATE) {
      setModalHasBeenSeen();
    }
    setModalState(
      modalState === MODAL_STATE || modalHasBeenSeen ? BOOKMARK_STATE : HIDDEN_STATE
    );
    closeAssistant();
  };
  const displayModalFromBookMark = () => {
    openAssistant();
    setModalState(CHAT_STATE);
    setModalHasBeenSeen();
  };
  const askSomething = (question) => {
    sendMessage(question);
    setModalState(CHAT_STATE);
    setModalHasBeenSeen();
    posthog.capture(TRACKING_EVENTS.USER_SENT_MODAL_MESSAGE);
  };
  return /* @__PURE__ */ jsxs(AssistantViewer, { onClose, children: [
    /* @__PURE__ */ jsx2(AssistantViewer.Modal, { modalState, children: /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx2(
        Button,
        {
          onClick: onClose,
          enableCleanIconOnlyStyle: true,
          customCss: css({
            position: "absolute",
            top: spacings.md,
            right: spacings.md
          }),
          variant: "blank",
          iconLeft: /* @__PURE__ */ jsx2(CrossIcon, {})
        }
      ),
      /* @__PURE__ */ jsx2(
        AssistantModalContentThemed,
        {
          askSomethingOnProduct: askSomething,
          assistantName,
          suggestions: suggestions ?? [],
          description: description2,
          inputPlaceholder
        }
      )
    ] }) }),
    isLoading ? /* @__PURE__ */ jsx2(Fragment, {}) : /* @__PURE__ */ jsx2(AssistantViewer.Bookmark, { modalState, children: /* @__PURE__ */ jsx2(
      Button,
      {
        onClick: displayModalFromBookMark,
        variant: "blank",
        customCss: css({
          width: "100%",
          height: "100%",
          background: theme.palette.classic.white
        }),
        children: /* @__PURE__ */ jsx2(DialogOrOrganizationIcon, { size: 36 })
      }
    ) }),
    /* @__PURE__ */ jsx2(AssistantViewer.Chat, { modalState, children: /* @__PURE__ */ jsx2(AssistantShopping, { isDesktop, onClose }) })
  ] });
};
const formatModalProductQuestionToProductQuestion = (modalProductQuestions, locale2) => {
  const productQuestionsFormatted = modalProductQuestions.map((modalProductQuestion) => {
    var _a3;
    const question = modalProductQuestion.question[locale2];
    const answer = (_a3 = modalProductQuestion.answer) == null ? void 0 : _a3[locale2];
    if (question === void 0) return void 0;
    return {
      question,
      answer
    };
  }).filter((q2) => q2 !== void 0);
  return productQuestionsFormatted;
};
const AssistantModalWrapper = () => {
  const { modalState, setModalState } = useModalState();
  const { updateAssistantState } = useAssistantState();
  const postHog = usePostHog();
  const [currentModalConfigTriggered, setCurrentModalConfigTriggered] = p$1();
  const {
    sendMessage,
    apiKey: apiKey2,
    openAssistant,
    saveQuestionAndAnswer,
    clearAssistantMessages
  } = useAssistantMessages();
  const { languageIsoCode: languageIsoCode2 } = useLocalization();
  const { config: dialogConfig, error: error2 } = useDialogConfig();
  _(() => {
    if (error2) {
      setModalState(HIDDEN_STATE);
    }
  }, [error2, setModalState]);
  const { setProductId } = useCurrentProductId();
  _(() => {
    postHog.onSessionId(() => {
      var _a3, _b2;
      if (((_b2 = (_a3 = window.Shopify) == null ? void 0 : _a3.customerPrivacy) == null ? void 0 : _b2.analyticsProcessingAllowed()) === true) {
        postHog.capture(TRACKING_EVENTS.NEW_SESSION);
      }
    });
  }, [apiKey2, postHog]);
  const initChat = (productId) => {
    openAssistant();
    setModalState(CHAT_STATE);
    setProductId(productId);
  };
  useModalTrigger({
    modalConfigs: dialogConfig == null ? void 0 : dialogConfig.modalTriggers,
    onModalStateChange: (newState, triggeredModalConfig) => {
      setCurrentModalConfigTriggered(triggeredModalConfig);
      setModalState(newState);
      if (newState !== CLOSED_STATE && newState !== HIDDEN_STATE) {
        openAssistant();
      }
    }
  });
  useModalEvent({
    onEvent: (event) => {
      if (isStartDiagnosticEvent(event)) {
        initChat(event.detail.payload.productId);
        updateAssistantState({ displayDiagnostic: true });
        clearAssistantMessages();
        return;
      }
      if (isProductQuestionAnswerEvent(event)) {
        initChat(event.detail.payload.productId);
        saveQuestionAndAnswer(
          event.detail.payload.question,
          event.detail.payload.answer,
          {
            title: event.detail.payload.productTitle,
            id: event.detail.payload.productId,
            selectedVariantId: event.detail.payload.selectedVariantId,
            handle: event.detail.payload.handle
          },
          "questionMessage"
        );
        return;
      }
      if (isProductQuestionEvent(event)) {
        initChat(event.detail.payload.productId);
        sendMessage(
          event.detail.payload.question,
          {
            title: event.detail.payload.productTitle,
            id: event.detail.payload.productId,
            handle: event.detail.payload.handle,
            selectedVariantId: event.detail.payload.selectedVariantId,
            fromQuestionSuggestion: event.detail.payload.fromQuestionSuggestion
          },
          "questionMessage"
        );
      }
      if (isGenericQuestionEvent(event)) {
        initChat();
        sendMessage(event.detail.payload.question);
      }
    }
  });
  const formattedSuggestions = formatModalProductQuestionToProductQuestion(
    (currentModalConfigTriggered == null ? void 0 : currentModalConfigTriggered.suggestions) ?? [],
    languageIsoCode2
  );
  return /* @__PURE__ */ jsx2(
    AssistantModal,
    {
      suggestions: formattedSuggestions,
      assistantName: currentModalConfigTriggered == null ? void 0 : currentModalConfigTriggered.assistantName,
      description: currentModalConfigTriggered == null ? void 0 : currentModalConfigTriggered.description,
      inputPlaceholder: currentModalConfigTriggered == null ? void 0 : currentModalConfigTriggered.inputPlaceholder,
      modalState,
      setModalState
    },
    modalState
  );
};
_o.init("phc_EKMR6Jt4OTMEYmoUlz0v58KPwqcFxI7aZCLckpSD8Tv", {
  api_host: "https://eu.posthog.com",
  persistence: (
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    ((_b = (_a2 = window.Shopify) == null ? void 0 : _a2.customerPrivacy) == null ? void 0 : _b.analyticsProcessingAllowed()) === true ? "localStorage+cookie" : "memory"
  ),
  autocapture: false,
  disable_session_recording: true,
  capture_pageleave: false,
  capture_pageview: false,
  capture_performance: false
});
if (((_d = (_c = window.Shopify) == null ? void 0 : _c.customerPrivacy) == null ? void 0 : _d.analyticsProcessingAllowed()) === true) {
  _o.register({ useCookie: true });
}
const ShopifyAI = ({
  apiKey: apiKey2,
  userId: userId2,
  primaryColor: primaryColor2,
  ctaTextColor: ctaTextColor2,
  backgroundColor: backgroundColor2,
  countryCode: countryCode2,
  language: language2,
  languageIsoCode: languageIsoCode2,
  ctaBorderType: ctaBorderType2,
  fontFamily: fontFamily2,
  capitalizeCtas: capitalizeCtas2,
  highlightProductName: highlightProductName2,
  locale: locale2
}) => {
  const queryClient = new QueryClient();
  return /* @__PURE__ */ u$2(LocalStorageProvider, { children: /* @__PURE__ */ u$2(PostHogProvider, { client: _o, children: /* @__PURE__ */ u$2(QueryClientProvider, { client: queryClient, children: /* @__PURE__ */ u$2(
    LocalizationProvider,
    {
      countryCode: countryCode2,
      languageIsoCode: languageIsoCode2,
      language: language2,
      locale: locale2,
      children: /* @__PURE__ */ u$2(
        ThemeProvider2,
        {
          primaryColor: primaryColor2,
          ctaTextColor: ctaTextColor2,
          backgroundColor: backgroundColor2,
          ctaBorderType: ctaBorderType2,
          fontFamily: fontFamily2,
          capitalizeCtas: capitalizeCtas2,
          highlightProductName: highlightProductName2,
          children: /* @__PURE__ */ u$2(
            WebSocketProvider,
            {
              apiKey: apiKey2,
              sessionId: userId2,
              baseWebSocketUrl: "wss://d3snc9e27l.execute-api.eu-west-1.amazonaws.com/production",
              children: /* @__PURE__ */ u$2(DialogConfigProvider, { apiKey: apiKey2, children: /* @__PURE__ */ u$2(AssistantStateProvider, { children: /* @__PURE__ */ u$2(CurrentProductIdProvider, { children: /* @__PURE__ */ u$2(
                AssistantMessagesProvider,
                {
                  apiKey: apiKey2,
                  userId: userId2,
                  children: /* @__PURE__ */ u$2(ModalStateProvider, { children: /* @__PURE__ */ u$2(RecommendationDrawerProvider, { children: /* @__PURE__ */ u$2(AssistantModalWrapper, {}) }) })
                }
              ) }) }) })
            }
          )
        }
      )
    }
  ) }) }) });
};
const App = ({
  apiKey: apiKey2,
  userId: userId2,
  primaryColor: primaryColor2,
  ctaTextColor: ctaTextColor2,
  backgroundColor: backgroundColor2,
  countryCode: countryCode2,
  language: language2,
  languageIsoCode: languageIsoCode2,
  ctaBorderType: ctaBorderType2,
  fontFamily: fontFamily2,
  capitalizeCtas: capitalizeCtas2,
  locale: locale2,
  highlightProductName: highlightProductName2
}) => {
  return /* @__PURE__ */ u$2(
    ShopifyAI,
    {
      apiKey: apiKey2,
      userId: userId2,
      primaryColor: primaryColor2,
      ctaTextColor: ctaTextColor2,
      countryCode: countryCode2,
      backgroundColor: backgroundColor2,
      language: language2,
      languageIsoCode: languageIsoCode2,
      ctaBorderType: ctaBorderType2,
      fontFamily: fontFamily2,
      capitalizeCtas: capitalizeCtas2,
      highlightProductName: highlightProductName2,
      locale: locale2
    }
  );
};
const shopifyRoot = document.getElementById("dialog-shopify-ai");
let apiKey = shopifyRoot == null ? void 0 : shopifyRoot.dataset.apiKey;
let userId = shopifyRoot == null ? void 0 : shopifyRoot.dataset.userId;
let primaryColor = shopifyRoot == null ? void 0 : shopifyRoot.dataset.primaryColor;
let ctaTextColor = shopifyRoot == null ? void 0 : shopifyRoot.dataset.ctaTextColor;
let backgroundColor = shopifyRoot == null ? void 0 : shopifyRoot.dataset.backgroundColor;
let countryCode = shopifyRoot == null ? void 0 : shopifyRoot.dataset.countryCode;
let locale = shopifyRoot == null ? void 0 : shopifyRoot.dataset.locale;
let language = shopifyRoot == null ? void 0 : shopifyRoot.dataset.language;
let languageIsoCode = shopifyRoot == null ? void 0 : shopifyRoot.dataset.shopIsoCode;
let ctaBorderType = shopifyRoot == null ? void 0 : shopifyRoot.dataset.ctaBorderType;
let fontFamily = shopifyRoot == null ? void 0 : shopifyRoot.dataset.fontFamily;
const capitalizeCtas = shopifyRoot == null ? void 0 : shopifyRoot.dataset.capitalizeCtas;
let highlightProductName = shopifyRoot == null ? void 0 : shopifyRoot.dataset.highlightProductName;
N$2(
  /* @__PURE__ */ u$2(g$3, { children: [
    /* @__PURE__ */ u$2(
      "link",
      {
        href: "https://fonts.googleapis.com/css2?family=Inter:wght@100;200;300;400;500;600;700;800;900&display=swap",
        rel: "stylesheet"
      }
    ),
    /* @__PURE__ */ u$2(
      App,
      {
        apiKey,
        userId,
        primaryColor,
        ctaTextColor,
        backgroundColor,
        countryCode,
        locale,
        language,
        languageIsoCode,
        ctaBorderType,
        fontFamily,
        capitalizeCtas: capitalizeCtas === "true" ? true : false,
        highlightProductName: highlightProductName === "true" ? true : false
      }
    )
  ] }),
  shopifyRoot
);
//# sourceMappingURL=index.js.map
